// ==UserScript==
// @name         wayfarer-map-extension
// @namespace    http://tampermonkey.net/
// @version      0.4.0
// @description  A user script that extends the official Niantic Wayfarer map.
// @author       Wiinuk
// @match        https://wayfarer.nianticlabs.com/new/mapview
// @grant        none
// ==/UserScript==
"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // source/gcs.ts
  var TARGET_PATH = "/api/v1/vault/mapview/gcs";
  function normalizeUrl(url2) {
    try {
      return new URL(url2, location.origin);
    } catch {
      return null;
    }
  }
  function injectGcsListener(listener) {
    const origOpen = XMLHttpRequest.prototype.open;
    const origSend = XMLHttpRequest.prototype.send;
    const isTargetSymbol = /* @__PURE__ */ Symbol("_isTarget");
    const urlObjSymbol = /* @__PURE__ */ Symbol("_urlObj");
    XMLHttpRequest.prototype.open = function(method, url2, ...rest) {
      const urlObj = normalizeUrl(url2);
      this[isTargetSymbol] = method === "GET" && urlObj?.pathname === TARGET_PATH;
      this[urlObjSymbol] = urlObj;
      return origOpen.call(this, method, url2, ...rest);
    };
    XMLHttpRequest.prototype.send = function(...args) {
      if (this[isTargetSymbol]) {
        this.addEventListener("load", function() {
          try {
            const ct = this.getResponseHeader("content-type") || "";
            if (!ct.includes("application/json")) return;
            listener(this[urlObjSymbol], this.responseText);
          } catch (e) {
            console.warn("[GCS LOGGER] Parse failed", e);
          }
        });
      }
      return origSend.apply(this, args);
    };
  }

  // source/environments.ts
  function isWebWorker() {
    return typeof window === "undefined" && typeof self !== "undefined";
  }

  // source/dom-extensions.ts
  function createSchedulerByAnimationFrame(signal, thresholdMs) {
    let startTime = performance.now();
    let lastHandle = null;
    signal.addEventListener(
      "abort",
      () => {
        if (lastHandle != null) {
          cancelAnimationFrame(lastHandle);
          lastHandle = null;
        }
      },
      { once: true }
    );
    return {
      get isYieldRequested() {
        if (navigator.scheduling?.isInputPending?.()) {
          return true;
        }
        const now = performance.now();
        return now - startTime >= thresholdMs;
      },
      yield() {
        if (!this.isYieldRequested) return null;
        return new Promise((resolve) => {
          lastHandle = requestAnimationFrame(() => {
            startTime = performance.now();
            resolve();
          });
        });
      }
    };
  }
  function createWorkerScheduler() {
    return {
      isYieldRequested: false,
      yield() {
        return null;
      }
    };
  }
  function createScheduler(signal, thresholdMs = 10) {
    if (isWebWorker()) return createWorkerScheduler();
    return createSchedulerByAnimationFrame(signal, thresholdMs);
  }

  // source/geometry.ts
  function toLatLngLiteral(latLng) {
    return { lat: latLng.lat(), lng: latLng.lng() };
  }
  function distanceSquared(a, b) {
    const dLat = b.lat - a.lat;
    const dLng = b.lng - a.lng;
    return dLat * dLat + dLng * dLng;
  }
  function padBounds(bounds, ratio) {
    const sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), swLat = sw.lat(), swLng = sw.lng(), neLat = ne.lat(), neLng = ne.lng();
    const height = Math.abs(swLat - neLat) * ratio;
    const width = Math.abs(swLng - neLng) * ratio;
    return new google.maps.LatLngBounds(
      { lat: swLat - height, lng: swLng - width },
      { lat: neLat + height, lng: neLng + width }
    );
  }
  function parseCoordinates(coordinatesText) {
    const tokens = coordinatesText.split(",");
    const result = [];
    for (let i = 1; i < tokens.length; i += 2) {
      result.push({ lat: Number(tokens[i - 1]), lng: Number(tokens[i]) });
    }
    if (result.length === 0) {
      throw new Error();
    }
    return result;
  }
  function coordinatesToString(coords) {
    return coords.map((ll) => `${ll.lat},${ll.lng}`).join(",");
  }

  // source/bounds.ts
  function createDefault() {
    return {
      sw: { lat: Infinity, lng: Infinity },
      ne: { lat: -Infinity, lng: -Infinity }
    };
  }
  function fromSwNeLatLng(swLat, swLng, neLat, neLng) {
    return {
      sw: { lat: swLat, lng: swLng },
      ne: { lat: neLat, lng: neLng }
    };
  }
  function getCenter(bounds) {
    return {
      lat: (bounds.sw.lat + bounds.ne.lat) / 2,
      lng: (bounds.sw.lng + bounds.ne.lng) / 2
    };
  }
  function toExtended(bounds, point) {
    return {
      sw: {
        lat: Math.min(bounds.sw.lat, point.lat),
        lng: Math.min(bounds.sw.lng, point.lng)
      },
      ne: {
        lat: Math.max(bounds.ne.lat, point.lat),
        lng: Math.max(bounds.ne.lng, point.lng)
      }
    };
  }
  function intersects(bounds, other) {
    return bounds.sw.lat <= other.ne.lat && bounds.ne.lat >= other.sw.lat && bounds.sw.lng <= other.ne.lng && bounds.ne.lng >= other.sw.lng;
  }
  function fromClass(object2) {
    const sw = object2.getSouthWest();
    const ne = object2.getNorthEast();
    return fromSwNeLatLng(sw.lat(), sw.lng(), ne.lat(), ne.lng());
  }

  // source/standard-extensions.ts
  function id(value) {
    return value;
  }
  function ignore(..._) {
  }
  function withTag(value) {
    return value;
  }
  async function awaitElement(get, options) {
    let currentInterval = 100;
    const maxInterval = 500;
    while (true) {
      const ref = get();
      if (ref) return ref;
      await sleep(Math.min(currentInterval *= 2, maxInterval), options);
    }
  }
  function sleep(ms, options) {
    return new Promise((resolve, reject) => {
      const signal = options?.signal;
      if (signal?.aborted) return reject(signal.reason);
      const handle = setTimeout(() => {
        cleanup();
        resolve();
      }, ms);
      function onAbort() {
        cleanup();
        queueMicrotask(
          () => reject(signal == null ? newAbortError() : signal.reason)
        );
      }
      function cleanup() {
        clearTimeout(handle);
        signal?.removeEventListener("abort", onAbort);
      }
      signal?.addEventListener("abort", onAbort);
    });
  }
  var AbortError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "AbortError";
    }
  };
  function newAbortError(message = "The operation was aborted.") {
    if (typeof DOMException === "function") {
      return new DOMException(message, "AbortError");
    } else {
      return new AbortError(message);
    }
  }
  function isAbortError(e) {
    return e != null && typeof e === "object" && "name" in e && e.name === "AbortError";
  }
  function createAsyncCancelScope(onError) {
    let activeController;
    return (process2) => {
      activeController?.abort(newAbortError());
      activeController = new AbortController();
      process2(activeController.signal).catch((e) => {
        if (isAbortError(e)) return;
        onError(e);
      });
    };
  }

  // source/typed-idb.ts
  function defineDatabase(database, schema) {
    for (const [storeName, storeSchema] of Object.entries(schema)) {
      const store = database.createObjectStore(storeName, {
        keyPath: storeSchema.key.slice()
      });
      for (const [indexName, options] of Object.entries(
        storeSchema.indexes
      )) {
        store.createIndex(indexName, options.key, options);
      }
    }
  }
  function openDatabase(databaseName2, databaseVersion2, databaseSchema2) {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(databaseName2, databaseVersion2);
      request.addEventListener(
        "upgradeneeded",
        () => defineDatabase(request.result, databaseSchema2)
      );
      request.addEventListener(
        "blocked",
        () => reject(new Error("database blocked"))
      );
      request.addEventListener("error", () => reject(request.error));
      request.addEventListener(
        "success",
        () => resolve(withTag(request.result))
      );
    });
  }
  var IterateValuesRequest = class {
    constructor(source, query, action) {
      this.source = source;
      this.query = query;
      this.action = action;
    }
  };
  function enterTransactionScope(database, {
    mode,
    signal
  }, scope, ...storeNames) {
    return new Promise((resolve, reject) => {
      if (signal?.aborted) {
        reject(newAbortError());
        return;
      }
      let hasResult = false;
      let result;
      const transaction = database.transaction(storeNames, mode);
      const onAbort = signal ? () => {
        if (!hasResult) {
          transaction.abort();
        }
      } : ignore;
      transaction.addEventListener("complete", () => {
        signal?.removeEventListener("abort", onAbort);
        if (hasResult) {
          resolve(result);
        } else {
          reject(new Error(`internal error`));
        }
      });
      transaction.addEventListener("error", (e) => {
        signal?.removeEventListener("abort", onAbort);
        reject(e.target.error);
      });
      signal?.addEventListener("abort", onAbort);
      const stores = {};
      for (const name of storeNames) {
        stores[name] = withTag(transaction.objectStore(name));
      }
      const iterator = scope(
        stores
      );
      let stateKind;
      let request_request;
      let waitRequests_results;
      let waitRequests_requests;
      let openCursor_request;
      let openCursor_action;
      function onResolved() {
        let r;
        switch (stateKind) {
          case void 0:
            r = iterator.next();
            break;
          case "Request": {
            const result2 = request_request.result;
            stateKind = void 0;
            request_request = void 0;
            r = iterator.next(result2);
            break;
          }
          case "WaitRequests": {
            const results = waitRequests_results;
            const requests = waitRequests_requests;
            const result2 = requests[results.length].result;
            results.push(result2);
            if (results.length !== requests.length) return;
            stateKind = void 0;
            waitRequests_requests = void 0;
            waitRequests_results = void 0;
            r = iterator.next(results);
            break;
          }
          case "OpenCursor": {
            const cursor = openCursor_request.result;
            if (cursor === null || openCursor_action(cursor.value) === "break") {
              stateKind = void 0;
              openCursor_request = void 0;
              openCursor_action = void 0;
              r = iterator.next(void 0);
            } else {
              cursor.continue();
              return;
            }
            break;
          }
          default: {
            reject(new Error(`Invalid resolving kind: ${stateKind}`));
            return;
          }
        }
        if (r.done) {
          hasResult = true;
          result = r.value;
          return;
        }
        const yieldValue = r.value;
        if (yieldValue instanceof IDBRequest) {
          stateKind = "Request";
          request_request = yieldValue;
          yieldValue.onsuccess = onResolved;
          return;
        }
        if (yieldValue instanceof IterateValuesRequest) {
          stateKind = "OpenCursor";
          openCursor_request = yieldValue.source.openCursor(
            yieldValue.query
          );
          openCursor_action = yieldValue.action;
          openCursor_request.onsuccess = onResolved;
          return;
        }
        stateKind = "WaitRequests";
        waitRequests_requests = yieldValue;
        waitRequests_results = [];
        for (const request of yieldValue) {
          request.onsuccess = onResolved;
        }
        return;
      }
      onResolved();
    });
  }
  function getIndex(store, indexName) {
    return withTag(store.index(indexName));
  }
  function* iterateValuesOfIndex(index, query, action) {
    yield new IterateValuesRequest(index, query, action);
    return;
  }

  // source/s2.ts
  function exposeS2Module(exports) {
    "use strict";
    var S22 = exports.S2 = {
      L: {}
    };
    S22.L.LatLng = function(rawLat, rawLng, noWrap) {
      var lat = parseFloat(rawLat, 10);
      var lng = parseFloat(rawLng, 10);
      if (isNaN(lat) || isNaN(lng)) {
        throw new Error(
          "Invalid LatLng object: (" + rawLat + ", " + rawLng + ")"
        );
      }
      if (noWrap !== true) {
        lat = Math.max(Math.min(lat, 90), -90);
        lng = (lng + 180) % 360 + (lng < -180 || lng === 180 ? 180 : -180);
      }
      return {
        lat,
        lng
      };
    };
    S22.L.LatLng.DEG_TO_RAD = Math.PI / 180;
    S22.L.LatLng.RAD_TO_DEG = 180 / Math.PI;
    S22.LatLngToXYZ = function(latLng) {
      var d2r = S22.L.LatLng.DEG_TO_RAD;
      var phi = latLng.lat * d2r;
      var theta = latLng.lng * d2r;
      var cosphi = Math.cos(phi);
      return [
        Math.cos(theta) * cosphi,
        Math.sin(theta) * cosphi,
        Math.sin(phi)
      ];
    };
    S22.XYZToLatLng = function(xyz) {
      var r2d = S22.L.LatLng.RAD_TO_DEG;
      var lat = Math.atan2(
        xyz[2],
        Math.sqrt(xyz[0] * xyz[0] + xyz[1] * xyz[1])
      );
      var lng = Math.atan2(xyz[1], xyz[0]);
      return S22.L.LatLng(lat * r2d, lng * r2d);
    };
    var largestAbsComponent = function(xyz) {
      var temp = [Math.abs(xyz[0]), Math.abs(xyz[1]), Math.abs(xyz[2])];
      if (temp[0] > temp[1]) {
        if (temp[0] > temp[2]) {
          return 0;
        } else {
          return 2;
        }
      } else {
        if (temp[1] > temp[2]) {
          return 1;
        } else {
          return 2;
        }
      }
    };
    var faceXYZToUV = function(face, xyz) {
      var u, v;
      switch (face) {
        case 0:
          u = xyz[1] / xyz[0];
          v = xyz[2] / xyz[0];
          break;
        case 1:
          u = -xyz[0] / xyz[1];
          v = xyz[2] / xyz[1];
          break;
        case 2:
          u = -xyz[0] / xyz[2];
          v = -xyz[1] / xyz[2];
          break;
        case 3:
          u = xyz[2] / xyz[0];
          v = xyz[1] / xyz[0];
          break;
        case 4:
          u = xyz[2] / xyz[1];
          v = -xyz[0] / xyz[1];
          break;
        case 5:
          u = -xyz[1] / xyz[2];
          v = -xyz[0] / xyz[2];
          break;
        default:
          throw {
            error: "Invalid face"
          };
      }
      return [u, v];
    };
    S22.XYZToFaceUV = function(xyz) {
      var face = largestAbsComponent(xyz);
      if (xyz[face] < 0) {
        face += 3;
      }
      var uv = faceXYZToUV(face, xyz);
      return [face, uv];
    };
    S22.FaceUVToXYZ = function(face, uv) {
      var u = uv[0];
      var v = uv[1];
      switch (face) {
        case 0:
          return [1, u, v];
        case 1:
          return [-u, 1, v];
        case 2:
          return [-u, -v, 1];
        case 3:
          return [-1, -v, -u];
        case 4:
          return [v, -1, -u];
        case 5:
          return [v, u, -1];
        default:
          throw {
            error: "Invalid face"
          };
      }
    };
    var singleSTtoUV = function(st) {
      if (st >= 0.5) {
        return 1 / 3 * (4 * st * st - 1);
      } else {
        return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
      }
    };
    S22.STToUV = function(st) {
      return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];
    };
    var singleUVtoST = function(uv) {
      if (uv >= 0) {
        return 0.5 * Math.sqrt(1 + 3 * uv);
      } else {
        return 1 - 0.5 * Math.sqrt(1 - 3 * uv);
      }
    };
    S22.UVToST = function(uv) {
      return [singleUVtoST(uv[0]), singleUVtoST(uv[1])];
    };
    S22.STToIJ = function(st, order) {
      var maxSize = 1 << order;
      var singleSTtoIJ = function(st2) {
        var ij = Math.floor(st2 * maxSize);
        return Math.max(0, Math.min(maxSize - 1, ij));
      };
      return [singleSTtoIJ(st[0]), singleSTtoIJ(st[1])];
    };
    S22.IJToST = function(ij, order, offsets) {
      var maxSize = 1 << order;
      return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
    };
    var rotateAndFlipQuadrant = function(n, point, rx, ry) {
      var newX, newY;
      if (ry == 0) {
        if (rx == 1) {
          point.x = n - 1 - point.x;
          point.y = n - 1 - point.y;
        }
        var x = point.x;
        point.x = point.y;
        point.y = x;
      }
    };
    var pointToHilbertQuadList = function(x, y, order, face) {
      var hilbertMap = {
        a: [
          [0, "d"],
          [1, "a"],
          [3, "b"],
          [2, "a"]
        ],
        b: [
          [2, "b"],
          [1, "b"],
          [3, "a"],
          [0, "c"]
        ],
        c: [
          [2, "c"],
          [3, "d"],
          [1, "c"],
          [0, "b"]
        ],
        d: [
          [0, "a"],
          [3, "c"],
          [1, "d"],
          [2, "d"]
        ]
      };
      if ("number" !== typeof face) {
        console.warn(
          new Error(
            "called pointToHilbertQuadList without face value, defaulting to '0'"
          ).stack
        );
      }
      var currentSquare = face % 2 ? "d" : "a";
      var positions = [];
      for (var i = order - 1; i >= 0; i--) {
        var mask = 1 << i;
        var quad_x = x & mask ? 1 : 0;
        var quad_y = y & mask ? 1 : 0;
        var t = hilbertMap[currentSquare][quad_x * 2 + quad_y];
        positions.push(t[0]);
        currentSquare = t[1];
      }
      return positions;
    };
    S22.S2Cell = function() {
    };
    S22.S2Cell.FromHilbertQuadKey = function(hilbertQuadkey) {
      var parts = hilbertQuadkey.split("/");
      var face = parseInt(parts[0]);
      var position = parts[1];
      var maxLevel = position.length;
      var point = {
        x: 0,
        y: 0
      };
      var i;
      var level;
      var bit;
      var rx, ry;
      var val;
      for (i = maxLevel - 1; i >= 0; i--) {
        level = maxLevel - i;
        bit = position[i];
        rx = 0;
        ry = 0;
        if (bit === "1") {
          ry = 1;
        } else if (bit === "2") {
          rx = 1;
          ry = 1;
        } else if (bit === "3") {
          rx = 1;
        }
        val = Math.pow(2, level - 1);
        rotateAndFlipQuadrant(val, point, rx, ry);
        point.x += val * rx;
        point.y += val * ry;
      }
      if (face % 2 === 1) {
        var t = point.x;
        point.x = point.y;
        point.y = t;
      }
      return S22.S2Cell.FromFaceIJ(parseInt(face), [point.x, point.y], level);
    };
    S22.S2Cell.FromLatLng = function(latLng, level) {
      if (!latLng.lat && latLng.lat !== 0 || !latLng.lng && latLng.lng !== 0) {
        throw new Error(
          "Pass { lat: lat, lng: lng } to S2.S2Cell.FromLatLng"
        );
      }
      var xyz = S22.LatLngToXYZ(latLng);
      var faceuv = S22.XYZToFaceUV(xyz);
      var st = S22.UVToST(faceuv[1]);
      var ij = S22.STToIJ(st, level);
      return S22.S2Cell.FromFaceIJ(faceuv[0], ij, level);
    };
    S22.S2Cell.FromFaceIJ = function(face, ij, level) {
      var cell = new S22.S2Cell();
      cell.face = face;
      cell.ij = ij;
      cell.level = level;
      return cell;
    };
    S22.S2Cell.prototype.toString = function() {
      return "F" + this.face + "ij[" + this.ij[0] + "," + this.ij[1] + "]@" + this.level;
    };
    S22.S2Cell.prototype.getLatLng = function() {
      var st = S22.IJToST(this.ij, this.level, [0.5, 0.5]);
      var uv = S22.STToUV(st);
      var xyz = S22.FaceUVToXYZ(this.face, uv);
      return S22.XYZToLatLng(xyz);
    };
    S22.S2Cell.prototype.getCornerLatLngs = function() {
      var result = [];
      var offsets = [
        [0, 0],
        [0, 1],
        [1, 1],
        [1, 0]
      ];
      for (var i = 0; i < 4; i++) {
        var st = S22.IJToST(this.ij, this.level, offsets[i]);
        var uv = S22.STToUV(st);
        var xyz = S22.FaceUVToXYZ(this.face, uv);
        result.push(S22.XYZToLatLng(xyz));
      }
      return result;
    };
    S22.S2Cell.prototype.getFaceAndQuads = function() {
      var quads = pointToHilbertQuadList(
        this.ij[0],
        this.ij[1],
        this.level,
        this.face
      );
      return [this.face, quads];
    };
    S22.S2Cell.prototype.toHilbertQuadkey = function() {
      var quads = pointToHilbertQuadList(
        this.ij[0],
        this.ij[1],
        this.level,
        this.face
      );
      return this.face.toString(10) + "/" + quads.join("");
    };
    S22.latLngToNeighborKeys = S22.S2Cell.latLngToNeighborKeys = function(lat, lng, level) {
      return S22.S2Cell.FromLatLng(
        {
          lat,
          lng
        },
        level
      ).getNeighbors().map(function(cell) {
        return cell.toHilbertQuadkey();
      });
    };
    S22.S2Cell.prototype.getNeighbors = function() {
      var fromFaceIJWrap = function(face2, ij, level2) {
        var maxSize = 1 << level2;
        if (ij[0] >= 0 && ij[1] >= 0 && ij[0] < maxSize && ij[1] < maxSize) {
          return S22.S2Cell.FromFaceIJ(face2, ij, level2);
        } else {
          var st = S22.IJToST(ij, level2, [0.5, 0.5]);
          var uv = S22.STToUV(st);
          var xyz = S22.FaceUVToXYZ(face2, uv);
          var faceuv = S22.XYZToFaceUV(xyz);
          face2 = faceuv[0];
          uv = faceuv[1];
          st = S22.UVToST(uv);
          ij = S22.STToIJ(st, level2);
          return S22.S2Cell.FromFaceIJ(face2, ij, level2);
        }
      };
      var face = this.face;
      var i = this.ij[0];
      var j = this.ij[1];
      var level = this.level;
      return [
        fromFaceIJWrap(face, [i - 1, j], level),
        fromFaceIJWrap(face, [i, j - 1], level),
        fromFaceIJWrap(face, [i + 1, j], level),
        fromFaceIJWrap(face, [i, j + 1], level)
      ];
    };
    S22.FACE_BITS = 3;
    S22.MAX_LEVEL = 30;
    S22.POS_BITS = 2 * S22.MAX_LEVEL + 1;
    S22.facePosLevelToId = S22.S2Cell.facePosLevelToId = S22.fromFacePosLevel = function(faceN, posS, levelN) {
      var Long = exports.dcodeIO && exports.dcodeIO.Long;
      var faceB;
      var posB;
      var bin;
      if (!levelN) {
        levelN = posS.length;
      }
      if (posS.length > levelN) {
        posS = posS.substr(0, levelN);
      }
      faceB = Long.fromString(faceN.toString(10), true, 10).toString(
        2
      );
      while (faceB.length < S22.FACE_BITS) {
        faceB = "0" + faceB;
      }
      posB = Long.fromString(posS, true, 4).toString(2);
      while (posB.length < 2 * levelN) {
        posB = "0" + posB;
      }
      bin = faceB + posB;
      bin += "1";
      while (bin.length < S22.FACE_BITS + S22.POS_BITS) {
        bin += "0";
      }
      return Long.fromString(bin, true, 2).toString(10);
    };
    S22.keyToId = S22.S2Cell.keyToId = S22.toId = S22.toCellId = S22.fromKey = function(key) {
      var parts = key.split("/");
      return S22.fromFacePosLevel(parts[0], parts[1], parts[1].length);
    };
    S22.idToKey = S22.S2Cell.idToKey = S22.S2Cell.toKey = S22.toKey = S22.fromId = S22.fromCellId = S22.S2Cell.toHilbertQuadkey = S22.toHilbertQuadkey = function(idS) {
      var Long = exports.dcodeIO && exports.dcodeIO.Long;
      var bin = Long.fromString(idS, true, 10).toString(2);
      while (bin.length < S22.FACE_BITS + S22.POS_BITS) {
        bin = "0" + bin;
      }
      var lsbIndex = bin.lastIndexOf("1");
      var faceB = bin.substring(0, 3);
      var posB = bin.substring(3, lsbIndex);
      var levelN = posB.length / 2;
      var faceS = Long.fromString(faceB, true, 2).toString(10);
      var posS = Long.fromString(posB, true, 2).toString(4);
      while (posS.length < levelN) {
        posS = "0" + posS;
      }
      return faceS + "/" + posS;
    };
    S22.keyToLatLng = S22.S2Cell.keyToLatLng = function(key) {
      var cell2 = S22.S2Cell.FromHilbertQuadKey(key);
      return cell2.getLatLng();
    };
    S22.idToLatLng = S22.S2Cell.idToLatLng = function(id2) {
      var key = S22.idToKey(id2);
      return S22.keyToLatLng(key);
    };
    S22.S2Cell.latLngToKey = S22.latLngToKey = S22.latLngToQuadkey = function(lat, lng, level) {
      if (isNaN(level) || level < 1 || level > 30) {
        throw new Error(
          "'level' is not a number between 1 and 30 (but it should be)"
        );
      }
      return S22.S2Cell.FromLatLng(
        {
          lat,
          lng
        },
        level
      ).toHilbertQuadkey();
    };
    S22.stepKey = function(key, num) {
      var Long = exports.dcodeIO && exports.dcodeIO.Long;
      var parts = key.split("/");
      var faceS = parts[0];
      var posS = parts[1];
      var level = parts[1].length;
      var posL = Long.fromString(posS, true, 4);
      var otherL;
      if (num > 0) {
        otherL = posL.add(Math.abs(num));
      } else if (num < 0) {
        otherL = posL.subtract(Math.abs(num));
      }
      var otherS = otherL.toString(4);
      if ("0" === otherS) {
        console.warning(
          new Error("face/position wrapping is not yet supported")
        );
      }
      while (otherS.length < level) {
        otherS = "0" + otherS;
      }
      return faceS + "/" + otherS;
    };
    S22.S2Cell.prevKey = S22.prevKey = function(key) {
      return S22.stepKey(key, -1);
    };
    S22.S2Cell.nextKey = S22.nextKey = function(key) {
      return S22.stepKey(key, 1);
    };
    return S22;
  }
  var S2 = exposeS2Module(
    typeof module !== "undefined" && module.exports ? module.exports : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : void 0
  );

  // source/typed-s2cell.ts
  function createCellFromCoordinates(latLng, level) {
    return S2.S2Cell.FromLatLng(latLng, level);
  }
  var indexes = Object.freeze(["0", "1", "2", "3"]);
  var buffer64 = new BigUint64Array(1);
  var view32 = new Uint32Array(buffer64.buffer);

  // source/queue.ts
  function createQueue(initialCapacity = 1024) {
    const buf = new Array(initialCapacity);
    const mask = initialCapacity - 1;
    let head = 0;
    let tail = 0;
    return {
      enqueue(x) {
        buf[tail & mask] = x;
        tail++;
      },
      dequeue() {
        if (head === tail) return void 0;
        const x = buf[head & mask];
        head++;
        return x;
      }
    };
  }

  // source/async-queue.ts
  function createAsyncQueue(consume, handleAsyncError2, { batchSize = 10 } = {}) {
    const queue = [];
    let processing = false;
    let scheduled = false;
    function push(item) {
      queue.push(item);
      schedule();
    }
    function schedule() {
      if (scheduled) return;
      scheduled = true;
      queueMicrotask(() => {
        scheduled = false;
        void flush().catch(handleAsyncError2);
      });
    }
    async function flush() {
      if (processing) return;
      if (queue.length === 0) return;
      processing = true;
      const batch = queue.splice(0, batchSize);
      try {
        await consume(batch);
      } finally {
        processing = false;
        if (queue.length) {
          schedule();
        }
      }
    }
    function close() {
      queue.length = 0;
    }
    return { push, close };
  }

  // node_modules/zod/v4/classic/external.js
  var external_exports = {};
  __export(external_exports, {
    $brand: () => $brand,
    $input: () => $input,
    $output: () => $output,
    NEVER: () => NEVER,
    TimePrecision: () => TimePrecision,
    ZodAny: () => ZodAny,
    ZodArray: () => ZodArray,
    ZodBase64: () => ZodBase64,
    ZodBase64URL: () => ZodBase64URL,
    ZodBigInt: () => ZodBigInt,
    ZodBigIntFormat: () => ZodBigIntFormat,
    ZodBoolean: () => ZodBoolean,
    ZodCIDRv4: () => ZodCIDRv4,
    ZodCIDRv6: () => ZodCIDRv6,
    ZodCUID: () => ZodCUID,
    ZodCUID2: () => ZodCUID2,
    ZodCatch: () => ZodCatch,
    ZodCodec: () => ZodCodec,
    ZodCustom: () => ZodCustom,
    ZodCustomStringFormat: () => ZodCustomStringFormat,
    ZodDate: () => ZodDate,
    ZodDefault: () => ZodDefault,
    ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
    ZodE164: () => ZodE164,
    ZodEmail: () => ZodEmail,
    ZodEmoji: () => ZodEmoji,
    ZodEnum: () => ZodEnum,
    ZodError: () => ZodError,
    ZodExactOptional: () => ZodExactOptional,
    ZodFile: () => ZodFile,
    ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
    ZodFunction: () => ZodFunction,
    ZodGUID: () => ZodGUID,
    ZodIPv4: () => ZodIPv4,
    ZodIPv6: () => ZodIPv6,
    ZodISODate: () => ZodISODate,
    ZodISODateTime: () => ZodISODateTime,
    ZodISODuration: () => ZodISODuration,
    ZodISOTime: () => ZodISOTime,
    ZodIntersection: () => ZodIntersection,
    ZodIssueCode: () => ZodIssueCode,
    ZodJWT: () => ZodJWT,
    ZodKSUID: () => ZodKSUID,
    ZodLazy: () => ZodLazy,
    ZodLiteral: () => ZodLiteral,
    ZodMAC: () => ZodMAC,
    ZodMap: () => ZodMap,
    ZodNaN: () => ZodNaN,
    ZodNanoID: () => ZodNanoID,
    ZodNever: () => ZodNever,
    ZodNonOptional: () => ZodNonOptional,
    ZodNull: () => ZodNull,
    ZodNullable: () => ZodNullable,
    ZodNumber: () => ZodNumber,
    ZodNumberFormat: () => ZodNumberFormat,
    ZodObject: () => ZodObject,
    ZodOptional: () => ZodOptional,
    ZodPipe: () => ZodPipe,
    ZodPrefault: () => ZodPrefault,
    ZodPromise: () => ZodPromise,
    ZodReadonly: () => ZodReadonly,
    ZodRealError: () => ZodRealError,
    ZodRecord: () => ZodRecord,
    ZodSet: () => ZodSet,
    ZodString: () => ZodString,
    ZodStringFormat: () => ZodStringFormat,
    ZodSuccess: () => ZodSuccess,
    ZodSymbol: () => ZodSymbol,
    ZodTemplateLiteral: () => ZodTemplateLiteral,
    ZodTransform: () => ZodTransform,
    ZodTuple: () => ZodTuple,
    ZodType: () => ZodType,
    ZodULID: () => ZodULID,
    ZodURL: () => ZodURL,
    ZodUUID: () => ZodUUID,
    ZodUndefined: () => ZodUndefined,
    ZodUnion: () => ZodUnion,
    ZodUnknown: () => ZodUnknown,
    ZodVoid: () => ZodVoid,
    ZodXID: () => ZodXID,
    ZodXor: () => ZodXor,
    _ZodString: () => _ZodString,
    _default: () => _default2,
    _function: () => _function,
    any: () => any,
    array: () => array,
    base64: () => base642,
    base64url: () => base64url2,
    bigint: () => bigint2,
    boolean: () => boolean2,
    catch: () => _catch2,
    check: () => check,
    cidrv4: () => cidrv42,
    cidrv6: () => cidrv62,
    clone: () => clone,
    codec: () => codec,
    coerce: () => coerce_exports,
    config: () => config,
    core: () => core_exports2,
    cuid: () => cuid3,
    cuid2: () => cuid22,
    custom: () => custom,
    date: () => date3,
    decode: () => decode2,
    decodeAsync: () => decodeAsync2,
    describe: () => describe2,
    discriminatedUnion: () => discriminatedUnion,
    e164: () => e1642,
    email: () => email2,
    emoji: () => emoji2,
    encode: () => encode2,
    encodeAsync: () => encodeAsync2,
    endsWith: () => _endsWith,
    enum: () => _enum2,
    exactOptional: () => exactOptional,
    file: () => file,
    flattenError: () => flattenError,
    float32: () => float32,
    float64: () => float64,
    formatError: () => formatError,
    fromJSONSchema: () => fromJSONSchema,
    function: () => _function,
    getErrorMap: () => getErrorMap,
    globalRegistry: () => globalRegistry,
    gt: () => _gt,
    gte: () => _gte,
    guid: () => guid2,
    hash: () => hash,
    hex: () => hex2,
    hostname: () => hostname2,
    httpUrl: () => httpUrl,
    includes: () => _includes,
    instanceof: () => _instanceof,
    int: () => int,
    int32: () => int32,
    int64: () => int64,
    intersection: () => intersection,
    ipv4: () => ipv42,
    ipv6: () => ipv62,
    iso: () => iso_exports,
    json: () => json,
    jwt: () => jwt,
    keyof: () => keyof,
    ksuid: () => ksuid2,
    lazy: () => lazy,
    length: () => _length,
    literal: () => literal,
    locales: () => locales_exports,
    looseObject: () => looseObject,
    looseRecord: () => looseRecord,
    lowercase: () => _lowercase,
    lt: () => _lt,
    lte: () => _lte,
    mac: () => mac2,
    map: () => map,
    maxLength: () => _maxLength,
    maxSize: () => _maxSize,
    meta: () => meta2,
    mime: () => _mime,
    minLength: () => _minLength,
    minSize: () => _minSize,
    multipleOf: () => _multipleOf,
    nan: () => nan,
    nanoid: () => nanoid2,
    nativeEnum: () => nativeEnum,
    negative: () => _negative,
    never: () => never,
    nonnegative: () => _nonnegative,
    nonoptional: () => nonoptional,
    nonpositive: () => _nonpositive,
    normalize: () => _normalize,
    null: () => _null3,
    nullable: () => nullable,
    nullish: () => nullish2,
    number: () => number2,
    object: () => object,
    optional: () => optional,
    overwrite: () => _overwrite,
    parse: () => parse2,
    parseAsync: () => parseAsync2,
    partialRecord: () => partialRecord,
    pipe: () => pipe,
    positive: () => _positive,
    prefault: () => prefault,
    preprocess: () => preprocess,
    prettifyError: () => prettifyError,
    promise: () => promise,
    property: () => _property,
    readonly: () => readonly,
    record: () => record,
    refine: () => refine,
    regex: () => _regex,
    regexes: () => regexes_exports,
    registry: () => registry,
    safeDecode: () => safeDecode2,
    safeDecodeAsync: () => safeDecodeAsync2,
    safeEncode: () => safeEncode2,
    safeEncodeAsync: () => safeEncodeAsync2,
    safeParse: () => safeParse2,
    safeParseAsync: () => safeParseAsync2,
    set: () => set,
    setErrorMap: () => setErrorMap,
    size: () => _size,
    slugify: () => _slugify,
    startsWith: () => _startsWith,
    strictObject: () => strictObject,
    string: () => string2,
    stringFormat: () => stringFormat,
    stringbool: () => stringbool,
    success: () => success,
    superRefine: () => superRefine,
    symbol: () => symbol,
    templateLiteral: () => templateLiteral,
    toJSONSchema: () => toJSONSchema,
    toLowerCase: () => _toLowerCase,
    toUpperCase: () => _toUpperCase,
    transform: () => transform,
    treeifyError: () => treeifyError,
    trim: () => _trim,
    tuple: () => tuple,
    uint32: () => uint32,
    uint64: () => uint64,
    ulid: () => ulid2,
    undefined: () => _undefined3,
    union: () => union,
    unknown: () => unknown,
    uppercase: () => _uppercase,
    url: () => url,
    util: () => util_exports,
    uuid: () => uuid2,
    uuidv4: () => uuidv4,
    uuidv6: () => uuidv6,
    uuidv7: () => uuidv7,
    void: () => _void2,
    xid: () => xid2,
    xor: () => xor
  });

  // node_modules/zod/v4/core/index.js
  var core_exports2 = {};
  __export(core_exports2, {
    $ZodAny: () => $ZodAny,
    $ZodArray: () => $ZodArray,
    $ZodAsyncError: () => $ZodAsyncError,
    $ZodBase64: () => $ZodBase64,
    $ZodBase64URL: () => $ZodBase64URL,
    $ZodBigInt: () => $ZodBigInt,
    $ZodBigIntFormat: () => $ZodBigIntFormat,
    $ZodBoolean: () => $ZodBoolean,
    $ZodCIDRv4: () => $ZodCIDRv4,
    $ZodCIDRv6: () => $ZodCIDRv6,
    $ZodCUID: () => $ZodCUID,
    $ZodCUID2: () => $ZodCUID2,
    $ZodCatch: () => $ZodCatch,
    $ZodCheck: () => $ZodCheck,
    $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
    $ZodCheckEndsWith: () => $ZodCheckEndsWith,
    $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
    $ZodCheckIncludes: () => $ZodCheckIncludes,
    $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
    $ZodCheckLessThan: () => $ZodCheckLessThan,
    $ZodCheckLowerCase: () => $ZodCheckLowerCase,
    $ZodCheckMaxLength: () => $ZodCheckMaxLength,
    $ZodCheckMaxSize: () => $ZodCheckMaxSize,
    $ZodCheckMimeType: () => $ZodCheckMimeType,
    $ZodCheckMinLength: () => $ZodCheckMinLength,
    $ZodCheckMinSize: () => $ZodCheckMinSize,
    $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
    $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
    $ZodCheckOverwrite: () => $ZodCheckOverwrite,
    $ZodCheckProperty: () => $ZodCheckProperty,
    $ZodCheckRegex: () => $ZodCheckRegex,
    $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
    $ZodCheckStartsWith: () => $ZodCheckStartsWith,
    $ZodCheckStringFormat: () => $ZodCheckStringFormat,
    $ZodCheckUpperCase: () => $ZodCheckUpperCase,
    $ZodCodec: () => $ZodCodec,
    $ZodCustom: () => $ZodCustom,
    $ZodCustomStringFormat: () => $ZodCustomStringFormat,
    $ZodDate: () => $ZodDate,
    $ZodDefault: () => $ZodDefault,
    $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
    $ZodE164: () => $ZodE164,
    $ZodEmail: () => $ZodEmail,
    $ZodEmoji: () => $ZodEmoji,
    $ZodEncodeError: () => $ZodEncodeError,
    $ZodEnum: () => $ZodEnum,
    $ZodError: () => $ZodError,
    $ZodExactOptional: () => $ZodExactOptional,
    $ZodFile: () => $ZodFile,
    $ZodFunction: () => $ZodFunction,
    $ZodGUID: () => $ZodGUID,
    $ZodIPv4: () => $ZodIPv4,
    $ZodIPv6: () => $ZodIPv6,
    $ZodISODate: () => $ZodISODate,
    $ZodISODateTime: () => $ZodISODateTime,
    $ZodISODuration: () => $ZodISODuration,
    $ZodISOTime: () => $ZodISOTime,
    $ZodIntersection: () => $ZodIntersection,
    $ZodJWT: () => $ZodJWT,
    $ZodKSUID: () => $ZodKSUID,
    $ZodLazy: () => $ZodLazy,
    $ZodLiteral: () => $ZodLiteral,
    $ZodMAC: () => $ZodMAC,
    $ZodMap: () => $ZodMap,
    $ZodNaN: () => $ZodNaN,
    $ZodNanoID: () => $ZodNanoID,
    $ZodNever: () => $ZodNever,
    $ZodNonOptional: () => $ZodNonOptional,
    $ZodNull: () => $ZodNull,
    $ZodNullable: () => $ZodNullable,
    $ZodNumber: () => $ZodNumber,
    $ZodNumberFormat: () => $ZodNumberFormat,
    $ZodObject: () => $ZodObject,
    $ZodObjectJIT: () => $ZodObjectJIT,
    $ZodOptional: () => $ZodOptional,
    $ZodPipe: () => $ZodPipe,
    $ZodPrefault: () => $ZodPrefault,
    $ZodPromise: () => $ZodPromise,
    $ZodReadonly: () => $ZodReadonly,
    $ZodRealError: () => $ZodRealError,
    $ZodRecord: () => $ZodRecord,
    $ZodRegistry: () => $ZodRegistry,
    $ZodSet: () => $ZodSet,
    $ZodString: () => $ZodString,
    $ZodStringFormat: () => $ZodStringFormat,
    $ZodSuccess: () => $ZodSuccess,
    $ZodSymbol: () => $ZodSymbol,
    $ZodTemplateLiteral: () => $ZodTemplateLiteral,
    $ZodTransform: () => $ZodTransform,
    $ZodTuple: () => $ZodTuple,
    $ZodType: () => $ZodType,
    $ZodULID: () => $ZodULID,
    $ZodURL: () => $ZodURL,
    $ZodUUID: () => $ZodUUID,
    $ZodUndefined: () => $ZodUndefined,
    $ZodUnion: () => $ZodUnion,
    $ZodUnknown: () => $ZodUnknown,
    $ZodVoid: () => $ZodVoid,
    $ZodXID: () => $ZodXID,
    $ZodXor: () => $ZodXor,
    $brand: () => $brand,
    $constructor: () => $constructor,
    $input: () => $input,
    $output: () => $output,
    Doc: () => Doc,
    JSONSchema: () => json_schema_exports,
    JSONSchemaGenerator: () => JSONSchemaGenerator,
    NEVER: () => NEVER,
    TimePrecision: () => TimePrecision,
    _any: () => _any,
    _array: () => _array,
    _base64: () => _base64,
    _base64url: () => _base64url,
    _bigint: () => _bigint,
    _boolean: () => _boolean,
    _catch: () => _catch,
    _check: () => _check,
    _cidrv4: () => _cidrv4,
    _cidrv6: () => _cidrv6,
    _coercedBigint: () => _coercedBigint,
    _coercedBoolean: () => _coercedBoolean,
    _coercedDate: () => _coercedDate,
    _coercedNumber: () => _coercedNumber,
    _coercedString: () => _coercedString,
    _cuid: () => _cuid,
    _cuid2: () => _cuid2,
    _custom: () => _custom,
    _date: () => _date,
    _decode: () => _decode,
    _decodeAsync: () => _decodeAsync,
    _default: () => _default,
    _discriminatedUnion: () => _discriminatedUnion,
    _e164: () => _e164,
    _email: () => _email,
    _emoji: () => _emoji2,
    _encode: () => _encode,
    _encodeAsync: () => _encodeAsync,
    _endsWith: () => _endsWith,
    _enum: () => _enum,
    _file: () => _file,
    _float32: () => _float32,
    _float64: () => _float64,
    _gt: () => _gt,
    _gte: () => _gte,
    _guid: () => _guid,
    _includes: () => _includes,
    _int: () => _int,
    _int32: () => _int32,
    _int64: () => _int64,
    _intersection: () => _intersection,
    _ipv4: () => _ipv4,
    _ipv6: () => _ipv6,
    _isoDate: () => _isoDate,
    _isoDateTime: () => _isoDateTime,
    _isoDuration: () => _isoDuration,
    _isoTime: () => _isoTime,
    _jwt: () => _jwt,
    _ksuid: () => _ksuid,
    _lazy: () => _lazy,
    _length: () => _length,
    _literal: () => _literal,
    _lowercase: () => _lowercase,
    _lt: () => _lt,
    _lte: () => _lte,
    _mac: () => _mac,
    _map: () => _map,
    _max: () => _lte,
    _maxLength: () => _maxLength,
    _maxSize: () => _maxSize,
    _mime: () => _mime,
    _min: () => _gte,
    _minLength: () => _minLength,
    _minSize: () => _minSize,
    _multipleOf: () => _multipleOf,
    _nan: () => _nan,
    _nanoid: () => _nanoid,
    _nativeEnum: () => _nativeEnum,
    _negative: () => _negative,
    _never: () => _never,
    _nonnegative: () => _nonnegative,
    _nonoptional: () => _nonoptional,
    _nonpositive: () => _nonpositive,
    _normalize: () => _normalize,
    _null: () => _null2,
    _nullable: () => _nullable,
    _number: () => _number,
    _optional: () => _optional,
    _overwrite: () => _overwrite,
    _parse: () => _parse,
    _parseAsync: () => _parseAsync,
    _pipe: () => _pipe,
    _positive: () => _positive,
    _promise: () => _promise,
    _property: () => _property,
    _readonly: () => _readonly,
    _record: () => _record,
    _refine: () => _refine,
    _regex: () => _regex,
    _safeDecode: () => _safeDecode,
    _safeDecodeAsync: () => _safeDecodeAsync,
    _safeEncode: () => _safeEncode,
    _safeEncodeAsync: () => _safeEncodeAsync,
    _safeParse: () => _safeParse,
    _safeParseAsync: () => _safeParseAsync,
    _set: () => _set,
    _size: () => _size,
    _slugify: () => _slugify,
    _startsWith: () => _startsWith,
    _string: () => _string,
    _stringFormat: () => _stringFormat,
    _stringbool: () => _stringbool,
    _success: () => _success,
    _superRefine: () => _superRefine,
    _symbol: () => _symbol,
    _templateLiteral: () => _templateLiteral,
    _toLowerCase: () => _toLowerCase,
    _toUpperCase: () => _toUpperCase,
    _transform: () => _transform,
    _trim: () => _trim,
    _tuple: () => _tuple,
    _uint32: () => _uint32,
    _uint64: () => _uint64,
    _ulid: () => _ulid,
    _undefined: () => _undefined2,
    _union: () => _union,
    _unknown: () => _unknown,
    _uppercase: () => _uppercase,
    _url: () => _url,
    _uuid: () => _uuid,
    _uuidv4: () => _uuidv4,
    _uuidv6: () => _uuidv6,
    _uuidv7: () => _uuidv7,
    _void: () => _void,
    _xid: () => _xid,
    _xor: () => _xor,
    clone: () => clone,
    config: () => config,
    createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
    createToJSONSchemaMethod: () => createToJSONSchemaMethod,
    decode: () => decode,
    decodeAsync: () => decodeAsync,
    describe: () => describe,
    encode: () => encode,
    encodeAsync: () => encodeAsync,
    extractDefs: () => extractDefs,
    finalize: () => finalize,
    flattenError: () => flattenError,
    formatError: () => formatError,
    globalConfig: () => globalConfig,
    globalRegistry: () => globalRegistry,
    initializeContext: () => initializeContext,
    isValidBase64: () => isValidBase64,
    isValidBase64URL: () => isValidBase64URL,
    isValidJWT: () => isValidJWT,
    locales: () => locales_exports,
    meta: () => meta,
    parse: () => parse,
    parseAsync: () => parseAsync,
    prettifyError: () => prettifyError,
    process: () => process,
    regexes: () => regexes_exports,
    registry: () => registry,
    safeDecode: () => safeDecode,
    safeDecodeAsync: () => safeDecodeAsync,
    safeEncode: () => safeEncode,
    safeEncodeAsync: () => safeEncodeAsync,
    safeParse: () => safeParse,
    safeParseAsync: () => safeParseAsync,
    toDotPath: () => toDotPath,
    toJSONSchema: () => toJSONSchema,
    treeifyError: () => treeifyError,
    util: () => util_exports,
    version: () => version
  });

  // node_modules/zod/v4/core/core.js
  var NEVER = Object.freeze({
    status: "aborted"
  });
  // @__NO_SIDE_EFFECTS__
  function $constructor(name, initializer3, params) {
    function init(inst, def) {
      if (!inst._zod) {
        Object.defineProperty(inst, "_zod", {
          value: {
            def,
            constr: _,
            traits: /* @__PURE__ */ new Set()
          },
          enumerable: false
        });
      }
      if (inst._zod.traits.has(name)) {
        return;
      }
      inst._zod.traits.add(name);
      initializer3(inst, def);
      const proto = _.prototype;
      const keys = Object.keys(proto);
      for (let i = 0; i < keys.length; i++) {
        const k = keys[i];
        if (!(k in inst)) {
          inst[k] = proto[k].bind(inst);
        }
      }
    }
    const Parent = params?.Parent ?? Object;
    class Definition extends Parent {
    }
    Object.defineProperty(Definition, "name", { value: name });
    function _(def) {
      var _a2;
      const inst = params?.Parent ? new Definition() : this;
      init(inst, def);
      (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
      for (const fn of inst._zod.deferred) {
        fn();
      }
      return inst;
    }
    Object.defineProperty(_, "init", { value: init });
    Object.defineProperty(_, Symbol.hasInstance, {
      value: (inst) => {
        if (params?.Parent && inst instanceof params.Parent)
          return true;
        return inst?._zod?.traits?.has(name);
      }
    });
    Object.defineProperty(_, "name", { value: name });
    return _;
  }
  var $brand = /* @__PURE__ */ Symbol("zod_brand");
  var $ZodAsyncError = class extends Error {
    constructor() {
      super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
    }
  };
  var $ZodEncodeError = class extends Error {
    constructor(name) {
      super(`Encountered unidirectional transform during encode: ${name}`);
      this.name = "ZodEncodeError";
    }
  };
  var globalConfig = {};
  function config(newConfig) {
    if (newConfig)
      Object.assign(globalConfig, newConfig);
    return globalConfig;
  }

  // node_modules/zod/v4/core/util.js
  var util_exports = {};
  __export(util_exports, {
    BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
    Class: () => Class,
    NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
    aborted: () => aborted,
    allowsEval: () => allowsEval,
    assert: () => assert,
    assertEqual: () => assertEqual,
    assertIs: () => assertIs,
    assertNever: () => assertNever,
    assertNotEqual: () => assertNotEqual,
    assignProp: () => assignProp,
    base64ToUint8Array: () => base64ToUint8Array,
    base64urlToUint8Array: () => base64urlToUint8Array,
    cached: () => cached,
    captureStackTrace: () => captureStackTrace,
    cleanEnum: () => cleanEnum,
    cleanRegex: () => cleanRegex,
    clone: () => clone,
    cloneDef: () => cloneDef,
    createTransparentProxy: () => createTransparentProxy,
    defineLazy: () => defineLazy,
    esc: () => esc,
    escapeRegex: () => escapeRegex,
    extend: () => extend,
    finalizeIssue: () => finalizeIssue,
    floatSafeRemainder: () => floatSafeRemainder,
    getElementAtPath: () => getElementAtPath,
    getEnumValues: () => getEnumValues,
    getLengthableOrigin: () => getLengthableOrigin,
    getParsedType: () => getParsedType,
    getSizableOrigin: () => getSizableOrigin,
    hexToUint8Array: () => hexToUint8Array,
    isObject: () => isObject,
    isPlainObject: () => isPlainObject,
    issue: () => issue,
    joinValues: () => joinValues,
    jsonStringifyReplacer: () => jsonStringifyReplacer,
    merge: () => merge,
    mergeDefs: () => mergeDefs,
    normalizeParams: () => normalizeParams,
    nullish: () => nullish,
    numKeys: () => numKeys,
    objectClone: () => objectClone,
    omit: () => omit,
    optionalKeys: () => optionalKeys,
    parsedType: () => parsedType,
    partial: () => partial,
    pick: () => pick,
    prefixIssues: () => prefixIssues,
    primitiveTypes: () => primitiveTypes,
    promiseAllObject: () => promiseAllObject,
    propertyKeyTypes: () => propertyKeyTypes,
    randomString: () => randomString,
    required: () => required,
    safeExtend: () => safeExtend,
    shallowClone: () => shallowClone,
    slugify: () => slugify,
    stringifyPrimitive: () => stringifyPrimitive,
    uint8ArrayToBase64: () => uint8ArrayToBase64,
    uint8ArrayToBase64url: () => uint8ArrayToBase64url,
    uint8ArrayToHex: () => uint8ArrayToHex,
    unwrapMessage: () => unwrapMessage
  });
  function assertEqual(val) {
    return val;
  }
  function assertNotEqual(val) {
    return val;
  }
  function assertIs(_arg) {
  }
  function assertNever(_x) {
    throw new Error("Unexpected value in exhaustive check");
  }
  function assert(_) {
  }
  function getEnumValues(entries) {
    const numericValues = Object.values(entries).filter((v) => typeof v === "number");
    const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
    return values;
  }
  function joinValues(array3, separator = "|") {
    return array3.map((val) => stringifyPrimitive(val)).join(separator);
  }
  function jsonStringifyReplacer(_, value) {
    if (typeof value === "bigint")
      return value.toString();
    return value;
  }
  function cached(getter) {
    const set2 = false;
    return {
      get value() {
        if (!set2) {
          const value = getter();
          Object.defineProperty(this, "value", { value });
          return value;
        }
        throw new Error("cached value already set");
      }
    };
  }
  function nullish(input) {
    return input === null || input === void 0;
  }
  function cleanRegex(source) {
    const start = source.startsWith("^") ? 1 : 0;
    const end = source.endsWith("$") ? source.length - 1 : source.length;
    return source.slice(start, end);
  }
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepString = step.toString();
    let stepDecCount = (stepString.split(".")[1] || "").length;
    if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
      const match = stepString.match(/\d?e-(\d?)/);
      if (match?.[1]) {
        stepDecCount = Number.parseInt(match[1]);
      }
    }
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
  }
  var EVALUATING = /* @__PURE__ */ Symbol("evaluating");
  function defineLazy(object2, key, getter) {
    let value = void 0;
    Object.defineProperty(object2, key, {
      get() {
        if (value === EVALUATING) {
          return void 0;
        }
        if (value === void 0) {
          value = EVALUATING;
          value = getter();
        }
        return value;
      },
      set(v) {
        Object.defineProperty(object2, key, {
          value: v
          // configurable: true,
        });
      },
      configurable: true
    });
  }
  function objectClone(obj) {
    return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
  }
  function assignProp(target, prop, value) {
    Object.defineProperty(target, prop, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
  }
  function mergeDefs(...defs) {
    const mergedDescriptors = {};
    for (const def of defs) {
      const descriptors = Object.getOwnPropertyDescriptors(def);
      Object.assign(mergedDescriptors, descriptors);
    }
    return Object.defineProperties({}, mergedDescriptors);
  }
  function cloneDef(schema) {
    return mergeDefs(schema._zod.def);
  }
  function getElementAtPath(obj, path) {
    if (!path)
      return obj;
    return path.reduce((acc, key) => acc?.[key], obj);
  }
  function promiseAllObject(promisesObj) {
    const keys = Object.keys(promisesObj);
    const promises = keys.map((key) => promisesObj[key]);
    return Promise.all(promises).then((results) => {
      const resolvedObj = {};
      for (let i = 0; i < keys.length; i++) {
        resolvedObj[keys[i]] = results[i];
      }
      return resolvedObj;
    });
  }
  function randomString(length = 10) {
    const chars = "abcdefghijklmnopqrstuvwxyz";
    let str = "";
    for (let i = 0; i < length; i++) {
      str += chars[Math.floor(Math.random() * chars.length)];
    }
    return str;
  }
  function esc(str) {
    return JSON.stringify(str);
  }
  function slugify(input) {
    return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
  }
  var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
  };
  function isObject(data) {
    return typeof data === "object" && data !== null && !Array.isArray(data);
  }
  var allowsEval = cached(() => {
    if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
      return false;
    }
    try {
      const F = Function;
      new F("");
      return true;
    } catch (_) {
      return false;
    }
  });
  function isPlainObject(o) {
    if (isObject(o) === false)
      return false;
    const ctor = o.constructor;
    if (ctor === void 0)
      return true;
    if (typeof ctor !== "function")
      return true;
    const prot = ctor.prototype;
    if (isObject(prot) === false)
      return false;
    if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
      return false;
    }
    return true;
  }
  function shallowClone(o) {
    if (isPlainObject(o))
      return { ...o };
    if (Array.isArray(o))
      return [...o];
    return o;
  }
  function numKeys(data) {
    let keyCount = 0;
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        keyCount++;
      }
    }
    return keyCount;
  }
  var getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return "undefined";
      case "string":
        return "string";
      case "number":
        return Number.isNaN(data) ? "nan" : "number";
      case "boolean":
        return "boolean";
      case "function":
        return "function";
      case "bigint":
        return "bigint";
      case "symbol":
        return "symbol";
      case "object":
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return "promise";
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return "map";
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return "set";
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return "date";
        }
        if (typeof File !== "undefined" && data instanceof File) {
          return "file";
        }
        return "object";
      default:
        throw new Error(`Unknown data type: ${t}`);
    }
  };
  var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
  var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
  function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function clone(inst, def, params) {
    const cl = new inst._zod.constr(def ?? inst._zod.def);
    if (!def || params?.parent)
      cl._zod.parent = inst;
    return cl;
  }
  function normalizeParams(_params) {
    const params = _params;
    if (!params)
      return {};
    if (typeof params === "string")
      return { error: () => params };
    if (params?.message !== void 0) {
      if (params?.error !== void 0)
        throw new Error("Cannot specify both `message` and `error` params");
      params.error = params.message;
    }
    delete params.message;
    if (typeof params.error === "string")
      return { ...params, error: () => params.error };
    return params;
  }
  function createTransparentProxy(getter) {
    let target;
    return new Proxy({}, {
      get(_, prop, receiver) {
        target ?? (target = getter());
        return Reflect.get(target, prop, receiver);
      },
      set(_, prop, value, receiver) {
        target ?? (target = getter());
        return Reflect.set(target, prop, value, receiver);
      },
      has(_, prop) {
        target ?? (target = getter());
        return Reflect.has(target, prop);
      },
      deleteProperty(_, prop) {
        target ?? (target = getter());
        return Reflect.deleteProperty(target, prop);
      },
      ownKeys(_) {
        target ?? (target = getter());
        return Reflect.ownKeys(target);
      },
      getOwnPropertyDescriptor(_, prop) {
        target ?? (target = getter());
        return Reflect.getOwnPropertyDescriptor(target, prop);
      },
      defineProperty(_, prop, descriptor) {
        target ?? (target = getter());
        return Reflect.defineProperty(target, prop, descriptor);
      }
    });
  }
  function stringifyPrimitive(value) {
    if (typeof value === "bigint")
      return value.toString() + "n";
    if (typeof value === "string")
      return `"${value}"`;
    return `${value}`;
  }
  function optionalKeys(shape) {
    return Object.keys(shape).filter((k) => {
      return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
    });
  }
  var NUMBER_FORMAT_RANGES = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-34028234663852886e22, 34028234663852886e22],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
  };
  var BIGINT_FORMAT_RANGES = {
    int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
    uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
  };
  function pick(schema, mask) {
    const currDef = schema._zod.def;
    const checks = currDef.checks;
    const hasChecks = checks && checks.length > 0;
    if (hasChecks) {
      throw new Error(".pick() cannot be used on object schemas containing refinements");
    }
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const newShape = {};
        for (const key in mask) {
          if (!(key in currDef.shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          newShape[key] = currDef.shape[key];
        }
        assignProp(this, "shape", newShape);
        return newShape;
      },
      checks: []
    });
    return clone(schema, def);
  }
  function omit(schema, mask) {
    const currDef = schema._zod.def;
    const checks = currDef.checks;
    const hasChecks = checks && checks.length > 0;
    if (hasChecks) {
      throw new Error(".omit() cannot be used on object schemas containing refinements");
    }
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const newShape = { ...schema._zod.def.shape };
        for (const key in mask) {
          if (!(key in currDef.shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          delete newShape[key];
        }
        assignProp(this, "shape", newShape);
        return newShape;
      },
      checks: []
    });
    return clone(schema, def);
  }
  function extend(schema, shape) {
    if (!isPlainObject(shape)) {
      throw new Error("Invalid input to extend: expected a plain object");
    }
    const checks = schema._zod.def.checks;
    const hasChecks = checks && checks.length > 0;
    if (hasChecks) {
      const existingShape = schema._zod.def.shape;
      for (const key in shape) {
        if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) {
          throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
        }
      }
    }
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const _shape = { ...schema._zod.def.shape, ...shape };
        assignProp(this, "shape", _shape);
        return _shape;
      }
    });
    return clone(schema, def);
  }
  function safeExtend(schema, shape) {
    if (!isPlainObject(shape)) {
      throw new Error("Invalid input to safeExtend: expected a plain object");
    }
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const _shape = { ...schema._zod.def.shape, ...shape };
        assignProp(this, "shape", _shape);
        return _shape;
      }
    });
    return clone(schema, def);
  }
  function merge(a, b) {
    const def = mergeDefs(a._zod.def, {
      get shape() {
        const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
        assignProp(this, "shape", _shape);
        return _shape;
      },
      get catchall() {
        return b._zod.def.catchall;
      },
      checks: []
      // delete existing checks
    });
    return clone(a, def);
  }
  function partial(Class2, schema, mask) {
    const currDef = schema._zod.def;
    const checks = currDef.checks;
    const hasChecks = checks && checks.length > 0;
    if (hasChecks) {
      throw new Error(".partial() cannot be used on object schemas containing refinements");
    }
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const oldShape = schema._zod.def.shape;
        const shape = { ...oldShape };
        if (mask) {
          for (const key in mask) {
            if (!(key in oldShape)) {
              throw new Error(`Unrecognized key: "${key}"`);
            }
            if (!mask[key])
              continue;
            shape[key] = Class2 ? new Class2({
              type: "optional",
              innerType: oldShape[key]
            }) : oldShape[key];
          }
        } else {
          for (const key in oldShape) {
            shape[key] = Class2 ? new Class2({
              type: "optional",
              innerType: oldShape[key]
            }) : oldShape[key];
          }
        }
        assignProp(this, "shape", shape);
        return shape;
      },
      checks: []
    });
    return clone(schema, def);
  }
  function required(Class2, schema, mask) {
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const oldShape = schema._zod.def.shape;
        const shape = { ...oldShape };
        if (mask) {
          for (const key in mask) {
            if (!(key in shape)) {
              throw new Error(`Unrecognized key: "${key}"`);
            }
            if (!mask[key])
              continue;
            shape[key] = new Class2({
              type: "nonoptional",
              innerType: oldShape[key]
            });
          }
        } else {
          for (const key in oldShape) {
            shape[key] = new Class2({
              type: "nonoptional",
              innerType: oldShape[key]
            });
          }
        }
        assignProp(this, "shape", shape);
        return shape;
      }
    });
    return clone(schema, def);
  }
  function aborted(x, startIndex = 0) {
    if (x.aborted === true)
      return true;
    for (let i = startIndex; i < x.issues.length; i++) {
      if (x.issues[i]?.continue !== true) {
        return true;
      }
    }
    return false;
  }
  function prefixIssues(path, issues) {
    return issues.map((iss) => {
      var _a2;
      (_a2 = iss).path ?? (_a2.path = []);
      iss.path.unshift(path);
      return iss;
    });
  }
  function unwrapMessage(message) {
    return typeof message === "string" ? message : message?.message;
  }
  function finalizeIssue(iss, ctx, config2) {
    const full = { ...iss, path: iss.path ?? [] };
    if (!iss.message) {
      const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
      full.message = message;
    }
    delete full.inst;
    delete full.continue;
    if (!ctx?.reportInput) {
      delete full.input;
    }
    return full;
  }
  function getSizableOrigin(input) {
    if (input instanceof Set)
      return "set";
    if (input instanceof Map)
      return "map";
    if (input instanceof File)
      return "file";
    return "unknown";
  }
  function getLengthableOrigin(input) {
    if (Array.isArray(input))
      return "array";
    if (typeof input === "string")
      return "string";
    return "unknown";
  }
  function parsedType(data) {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "nan" : "number";
      }
      case "object": {
        if (data === null) {
          return "null";
        }
        if (Array.isArray(data)) {
          return "array";
        }
        const obj = data;
        if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
          return obj.constructor.name;
        }
      }
    }
    return t;
  }
  function issue(...args) {
    const [iss, input, inst] = args;
    if (typeof iss === "string") {
      return {
        message: iss,
        code: "custom",
        input,
        inst
      };
    }
    return { ...iss };
  }
  function cleanEnum(obj) {
    return Object.entries(obj).filter(([k, _]) => {
      return Number.isNaN(Number.parseInt(k, 10));
    }).map((el) => el[1]);
  }
  function base64ToUint8Array(base643) {
    const binaryString = atob(base643);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  }
  function uint8ArrayToBase64(bytes) {
    let binaryString = "";
    for (let i = 0; i < bytes.length; i++) {
      binaryString += String.fromCharCode(bytes[i]);
    }
    return btoa(binaryString);
  }
  function base64urlToUint8Array(base64url3) {
    const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
    const padding = "=".repeat((4 - base643.length % 4) % 4);
    return base64ToUint8Array(base643 + padding);
  }
  function uint8ArrayToBase64url(bytes) {
    return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  }
  function hexToUint8Array(hex3) {
    const cleanHex = hex3.replace(/^0x/, "");
    if (cleanHex.length % 2 !== 0) {
      throw new Error("Invalid hex string length");
    }
    const bytes = new Uint8Array(cleanHex.length / 2);
    for (let i = 0; i < cleanHex.length; i += 2) {
      bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
    }
    return bytes;
  }
  function uint8ArrayToHex(bytes) {
    return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  var Class = class {
    constructor(..._args) {
    }
  };

  // node_modules/zod/v4/core/errors.js
  var initializer = (inst, def) => {
    inst.name = "$ZodError";
    Object.defineProperty(inst, "_zod", {
      value: inst._zod,
      enumerable: false
    });
    Object.defineProperty(inst, "issues", {
      value: def,
      enumerable: false
    });
    inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
    Object.defineProperty(inst, "toString", {
      value: () => inst.message,
      enumerable: false
    });
  };
  var $ZodError = $constructor("$ZodError", initializer);
  var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
  function flattenError(error48, mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of error48.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  function formatError(error48, mapper = (issue2) => issue2.message) {
    const fieldErrors = { _errors: [] };
    const processError = (error49) => {
      for (const issue2 of error49.issues) {
        if (issue2.code === "invalid_union" && issue2.errors.length) {
          issue2.errors.map((issues) => processError({ issues }));
        } else if (issue2.code === "invalid_key") {
          processError({ issues: issue2.issues });
        } else if (issue2.code === "invalid_element") {
          processError({ issues: issue2.issues });
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(error48);
    return fieldErrors;
  }
  function treeifyError(error48, mapper = (issue2) => issue2.message) {
    const result = { errors: [] };
    const processError = (error49, path = []) => {
      var _a2, _b;
      for (const issue2 of error49.issues) {
        if (issue2.code === "invalid_union" && issue2.errors.length) {
          issue2.errors.map((issues) => processError({ issues }, issue2.path));
        } else if (issue2.code === "invalid_key") {
          processError({ issues: issue2.issues }, issue2.path);
        } else if (issue2.code === "invalid_element") {
          processError({ issues: issue2.issues }, issue2.path);
        } else {
          const fullpath = [...path, ...issue2.path];
          if (fullpath.length === 0) {
            result.errors.push(mapper(issue2));
            continue;
          }
          let curr = result;
          let i = 0;
          while (i < fullpath.length) {
            const el = fullpath[i];
            const terminal = i === fullpath.length - 1;
            if (typeof el === "string") {
              curr.properties ?? (curr.properties = {});
              (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
              curr = curr.properties[el];
            } else {
              curr.items ?? (curr.items = []);
              (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
              curr = curr.items[el];
            }
            if (terminal) {
              curr.errors.push(mapper(issue2));
            }
            i++;
          }
        }
      }
    };
    processError(error48);
    return result;
  }
  function toDotPath(_path) {
    const segs = [];
    const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
    for (const seg of path) {
      if (typeof seg === "number")
        segs.push(`[${seg}]`);
      else if (typeof seg === "symbol")
        segs.push(`[${JSON.stringify(String(seg))}]`);
      else if (/[^\w$]/.test(seg))
        segs.push(`[${JSON.stringify(seg)}]`);
      else {
        if (segs.length)
          segs.push(".");
        segs.push(seg);
      }
    }
    return segs.join("");
  }
  function prettifyError(error48) {
    const lines = [];
    const issues = [...error48.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
    for (const issue2 of issues) {
      lines.push(`\u2716 ${issue2.message}`);
      if (issue2.path?.length)
        lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
    }
    return lines.join("\n");
  }

  // node_modules/zod/v4/core/parse.js
  var _parse = (_Err) => (schema, value, _ctx, _params) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
    const result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise) {
      throw new $ZodAsyncError();
    }
    if (result.issues.length) {
      const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
      captureStackTrace(e, _params?.callee);
      throw e;
    }
    return result.value;
  };
  var parse = /* @__PURE__ */ _parse($ZodRealError);
  var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
    let result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise)
      result = await result;
    if (result.issues.length) {
      const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
      captureStackTrace(e, params?.callee);
      throw e;
    }
    return result.value;
  };
  var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
  var _safeParse = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
    const result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise) {
      throw new $ZodAsyncError();
    }
    return result.issues.length ? {
      success: false,
      error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    } : { success: true, data: result.value };
  };
  var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
  var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
    let result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise)
      result = await result;
    return result.issues.length ? {
      success: false,
      error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    } : { success: true, data: result.value };
  };
  var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
  var _encode = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _parse(_Err)(schema, value, ctx);
  };
  var encode = /* @__PURE__ */ _encode($ZodRealError);
  var _decode = (_Err) => (schema, value, _ctx) => {
    return _parse(_Err)(schema, value, _ctx);
  };
  var decode = /* @__PURE__ */ _decode($ZodRealError);
  var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _parseAsync(_Err)(schema, value, ctx);
  };
  var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
  var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
    return _parseAsync(_Err)(schema, value, _ctx);
  };
  var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
  var _safeEncode = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _safeParse(_Err)(schema, value, ctx);
  };
  var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
  var _safeDecode = (_Err) => (schema, value, _ctx) => {
    return _safeParse(_Err)(schema, value, _ctx);
  };
  var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
  var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _safeParseAsync(_Err)(schema, value, ctx);
  };
  var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
  var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
    return _safeParseAsync(_Err)(schema, value, _ctx);
  };
  var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);

  // node_modules/zod/v4/core/regexes.js
  var regexes_exports = {};
  __export(regexes_exports, {
    base64: () => base64,
    base64url: () => base64url,
    bigint: () => bigint,
    boolean: () => boolean,
    browserEmail: () => browserEmail,
    cidrv4: () => cidrv4,
    cidrv6: () => cidrv6,
    cuid: () => cuid,
    cuid2: () => cuid2,
    date: () => date,
    datetime: () => datetime,
    domain: () => domain,
    duration: () => duration,
    e164: () => e164,
    email: () => email,
    emoji: () => emoji,
    extendedDuration: () => extendedDuration,
    guid: () => guid,
    hex: () => hex,
    hostname: () => hostname,
    html5Email: () => html5Email,
    idnEmail: () => idnEmail,
    integer: () => integer,
    ipv4: () => ipv4,
    ipv6: () => ipv6,
    ksuid: () => ksuid,
    lowercase: () => lowercase,
    mac: () => mac,
    md5_base64: () => md5_base64,
    md5_base64url: () => md5_base64url,
    md5_hex: () => md5_hex,
    nanoid: () => nanoid,
    null: () => _null,
    number: () => number,
    rfc5322Email: () => rfc5322Email,
    sha1_base64: () => sha1_base64,
    sha1_base64url: () => sha1_base64url,
    sha1_hex: () => sha1_hex,
    sha256_base64: () => sha256_base64,
    sha256_base64url: () => sha256_base64url,
    sha256_hex: () => sha256_hex,
    sha384_base64: () => sha384_base64,
    sha384_base64url: () => sha384_base64url,
    sha384_hex: () => sha384_hex,
    sha512_base64: () => sha512_base64,
    sha512_base64url: () => sha512_base64url,
    sha512_hex: () => sha512_hex,
    string: () => string,
    time: () => time,
    ulid: () => ulid,
    undefined: () => _undefined,
    unicodeEmail: () => unicodeEmail,
    uppercase: () => uppercase,
    uuid: () => uuid,
    uuid4: () => uuid4,
    uuid6: () => uuid6,
    uuid7: () => uuid7,
    xid: () => xid
  });
  var cuid = /^[cC][^\s-]{8,}$/;
  var cuid2 = /^[0-9a-z]+$/;
  var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
  var xid = /^[0-9a-vA-V]{20}$/;
  var ksuid = /^[A-Za-z0-9]{27}$/;
  var nanoid = /^[a-zA-Z0-9_-]{21}$/;
  var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
  var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
  var uuid = (version2) => {
    if (!version2)
      return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
    return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
  };
  var uuid4 = /* @__PURE__ */ uuid(4);
  var uuid6 = /* @__PURE__ */ uuid(6);
  var uuid7 = /* @__PURE__ */ uuid(7);
  var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
  var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
  var idnEmail = unicodeEmail;
  var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  function emoji() {
    return new RegExp(_emoji, "u");
  }
  var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
  var mac = (delimiter) => {
    const escapedDelim = escapeRegex(delimiter ?? ":");
    return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
  };
  var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
  var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
  var base64url = /^[A-Za-z0-9_-]*$/;
  var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
  var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
  var e164 = /^\+[1-9]\d{6,14}$/;
  var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
  var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
  function timeSource(args) {
    const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
    const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
    return regex;
  }
  function time(args) {
    return new RegExp(`^${timeSource(args)}$`);
  }
  function datetime(args) {
    const time3 = timeSource({ precision: args.precision });
    const opts = ["Z"];
    if (args.local)
      opts.push("");
    if (args.offset)
      opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
    const timeRegex = `${time3}(?:${opts.join("|")})`;
    return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
  }
  var string = (params) => {
    const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
    return new RegExp(`^${regex}$`);
  };
  var bigint = /^-?\d+n?$/;
  var integer = /^-?\d+$/;
  var number = /^-?\d+(?:\.\d+)?$/;
  var boolean = /^(?:true|false)$/i;
  var _null = /^null$/i;
  var _undefined = /^undefined$/i;
  var lowercase = /^[^A-Z]*$/;
  var uppercase = /^[^a-z]*$/;
  var hex = /^[0-9a-fA-F]*$/;
  function fixedBase64(bodyLength, padding) {
    return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
  }
  function fixedBase64url(length) {
    return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
  }
  var md5_hex = /^[0-9a-fA-F]{32}$/;
  var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
  var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
  var sha1_hex = /^[0-9a-fA-F]{40}$/;
  var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
  var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
  var sha256_hex = /^[0-9a-fA-F]{64}$/;
  var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
  var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
  var sha384_hex = /^[0-9a-fA-F]{96}$/;
  var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
  var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
  var sha512_hex = /^[0-9a-fA-F]{128}$/;
  var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
  var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

  // node_modules/zod/v4/core/checks.js
  var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
    var _a2;
    inst._zod ?? (inst._zod = {});
    inst._zod.def = def;
    (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
  });
  var numericOriginMap = {
    number: "number",
    bigint: "bigint",
    object: "date"
  };
  var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
      if (def.value < curr) {
        if (def.inclusive)
          bag.maximum = def.value;
        else
          bag.exclusiveMaximum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
      if (def.value > curr) {
        if (def.inclusive)
          bag.minimum = def.value;
        else
          bag.exclusiveMinimum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      var _a2;
      (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
    });
    inst._zod.check = (payload) => {
      if (typeof payload.value !== typeof def.value)
        throw new Error("Cannot mix number and bigint in multiple_of check.");
      const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
      if (isMultiple)
        return;
      payload.issues.push({
        origin: typeof payload.value,
        code: "not_multiple_of",
        divisor: def.value,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
    $ZodCheck.init(inst, def);
    def.format = def.format || "float64";
    const isInt = def.format?.includes("int");
    const origin = isInt ? "int" : "number";
    const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
      if (isInt)
        bag.pattern = integer;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      if (isInt) {
        if (!Number.isInteger(input)) {
          payload.issues.push({
            expected: origin,
            format: def.format,
            code: "invalid_type",
            continue: false,
            input,
            inst
          });
          return;
        }
        if (!Number.isSafeInteger(input)) {
          if (input > 0) {
            payload.issues.push({
              input,
              code: "too_big",
              maximum: Number.MAX_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              inclusive: true,
              continue: !def.abort
            });
          } else {
            payload.issues.push({
              input,
              code: "too_small",
              minimum: Number.MIN_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              inclusive: true,
              continue: !def.abort
            });
          }
          return;
        }
      }
      if (input < minimum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_small",
          minimum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_big",
          maximum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
    $ZodCheck.init(inst, def);
    const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      if (input < minimum) {
        payload.issues.push({
          origin: "bigint",
          input,
          code: "too_small",
          minimum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: "bigint",
          input,
          code: "too_big",
          maximum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
    var _a2;
    $ZodCheck.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr)
        inst2._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size <= def.maximum)
        return;
      payload.issues.push({
        origin: getSizableOrigin(input),
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
    var _a2;
    $ZodCheck.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr)
        inst2._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size >= def.minimum)
        return;
      payload.issues.push({
        origin: getSizableOrigin(input),
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
    var _a2;
    $ZodCheck.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.minimum = def.size;
      bag.maximum = def.size;
      bag.size = def.size;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size === def.size)
        return;
      const tooBig = size > def.size;
      payload.issues.push({
        origin: getSizableOrigin(input),
        ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
    var _a2;
    $ZodCheck.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr)
        inst2._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length <= def.maximum)
        return;
      const origin = getLengthableOrigin(input);
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
    var _a2;
    $ZodCheck.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr)
        inst2._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length >= def.minimum)
        return;
      const origin = getLengthableOrigin(input);
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
    var _a2;
    $ZodCheck.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.minimum = def.length;
      bag.maximum = def.length;
      bag.length = def.length;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length === def.length)
        return;
      const origin = getLengthableOrigin(input);
      const tooBig = length > def.length;
      payload.issues.push({
        origin,
        ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
    var _a2, _b;
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      if (def.pattern) {
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(def.pattern);
      }
    });
    if (def.pattern)
      (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          ...def.pattern ? { pattern: def.pattern.toString() } : {},
          inst,
          continue: !def.abort
        });
      });
    else
      (_b = inst._zod).check ?? (_b.check = () => {
      });
  });
  var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
    $ZodCheckStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "regex",
        input: payload.value,
        pattern: def.pattern.toString(),
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
    def.pattern ?? (def.pattern = lowercase);
    $ZodCheckStringFormat.init(inst, def);
  });
  var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
    def.pattern ?? (def.pattern = uppercase);
    $ZodCheckStringFormat.init(inst, def);
  });
  var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
    $ZodCheck.init(inst, def);
    const escapedRegex = escapeRegex(def.includes);
    const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
    def.pattern = pattern;
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.includes(def.includes, def.position))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "includes",
        includes: def.includes,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.startsWith(def.prefix))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "starts_with",
        prefix: def.prefix,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.endsWith(def.suffix))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "ends_with",
        suffix: def.suffix,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  function handleCheckPropertyResult(result, payload, property) {
    if (result.issues.length) {
      payload.issues.push(...prefixIssues(property, result.issues));
    }
  }
  var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
      const result = def.schema._zod.run({
        value: payload.value[def.property],
        issues: []
      }, {});
      if (result instanceof Promise) {
        return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
      }
      handleCheckPropertyResult(result, payload, def.property);
      return;
    };
  });
  var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
    $ZodCheck.init(inst, def);
    const mimeSet = new Set(def.mime);
    inst._zod.onattach.push((inst2) => {
      inst2._zod.bag.mime = def.mime;
    });
    inst._zod.check = (payload) => {
      if (mimeSet.has(payload.value.type))
        return;
      payload.issues.push({
        code: "invalid_value",
        values: def.mime,
        input: payload.value.type,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
      payload.value = def.tx(payload.value);
    };
  });

  // node_modules/zod/v4/core/doc.js
  var Doc = class {
    constructor(args = []) {
      this.content = [];
      this.indent = 0;
      if (this)
        this.args = args;
    }
    indented(fn) {
      this.indent += 1;
      fn(this);
      this.indent -= 1;
    }
    write(arg) {
      if (typeof arg === "function") {
        arg(this, { execution: "sync" });
        arg(this, { execution: "async" });
        return;
      }
      const content = arg;
      const lines = content.split("\n").filter((x) => x);
      const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
      const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
      for (const line of dedented) {
        this.content.push(line);
      }
    }
    compile() {
      const F = Function;
      const args = this?.args;
      const content = this?.content ?? [``];
      const lines = [...content.map((x) => `  ${x}`)];
      return new F(...args, lines.join("\n"));
    }
  };

  // node_modules/zod/v4/core/versions.js
  var version = {
    major: 4,
    minor: 3,
    patch: 6
  };

  // node_modules/zod/v4/core/schemas.js
  var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
    var _a2;
    inst ?? (inst = {});
    inst._zod.def = def;
    inst._zod.bag = inst._zod.bag || {};
    inst._zod.version = version;
    const checks = [...inst._zod.def.checks ?? []];
    if (inst._zod.traits.has("$ZodCheck")) {
      checks.unshift(inst);
    }
    for (const ch of checks) {
      for (const fn of ch._zod.onattach) {
        fn(inst);
      }
    }
    if (checks.length === 0) {
      (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
      inst._zod.deferred?.push(() => {
        inst._zod.run = inst._zod.parse;
      });
    } else {
      const runChecks = (payload, checks2, ctx) => {
        let isAborted = aborted(payload);
        let asyncResult;
        for (const ch of checks2) {
          if (ch._zod.def.when) {
            const shouldRun = ch._zod.def.when(payload);
            if (!shouldRun)
              continue;
          } else if (isAborted) {
            continue;
          }
          const currLen = payload.issues.length;
          const _ = ch._zod.check(payload);
          if (_ instanceof Promise && ctx?.async === false) {
            throw new $ZodAsyncError();
          }
          if (asyncResult || _ instanceof Promise) {
            asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
              await _;
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                return;
              if (!isAborted)
                isAborted = aborted(payload, currLen);
            });
          } else {
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              continue;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          }
        }
        if (asyncResult) {
          return asyncResult.then(() => {
            return payload;
          });
        }
        return payload;
      };
      const handleCanaryResult = (canary, payload, ctx) => {
        if (aborted(canary)) {
          canary.aborted = true;
          return canary;
        }
        const checkResult = runChecks(payload, checks, ctx);
        if (checkResult instanceof Promise) {
          if (ctx.async === false)
            throw new $ZodAsyncError();
          return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
        }
        return inst._zod.parse(checkResult, ctx);
      };
      inst._zod.run = (payload, ctx) => {
        if (ctx.skipChecks) {
          return inst._zod.parse(payload, ctx);
        }
        if (ctx.direction === "backward") {
          const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
          if (canary instanceof Promise) {
            return canary.then((canary2) => {
              return handleCanaryResult(canary2, payload, ctx);
            });
          }
          return handleCanaryResult(canary, payload, ctx);
        }
        const result = inst._zod.parse(payload, ctx);
        if (result instanceof Promise) {
          if (ctx.async === false)
            throw new $ZodAsyncError();
          return result.then((result2) => runChecks(result2, checks, ctx));
        }
        return runChecks(result, checks, ctx);
      };
    }
    defineLazy(inst, "~standard", () => ({
      validate: (value) => {
        try {
          const r = safeParse(inst, value);
          return r.success ? { value: r.data } : { issues: r.error?.issues };
        } catch (_) {
          return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
        }
      },
      vendor: "zod",
      version: 1
    }));
  });
  var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
    inst._zod.parse = (payload, _) => {
      if (def.coerce)
        try {
          payload.value = String(payload.value);
        } catch (_2) {
        }
      if (typeof payload.value === "string")
        return payload;
      payload.issues.push({
        expected: "string",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
    $ZodCheckStringFormat.init(inst, def);
    $ZodString.init(inst, def);
  });
  var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
    def.pattern ?? (def.pattern = guid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
    if (def.version) {
      const versionMap = {
        v1: 1,
        v2: 2,
        v3: 3,
        v4: 4,
        v5: 5,
        v6: 6,
        v7: 7,
        v8: 8
      };
      const v = versionMap[def.version];
      if (v === void 0)
        throw new Error(`Invalid UUID version: "${def.version}"`);
      def.pattern ?? (def.pattern = uuid(v));
    } else
      def.pattern ?? (def.pattern = uuid());
    $ZodStringFormat.init(inst, def);
  });
  var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
    def.pattern ?? (def.pattern = email);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      try {
        const trimmed = payload.value.trim();
        const url2 = new URL(trimmed);
        if (def.hostname) {
          def.hostname.lastIndex = 0;
          if (!def.hostname.test(url2.hostname)) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              note: "Invalid hostname",
              pattern: def.hostname.source,
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        }
        if (def.protocol) {
          def.protocol.lastIndex = 0;
          if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              note: "Invalid protocol",
              pattern: def.protocol.source,
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        }
        if (def.normalize) {
          payload.value = url2.href;
        } else {
          payload.value = trimmed;
        }
        return;
      } catch (_) {
        payload.issues.push({
          code: "invalid_format",
          format: "url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
    def.pattern ?? (def.pattern = emoji());
    $ZodStringFormat.init(inst, def);
  });
  var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
    def.pattern ?? (def.pattern = nanoid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
    def.pattern ?? (def.pattern = cuid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
    def.pattern ?? (def.pattern = cuid2);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
    def.pattern ?? (def.pattern = ulid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
    def.pattern ?? (def.pattern = xid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
    def.pattern ?? (def.pattern = ksuid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
    def.pattern ?? (def.pattern = datetime(def));
    $ZodStringFormat.init(inst, def);
  });
  var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
    def.pattern ?? (def.pattern = date);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
    def.pattern ?? (def.pattern = time(def));
    $ZodStringFormat.init(inst, def);
  });
  var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
    def.pattern ?? (def.pattern = duration);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
    def.pattern ?? (def.pattern = ipv4);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.format = `ipv4`;
  });
  var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
    def.pattern ?? (def.pattern = ipv6);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.format = `ipv6`;
    inst._zod.check = (payload) => {
      try {
        new URL(`http://[${payload.value}]`);
      } catch {
        payload.issues.push({
          code: "invalid_format",
          format: "ipv6",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  var $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
    def.pattern ?? (def.pattern = mac(def.delimiter));
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.format = `mac`;
  });
  var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv4);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv6);
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      const parts = payload.value.split("/");
      try {
        if (parts.length !== 2)
          throw new Error();
        const [address, prefix] = parts;
        if (!prefix)
          throw new Error();
        const prefixNum = Number(prefix);
        if (`${prefixNum}` !== prefix)
          throw new Error();
        if (prefixNum < 0 || prefixNum > 128)
          throw new Error();
        new URL(`http://[${address}]`);
      } catch {
        payload.issues.push({
          code: "invalid_format",
          format: "cidrv6",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  function isValidBase64(data) {
    if (data === "")
      return true;
    if (data.length % 4 !== 0)
      return false;
    try {
      atob(data);
      return true;
    } catch {
      return false;
    }
  }
  var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
    def.pattern ?? (def.pattern = base64);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.contentEncoding = "base64";
    inst._zod.check = (payload) => {
      if (isValidBase64(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  function isValidBase64URL(data) {
    if (!base64url.test(data))
      return false;
    const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
    const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
    return isValidBase64(padded);
  }
  var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
    def.pattern ?? (def.pattern = base64url);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.contentEncoding = "base64url";
    inst._zod.check = (payload) => {
      if (isValidBase64URL(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
    def.pattern ?? (def.pattern = e164);
    $ZodStringFormat.init(inst, def);
  });
  function isValidJWT(token, algorithm = null) {
    try {
      const tokensParts = token.split(".");
      if (tokensParts.length !== 3)
        return false;
      const [header] = tokensParts;
      if (!header)
        return false;
      const parsedHeader = JSON.parse(atob(header));
      if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
        return false;
      if (!parsedHeader.alg)
        return false;
      if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
        return false;
      return true;
    } catch {
      return false;
    }
  }
  var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      if (isValidJWT(payload.value, def.alg))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "jwt",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      if (def.fn(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = inst._zod.bag.pattern ?? number;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = Number(payload.value);
        } catch (_) {
        }
      const input = payload.value;
      if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
        return payload;
      }
      const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
      payload.issues.push({
        expected: "number",
        code: "invalid_type",
        input,
        inst,
        ...received ? { received } : {}
      });
      return payload;
    };
  });
  var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
    $ZodCheckNumberFormat.init(inst, def);
    $ZodNumber.init(inst, def);
  });
  var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = boolean;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = Boolean(payload.value);
        } catch (_) {
        }
      const input = payload.value;
      if (typeof input === "boolean")
        return payload;
      payload.issues.push({
        expected: "boolean",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = bigint;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = BigInt(payload.value);
        } catch (_) {
        }
      if (typeof payload.value === "bigint")
        return payload;
      payload.issues.push({
        expected: "bigint",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
    $ZodCheckBigIntFormat.init(inst, def);
    $ZodBigInt.init(inst, def);
  });
  var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "symbol")
        return payload;
      payload.issues.push({
        expected: "symbol",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = _undefined;
    inst._zod.values = /* @__PURE__ */ new Set([void 0]);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "undefined")
        return payload;
      payload.issues.push({
        expected: "undefined",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = _null;
    inst._zod.values = /* @__PURE__ */ new Set([null]);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (input === null)
        return payload;
      payload.issues.push({
        expected: "null",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload) => payload;
  });
  var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload) => payload;
  });
  var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      payload.issues.push({
        expected: "never",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "undefined")
        return payload;
      payload.issues.push({
        expected: "void",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce) {
        try {
          payload.value = new Date(payload.value);
        } catch (_err) {
        }
      }
      const input = payload.value;
      const isDate = input instanceof Date;
      const isValidDate = isDate && !Number.isNaN(input.getTime());
      if (isValidDate)
        return payload;
      payload.issues.push({
        expected: "date",
        code: "invalid_type",
        input,
        ...isDate ? { received: "Invalid Date" } : {},
        inst
      });
      return payload;
    };
  });
  function handleArrayResult(result, final, index) {
    if (result.issues.length) {
      final.issues.push(...prefixIssues(index, result.issues));
    }
    final.value[index] = result.value;
  }
  var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!Array.isArray(input)) {
        payload.issues.push({
          expected: "array",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      payload.value = Array(input.length);
      const proms = [];
      for (let i = 0; i < input.length; i++) {
        const item = input[i];
        const result = def.element._zod.run({
          value: item,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
        } else {
          handleArrayResult(result, payload, i);
        }
      }
      if (proms.length) {
        return Promise.all(proms).then(() => payload);
      }
      return payload;
    };
  });
  function handlePropertyResult(result, final, key, input, isOptionalOut) {
    if (result.issues.length) {
      if (isOptionalOut && !(key in input)) {
        return;
      }
      final.issues.push(...prefixIssues(key, result.issues));
    }
    if (result.value === void 0) {
      if (key in input) {
        final.value[key] = void 0;
      }
    } else {
      final.value[key] = result.value;
    }
  }
  function normalizeDef(def) {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
      if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      ...def,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  }
  function handleCatchall(proms, input, payload, ctx, def, inst) {
    const unrecognized = [];
    const keySet = def.keySet;
    const _catchall = def.catchall._zod;
    const t = _catchall.def.type;
    const isOptionalOut = _catchall.optout === "optional";
    for (const key in input) {
      if (keySet.has(key))
        continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
      } else {
        handlePropertyResult(r, payload, key, input, isOptionalOut);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  }
  var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
    $ZodType.init(inst, def);
    const desc = Object.getOwnPropertyDescriptor(def, "shape");
    if (!desc?.get) {
      const sh = def.shape;
      Object.defineProperty(def, "shape", {
        get: () => {
          const newSh = { ...sh };
          Object.defineProperty(def, "shape", {
            value: newSh
          });
          return newSh;
        }
      });
    }
    const _normalized = cached(() => normalizeDef(def));
    defineLazy(inst._zod, "propValues", () => {
      const shape = def.shape;
      const propValues = {};
      for (const key in shape) {
        const field = shape[key]._zod;
        if (field.values) {
          propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
          for (const v of field.values)
            propValues[key].add(v);
        }
      }
      return propValues;
    });
    const isObject3 = isObject;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
      value ?? (value = _normalized.value);
      const input = payload.value;
      if (!isObject3(input)) {
        payload.issues.push({
          expected: "object",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      payload.value = {};
      const proms = [];
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const isOptionalOut = el._zod.optout === "optional";
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        if (r instanceof Promise) {
          proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
        } else {
          handlePropertyResult(r, payload, key, input, isOptionalOut);
        }
      }
      if (!catchall) {
        return proms.length ? Promise.all(proms).then(() => payload) : payload;
      }
      return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
    };
  });
  var $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
    $ZodObject.init(inst, def);
    const superParse = inst._zod.parse;
    const _normalized = cached(() => normalizeDef(def));
    const generateFastpass = (shape) => {
      const doc = new Doc(["shape", "payload", "ctx"]);
      const normalized = _normalized.value;
      const parseStr = (key) => {
        const k = esc(key);
        return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
      };
      doc.write(`const input = payload.value;`);
      const ids = /* @__PURE__ */ Object.create(null);
      let counter = 0;
      for (const key of normalized.keys) {
        ids[key] = `key_${counter++}`;
      }
      doc.write(`const newResult = {};`);
      for (const key of normalized.keys) {
        const id2 = ids[key];
        const k = esc(key);
        const schema = shape[key];
        const isOptionalOut = schema?._zod?.optout === "optional";
        doc.write(`const ${id2} = ${parseStr(key)};`);
        if (isOptionalOut) {
          doc.write(`
        if (${id2}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id2}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id2}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id2}.value;
        }
        
      `);
        } else {
          doc.write(`
        if (${id2}.issues.length) {
          payload.issues = payload.issues.concat(${id2}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id2}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id2}.value;
        }
        
      `);
        }
      }
      doc.write(`payload.value = newResult;`);
      doc.write(`return payload;`);
      const fn = doc.compile();
      return (payload, ctx) => fn(shape, payload, ctx);
    };
    let fastpass;
    const isObject3 = isObject;
    const jit = !globalConfig.jitless;
    const allowsEval2 = allowsEval;
    const fastEnabled = jit && allowsEval2.value;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
      value ?? (value = _normalized.value);
      const input = payload.value;
      if (!isObject3(input)) {
        payload.issues.push({
          expected: "object",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
        if (!fastpass)
          fastpass = generateFastpass(def.shape);
        payload = fastpass(payload, ctx);
        if (!catchall)
          return payload;
        return handleCatchall([], input, payload, ctx, value, inst);
      }
      return superParse(payload, ctx);
    };
  });
  function handleUnionResults(results, final, inst, ctx) {
    for (const result of results) {
      if (result.issues.length === 0) {
        final.value = result.value;
        return final;
      }
    }
    const nonaborted = results.filter((r) => !aborted(r));
    if (nonaborted.length === 1) {
      final.value = nonaborted[0].value;
      return nonaborted[0];
    }
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
    return final;
  }
  var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
    defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
    defineLazy(inst._zod, "values", () => {
      if (def.options.every((o) => o._zod.values)) {
        return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
      }
      return void 0;
    });
    defineLazy(inst._zod, "pattern", () => {
      if (def.options.every((o) => o._zod.pattern)) {
        const patterns = def.options.map((o) => o._zod.pattern);
        return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
      }
      return void 0;
    });
    const single = def.options.length === 1;
    const first = def.options[0]._zod.run;
    inst._zod.parse = (payload, ctx) => {
      if (single) {
        return first(payload, ctx);
      }
      let async = false;
      const results = [];
      for (const option of def.options) {
        const result = option._zod.run({
          value: payload.value,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          results.push(result);
          async = true;
        } else {
          if (result.issues.length === 0)
            return result;
          results.push(result);
        }
      }
      if (!async)
        return handleUnionResults(results, payload, inst, ctx);
      return Promise.all(results).then((results2) => {
        return handleUnionResults(results2, payload, inst, ctx);
      });
    };
  });
  function handleExclusiveUnionResults(results, final, inst, ctx) {
    const successes = results.filter((r) => r.issues.length === 0);
    if (successes.length === 1) {
      final.value = successes[0].value;
      return final;
    }
    if (successes.length === 0) {
      final.issues.push({
        code: "invalid_union",
        input: final.value,
        inst,
        errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      });
    } else {
      final.issues.push({
        code: "invalid_union",
        input: final.value,
        inst,
        errors: [],
        inclusive: false
      });
    }
    return final;
  }
  var $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
    $ZodUnion.init(inst, def);
    def.inclusive = false;
    const single = def.options.length === 1;
    const first = def.options[0]._zod.run;
    inst._zod.parse = (payload, ctx) => {
      if (single) {
        return first(payload, ctx);
      }
      let async = false;
      const results = [];
      for (const option of def.options) {
        const result = option._zod.run({
          value: payload.value,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          results.push(result);
          async = true;
        } else {
          results.push(result);
        }
      }
      if (!async)
        return handleExclusiveUnionResults(results, payload, inst, ctx);
      return Promise.all(results).then((results2) => {
        return handleExclusiveUnionResults(results2, payload, inst, ctx);
      });
    };
  });
  var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
    def.inclusive = false;
    $ZodUnion.init(inst, def);
    const _super = inst._zod.parse;
    defineLazy(inst._zod, "propValues", () => {
      const propValues = {};
      for (const option of def.options) {
        const pv = option._zod.propValues;
        if (!pv || Object.keys(pv).length === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
        for (const [k, v] of Object.entries(pv)) {
          if (!propValues[k])
            propValues[k] = /* @__PURE__ */ new Set();
          for (const val of v) {
            propValues[k].add(val);
          }
        }
      }
      return propValues;
    });
    const disc = cached(() => {
      const opts = def.options;
      const map2 = /* @__PURE__ */ new Map();
      for (const o of opts) {
        const values = o._zod.propValues?.[def.discriminator];
        if (!values || values.size === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
        for (const v of values) {
          if (map2.has(v)) {
            throw new Error(`Duplicate discriminator value "${String(v)}"`);
          }
          map2.set(v, o);
        }
      }
      return map2;
    });
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!isObject(input)) {
        payload.issues.push({
          code: "invalid_type",
          expected: "object",
          input,
          inst
        });
        return payload;
      }
      const opt = disc.value.get(input?.[def.discriminator]);
      if (opt) {
        return opt._zod.run(payload, ctx);
      }
      if (def.unionFallback) {
        return _super(payload, ctx);
      }
      payload.issues.push({
        code: "invalid_union",
        errors: [],
        note: "No matching discriminator",
        discriminator: def.discriminator,
        input,
        path: [def.discriminator],
        inst
      });
      return payload;
    };
  });
  var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      const left = def.left._zod.run({ value: input, issues: [] }, ctx);
      const right = def.right._zod.run({ value: input, issues: [] }, ctx);
      const async = left instanceof Promise || right instanceof Promise;
      if (async) {
        return Promise.all([left, right]).then(([left2, right2]) => {
          return handleIntersectionResults(payload, left2, right2);
        });
      }
      return handleIntersectionResults(payload, left, right);
    };
  });
  function mergeValues(a, b) {
    if (a === b) {
      return { valid: true, data: a };
    }
    if (a instanceof Date && b instanceof Date && +a === +b) {
      return { valid: true, data: a };
    }
    if (isPlainObject(a) && isPlainObject(b)) {
      const bKeys = Object.keys(b);
      const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return {
            valid: false,
            mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
          };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    }
    if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) {
        return { valid: false, mergeErrorPath: [] };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return {
            valid: false,
            mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
          };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    }
    return { valid: false, mergeErrorPath: [] };
  }
  function handleIntersectionResults(result, left, right) {
    const unrecKeys = /* @__PURE__ */ new Map();
    let unrecIssue;
    for (const iss of left.issues) {
      if (iss.code === "unrecognized_keys") {
        unrecIssue ?? (unrecIssue = iss);
        for (const k of iss.keys) {
          if (!unrecKeys.has(k))
            unrecKeys.set(k, {});
          unrecKeys.get(k).l = true;
        }
      } else {
        result.issues.push(iss);
      }
    }
    for (const iss of right.issues) {
      if (iss.code === "unrecognized_keys") {
        for (const k of iss.keys) {
          if (!unrecKeys.has(k))
            unrecKeys.set(k, {});
          unrecKeys.get(k).r = true;
        }
      } else {
        result.issues.push(iss);
      }
    }
    const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
    if (bothKeys.length && unrecIssue) {
      result.issues.push({ ...unrecIssue, keys: bothKeys });
    }
    if (aborted(result))
      return result;
    const merged = mergeValues(left.value, right.value);
    if (!merged.valid) {
      throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
    }
    result.value = merged.data;
    return result;
  }
  var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
    $ZodType.init(inst, def);
    const items = def.items;
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!Array.isArray(input)) {
        payload.issues.push({
          input,
          inst,
          expected: "tuple",
          code: "invalid_type"
        });
        return payload;
      }
      payload.value = [];
      const proms = [];
      const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
      const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
      if (!def.rest) {
        const tooBig = input.length > items.length;
        const tooSmall = input.length < optStart - 1;
        if (tooBig || tooSmall) {
          payload.issues.push({
            ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
            input,
            inst,
            origin: "array"
          });
          return payload;
        }
      }
      let i = -1;
      for (const item of items) {
        i++;
        if (i >= input.length) {
          if (i >= optStart)
            continue;
        }
        const result = item._zod.run({
          value: input[i],
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
      if (def.rest) {
        const rest = input.slice(items.length);
        for (const el of rest) {
          i++;
          const result = def.rest._zod.run({
            value: el,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
          } else {
            handleTupleResult(result, payload, i);
          }
        }
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  function handleTupleResult(result, final, index) {
    if (result.issues.length) {
      final.issues.push(...prefixIssues(index, result.issues));
    }
    final.value[index] = result.value;
  }
  var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!isPlainObject(input)) {
        payload.issues.push({
          expected: "record",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      const proms = [];
      const values = def.keyType._zod.values;
      if (values) {
        payload.value = {};
        const recordKeys = /* @__PURE__ */ new Set();
        for (const key of values) {
          if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
            recordKeys.add(typeof key === "number" ? key.toString() : key);
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues(key, result2.issues));
                }
                payload.value[key] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues(key, result.issues));
              }
              payload.value[key] = result.value;
            }
          }
        }
        let unrecognized;
        for (const key in input) {
          if (!recordKeys.has(key)) {
            unrecognized = unrecognized ?? [];
            unrecognized.push(key);
          }
        }
        if (unrecognized && unrecognized.length > 0) {
          payload.issues.push({
            code: "unrecognized_keys",
            input,
            inst,
            keys: unrecognized
          });
        }
      } else {
        payload.value = {};
        for (const key of Reflect.ownKeys(input)) {
          if (key === "__proto__")
            continue;
          let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          if (keyResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          const checkNumericKey = typeof key === "string" && number.test(key) && keyResult.issues.length;
          if (checkNumericKey) {
            const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
            if (retryResult instanceof Promise) {
              throw new Error("Async schemas not supported in object keys currently");
            }
            if (retryResult.issues.length === 0) {
              keyResult = retryResult;
            }
          }
          if (keyResult.issues.length) {
            if (def.mode === "loose") {
              payload.value[key] = input[key];
            } else {
              payload.issues.push({
                code: "invalid_key",
                origin: "record",
                issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                input: key,
                path: [key],
                inst
              });
            }
            continue;
          }
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[keyResult.value] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[keyResult.value] = result.value;
          }
        }
      }
      if (proms.length) {
        return Promise.all(proms).then(() => payload);
      }
      return payload;
    };
  });
  var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!(input instanceof Map)) {
        payload.issues.push({
          expected: "map",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      const proms = [];
      payload.value = /* @__PURE__ */ new Map();
      for (const [key, value] of input) {
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
        if (keyResult instanceof Promise || valueResult instanceof Promise) {
          proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
            handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
          }));
        } else {
          handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
        }
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
    if (keyResult.issues.length) {
      if (propertyKeyTypes.has(typeof key)) {
        final.issues.push(...prefixIssues(key, keyResult.issues));
      } else {
        final.issues.push({
          code: "invalid_key",
          origin: "map",
          input,
          inst,
          issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        });
      }
    }
    if (valueResult.issues.length) {
      if (propertyKeyTypes.has(typeof key)) {
        final.issues.push(...prefixIssues(key, valueResult.issues));
      } else {
        final.issues.push({
          origin: "map",
          code: "invalid_element",
          input,
          inst,
          key,
          issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        });
      }
    }
    final.value.set(keyResult.value, valueResult.value);
  }
  var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!(input instanceof Set)) {
        payload.issues.push({
          input,
          inst,
          expected: "set",
          code: "invalid_type"
        });
        return payload;
      }
      const proms = [];
      payload.value = /* @__PURE__ */ new Set();
      for (const item of input) {
        const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleSetResult(result2, payload)));
        } else
          handleSetResult(result, payload);
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  function handleSetResult(result, final) {
    if (result.issues.length) {
      final.issues.push(...result.issues);
    }
    final.value.add(result.value);
  }
  var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
    $ZodType.init(inst, def);
    const values = getEnumValues(def.entries);
    const valuesSet = new Set(values);
    inst._zod.values = valuesSet;
    inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (valuesSet.has(input)) {
        return payload;
      }
      payload.issues.push({
        code: "invalid_value",
        values,
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
    $ZodType.init(inst, def);
    if (def.values.length === 0) {
      throw new Error("Cannot create literal schema with no valid values");
    }
    const values = new Set(def.values);
    inst._zod.values = values;
    inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (values.has(input)) {
        return payload;
      }
      payload.issues.push({
        code: "invalid_value",
        values: def.values,
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (input instanceof File)
        return payload;
      payload.issues.push({
        expected: "file",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        throw new $ZodEncodeError(inst.constructor.name);
      }
      const _out = def.transform(payload.value, payload);
      if (ctx.async) {
        const output = _out instanceof Promise ? _out : Promise.resolve(_out);
        return output.then((output2) => {
          payload.value = output2;
          return payload;
        });
      }
      if (_out instanceof Promise) {
        throw new $ZodAsyncError();
      }
      payload.value = _out;
      return payload;
    };
  });
  function handleOptionalResult(result, input) {
    if (result.issues.length && input === void 0) {
      return { issues: [], value: void 0 };
    }
    return result;
  }
  var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    defineLazy(inst._zod, "values", () => {
      return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
    });
    defineLazy(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
    });
    inst._zod.parse = (payload, ctx) => {
      if (def.innerType._zod.optin === "optional") {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise)
          return result.then((r) => handleOptionalResult(r, payload.value));
        return handleOptionalResult(result, payload.value);
      }
      if (payload.value === void 0) {
        return payload;
      }
      return def.innerType._zod.run(payload, ctx);
    };
  });
  var $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
    $ZodOptional.init(inst, def);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
    inst._zod.parse = (payload, ctx) => {
      return def.innerType._zod.run(payload, ctx);
    };
  });
  var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
    });
    defineLazy(inst._zod, "values", () => {
      return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
    });
    inst._zod.parse = (payload, ctx) => {
      if (payload.value === null)
        return payload;
      return def.innerType._zod.run(payload, ctx);
    };
  });
  var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      if (payload.value === void 0) {
        payload.value = def.defaultValue;
        return payload;
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => handleDefaultResult(result2, def));
      }
      return handleDefaultResult(result, def);
    };
  });
  function handleDefaultResult(payload, def) {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return payload;
  }
  var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      if (payload.value === void 0) {
        payload.value = def.defaultValue;
      }
      return def.innerType._zod.run(payload, ctx);
    };
  });
  var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => {
      const v = def.innerType._zod.values;
      return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
    });
    inst._zod.parse = (payload, ctx) => {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => handleNonOptionalResult(result2, inst));
      }
      return handleNonOptionalResult(result, inst);
    };
  });
  function handleNonOptionalResult(payload, inst) {
    if (!payload.issues.length && payload.value === void 0) {
      payload.issues.push({
        code: "invalid_type",
        expected: "nonoptional",
        input: payload.value,
        inst
      });
    }
    return payload;
  }
  var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        throw new $ZodEncodeError("ZodSuccess");
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => {
          payload.value = result2.issues.length === 0;
          return payload;
        });
      }
      payload.value = result.issues.length === 0;
      return payload;
    };
  });
  var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => {
          payload.value = result2.value;
          if (result2.issues.length) {
            payload.value = def.catchValue({
              ...payload,
              error: {
                issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
              },
              input: payload.value
            });
            payload.issues = [];
          }
          return payload;
        });
      }
      payload.value = result.value;
      if (result.issues.length) {
        payload.value = def.catchValue({
          ...payload,
          error: {
            issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
          },
          input: payload.value
        });
        payload.issues = [];
      }
      return payload;
    };
  });
  var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
        payload.issues.push({
          input: payload.value,
          inst,
          expected: "nan",
          code: "invalid_type"
        });
        return payload;
      }
      return payload;
    };
  });
  var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => def.in._zod.values);
    defineLazy(inst._zod, "optin", () => def.in._zod.optin);
    defineLazy(inst._zod, "optout", () => def.out._zod.optout);
    defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        const right = def.out._zod.run(payload, ctx);
        if (right instanceof Promise) {
          return right.then((right2) => handlePipeResult(right2, def.in, ctx));
        }
        return handlePipeResult(right, def.in, ctx);
      }
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handlePipeResult(left2, def.out, ctx));
      }
      return handlePipeResult(left, def.out, ctx);
    };
  });
  function handlePipeResult(left, next, ctx) {
    if (left.issues.length) {
      left.aborted = true;
      return left;
    }
    return next._zod.run({ value: left.value, issues: left.issues }, ctx);
  }
  var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => def.in._zod.values);
    defineLazy(inst._zod, "optin", () => def.in._zod.optin);
    defineLazy(inst._zod, "optout", () => def.out._zod.optout);
    defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
      const direction = ctx.direction || "forward";
      if (direction === "forward") {
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handleCodecAResult(left2, def, ctx));
        }
        return handleCodecAResult(left, def, ctx);
      } else {
        const right = def.out._zod.run(payload, ctx);
        if (right instanceof Promise) {
          return right.then((right2) => handleCodecAResult(right2, def, ctx));
        }
        return handleCodecAResult(right, def, ctx);
      }
    };
  });
  function handleCodecAResult(result, def, ctx) {
    if (result.issues.length) {
      result.aborted = true;
      return result;
    }
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const transformed = def.transform(result.value, result);
      if (transformed instanceof Promise) {
        return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
      }
      return handleCodecTxResult(result, transformed, def.out, ctx);
    } else {
      const transformed = def.reverseTransform(result.value, result);
      if (transformed instanceof Promise) {
        return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
      }
      return handleCodecTxResult(result, transformed, def.in, ctx);
    }
  }
  function handleCodecTxResult(left, value, nextSchema, ctx) {
    if (left.issues.length) {
      left.aborted = true;
      return left;
    }
    return nextSchema._zod.run({ value, issues: left.issues }, ctx);
  }
  var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
    defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then(handleReadonlyResult);
      }
      return handleReadonlyResult(result);
    };
  });
  function handleReadonlyResult(payload) {
    payload.value = Object.freeze(payload.value);
    return payload;
  }
  var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
    $ZodType.init(inst, def);
    const regexParts = [];
    for (const part of def.parts) {
      if (typeof part === "object" && part !== null) {
        if (!part._zod.pattern) {
          throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
        }
        const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
        if (!source)
          throw new Error(`Invalid template literal part: ${part._zod.traits}`);
        const start = source.startsWith("^") ? 1 : 0;
        const end = source.endsWith("$") ? source.length - 1 : source.length;
        regexParts.push(source.slice(start, end));
      } else if (part === null || primitiveTypes.has(typeof part)) {
        regexParts.push(escapeRegex(`${part}`));
      } else {
        throw new Error(`Invalid template literal part: ${part}`);
      }
    }
    inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "string") {
        payload.issues.push({
          input: payload.value,
          inst,
          expected: "string",
          code: "invalid_type"
        });
        return payload;
      }
      inst._zod.pattern.lastIndex = 0;
      if (!inst._zod.pattern.test(payload.value)) {
        payload.issues.push({
          input: payload.value,
          inst,
          code: "invalid_format",
          format: def.format ?? "template_literal",
          pattern: inst._zod.pattern.source
        });
        return payload;
      }
      return payload;
    };
  });
  var $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
    $ZodType.init(inst, def);
    inst._def = def;
    inst._zod.def = def;
    inst.implement = (func) => {
      if (typeof func !== "function") {
        throw new Error("implement() must be called with a function");
      }
      return function(...args) {
        const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
        const result = Reflect.apply(func, this, parsedArgs);
        if (inst._def.output) {
          return parse(inst._def.output, result);
        }
        return result;
      };
    };
    inst.implementAsync = (func) => {
      if (typeof func !== "function") {
        throw new Error("implementAsync() must be called with a function");
      }
      return async function(...args) {
        const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
        const result = await Reflect.apply(func, this, parsedArgs);
        if (inst._def.output) {
          return await parseAsync(inst._def.output, result);
        }
        return result;
      };
    };
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "function") {
        payload.issues.push({
          code: "invalid_type",
          expected: "function",
          input: payload.value,
          inst
        });
        return payload;
      }
      const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
      if (hasPromiseOutput) {
        payload.value = inst.implementAsync(payload.value);
      } else {
        payload.value = inst.implement(payload.value);
      }
      return payload;
    };
    inst.input = (...args) => {
      const F = inst.constructor;
      if (Array.isArray(args[0])) {
        return new F({
          type: "function",
          input: new $ZodTuple({
            type: "tuple",
            items: args[0],
            rest: args[1]
          }),
          output: inst._def.output
        });
      }
      return new F({
        type: "function",
        input: args[0],
        output: inst._def.output
      });
    };
    inst.output = (output) => {
      const F = inst.constructor;
      return new F({
        type: "function",
        input: inst._def.input,
        output
      });
    };
    return inst;
  });
  var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
    };
  });
  var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "innerType", () => def.getter());
    defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
    defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
    defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0);
    defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0);
    inst._zod.parse = (payload, ctx) => {
      const inner = inst._zod.innerType;
      return inner._zod.run(payload, ctx);
    };
  });
  var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
    $ZodCheck.init(inst, def);
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _) => {
      return payload;
    };
    inst._zod.check = (payload) => {
      const input = payload.value;
      const r = def.fn(input);
      if (r instanceof Promise) {
        return r.then((r2) => handleRefineResult(r2, payload, input, inst));
      }
      handleRefineResult(r, payload, input, inst);
      return;
    };
  });
  function handleRefineResult(result, payload, input, inst) {
    if (!result) {
      const _iss = {
        code: "custom",
        input,
        inst,
        // incorporates params.error into issue reporting
        path: [...inst._zod.def.path ?? []],
        // incorporates params.error into issue reporting
        continue: !inst._zod.def.abort
        // params: inst._zod.def.params,
      };
      if (inst._zod.def.params)
        _iss.params = inst._zod.def.params;
      payload.issues.push(issue(_iss));
    }
  }

  // node_modules/zod/v4/locales/index.js
  var locales_exports = {};
  __export(locales_exports, {
    ar: () => ar_default,
    az: () => az_default,
    be: () => be_default,
    bg: () => bg_default,
    ca: () => ca_default,
    cs: () => cs_default,
    da: () => da_default,
    de: () => de_default,
    en: () => en_default,
    eo: () => eo_default,
    es: () => es_default,
    fa: () => fa_default,
    fi: () => fi_default,
    fr: () => fr_default,
    frCA: () => fr_CA_default,
    he: () => he_default,
    hu: () => hu_default,
    hy: () => hy_default,
    id: () => id_default,
    is: () => is_default,
    it: () => it_default,
    ja: () => ja_default,
    ka: () => ka_default,
    kh: () => kh_default,
    km: () => km_default,
    ko: () => ko_default,
    lt: () => lt_default,
    mk: () => mk_default,
    ms: () => ms_default,
    nl: () => nl_default,
    no: () => no_default,
    ota: () => ota_default,
    pl: () => pl_default,
    ps: () => ps_default,
    pt: () => pt_default,
    ru: () => ru_default,
    sl: () => sl_default,
    sv: () => sv_default,
    ta: () => ta_default,
    th: () => th_default,
    tr: () => tr_default,
    ua: () => ua_default,
    uk: () => uk_default,
    ur: () => ur_default,
    uz: () => uz_default,
    vi: () => vi_default,
    yo: () => yo_default,
    zhCN: () => zh_CN_default,
    zhTW: () => zh_TW_default
  });

  // node_modules/zod/v4/locales/ar.js
  var error = () => {
    const Sizable = {
      string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
      file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
      array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
      set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0645\u062F\u062E\u0644",
      email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
      url: "\u0631\u0627\u0628\u0637",
      emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
      ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
      cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
      cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
      base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
      base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
      json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
      e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
      jwt: "JWT",
      template_literal: "\u0645\u062F\u062E\u0644"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 instanceof ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
          }
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
          return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
          return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
          return `${FormatDictionary[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
        }
        case "not_multiple_of":
          return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
        case "invalid_key":
          return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
        case "invalid_union":
          return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
        case "invalid_element":
          return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
        default:
          return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      }
    };
  };
  function ar_default() {
    return {
      localeError: error()
    };
  }

  // node_modules/zod/v4/locales/az.js
  var error2 = () => {
    const Sizable = {
      string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
      file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
      array: { unit: "element", verb: "olmal\u0131d\u0131r" },
      set: { unit: "element", verb: "olmal\u0131d\u0131r" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "input",
      email: "email address",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datetime",
      date: "ISO date",
      time: "ISO time",
      duration: "ISO duration",
      ipv4: "IPv4 address",
      ipv6: "IPv6 address",
      cidrv4: "IPv4 range",
      cidrv6: "IPv6 range",
      base64: "base64-encoded string",
      base64url: "base64url-encoded string",
      json_string: "JSON string",
      e164: "E.164 number",
      jwt: "JWT",
      template_literal: "input"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n instanceof ${issue2.expected}, daxil olan ${received}`;
          }
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${expected}, daxil olan ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
          return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
          if (_issue.format === "ends_with")
            return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
          if (_issue.format === "includes")
            return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
          if (_issue.format === "regex")
            return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
          return `Yanl\u0131\u015F ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
        case "unrecognized_keys":
          return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
        case "invalid_union":
          return "Yanl\u0131\u015F d\u0259y\u0259r";
        case "invalid_element":
          return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
        default:
          return `Yanl\u0131\u015F d\u0259y\u0259r`;
      }
    };
  };
  function az_default() {
    return {
      localeError: error2()
    };
  }

  // node_modules/zod/v4/locales/be.js
  function getBelarusianPlural(count, one, few, many) {
    const absCount = Math.abs(count);
    const lastDigit = absCount % 10;
    const lastTwoDigits = absCount % 100;
    if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
      return many;
    }
    if (lastDigit === 1) {
      return one;
    }
    if (lastDigit >= 2 && lastDigit <= 4) {
      return few;
    }
    return many;
  }
  var error3 = () => {
    const Sizable = {
      string: {
        unit: {
          one: "\u0441\u0456\u043C\u0432\u0430\u043B",
          few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
          many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
        },
        verb: "\u043C\u0435\u0446\u044C"
      },
      array: {
        unit: {
          one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
          few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
          many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
        },
        verb: "\u043C\u0435\u0446\u044C"
      },
      set: {
        unit: {
          one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
          few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
          many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
        },
        verb: "\u043C\u0435\u0446\u044C"
      },
      file: {
        unit: {
          one: "\u0431\u0430\u0439\u0442",
          few: "\u0431\u0430\u0439\u0442\u044B",
          many: "\u0431\u0430\u0439\u0442\u0430\u045E"
        },
        verb: "\u043C\u0435\u0446\u044C"
      }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0443\u0432\u043E\u0434",
      email: "email \u0430\u0434\u0440\u0430\u0441",
      url: "URL",
      emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
      date: "ISO \u0434\u0430\u0442\u0430",
      time: "ISO \u0447\u0430\u0441",
      duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
      ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
      ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
      cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
      cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
      base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
      base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
      json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
      e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
      jwt: "JWT",
      template_literal: "\u0443\u0432\u043E\u0434"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u043B\u0456\u043A",
      array: "\u043C\u0430\u0441\u0456\u045E"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F instanceof ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
          }
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            const maxValue = Number(issue2.maximum);
            const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
          }
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            const minValue = Number(issue2.minimum);
            const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
          }
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
        case "invalid_union":
          return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
        case "invalid_element":
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
        default:
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
      }
    };
  };
  function be_default() {
    return {
      localeError: error3()
    };
  }

  // node_modules/zod/v4/locales/bg.js
  var error4 = () => {
    const Sizable = {
      string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
      file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
      array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
      set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0432\u0445\u043E\u0434",
      email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
      url: "URL",
      emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
      date: "ISO \u0434\u0430\u0442\u0430",
      time: "ISO \u0432\u0440\u0435\u043C\u0435",
      duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
      ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
      ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
      cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
      cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
      base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
      base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
      json_string: "JSON \u043D\u0438\u0437",
      e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
      jwt: "JWT",
      template_literal: "\u0432\u0445\u043E\u0434"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0447\u0438\u0441\u043B\u043E",
      array: "\u043C\u0430\u0441\u0438\u0432"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
          }
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
          let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
          if (_issue.format === "emoji")
            invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
          if (_issue.format === "datetime")
            invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
          if (_issue.format === "date")
            invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
          if (_issue.format === "time")
            invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
          if (_issue.format === "duration")
            invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
          return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
        case "invalid_union":
          return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
        case "invalid_element":
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
        default:
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
      }
    };
  };
  function bg_default() {
    return {
      localeError: error4()
    };
  }

  // node_modules/zod/v4/locales/ca.js
  var error5 = () => {
    const Sizable = {
      string: { unit: "car\xE0cters", verb: "contenir" },
      file: { unit: "bytes", verb: "contenir" },
      array: { unit: "elements", verb: "contenir" },
      set: { unit: "elements", verb: "contenir" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "entrada",
      email: "adre\xE7a electr\xF2nica",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data i hora ISO",
      date: "data ISO",
      time: "hora ISO",
      duration: "durada ISO",
      ipv4: "adre\xE7a IPv4",
      ipv6: "adre\xE7a IPv6",
      cidrv4: "rang IPv4",
      cidrv6: "rang IPv6",
      base64: "cadena codificada en base64",
      base64url: "cadena codificada en base64url",
      json_string: "cadena JSON",
      e164: "n\xFAmero E.164",
      jwt: "JWT",
      template_literal: "entrada"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Tipus inv\xE0lid: s'esperava instanceof ${issue2.expected}, s'ha rebut ${received}`;
          }
          return `Tipus inv\xE0lid: s'esperava ${expected}, s'ha rebut ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
          return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
          return `Format inv\xE0lid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Clau inv\xE0lida a ${issue2.origin}`;
        case "invalid_union":
          return "Entrada inv\xE0lida";
        // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
        case "invalid_element":
          return `Element inv\xE0lid a ${issue2.origin}`;
        default:
          return `Entrada inv\xE0lida`;
      }
    };
  };
  function ca_default() {
    return {
      localeError: error5()
    };
  }

  // node_modules/zod/v4/locales/cs.js
  var error6 = () => {
    const Sizable = {
      string: { unit: "znak\u016F", verb: "m\xEDt" },
      file: { unit: "bajt\u016F", verb: "m\xEDt" },
      array: { unit: "prvk\u016F", verb: "m\xEDt" },
      set: { unit: "prvk\u016F", verb: "m\xEDt" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "regul\xE1rn\xED v\xFDraz",
      email: "e-mailov\xE1 adresa",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "datum a \u010Das ve form\xE1tu ISO",
      date: "datum ve form\xE1tu ISO",
      time: "\u010Das ve form\xE1tu ISO",
      duration: "doba trv\xE1n\xED ISO",
      ipv4: "IPv4 adresa",
      ipv6: "IPv6 adresa",
      cidrv4: "rozsah IPv4",
      cidrv6: "rozsah IPv6",
      base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
      base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
      json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
      e164: "\u010D\xEDslo E.164",
      jwt: "JWT",
      template_literal: "vstup"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u010D\xEDslo",
      string: "\u0159et\u011Bzec",
      function: "funkce",
      array: "pole"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no instanceof ${issue2.expected}, obdr\u017Eeno ${received}`;
          }
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${expected}, obdr\u017Eeno ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
          return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
          }
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
          }
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
          return `Neplatn\xFD form\xE1t ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
        case "invalid_union":
          return "Neplatn\xFD vstup";
        case "invalid_element":
          return `Neplatn\xE1 hodnota v ${issue2.origin}`;
        default:
          return `Neplatn\xFD vstup`;
      }
    };
  };
  function cs_default() {
    return {
      localeError: error6()
    };
  }

  // node_modules/zod/v4/locales/da.js
  var error7 = () => {
    const Sizable = {
      string: { unit: "tegn", verb: "havde" },
      file: { unit: "bytes", verb: "havde" },
      array: { unit: "elementer", verb: "indeholdt" },
      set: { unit: "elementer", verb: "indeholdt" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "input",
      email: "e-mailadresse",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO dato- og klokkesl\xE6t",
      date: "ISO-dato",
      time: "ISO-klokkesl\xE6t",
      duration: "ISO-varighed",
      ipv4: "IPv4-omr\xE5de",
      ipv6: "IPv6-omr\xE5de",
      cidrv4: "IPv4-spektrum",
      cidrv6: "IPv6-spektrum",
      base64: "base64-kodet streng",
      base64url: "base64url-kodet streng",
      json_string: "JSON-streng",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "input"
    };
    const TypeDictionary = {
      nan: "NaN",
      string: "streng",
      number: "tal",
      boolean: "boolean",
      array: "liste",
      object: "objekt",
      set: "s\xE6t",
      file: "fil"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;
          }
          return `Ugyldigt input: forventede ${expected}, fik ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
          return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
          if (sizing)
            return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
          return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
          if (sizing) {
            return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
          return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Ugyldig n\xF8gle i ${issue2.origin}`;
        case "invalid_union":
          return "Ugyldigt input: matcher ingen af de tilladte typer";
        case "invalid_element":
          return `Ugyldig v\xE6rdi i ${issue2.origin}`;
        default:
          return `Ugyldigt input`;
      }
    };
  };
  function da_default() {
    return {
      localeError: error7()
    };
  }

  // node_modules/zod/v4/locales/de.js
  var error8 = () => {
    const Sizable = {
      string: { unit: "Zeichen", verb: "zu haben" },
      file: { unit: "Bytes", verb: "zu haben" },
      array: { unit: "Elemente", verb: "zu haben" },
      set: { unit: "Elemente", verb: "zu haben" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "Eingabe",
      email: "E-Mail-Adresse",
      url: "URL",
      emoji: "Emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-Datum und -Uhrzeit",
      date: "ISO-Datum",
      time: "ISO-Uhrzeit",
      duration: "ISO-Dauer",
      ipv4: "IPv4-Adresse",
      ipv6: "IPv6-Adresse",
      cidrv4: "IPv4-Bereich",
      cidrv6: "IPv6-Bereich",
      base64: "Base64-codierter String",
      base64url: "Base64-URL-codierter String",
      json_string: "JSON-String",
      e164: "E.164-Nummer",
      jwt: "JWT",
      template_literal: "Eingabe"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "Zahl",
      array: "Array"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Ung\xFCltige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;
          }
          return `Ung\xFCltige Eingabe: erwartet ${expected}, erhalten ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
          return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
          return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
          }
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
          if (_issue.format === "ends_with")
            return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
          if (_issue.format === "includes")
            return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
          if (_issue.format === "regex")
            return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
          return `Ung\xFCltig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
        case "invalid_union":
          return "Ung\xFCltige Eingabe";
        case "invalid_element":
          return `Ung\xFCltiger Wert in ${issue2.origin}`;
        default:
          return `Ung\xFCltige Eingabe`;
      }
    };
  };
  function de_default() {
    return {
      localeError: error8()
    };
  }

  // node_modules/zod/v4/locales/en.js
  var error9 = () => {
    const Sizable = {
      string: { unit: "characters", verb: "to have" },
      file: { unit: "bytes", verb: "to have" },
      array: { unit: "items", verb: "to have" },
      set: { unit: "items", verb: "to have" },
      map: { unit: "entries", verb: "to have" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "input",
      email: "email address",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datetime",
      date: "ISO date",
      time: "ISO time",
      duration: "ISO duration",
      ipv4: "IPv4 address",
      ipv6: "IPv6 address",
      mac: "MAC address",
      cidrv4: "IPv4 range",
      cidrv6: "IPv6 range",
      base64: "base64-encoded string",
      base64url: "base64url-encoded string",
      json_string: "JSON string",
      e164: "E.164 number",
      jwt: "JWT",
      template_literal: "input"
    };
    const TypeDictionary = {
      // Compatibility: "nan" -> "NaN" for display
      nan: "NaN"
      // All other type names omitted - they fall back to raw values via ?? operator
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          return `Invalid input: expected ${expected}, received ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
          return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
          return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Invalid string: must start with "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Invalid string: must end with "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Invalid string: must include "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Invalid string: must match pattern ${_issue.pattern}`;
          return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Invalid number: must be a multiple of ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Invalid key in ${issue2.origin}`;
        case "invalid_union":
          return "Invalid input";
        case "invalid_element":
          return `Invalid value in ${issue2.origin}`;
        default:
          return `Invalid input`;
      }
    };
  };
  function en_default() {
    return {
      localeError: error9()
    };
  }

  // node_modules/zod/v4/locales/eo.js
  var error10 = () => {
    const Sizable = {
      string: { unit: "karaktrojn", verb: "havi" },
      file: { unit: "bajtojn", verb: "havi" },
      array: { unit: "elementojn", verb: "havi" },
      set: { unit: "elementojn", verb: "havi" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "enigo",
      email: "retadreso",
      url: "URL",
      emoji: "emo\u011Dio",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-datotempo",
      date: "ISO-dato",
      time: "ISO-tempo",
      duration: "ISO-da\u016Dro",
      ipv4: "IPv4-adreso",
      ipv6: "IPv6-adreso",
      cidrv4: "IPv4-rango",
      cidrv6: "IPv6-rango",
      base64: "64-ume kodita karaktraro",
      base64url: "URL-64-ume kodita karaktraro",
      json_string: "JSON-karaktraro",
      e164: "E.164-nombro",
      jwt: "JWT",
      template_literal: "enigo"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "nombro",
      array: "tabelo",
      null: "senvalora"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Nevalida enigo: atendi\u011Dis instanceof ${issue2.expected}, ricevi\u011Dis ${received}`;
          }
          return `Nevalida enigo: atendi\u011Dis ${expected}, ricevi\u011Dis ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
          return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
          return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
          return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Nevalida \u015Dlosilo en ${issue2.origin}`;
        case "invalid_union":
          return "Nevalida enigo";
        case "invalid_element":
          return `Nevalida valoro en ${issue2.origin}`;
        default:
          return `Nevalida enigo`;
      }
    };
  };
  function eo_default() {
    return {
      localeError: error10()
    };
  }

  // node_modules/zod/v4/locales/es.js
  var error11 = () => {
    const Sizable = {
      string: { unit: "caracteres", verb: "tener" },
      file: { unit: "bytes", verb: "tener" },
      array: { unit: "elementos", verb: "tener" },
      set: { unit: "elementos", verb: "tener" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "entrada",
      email: "direcci\xF3n de correo electr\xF3nico",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "fecha y hora ISO",
      date: "fecha ISO",
      time: "hora ISO",
      duration: "duraci\xF3n ISO",
      ipv4: "direcci\xF3n IPv4",
      ipv6: "direcci\xF3n IPv6",
      cidrv4: "rango IPv4",
      cidrv6: "rango IPv6",
      base64: "cadena codificada en base64",
      base64url: "URL codificada en base64",
      json_string: "cadena JSON",
      e164: "n\xFAmero E.164",
      jwt: "JWT",
      template_literal: "entrada"
    };
    const TypeDictionary = {
      nan: "NaN",
      string: "texto",
      number: "n\xFAmero",
      boolean: "booleano",
      array: "arreglo",
      object: "objeto",
      set: "conjunto",
      file: "archivo",
      date: "fecha",
      bigint: "n\xFAmero grande",
      symbol: "s\xEDmbolo",
      undefined: "indefinido",
      null: "nulo",
      function: "funci\xF3n",
      map: "mapa",
      record: "registro",
      tuple: "tupla",
      enum: "enumeraci\xF3n",
      union: "uni\xF3n",
      literal: "literal",
      promise: "promesa",
      void: "vac\xEDo",
      never: "nunca",
      unknown: "desconocido",
      any: "cualquiera"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Entrada inv\xE1lida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;
          }
          return `Entrada inv\xE1lida: se esperaba ${expected}, recibido ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
          return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
          if (sizing)
            return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
          if (sizing) {
            return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
          return `Inv\xE1lido ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Llave inv\xE1lida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
        case "invalid_union":
          return "Entrada inv\xE1lida";
        case "invalid_element":
          return `Valor inv\xE1lido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
        default:
          return `Entrada inv\xE1lida`;
      }
    };
  };
  function es_default() {
    return {
      localeError: error11()
    };
  }

  // node_modules/zod/v4/locales/fa.js
  var error12 = () => {
    const Sizable = {
      string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
      file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
      array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
      set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0648\u0631\u0648\u062F\u06CC",
      email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
      url: "URL",
      emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
      date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
      time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
      duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
      ipv4: "IPv4 \u0622\u062F\u0631\u0633",
      ipv6: "IPv6 \u0622\u062F\u0631\u0633",
      cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
      cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
      base64: "base64-encoded \u0631\u0634\u062A\u0647",
      base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
      json_string: "JSON \u0631\u0634\u062A\u0647",
      e164: "E.164 \u0639\u062F\u062F",
      jwt: "JWT",
      template_literal: "\u0648\u0631\u0648\u062F\u06CC"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0639\u062F\u062F",
      array: "\u0622\u0631\u0627\u06CC\u0647"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A instanceof ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
          }
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
        }
        case "invalid_value":
          if (issue2.values.length === 1) {
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
          }
          return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
          }
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
          }
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
          }
          if (_issue.format === "ends_with") {
            return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
          }
          if (_issue.format === "includes") {
            return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
          }
          if (_issue.format === "regex") {
            return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
          }
          return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
        }
        case "not_multiple_of":
          return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
        case "unrecognized_keys":
          return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
        case "invalid_union":
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
        case "invalid_element":
          return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
        default:
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
    };
  };
  function fa_default() {
    return {
      localeError: error12()
    };
  }

  // node_modules/zod/v4/locales/fi.js
  var error13 = () => {
    const Sizable = {
      string: { unit: "merkki\xE4", subject: "merkkijonon" },
      file: { unit: "tavua", subject: "tiedoston" },
      array: { unit: "alkiota", subject: "listan" },
      set: { unit: "alkiota", subject: "joukon" },
      number: { unit: "", subject: "luvun" },
      bigint: { unit: "", subject: "suuren kokonaisluvun" },
      int: { unit: "", subject: "kokonaisluvun" },
      date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "s\xE4\xE4nn\xF6llinen lauseke",
      email: "s\xE4hk\xF6postiosoite",
      url: "URL-osoite",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-aikaleima",
      date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
      time: "ISO-aika",
      duration: "ISO-kesto",
      ipv4: "IPv4-osoite",
      ipv6: "IPv6-osoite",
      cidrv4: "IPv4-alue",
      cidrv6: "IPv6-alue",
      base64: "base64-koodattu merkkijono",
      base64url: "base64url-koodattu merkkijono",
      json_string: "JSON-merkkijono",
      e164: "E.164-luku",
      jwt: "JWT",
      template_literal: "templaattimerkkijono"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;
          }
          return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
          return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
          }
          return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
          }
          return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
          if (_issue.format === "regex") {
            return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
          }
          return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return "Virheellinen avain tietueessa";
        case "invalid_union":
          return "Virheellinen unioni";
        case "invalid_element":
          return "Virheellinen arvo joukossa";
        default:
          return `Virheellinen sy\xF6te`;
      }
    };
  };
  function fi_default() {
    return {
      localeError: error13()
    };
  }

  // node_modules/zod/v4/locales/fr.js
  var error14 = () => {
    const Sizable = {
      string: { unit: "caract\xE8res", verb: "avoir" },
      file: { unit: "octets", verb: "avoir" },
      array: { unit: "\xE9l\xE9ments", verb: "avoir" },
      set: { unit: "\xE9l\xE9ments", verb: "avoir" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "entr\xE9e",
      email: "adresse e-mail",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "date et heure ISO",
      date: "date ISO",
      time: "heure ISO",
      duration: "dur\xE9e ISO",
      ipv4: "adresse IPv4",
      ipv6: "adresse IPv6",
      cidrv4: "plage IPv4",
      cidrv6: "plage IPv6",
      base64: "cha\xEEne encod\xE9e en base64",
      base64url: "cha\xEEne encod\xE9e en base64url",
      json_string: "cha\xEEne JSON",
      e164: "num\xE9ro E.164",
      jwt: "JWT",
      template_literal: "entr\xE9e"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "nombre",
      array: "tableau"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Entr\xE9e invalide : instanceof ${issue2.expected} attendu, ${received} re\xE7u`;
          }
          return `Entr\xE9e invalide : ${expected} attendu, ${received} re\xE7u`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
          return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
          return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
          return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
        }
        case "not_multiple_of":
          return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Cl\xE9 invalide dans ${issue2.origin}`;
        case "invalid_union":
          return "Entr\xE9e invalide";
        case "invalid_element":
          return `Valeur invalide dans ${issue2.origin}`;
        default:
          return `Entr\xE9e invalide`;
      }
    };
  };
  function fr_default() {
    return {
      localeError: error14()
    };
  }

  // node_modules/zod/v4/locales/fr-CA.js
  var error15 = () => {
    const Sizable = {
      string: { unit: "caract\xE8res", verb: "avoir" },
      file: { unit: "octets", verb: "avoir" },
      array: { unit: "\xE9l\xE9ments", verb: "avoir" },
      set: { unit: "\xE9l\xE9ments", verb: "avoir" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "entr\xE9e",
      email: "adresse courriel",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "date-heure ISO",
      date: "date ISO",
      time: "heure ISO",
      duration: "dur\xE9e ISO",
      ipv4: "adresse IPv4",
      ipv6: "adresse IPv6",
      cidrv4: "plage IPv4",
      cidrv6: "plage IPv6",
      base64: "cha\xEEne encod\xE9e en base64",
      base64url: "cha\xEEne encod\xE9e en base64url",
      json_string: "cha\xEEne JSON",
      e164: "num\xE9ro E.164",
      jwt: "JWT",
      template_literal: "entr\xE9e"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Entr\xE9e invalide : attendu instanceof ${issue2.expected}, re\xE7u ${received}`;
          }
          return `Entr\xE9e invalide : attendu ${expected}, re\xE7u ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
          return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "\u2264" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "\u2265" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
          return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
        }
        case "not_multiple_of":
          return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Cl\xE9 invalide dans ${issue2.origin}`;
        case "invalid_union":
          return "Entr\xE9e invalide";
        case "invalid_element":
          return `Valeur invalide dans ${issue2.origin}`;
        default:
          return `Entr\xE9e invalide`;
      }
    };
  };
  function fr_CA_default() {
    return {
      localeError: error15()
    };
  }

  // node_modules/zod/v4/locales/he.js
  var error16 = () => {
    const TypeNames = {
      string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
      number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
      boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
      bigint: { label: "BigInt", gender: "m" },
      date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
      array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
      object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
      null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
      undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
      symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
      function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
      map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
      set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
      file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
      promise: { label: "Promise", gender: "m" },
      NaN: { label: "NaN", gender: "m" },
      unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
      value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
    };
    const Sizable = {
      string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
      file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
      array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
      set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
      number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
      // no unit
    };
    const typeEntry = (t) => t ? TypeNames[t] : void 0;
    const typeLabel = (t) => {
      const e = typeEntry(t);
      if (e)
        return e.label;
      return t ?? TypeNames.unknown.label;
    };
    const withDefinite = (t) => `\u05D4${typeLabel(t)}`;
    const verbFor = (t) => {
      const e = typeEntry(t);
      const gender = e?.gender ?? "m";
      return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
    };
    const getSizing = (origin) => {
      if (!origin)
        return null;
      return Sizable[origin] ?? null;
    };
    const FormatDictionary = {
      regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
      email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
      url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
      emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
      uuid: { label: "UUID", gender: "m" },
      nanoid: { label: "nanoid", gender: "m" },
      guid: { label: "GUID", gender: "m" },
      cuid: { label: "cuid", gender: "m" },
      cuid2: { label: "cuid2", gender: "m" },
      ulid: { label: "ULID", gender: "m" },
      xid: { label: "XID", gender: "m" },
      ksuid: { label: "KSUID", gender: "m" },
      datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
      date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
      time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
      duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
      ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
      ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
      cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
      cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
      base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
      base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
      json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
      e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
      jwt: { label: "JWT", gender: "m" },
      ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
      includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
      lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
      starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
      uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expectedKey = issue2.expected;
          const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA instanceof ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
          }
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
        }
        case "invalid_value": {
          if (issue2.values.length === 1) {
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive(issue2.values[0])}`;
          }
          const stringified = issue2.values.map((v) => stringifyPrimitive(v));
          if (issue2.values.length === 2) {
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
          }
          const lastValue = stringified[stringified.length - 1];
          const restValues = stringified.slice(0, -1).join(", ");
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
        }
        case "too_big": {
          const sizing = getSizing(issue2.origin);
          const subject = withDefinite(issue2.origin ?? "value");
          if (issue2.origin === "string") {
            return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
          }
          if (issue2.origin === "number") {
            const comparison = issue2.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue2.maximum}`;
            return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
          }
          if (issue2.origin === "array" || issue2.origin === "set") {
            const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
            const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue2.maximum} ${sizing?.unit ?? ""}`;
            return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
          }
          const adj = issue2.inclusive ? "<=" : "<";
          const be = verbFor(issue2.origin ?? "value");
          if (sizing?.unit) {
            return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
          }
          return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const sizing = getSizing(issue2.origin);
          const subject = withDefinite(issue2.origin ?? "value");
          if (issue2.origin === "string") {
            return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
          }
          if (issue2.origin === "number") {
            const comparison = issue2.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue2.minimum}`;
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
          }
          if (issue2.origin === "array" || issue2.origin === "set") {
            const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
            if (issue2.minimum === 1 && issue2.inclusive) {
              const singularPhrase = issue2.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
              return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
            }
            const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue2.minimum} ${sizing?.unit ?? ""}`;
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
          }
          const adj = issue2.inclusive ? ">=" : ">";
          const be = verbFor(issue2.origin ?? "value");
          if (sizing?.unit) {
            return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
          const nounEntry = FormatDictionary[_issue.format];
          const noun = nounEntry?.label ?? _issue.format;
          const gender = nounEntry?.gender ?? "m";
          const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
          return `${noun} \u05DC\u05D0 ${adjective}`;
        }
        case "not_multiple_of":
          return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key": {
          return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
        }
        case "invalid_union":
          return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
        case "invalid_element": {
          const place = withDefinite(issue2.origin ?? "array");
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
        }
        default:
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
      }
    };
  };
  function he_default() {
    return {
      localeError: error16()
    };
  }

  // node_modules/zod/v4/locales/hu.js
  var error17 = () => {
    const Sizable = {
      string: { unit: "karakter", verb: "legyen" },
      file: { unit: "byte", verb: "legyen" },
      array: { unit: "elem", verb: "legyen" },
      set: { unit: "elem", verb: "legyen" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "bemenet",
      email: "email c\xEDm",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO id\u0151b\xE9lyeg",
      date: "ISO d\xE1tum",
      time: "ISO id\u0151",
      duration: "ISO id\u0151intervallum",
      ipv4: "IPv4 c\xEDm",
      ipv6: "IPv6 c\xEDm",
      cidrv4: "IPv4 tartom\xE1ny",
      cidrv6: "IPv6 tartom\xE1ny",
      base64: "base64-k\xF3dolt string",
      base64url: "base64url-k\xF3dolt string",
      json_string: "JSON string",
      e164: "E.164 sz\xE1m",
      jwt: "JWT",
      template_literal: "bemenet"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "sz\xE1m",
      array: "t\xF6mb"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k instanceof ${issue2.expected}, a kapott \xE9rt\xE9k ${received}`;
          }
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${expected}, a kapott \xE9rt\xE9k ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
          return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
          return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
          if (_issue.format === "ends_with")
            return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
          if (_issue.format === "includes")
            return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
          if (_issue.format === "regex")
            return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
          return `\xC9rv\xE9nytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
        case "unrecognized_keys":
          return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
        case "invalid_union":
          return "\xC9rv\xE9nytelen bemenet";
        case "invalid_element":
          return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
        default:
          return `\xC9rv\xE9nytelen bemenet`;
      }
    };
  };
  function hu_default() {
    return {
      localeError: error17()
    };
  }

  // node_modules/zod/v4/locales/hy.js
  function getArmenianPlural(count, one, many) {
    return Math.abs(count) === 1 ? one : many;
  }
  function withDefiniteArticle(word) {
    if (!word)
      return "";
    const vowels = ["\u0561", "\u0565", "\u0568", "\u056B", "\u0578", "\u0578\u0582", "\u0585"];
    const lastChar = word[word.length - 1];
    return word + (vowels.includes(lastChar) ? "\u0576" : "\u0568");
  }
  var error18 = () => {
    const Sizable = {
      string: {
        unit: {
          one: "\u0576\u0577\u0561\u0576",
          many: "\u0576\u0577\u0561\u0576\u0576\u0565\u0580"
        },
        verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
      },
      file: {
        unit: {
          one: "\u0562\u0561\u0575\u0569",
          many: "\u0562\u0561\u0575\u0569\u0565\u0580"
        },
        verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
      },
      array: {
        unit: {
          one: "\u057F\u0561\u0580\u0580",
          many: "\u057F\u0561\u0580\u0580\u0565\u0580"
        },
        verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
      },
      set: {
        unit: {
          one: "\u057F\u0561\u0580\u0580",
          many: "\u057F\u0561\u0580\u0580\u0565\u0580"
        },
        verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
      }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0574\u0578\u0582\u057F\u0584",
      email: "\u0567\u056C. \u0570\u0561\u057D\u0581\u0565",
      url: "URL",
      emoji: "\u0567\u0574\u0578\u057B\u056B",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E \u0587 \u056A\u0561\u0574",
      date: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E",
      time: "ISO \u056A\u0561\u0574",
      duration: "ISO \u057F\u0587\u0578\u0572\u0578\u0582\u0569\u0575\u0578\u0582\u0576",
      ipv4: "IPv4 \u0570\u0561\u057D\u0581\u0565",
      ipv6: "IPv6 \u0570\u0561\u057D\u0581\u0565",
      cidrv4: "IPv4 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
      cidrv6: "IPv6 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
      base64: "base64 \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
      base64url: "base64url \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
      json_string: "JSON \u057F\u0578\u0572",
      e164: "E.164 \u0570\u0561\u0574\u0561\u0580",
      jwt: "JWT",
      template_literal: "\u0574\u0578\u0582\u057F\u0584"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0569\u056B\u057E",
      array: "\u0566\u0561\u0576\u0563\u057E\u0561\u056E"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 instanceof ${issue2.expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
          }
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${stringifyPrimitive(issue2.values[1])}`;
          return `\u054D\u056D\u0561\u056C \u057F\u0561\u0580\u0562\u0565\u0580\u0561\u056F\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 \u0570\u0565\u057F\u0587\u0575\u0561\u056C\u0576\u0565\u0580\u056B\u0581 \u0574\u0565\u056F\u0568\u055D ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            const maxValue = Number(issue2.maximum);
            const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
            return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.maximum.toString()} ${unit}`;
          }
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056C\u056B\u0576\u056B ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            const minValue = Number(issue2.minimum);
            const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
            return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.minimum.toString()} ${unit}`;
          }
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056C\u056B\u0576\u056B ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057D\u056F\u057D\u057E\u056B "${_issue.prefix}"-\u0578\u057E`;
          if (_issue.format === "ends_with")
            return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0561\u057E\u0561\u0580\u057F\u057E\u056B "${_issue.suffix}"-\u0578\u057E`;
          if (_issue.format === "includes")
            return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057A\u0561\u0580\u0578\u0582\u0576\u0561\u056F\u056B "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0570\u0561\u0574\u0561\u057A\u0561\u057F\u0561\u057D\u056D\u0561\u0576\u056B ${_issue.pattern} \u0571\u0587\u0561\u0579\u0561\u0583\u056B\u0576`;
          return `\u054D\u056D\u0561\u056C ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u054D\u056D\u0561\u056C \u0569\u056B\u057E\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0562\u0561\u0566\u0574\u0561\u057A\u0561\u057F\u056B\u056F \u056C\u056B\u0576\u056B ${issue2.divisor}-\u056B`;
        case "unrecognized_keys":
          return `\u0549\u0573\u0561\u0576\u0561\u0579\u057E\u0561\u056E \u0562\u0561\u0576\u0561\u056C\u056B${issue2.keys.length > 1 ? "\u0576\u0565\u0580" : ""}. ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u054D\u056D\u0561\u056C \u0562\u0561\u0576\u0561\u056C\u056B ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
        case "invalid_union":
          return "\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574";
        case "invalid_element":
          return `\u054D\u056D\u0561\u056C \u0561\u0580\u056A\u0565\u0584 ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
        default:
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574`;
      }
    };
  };
  function hy_default() {
    return {
      localeError: error18()
    };
  }

  // node_modules/zod/v4/locales/id.js
  var error19 = () => {
    const Sizable = {
      string: { unit: "karakter", verb: "memiliki" },
      file: { unit: "byte", verb: "memiliki" },
      array: { unit: "item", verb: "memiliki" },
      set: { unit: "item", verb: "memiliki" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "input",
      email: "alamat email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "tanggal dan waktu format ISO",
      date: "tanggal format ISO",
      time: "jam format ISO",
      duration: "durasi format ISO",
      ipv4: "alamat IPv4",
      ipv6: "alamat IPv6",
      cidrv4: "rentang alamat IPv4",
      cidrv6: "rentang alamat IPv6",
      base64: "string dengan enkode base64",
      base64url: "string dengan enkode base64url",
      json_string: "string JSON",
      e164: "angka E.164",
      jwt: "JWT",
      template_literal: "input"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;
          }
          return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
          return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `String tidak valid: harus menyertakan "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
          return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;
        }
        case "not_multiple_of":
          return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Kunci tidak valid di ${issue2.origin}`;
        case "invalid_union":
          return "Input tidak valid";
        case "invalid_element":
          return `Nilai tidak valid di ${issue2.origin}`;
        default:
          return `Input tidak valid`;
      }
    };
  };
  function id_default() {
    return {
      localeError: error19()
    };
  }

  // node_modules/zod/v4/locales/is.js
  var error20 = () => {
    const Sizable = {
      string: { unit: "stafi", verb: "a\xF0 hafa" },
      file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
      array: { unit: "hluti", verb: "a\xF0 hafa" },
      set: { unit: "hluti", verb: "a\xF0 hafa" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "gildi",
      email: "netfang",
      url: "vefsl\xF3\xF0",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO dagsetning og t\xEDmi",
      date: "ISO dagsetning",
      time: "ISO t\xEDmi",
      duration: "ISO t\xEDmalengd",
      ipv4: "IPv4 address",
      ipv6: "IPv6 address",
      cidrv4: "IPv4 range",
      cidrv6: "IPv6 range",
      base64: "base64-encoded strengur",
      base64url: "base64url-encoded strengur",
      json_string: "JSON strengur",
      e164: "E.164 t\xF6lugildi",
      jwt: "JWT",
      template_literal: "gildi"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "n\xFAmer",
      array: "fylki"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera instanceof ${issue2.expected}`;
          }
          return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera ${expected}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
          return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
          return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Rangur lykill \xED ${issue2.origin}`;
        case "invalid_union":
          return "Rangt gildi";
        case "invalid_element":
          return `Rangt gildi \xED ${issue2.origin}`;
        default:
          return `Rangt gildi`;
      }
    };
  };
  function is_default() {
    return {
      localeError: error20()
    };
  }

  // node_modules/zod/v4/locales/it.js
  var error21 = () => {
    const Sizable = {
      string: { unit: "caratteri", verb: "avere" },
      file: { unit: "byte", verb: "avere" },
      array: { unit: "elementi", verb: "avere" },
      set: { unit: "elementi", verb: "avere" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "input",
      email: "indirizzo email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data e ora ISO",
      date: "data ISO",
      time: "ora ISO",
      duration: "durata ISO",
      ipv4: "indirizzo IPv4",
      ipv6: "indirizzo IPv6",
      cidrv4: "intervallo IPv4",
      cidrv6: "intervallo IPv6",
      base64: "stringa codificata in base64",
      base64url: "URL codificata in base64",
      json_string: "stringa JSON",
      e164: "numero E.164",
      jwt: "JWT",
      template_literal: "input"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "numero",
      array: "vettore"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;
          }
          return `Input non valido: atteso ${expected}, ricevuto ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
          return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
          return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Stringa non valida: deve includere "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
          return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Chiave non valida in ${issue2.origin}`;
        case "invalid_union":
          return "Input non valido";
        case "invalid_element":
          return `Valore non valido in ${issue2.origin}`;
        default:
          return `Input non valido`;
      }
    };
  };
  function it_default() {
    return {
      localeError: error21()
    };
  }

  // node_modules/zod/v4/locales/ja.js
  var error22 = () => {
    const Sizable = {
      string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
      file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
      array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
      set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u5165\u529B\u5024",
      email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
      url: "URL",
      emoji: "\u7D75\u6587\u5B57",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO\u65E5\u6642",
      date: "ISO\u65E5\u4ED8",
      time: "ISO\u6642\u523B",
      duration: "ISO\u671F\u9593",
      ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
      ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
      cidrv4: "IPv4\u7BC4\u56F2",
      cidrv6: "IPv6\u7BC4\u56F2",
      base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
      base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
      json_string: "JSON\u6587\u5B57\u5217",
      e164: "E.164\u756A\u53F7",
      jwt: "JWT",
      template_literal: "\u5165\u529B\u5024"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u6570\u5024",
      array: "\u914D\u5217"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u7121\u52B9\u306A\u5165\u529B: instanceof ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
          }
          return `\u7121\u52B9\u306A\u5165\u529B: ${expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
          return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        case "too_big": {
          const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          if (_issue.format === "ends_with")
            return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          if (_issue.format === "includes")
            return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          if (_issue.format === "regex")
            return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          return `\u7121\u52B9\u306A${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        case "unrecognized_keys":
          return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
        case "invalid_key":
          return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
        case "invalid_union":
          return "\u7121\u52B9\u306A\u5165\u529B";
        case "invalid_element":
          return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
        default:
          return `\u7121\u52B9\u306A\u5165\u529B`;
      }
    };
  };
  function ja_default() {
    return {
      localeError: error22()
    };
  }

  // node_modules/zod/v4/locales/ka.js
  var error23 = () => {
    const Sizable = {
      string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
      file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
      array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
      set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
      email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
      url: "URL",
      emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
      date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
      time: "\u10D3\u10E0\u10DD",
      duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
      ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
      ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
      cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
      cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
      base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
      base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
      json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
      e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
      jwt: "JWT",
      template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8",
      string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
      boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
      function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0",
      array: "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 instanceof ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
          }
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
          }
          if (_issue.format === "ends_with")
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
          if (_issue.format === "includes")
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
          if (_issue.format === "regex")
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
        case "unrecognized_keys":
          return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
        case "invalid_union":
          return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
        case "invalid_element":
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
        default:
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
      }
    };
  };
  function ka_default() {
    return {
      localeError: error23()
    };
  }

  // node_modules/zod/v4/locales/km.js
  var error24 = () => {
    const Sizable = {
      string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
      file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
      array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
      set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
      email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
      url: "URL",
      emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
      date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
      time: "\u1798\u17C9\u17C4\u1784 ISO",
      duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
      ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
      ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
      cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
      cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
      base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
      base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
      json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
      e164: "\u179B\u17C1\u1781 E.164",
      jwt: "JWT",
      template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u179B\u17C1\u1781",
      array: "\u17A2\u17B6\u179A\u17C1 (Array)",
      null: "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A instanceof ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
          }
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
          return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
          return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
        case "invalid_union":
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
        case "invalid_element":
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
        default:
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      }
    };
  };
  function km_default() {
    return {
      localeError: error24()
    };
  }

  // node_modules/zod/v4/locales/kh.js
  function kh_default() {
    return km_default();
  }

  // node_modules/zod/v4/locales/ko.js
  var error25 = () => {
    const Sizable = {
      string: { unit: "\uBB38\uC790", verb: "to have" },
      file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
      array: { unit: "\uAC1C", verb: "to have" },
      set: { unit: "\uAC1C", verb: "to have" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\uC785\uB825",
      email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
      url: "URL",
      emoji: "\uC774\uBAA8\uC9C0",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
      date: "ISO \uB0A0\uC9DC",
      time: "ISO \uC2DC\uAC04",
      duration: "ISO \uAE30\uAC04",
      ipv4: "IPv4 \uC8FC\uC18C",
      ipv6: "IPv6 \uC8FC\uC18C",
      cidrv4: "IPv4 \uBC94\uC704",
      cidrv6: "IPv6 \uBC94\uC704",
      base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
      base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
      json_string: "JSON \uBB38\uC790\uC5F4",
      e164: "E.164 \uBC88\uD638",
      jwt: "JWT",
      template_literal: "\uC785\uB825"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 instanceof ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
          }
          return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
          return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
        case "too_big": {
          const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
          const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
          const sizing = getSizing(issue2.origin);
          const unit = sizing?.unit ?? "\uC694\uC18C";
          if (sizing)
            return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
          const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
          const sizing = getSizing(issue2.origin);
          const unit = sizing?.unit ?? "\uC694\uC18C";
          if (sizing) {
            return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
          }
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
          }
          if (_issue.format === "ends_with")
            return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
          if (_issue.format === "includes")
            return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
          if (_issue.format === "regex")
            return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
          return `\uC798\uBABB\uB41C ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
        case "unrecognized_keys":
          return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
        case "invalid_union":
          return `\uC798\uBABB\uB41C \uC785\uB825`;
        case "invalid_element":
          return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
        default:
          return `\uC798\uBABB\uB41C \uC785\uB825`;
      }
    };
  };
  function ko_default() {
    return {
      localeError: error25()
    };
  }

  // node_modules/zod/v4/locales/lt.js
  var capitalizeFirstCharacter = (text) => {
    return text.charAt(0).toUpperCase() + text.slice(1);
  };
  function getUnitTypeFromNumber(number5) {
    const abs = Math.abs(number5);
    const last = abs % 10;
    const last2 = abs % 100;
    if (last2 >= 11 && last2 <= 19 || last === 0)
      return "many";
    if (last === 1)
      return "one";
    return "few";
  }
  var error26 = () => {
    const Sizable = {
      string: {
        unit: {
          one: "simbolis",
          few: "simboliai",
          many: "simboli\u0173"
        },
        verb: {
          smaller: {
            inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
            notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
          },
          bigger: {
            inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
            notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
          }
        }
      },
      file: {
        unit: {
          one: "baitas",
          few: "baitai",
          many: "bait\u0173"
        },
        verb: {
          smaller: {
            inclusive: "turi b\u016Bti ne didesnis kaip",
            notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
          },
          bigger: {
            inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
            notInclusive: "turi b\u016Bti didesnis kaip"
          }
        }
      },
      array: {
        unit: {
          one: "element\u0105",
          few: "elementus",
          many: "element\u0173"
        },
        verb: {
          smaller: {
            inclusive: "turi tur\u0117ti ne daugiau kaip",
            notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
          },
          bigger: {
            inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
            notInclusive: "turi tur\u0117ti daugiau kaip"
          }
        }
      },
      set: {
        unit: {
          one: "element\u0105",
          few: "elementus",
          many: "element\u0173"
        },
        verb: {
          smaller: {
            inclusive: "turi tur\u0117ti ne daugiau kaip",
            notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
          },
          bigger: {
            inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
            notInclusive: "turi tur\u0117ti daugiau kaip"
          }
        }
      }
    };
    function getSizing(origin, unitType, inclusive, targetShouldBe) {
      const result = Sizable[origin] ?? null;
      if (result === null)
        return result;
      return {
        unit: result.unit[unitType],
        verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
      };
    }
    const FormatDictionary = {
      regex: "\u012Fvestis",
      email: "el. pa\u0161to adresas",
      url: "URL",
      emoji: "jaustukas",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO data ir laikas",
      date: "ISO data",
      time: "ISO laikas",
      duration: "ISO trukm\u0117",
      ipv4: "IPv4 adresas",
      ipv6: "IPv6 adresas",
      cidrv4: "IPv4 tinklo prefiksas (CIDR)",
      cidrv6: "IPv6 tinklo prefiksas (CIDR)",
      base64: "base64 u\u017Ekoduota eilut\u0117",
      base64url: "base64url u\u017Ekoduota eilut\u0117",
      json_string: "JSON eilut\u0117",
      e164: "E.164 numeris",
      jwt: "JWT",
      template_literal: "\u012Fvestis"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "skai\u010Dius",
      bigint: "sveikasis skai\u010Dius",
      string: "eilut\u0117",
      boolean: "login\u0117 reik\u0161m\u0117",
      undefined: "neapibr\u0117\u017Eta reik\u0161m\u0117",
      function: "funkcija",
      symbol: "simbolis",
      array: "masyvas",
      object: "objektas",
      null: "nulin\u0117 reik\u0161m\u0117"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Gautas tipas ${received}, o tik\u0117tasi - instanceof ${issue2.expected}`;
          }
          return `Gautas tipas ${received}, o tik\u0117tasi - ${expected}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
          return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
        case "too_big": {
          const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
          const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
          if (sizing?.verb)
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
          const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
        }
        case "too_small": {
          const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
          const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
          if (sizing?.verb)
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
          const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
          return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
        case "unrecognized_keys":
          return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return "Rastas klaidingas raktas";
        case "invalid_union":
          return "Klaidinga \u012Fvestis";
        case "invalid_element": {
          const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
        }
        default:
          return "Klaidinga \u012Fvestis";
      }
    };
  };
  function lt_default() {
    return {
      localeError: error26()
    };
  }

  // node_modules/zod/v4/locales/mk.js
  var error27 = () => {
    const Sizable = {
      string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
      file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
      array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
      set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0432\u043D\u0435\u0441",
      email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
      url: "URL",
      emoji: "\u0435\u043C\u043E\u045F\u0438",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
      date: "ISO \u0434\u0430\u0442\u0443\u043C",
      time: "ISO \u0432\u0440\u0435\u043C\u0435",
      duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
      ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
      ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
      cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
      cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
      base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
      base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
      json_string: "JSON \u043D\u0438\u0437\u0430",
      e164: "E.164 \u0431\u0440\u043E\u0458",
      jwt: "JWT",
      template_literal: "\u0432\u043D\u0435\u0441"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0431\u0440\u043E\u0458",
      array: "\u043D\u0438\u0437\u0430"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 instanceof ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
          }
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
          return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
          return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
        case "invalid_union":
          return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
        case "invalid_element":
          return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
        default:
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
      }
    };
  };
  function mk_default() {
    return {
      localeError: error27()
    };
  }

  // node_modules/zod/v4/locales/ms.js
  var error28 = () => {
    const Sizable = {
      string: { unit: "aksara", verb: "mempunyai" },
      file: { unit: "bait", verb: "mempunyai" },
      array: { unit: "elemen", verb: "mempunyai" },
      set: { unit: "elemen", verb: "mempunyai" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "input",
      email: "alamat e-mel",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "tarikh masa ISO",
      date: "tarikh ISO",
      time: "masa ISO",
      duration: "tempoh ISO",
      ipv4: "alamat IPv4",
      ipv6: "alamat IPv6",
      cidrv4: "julat IPv4",
      cidrv6: "julat IPv6",
      base64: "string dikodkan base64",
      base64url: "string dikodkan base64url",
      json_string: "string JSON",
      e164: "nombor E.164",
      jwt: "JWT",
      template_literal: "input"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "nombor"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;
          }
          return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
          return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
          return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;
        }
        case "not_multiple_of":
          return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Kunci tidak sah dalam ${issue2.origin}`;
        case "invalid_union":
          return "Input tidak sah";
        case "invalid_element":
          return `Nilai tidak sah dalam ${issue2.origin}`;
        default:
          return `Input tidak sah`;
      }
    };
  };
  function ms_default() {
    return {
      localeError: error28()
    };
  }

  // node_modules/zod/v4/locales/nl.js
  var error29 = () => {
    const Sizable = {
      string: { unit: "tekens", verb: "heeft" },
      file: { unit: "bytes", verb: "heeft" },
      array: { unit: "elementen", verb: "heeft" },
      set: { unit: "elementen", verb: "heeft" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "invoer",
      email: "emailadres",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datum en tijd",
      date: "ISO datum",
      time: "ISO tijd",
      duration: "ISO duur",
      ipv4: "IPv4-adres",
      ipv6: "IPv6-adres",
      cidrv4: "IPv4-bereik",
      cidrv6: "IPv6-bereik",
      base64: "base64-gecodeerde tekst",
      base64url: "base64 URL-gecodeerde tekst",
      json_string: "JSON string",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "invoer"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "getal"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;
          }
          return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
          return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          const longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";
          if (sizing)
            return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
          return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          const shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";
          if (sizing) {
            return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
          }
          return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
          }
          if (_issue.format === "ends_with")
            return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
          if (_issue.format === "includes")
            return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
          if (_issue.format === "regex")
            return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
          return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
        case "unrecognized_keys":
          return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Ongeldige key in ${issue2.origin}`;
        case "invalid_union":
          return "Ongeldige invoer";
        case "invalid_element":
          return `Ongeldige waarde in ${issue2.origin}`;
        default:
          return `Ongeldige invoer`;
      }
    };
  };
  function nl_default() {
    return {
      localeError: error29()
    };
  }

  // node_modules/zod/v4/locales/no.js
  var error30 = () => {
    const Sizable = {
      string: { unit: "tegn", verb: "\xE5 ha" },
      file: { unit: "bytes", verb: "\xE5 ha" },
      array: { unit: "elementer", verb: "\xE5 inneholde" },
      set: { unit: "elementer", verb: "\xE5 inneholde" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "input",
      email: "e-postadresse",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO dato- og klokkeslett",
      date: "ISO-dato",
      time: "ISO-klokkeslett",
      duration: "ISO-varighet",
      ipv4: "IPv4-omr\xE5de",
      ipv6: "IPv6-omr\xE5de",
      cidrv4: "IPv4-spekter",
      cidrv6: "IPv6-spekter",
      base64: "base64-enkodet streng",
      base64url: "base64url-enkodet streng",
      json_string: "JSON-streng",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "input"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "tall",
      array: "liste"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;
          }
          return `Ugyldig input: forventet ${expected}, fikk ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
          return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
          return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
          return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Ugyldig n\xF8kkel i ${issue2.origin}`;
        case "invalid_union":
          return "Ugyldig input";
        case "invalid_element":
          return `Ugyldig verdi i ${issue2.origin}`;
        default:
          return `Ugyldig input`;
      }
    };
  };
  function no_default() {
    return {
      localeError: error30()
    };
  }

  // node_modules/zod/v4/locales/ota.js
  var error31 = () => {
    const Sizable = {
      string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
      file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
      array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
      set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "giren",
      email: "epostag\xE2h",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO heng\xE2m\u0131",
      date: "ISO tarihi",
      time: "ISO zaman\u0131",
      duration: "ISO m\xFCddeti",
      ipv4: "IPv4 ni\u015F\xE2n\u0131",
      ipv6: "IPv6 ni\u015F\xE2n\u0131",
      cidrv4: "IPv4 menzili",
      cidrv6: "IPv6 menzili",
      base64: "base64-\u015Fifreli metin",
      base64url: "base64url-\u015Fifreli metin",
      json_string: "JSON metin",
      e164: "E.164 say\u0131s\u0131",
      jwt: "JWT",
      template_literal: "giren"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "numara",
      array: "saf",
      null: "gayb"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `F\xE2sit giren: umulan instanceof ${issue2.expected}, al\u0131nan ${received}`;
          }
          return `F\xE2sit giren: umulan ${expected}, al\u0131nan ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
          return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
          return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
          }
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
          if (_issue.format === "ends_with")
            return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
          if (_issue.format === "includes")
            return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
          if (_issue.format === "regex")
            return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
          return `F\xE2sit ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
        case "unrecognized_keys":
          return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
        case "invalid_union":
          return "Giren tan\u0131namad\u0131.";
        case "invalid_element":
          return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
        default:
          return `K\u0131ymet tan\u0131namad\u0131.`;
      }
    };
  };
  function ota_default() {
    return {
      localeError: error31()
    };
  }

  // node_modules/zod/v4/locales/ps.js
  var error32 = () => {
    const Sizable = {
      string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
      file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
      array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
      set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0648\u0631\u0648\u062F\u064A",
      email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
      url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
      emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
      date: "\u0646\u06D0\u067C\u0647",
      time: "\u0648\u062E\u062A",
      duration: "\u0645\u0648\u062F\u0647",
      ipv4: "\u062F IPv4 \u067E\u062A\u0647",
      ipv6: "\u062F IPv6 \u067E\u062A\u0647",
      cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
      cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
      base64: "base64-encoded \u0645\u062A\u0646",
      base64url: "base64url-encoded \u0645\u062A\u0646",
      json_string: "JSON \u0645\u062A\u0646",
      e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
      jwt: "JWT",
      template_literal: "\u0648\u0631\u0648\u062F\u064A"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0639\u062F\u062F",
      array: "\u0627\u0631\u06D0"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F instanceof ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
          }
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
        }
        case "invalid_value":
          if (issue2.values.length === 1) {
            return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
          }
          return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
          }
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
          }
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
          }
          if (_issue.format === "ends_with") {
            return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
          }
          if (_issue.format === "includes") {
            return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
          }
          if (_issue.format === "regex") {
            return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
          }
          return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
        }
        case "not_multiple_of":
          return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
        case "unrecognized_keys":
          return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
        case "invalid_union":
          return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
        case "invalid_element":
          return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
        default:
          return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      }
    };
  };
  function ps_default() {
    return {
      localeError: error32()
    };
  }

  // node_modules/zod/v4/locales/pl.js
  var error33 = () => {
    const Sizable = {
      string: { unit: "znak\xF3w", verb: "mie\u0107" },
      file: { unit: "bajt\xF3w", verb: "mie\u0107" },
      array: { unit: "element\xF3w", verb: "mie\u0107" },
      set: { unit: "element\xF3w", verb: "mie\u0107" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "wyra\u017Cenie",
      email: "adres email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data i godzina w formacie ISO",
      date: "data w formacie ISO",
      time: "godzina w formacie ISO",
      duration: "czas trwania ISO",
      ipv4: "adres IPv4",
      ipv6: "adres IPv6",
      cidrv4: "zakres IPv4",
      cidrv6: "zakres IPv6",
      base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
      base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
      json_string: "ci\u0105g znak\xF3w w formacie JSON",
      e164: "liczba E.164",
      jwt: "JWT",
      template_literal: "wej\u015Bcie"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "liczba",
      array: "tablica"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;
          }
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${expected}, otrzymano ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
          return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
          }
          return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
          }
          return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
          return `Nieprawid\u0142ow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
        case "invalid_union":
          return "Nieprawid\u0142owe dane wej\u015Bciowe";
        case "invalid_element":
          return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
        default:
          return `Nieprawid\u0142owe dane wej\u015Bciowe`;
      }
    };
  };
  function pl_default() {
    return {
      localeError: error33()
    };
  }

  // node_modules/zod/v4/locales/pt.js
  var error34 = () => {
    const Sizable = {
      string: { unit: "caracteres", verb: "ter" },
      file: { unit: "bytes", verb: "ter" },
      array: { unit: "itens", verb: "ter" },
      set: { unit: "itens", verb: "ter" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "padr\xE3o",
      email: "endere\xE7o de e-mail",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data e hora ISO",
      date: "data ISO",
      time: "hora ISO",
      duration: "dura\xE7\xE3o ISO",
      ipv4: "endere\xE7o IPv4",
      ipv6: "endere\xE7o IPv6",
      cidrv4: "faixa de IPv4",
      cidrv6: "faixa de IPv6",
      base64: "texto codificado em base64",
      base64url: "URL codificada em base64",
      json_string: "texto JSON",
      e164: "n\xFAmero E.164",
      jwt: "JWT",
      template_literal: "entrada"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "n\xFAmero",
      null: "nulo"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Tipo inv\xE1lido: esperado instanceof ${issue2.expected}, recebido ${received}`;
          }
          return `Tipo inv\xE1lido: esperado ${expected}, recebido ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
          return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
          return `${FormatDictionary[_issue.format] ?? issue2.format} inv\xE1lido`;
        }
        case "not_multiple_of":
          return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Chave inv\xE1lida em ${issue2.origin}`;
        case "invalid_union":
          return "Entrada inv\xE1lida";
        case "invalid_element":
          return `Valor inv\xE1lido em ${issue2.origin}`;
        default:
          return `Campo inv\xE1lido`;
      }
    };
  };
  function pt_default() {
    return {
      localeError: error34()
    };
  }

  // node_modules/zod/v4/locales/ru.js
  function getRussianPlural(count, one, few, many) {
    const absCount = Math.abs(count);
    const lastDigit = absCount % 10;
    const lastTwoDigits = absCount % 100;
    if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
      return many;
    }
    if (lastDigit === 1) {
      return one;
    }
    if (lastDigit >= 2 && lastDigit <= 4) {
      return few;
    }
    return many;
  }
  var error35 = () => {
    const Sizable = {
      string: {
        unit: {
          one: "\u0441\u0438\u043C\u0432\u043E\u043B",
          few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
          many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
        },
        verb: "\u0438\u043C\u0435\u0442\u044C"
      },
      file: {
        unit: {
          one: "\u0431\u0430\u0439\u0442",
          few: "\u0431\u0430\u0439\u0442\u0430",
          many: "\u0431\u0430\u0439\u0442"
        },
        verb: "\u0438\u043C\u0435\u0442\u044C"
      },
      array: {
        unit: {
          one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
          few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
          many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
        },
        verb: "\u0438\u043C\u0435\u0442\u044C"
      },
      set: {
        unit: {
          one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
          few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
          many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
        },
        verb: "\u0438\u043C\u0435\u0442\u044C"
      }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0432\u0432\u043E\u0434",
      email: "email \u0430\u0434\u0440\u0435\u0441",
      url: "URL",
      emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
      date: "ISO \u0434\u0430\u0442\u0430",
      time: "ISO \u0432\u0440\u0435\u043C\u044F",
      duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
      ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
      ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
      cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
      cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
      base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
      base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
      json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
      e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
      jwt: "JWT",
      template_literal: "\u0432\u0432\u043E\u0434"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0447\u0438\u0441\u043B\u043E",
      array: "\u043C\u0430\u0441\u0441\u0438\u0432"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
          }
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            const maxValue = Number(issue2.maximum);
            const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
          }
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            const minValue = Number(issue2.minimum);
            const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
          }
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
        case "invalid_union":
          return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
        case "invalid_element":
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
        default:
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
      }
    };
  };
  function ru_default() {
    return {
      localeError: error35()
    };
  }

  // node_modules/zod/v4/locales/sl.js
  var error36 = () => {
    const Sizable = {
      string: { unit: "znakov", verb: "imeti" },
      file: { unit: "bajtov", verb: "imeti" },
      array: { unit: "elementov", verb: "imeti" },
      set: { unit: "elementov", verb: "imeti" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "vnos",
      email: "e-po\u0161tni naslov",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datum in \u010Das",
      date: "ISO datum",
      time: "ISO \u010Das",
      duration: "ISO trajanje",
      ipv4: "IPv4 naslov",
      ipv6: "IPv6 naslov",
      cidrv4: "obseg IPv4",
      cidrv6: "obseg IPv6",
      base64: "base64 kodiran niz",
      base64url: "base64url kodiran niz",
      json_string: "JSON niz",
      e164: "E.164 \u0161tevilka",
      jwt: "JWT",
      template_literal: "vnos"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0161tevilo",
      array: "tabela"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Neveljaven vnos: pri\u010Dakovano instanceof ${issue2.expected}, prejeto ${received}`;
          }
          return `Neveljaven vnos: pri\u010Dakovano ${expected}, prejeto ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
          return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
          return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
          return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Neveljaven klju\u010D v ${issue2.origin}`;
        case "invalid_union":
          return "Neveljaven vnos";
        case "invalid_element":
          return `Neveljavna vrednost v ${issue2.origin}`;
        default:
          return "Neveljaven vnos";
      }
    };
  };
  function sl_default() {
    return {
      localeError: error36()
    };
  }

  // node_modules/zod/v4/locales/sv.js
  var error37 = () => {
    const Sizable = {
      string: { unit: "tecken", verb: "att ha" },
      file: { unit: "bytes", verb: "att ha" },
      array: { unit: "objekt", verb: "att inneh\xE5lla" },
      set: { unit: "objekt", verb: "att inneh\xE5lla" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "regulj\xE4rt uttryck",
      email: "e-postadress",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-datum och tid",
      date: "ISO-datum",
      time: "ISO-tid",
      duration: "ISO-varaktighet",
      ipv4: "IPv4-intervall",
      ipv6: "IPv6-intervall",
      cidrv4: "IPv4-spektrum",
      cidrv6: "IPv6-spektrum",
      base64: "base64-kodad str\xE4ng",
      base64url: "base64url-kodad str\xE4ng",
      json_string: "JSON-str\xE4ng",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "mall-literal"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "antal",
      array: "lista"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Ogiltig inmatning: f\xF6rv\xE4ntat instanceof ${issue2.expected}, fick ${received}`;
          }
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${expected}, fick ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
          return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
          }
          return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
          return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
        case "invalid_union":
          return "Ogiltig input";
        case "invalid_element":
          return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
        default:
          return `Ogiltig input`;
      }
    };
  };
  function sv_default() {
    return {
      localeError: error37()
    };
  }

  // node_modules/zod/v4/locales/ta.js
  var error38 = () => {
    const Sizable = {
      string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
      file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
      array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
      set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
      email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
      date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
      time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
      duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
      ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
      ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
      cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
      cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
      base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
      base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
      json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
      e164: "E.164 \u0B8E\u0BA3\u0BCD",
      jwt: "JWT",
      template_literal: "input"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0B8E\u0BA3\u0BCD",
      array: "\u0B85\u0BA3\u0BBF",
      null: "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 instanceof ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
          }
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          if (_issue.format === "ends_with")
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          if (_issue.format === "includes")
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          if (_issue.format === "regex")
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        case "unrecognized_keys":
          return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
        case "invalid_union":
          return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
        case "invalid_element":
          return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
        default:
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
      }
    };
  };
  function ta_default() {
    return {
      localeError: error38()
    };
  }

  // node_modules/zod/v4/locales/th.js
  var error39 = () => {
    const Sizable = {
      string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
      file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
      array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
      set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
      email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
      url: "URL",
      emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
      date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
      time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
      duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
      ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
      ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
      cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
      cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
      base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
      base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
      json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
      e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
      jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
      template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
      array: "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)",
      null: "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 instanceof ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
          }
          return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
          return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
          if (_issue.format === "regex")
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
        case "unrecognized_keys":
          return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
        case "invalid_union":
          return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
        case "invalid_element":
          return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
        default:
          return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
      }
    };
  };
  function th_default() {
    return {
      localeError: error39()
    };
  }

  // node_modules/zod/v4/locales/tr.js
  var error40 = () => {
    const Sizable = {
      string: { unit: "karakter", verb: "olmal\u0131" },
      file: { unit: "bayt", verb: "olmal\u0131" },
      array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
      set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "girdi",
      email: "e-posta adresi",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO tarih ve saat",
      date: "ISO tarih",
      time: "ISO saat",
      duration: "ISO s\xFCre",
      ipv4: "IPv4 adresi",
      ipv6: "IPv6 adresi",
      cidrv4: "IPv4 aral\u0131\u011F\u0131",
      cidrv6: "IPv6 aral\u0131\u011F\u0131",
      base64: "base64 ile \u015Fifrelenmi\u015F metin",
      base64url: "base64url ile \u015Fifrelenmi\u015F metin",
      json_string: "JSON dizesi",
      e164: "E.164 say\u0131s\u0131",
      jwt: "JWT",
      template_literal: "\u015Eablon dizesi"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Ge\xE7ersiz de\u011Fer: beklenen instanceof ${issue2.expected}, al\u0131nan ${received}`;
          }
          return `Ge\xE7ersiz de\u011Fer: beklenen ${expected}, al\u0131nan ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
          return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
          if (_issue.format === "ends_with")
            return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
          if (_issue.format === "includes")
            return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
          if (_issue.format === "regex")
            return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
          return `Ge\xE7ersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
        case "unrecognized_keys":
          return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
        case "invalid_union":
          return "Ge\xE7ersiz de\u011Fer";
        case "invalid_element":
          return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
        default:
          return `Ge\xE7ersiz de\u011Fer`;
      }
    };
  };
  function tr_default() {
    return {
      localeError: error40()
    };
  }

  // node_modules/zod/v4/locales/uk.js
  var error41 = () => {
    const Sizable = {
      string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
      file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
      array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
      set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
      email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
      url: "URL",
      emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
      date: "\u0434\u0430\u0442\u0430 ISO",
      time: "\u0447\u0430\u0441 ISO",
      duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
      ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
      ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
      cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
      cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
      base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
      base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
      json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
      e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
      jwt: "JWT",
      template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0447\u0438\u0441\u043B\u043E",
      array: "\u043C\u0430\u0441\u0438\u0432"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F instanceof ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
          }
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
        case "invalid_union":
          return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
        case "invalid_element":
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
        default:
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
      }
    };
  };
  function uk_default() {
    return {
      localeError: error41()
    };
  }

  // node_modules/zod/v4/locales/ua.js
  function ua_default() {
    return uk_default();
  }

  // node_modules/zod/v4/locales/ur.js
  var error42 = () => {
    const Sizable = {
      string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
      file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
      array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
      set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0627\u0646 \u067E\u0679",
      email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
      url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
      emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
      uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
      uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
      nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
      ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
      xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
      ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
      date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
      time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
      duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
      ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
      ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
      cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
      cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
      base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
      base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
      json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
      e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
      jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
      template_literal: "\u0627\u0646 \u067E\u0679"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0646\u0645\u0628\u0631",
      array: "\u0622\u0631\u06D2",
      null: "\u0646\u0644"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: instanceof ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
          }
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
          }
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          }
          if (_issue.format === "ends_with")
            return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          if (_issue.format === "includes")
            return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          if (_issue.format === "regex")
            return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          return `\u063A\u0644\u0637 ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        case "unrecognized_keys":
          return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
        case "invalid_key":
          return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
        case "invalid_union":
          return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
        case "invalid_element":
          return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
        default:
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
      }
    };
  };
  function ur_default() {
    return {
      localeError: error42()
    };
  }

  // node_modules/zod/v4/locales/uz.js
  var error43 = () => {
    const Sizable = {
      string: { unit: "belgi", verb: "bo\u2018lishi kerak" },
      file: { unit: "bayt", verb: "bo\u2018lishi kerak" },
      array: { unit: "element", verb: "bo\u2018lishi kerak" },
      set: { unit: "element", verb: "bo\u2018lishi kerak" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "kirish",
      email: "elektron pochta manzili",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO sana va vaqti",
      date: "ISO sana",
      time: "ISO vaqt",
      duration: "ISO davomiylik",
      ipv4: "IPv4 manzil",
      ipv6: "IPv6 manzil",
      mac: "MAC manzil",
      cidrv4: "IPv4 diapazon",
      cidrv6: "IPv6 diapazon",
      base64: "base64 kodlangan satr",
      base64url: "base64url kodlangan satr",
      json_string: "JSON satr",
      e164: "E.164 raqam",
      jwt: "JWT",
      template_literal: "kirish"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "raqam",
      array: "massiv"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Noto\u2018g\u2018ri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;
          }
          return `Noto\u2018g\u2018ri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Noto\u2018g\u2018ri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;
          return `Noto\u2018g\u2018ri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
          return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
          }
          return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Noto\u2018g\u2018ri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
          if (_issue.format === "ends_with")
            return `Noto\u2018g\u2018ri satr: "${_issue.suffix}" bilan tugashi kerak`;
          if (_issue.format === "includes")
            return `Noto\u2018g\u2018ri satr: "${_issue.includes}" ni o\u2018z ichiga olishi kerak`;
          if (_issue.format === "regex")
            return `Noto\u2018g\u2018ri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
          return `Noto\u2018g\u2018ri ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Noto\u2018g\u2018ri raqam: ${issue2.divisor} ning karralisi bo\u2018lishi kerak`;
        case "unrecognized_keys":
          return `Noma\u2019lum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} dagi kalit noto\u2018g\u2018ri`;
        case "invalid_union":
          return "Noto\u2018g\u2018ri kirish";
        case "invalid_element":
          return `${issue2.origin} da noto\u2018g\u2018ri qiymat`;
        default:
          return `Noto\u2018g\u2018ri kirish`;
      }
    };
  };
  function uz_default() {
    return {
      localeError: error43()
    };
  }

  // node_modules/zod/v4/locales/vi.js
  var error44 = () => {
    const Sizable = {
      string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
      file: { unit: "byte", verb: "c\xF3" },
      array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
      set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0111\u1EA7u v\xE0o",
      email: "\u0111\u1ECBa ch\u1EC9 email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ng\xE0y gi\u1EDD ISO",
      date: "ng\xE0y ISO",
      time: "gi\u1EDD ISO",
      duration: "kho\u1EA3ng th\u1EDDi gian ISO",
      ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
      ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
      cidrv4: "d\u1EA3i IPv4",
      cidrv6: "d\u1EA3i IPv6",
      base64: "chu\u1ED7i m\xE3 h\xF3a base64",
      base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
      json_string: "chu\u1ED7i JSON",
      e164: "s\u1ED1 E.164",
      jwt: "JWT",
      template_literal: "\u0111\u1EA7u v\xE0o"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "s\u1ED1",
      array: "m\u1EA3ng"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i instanceof ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
          }
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
          return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
          return `${FormatDictionary[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
        }
        case "not_multiple_of":
          return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
        case "invalid_union":
          return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
        case "invalid_element":
          return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
        default:
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
      }
    };
  };
  function vi_default() {
    return {
      localeError: error44()
    };
  }

  // node_modules/zod/v4/locales/zh-CN.js
  var error45 = () => {
    const Sizable = {
      string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
      file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
      array: { unit: "\u9879", verb: "\u5305\u542B" },
      set: { unit: "\u9879", verb: "\u5305\u542B" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u8F93\u5165",
      email: "\u7535\u5B50\u90AE\u4EF6",
      url: "URL",
      emoji: "\u8868\u60C5\u7B26\u53F7",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO\u65E5\u671F\u65F6\u95F4",
      date: "ISO\u65E5\u671F",
      time: "ISO\u65F6\u95F4",
      duration: "ISO\u65F6\u957F",
      ipv4: "IPv4\u5730\u5740",
      ipv6: "IPv6\u5730\u5740",
      cidrv4: "IPv4\u7F51\u6BB5",
      cidrv6: "IPv6\u7F51\u6BB5",
      base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
      base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
      json_string: "JSON\u5B57\u7B26\u4E32",
      e164: "E.164\u53F7\u7801",
      jwt: "JWT",
      template_literal: "\u8F93\u5165"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u6570\u5B57",
      array: "\u6570\u7EC4",
      null: "\u7A7A\u503C(null)"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B instanceof ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
          }
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
          return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
          if (_issue.format === "ends_with")
            return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
          if (_issue.format === "includes")
            return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
          return `\u65E0\u6548${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
        case "unrecognized_keys":
          return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
        case "invalid_union":
          return "\u65E0\u6548\u8F93\u5165";
        case "invalid_element":
          return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
        default:
          return `\u65E0\u6548\u8F93\u5165`;
      }
    };
  };
  function zh_CN_default() {
    return {
      localeError: error45()
    };
  }

  // node_modules/zod/v4/locales/zh-TW.js
  var error46 = () => {
    const Sizable = {
      string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
      file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
      array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
      set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u8F38\u5165",
      email: "\u90F5\u4EF6\u5730\u5740",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u65E5\u671F\u6642\u9593",
      date: "ISO \u65E5\u671F",
      time: "ISO \u6642\u9593",
      duration: "ISO \u671F\u9593",
      ipv4: "IPv4 \u4F4D\u5740",
      ipv6: "IPv6 \u4F4D\u5740",
      cidrv4: "IPv4 \u7BC4\u570D",
      cidrv6: "IPv6 \u7BC4\u570D",
      base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
      base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
      json_string: "JSON \u5B57\u4E32",
      e164: "E.164 \u6578\u503C",
      jwt: "JWT",
      template_literal: "\u8F38\u5165"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA instanceof ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
          }
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
          return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
          }
          if (_issue.format === "ends_with")
            return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
          if (_issue.format === "includes")
            return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
          return `\u7121\u6548\u7684 ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
        case "unrecognized_keys":
          return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
        case "invalid_key":
          return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
        case "invalid_union":
          return "\u7121\u6548\u7684\u8F38\u5165\u503C";
        case "invalid_element":
          return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
        default:
          return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
      }
    };
  };
  function zh_TW_default() {
    return {
      localeError: error46()
    };
  }

  // node_modules/zod/v4/locales/yo.js
  var error47 = () => {
    const Sizable = {
      string: { unit: "\xE0mi", verb: "n\xED" },
      file: { unit: "bytes", verb: "n\xED" },
      array: { unit: "nkan", verb: "n\xED" },
      set: { unit: "nkan", verb: "n\xED" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
      email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\xE0k\xF3k\xF2 ISO",
      date: "\u1ECDj\u1ECD\u0301 ISO",
      time: "\xE0k\xF3k\xF2 ISO",
      duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
      ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
      ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
      cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
      cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
      base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
      base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
      json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
      e164: "n\u1ECD\u0301mb\xE0 E.164",
      jwt: "JWT",
      template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "n\u1ECD\u0301mb\xE0",
      array: "akop\u1ECD"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi instanceof ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
          }
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
          return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
          return `A\u1E63\xEC\u1E63e: ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
        case "unrecognized_keys":
          return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
        case "invalid_union":
          return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
        case "invalid_element":
          return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
        default:
          return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      }
    };
  };
  function yo_default() {
    return {
      localeError: error47()
    };
  }

  // node_modules/zod/v4/core/registries.js
  var _a;
  var $output = /* @__PURE__ */ Symbol("ZodOutput");
  var $input = /* @__PURE__ */ Symbol("ZodInput");
  var $ZodRegistry = class {
    constructor() {
      this._map = /* @__PURE__ */ new WeakMap();
      this._idmap = /* @__PURE__ */ new Map();
    }
    add(schema, ..._meta) {
      const meta3 = _meta[0];
      this._map.set(schema, meta3);
      if (meta3 && typeof meta3 === "object" && "id" in meta3) {
        this._idmap.set(meta3.id, schema);
      }
      return this;
    }
    clear() {
      this._map = /* @__PURE__ */ new WeakMap();
      this._idmap = /* @__PURE__ */ new Map();
      return this;
    }
    remove(schema) {
      const meta3 = this._map.get(schema);
      if (meta3 && typeof meta3 === "object" && "id" in meta3) {
        this._idmap.delete(meta3.id);
      }
      this._map.delete(schema);
      return this;
    }
    get(schema) {
      const p = schema._zod.parent;
      if (p) {
        const pm = { ...this.get(p) ?? {} };
        delete pm.id;
        const f = { ...pm, ...this._map.get(schema) };
        return Object.keys(f).length ? f : void 0;
      }
      return this._map.get(schema);
    }
    has(schema) {
      return this._map.has(schema);
    }
  };
  function registry() {
    return new $ZodRegistry();
  }
  (_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
  var globalRegistry = globalThis.__zod_globalRegistry;

  // node_modules/zod/v4/core/api.js
  // @__NO_SIDE_EFFECTS__
  function _string(Class2, params) {
    return new Class2({
      type: "string",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _coercedString(Class2, params) {
    return new Class2({
      type: "string",
      coerce: true,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _email(Class2, params) {
    return new Class2({
      type: "string",
      format: "email",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _guid(Class2, params) {
    return new Class2({
      type: "string",
      format: "guid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uuid(Class2, params) {
    return new Class2({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uuidv4(Class2, params) {
    return new Class2({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: false,
      version: "v4",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uuidv6(Class2, params) {
    return new Class2({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: false,
      version: "v6",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uuidv7(Class2, params) {
    return new Class2({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: false,
      version: "v7",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _url(Class2, params) {
    return new Class2({
      type: "string",
      format: "url",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _emoji2(Class2, params) {
    return new Class2({
      type: "string",
      format: "emoji",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _nanoid(Class2, params) {
    return new Class2({
      type: "string",
      format: "nanoid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _cuid(Class2, params) {
    return new Class2({
      type: "string",
      format: "cuid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _cuid2(Class2, params) {
    return new Class2({
      type: "string",
      format: "cuid2",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _ulid(Class2, params) {
    return new Class2({
      type: "string",
      format: "ulid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _xid(Class2, params) {
    return new Class2({
      type: "string",
      format: "xid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _ksuid(Class2, params) {
    return new Class2({
      type: "string",
      format: "ksuid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _ipv4(Class2, params) {
    return new Class2({
      type: "string",
      format: "ipv4",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _ipv6(Class2, params) {
    return new Class2({
      type: "string",
      format: "ipv6",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _mac(Class2, params) {
    return new Class2({
      type: "string",
      format: "mac",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _cidrv4(Class2, params) {
    return new Class2({
      type: "string",
      format: "cidrv4",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _cidrv6(Class2, params) {
    return new Class2({
      type: "string",
      format: "cidrv6",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _base64(Class2, params) {
    return new Class2({
      type: "string",
      format: "base64",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _base64url(Class2, params) {
    return new Class2({
      type: "string",
      format: "base64url",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _e164(Class2, params) {
    return new Class2({
      type: "string",
      format: "e164",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _jwt(Class2, params) {
    return new Class2({
      type: "string",
      format: "jwt",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  var TimePrecision = {
    Any: null,
    Minute: -1,
    Second: 0,
    Millisecond: 3,
    Microsecond: 6
  };
  // @__NO_SIDE_EFFECTS__
  function _isoDateTime(Class2, params) {
    return new Class2({
      type: "string",
      format: "datetime",
      check: "string_format",
      offset: false,
      local: false,
      precision: null,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _isoDate(Class2, params) {
    return new Class2({
      type: "string",
      format: "date",
      check: "string_format",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _isoTime(Class2, params) {
    return new Class2({
      type: "string",
      format: "time",
      check: "string_format",
      precision: null,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _isoDuration(Class2, params) {
    return new Class2({
      type: "string",
      format: "duration",
      check: "string_format",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _number(Class2, params) {
    return new Class2({
      type: "number",
      checks: [],
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _coercedNumber(Class2, params) {
    return new Class2({
      type: "number",
      coerce: true,
      checks: [],
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _int(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "safeint",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _float32(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "float32",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _float64(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "float64",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _int32(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "int32",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uint32(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "uint32",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _boolean(Class2, params) {
    return new Class2({
      type: "boolean",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _coercedBoolean(Class2, params) {
    return new Class2({
      type: "boolean",
      coerce: true,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _bigint(Class2, params) {
    return new Class2({
      type: "bigint",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _coercedBigint(Class2, params) {
    return new Class2({
      type: "bigint",
      coerce: true,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _int64(Class2, params) {
    return new Class2({
      type: "bigint",
      check: "bigint_format",
      abort: false,
      format: "int64",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uint64(Class2, params) {
    return new Class2({
      type: "bigint",
      check: "bigint_format",
      abort: false,
      format: "uint64",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _symbol(Class2, params) {
    return new Class2({
      type: "symbol",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _undefined2(Class2, params) {
    return new Class2({
      type: "undefined",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _null2(Class2, params) {
    return new Class2({
      type: "null",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _any(Class2) {
    return new Class2({
      type: "any"
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _unknown(Class2) {
    return new Class2({
      type: "unknown"
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _never(Class2, params) {
    return new Class2({
      type: "never",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _void(Class2, params) {
    return new Class2({
      type: "void",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _date(Class2, params) {
    return new Class2({
      type: "date",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _coercedDate(Class2, params) {
    return new Class2({
      type: "date",
      coerce: true,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _nan(Class2, params) {
    return new Class2({
      type: "nan",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _lt(value, params) {
    return new $ZodCheckLessThan({
      check: "less_than",
      ...normalizeParams(params),
      value,
      inclusive: false
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _lte(value, params) {
    return new $ZodCheckLessThan({
      check: "less_than",
      ...normalizeParams(params),
      value,
      inclusive: true
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _gt(value, params) {
    return new $ZodCheckGreaterThan({
      check: "greater_than",
      ...normalizeParams(params),
      value,
      inclusive: false
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _gte(value, params) {
    return new $ZodCheckGreaterThan({
      check: "greater_than",
      ...normalizeParams(params),
      value,
      inclusive: true
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _positive(params) {
    return /* @__PURE__ */ _gt(0, params);
  }
  // @__NO_SIDE_EFFECTS__
  function _negative(params) {
    return /* @__PURE__ */ _lt(0, params);
  }
  // @__NO_SIDE_EFFECTS__
  function _nonpositive(params) {
    return /* @__PURE__ */ _lte(0, params);
  }
  // @__NO_SIDE_EFFECTS__
  function _nonnegative(params) {
    return /* @__PURE__ */ _gte(0, params);
  }
  // @__NO_SIDE_EFFECTS__
  function _multipleOf(value, params) {
    return new $ZodCheckMultipleOf({
      check: "multiple_of",
      ...normalizeParams(params),
      value
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _maxSize(maximum, params) {
    return new $ZodCheckMaxSize({
      check: "max_size",
      ...normalizeParams(params),
      maximum
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _minSize(minimum, params) {
    return new $ZodCheckMinSize({
      check: "min_size",
      ...normalizeParams(params),
      minimum
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _size(size, params) {
    return new $ZodCheckSizeEquals({
      check: "size_equals",
      ...normalizeParams(params),
      size
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _maxLength(maximum, params) {
    const ch = new $ZodCheckMaxLength({
      check: "max_length",
      ...normalizeParams(params),
      maximum
    });
    return ch;
  }
  // @__NO_SIDE_EFFECTS__
  function _minLength(minimum, params) {
    return new $ZodCheckMinLength({
      check: "min_length",
      ...normalizeParams(params),
      minimum
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _length(length, params) {
    return new $ZodCheckLengthEquals({
      check: "length_equals",
      ...normalizeParams(params),
      length
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _regex(pattern, params) {
    return new $ZodCheckRegex({
      check: "string_format",
      format: "regex",
      ...normalizeParams(params),
      pattern
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _lowercase(params) {
    return new $ZodCheckLowerCase({
      check: "string_format",
      format: "lowercase",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uppercase(params) {
    return new $ZodCheckUpperCase({
      check: "string_format",
      format: "uppercase",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _includes(includes, params) {
    return new $ZodCheckIncludes({
      check: "string_format",
      format: "includes",
      ...normalizeParams(params),
      includes
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _startsWith(prefix, params) {
    return new $ZodCheckStartsWith({
      check: "string_format",
      format: "starts_with",
      ...normalizeParams(params),
      prefix
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _endsWith(suffix, params) {
    return new $ZodCheckEndsWith({
      check: "string_format",
      format: "ends_with",
      ...normalizeParams(params),
      suffix
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _property(property, schema, params) {
    return new $ZodCheckProperty({
      check: "property",
      property,
      schema,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _mime(types, params) {
    return new $ZodCheckMimeType({
      check: "mime_type",
      mime: types,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _overwrite(tx) {
    return new $ZodCheckOverwrite({
      check: "overwrite",
      tx
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _normalize(form) {
    return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
  }
  // @__NO_SIDE_EFFECTS__
  function _trim() {
    return /* @__PURE__ */ _overwrite((input) => input.trim());
  }
  // @__NO_SIDE_EFFECTS__
  function _toLowerCase() {
    return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
  }
  // @__NO_SIDE_EFFECTS__
  function _toUpperCase() {
    return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
  }
  // @__NO_SIDE_EFFECTS__
  function _slugify() {
    return /* @__PURE__ */ _overwrite((input) => slugify(input));
  }
  // @__NO_SIDE_EFFECTS__
  function _array(Class2, element, params) {
    return new Class2({
      type: "array",
      element,
      // get element() {
      //   return element;
      // },
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _union(Class2, options, params) {
    return new Class2({
      type: "union",
      options,
      ...normalizeParams(params)
    });
  }
  function _xor(Class2, options, params) {
    return new Class2({
      type: "union",
      options,
      inclusive: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _discriminatedUnion(Class2, discriminator, options, params) {
    return new Class2({
      type: "union",
      options,
      discriminator,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _intersection(Class2, left, right) {
    return new Class2({
      type: "intersection",
      left,
      right
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _tuple(Class2, items, _paramsOrRest, _params) {
    const hasRest = _paramsOrRest instanceof $ZodType;
    const params = hasRest ? _params : _paramsOrRest;
    const rest = hasRest ? _paramsOrRest : null;
    return new Class2({
      type: "tuple",
      items,
      rest,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _record(Class2, keyType, valueType, params) {
    return new Class2({
      type: "record",
      keyType,
      valueType,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _map(Class2, keyType, valueType, params) {
    return new Class2({
      type: "map",
      keyType,
      valueType,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _set(Class2, valueType, params) {
    return new Class2({
      type: "set",
      valueType,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _enum(Class2, values, params) {
    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
    return new Class2({
      type: "enum",
      entries,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _nativeEnum(Class2, entries, params) {
    return new Class2({
      type: "enum",
      entries,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _literal(Class2, value, params) {
    return new Class2({
      type: "literal",
      values: Array.isArray(value) ? value : [value],
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _file(Class2, params) {
    return new Class2({
      type: "file",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _transform(Class2, fn) {
    return new Class2({
      type: "transform",
      transform: fn
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _optional(Class2, innerType) {
    return new Class2({
      type: "optional",
      innerType
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _nullable(Class2, innerType) {
    return new Class2({
      type: "nullable",
      innerType
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _default(Class2, innerType, defaultValue) {
    return new Class2({
      type: "default",
      innerType,
      get defaultValue() {
        return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
      }
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _nonoptional(Class2, innerType, params) {
    return new Class2({
      type: "nonoptional",
      innerType,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _success(Class2, innerType) {
    return new Class2({
      type: "success",
      innerType
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _catch(Class2, innerType, catchValue) {
    return new Class2({
      type: "catch",
      innerType,
      catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _pipe(Class2, in_, out) {
    return new Class2({
      type: "pipe",
      in: in_,
      out
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _readonly(Class2, innerType) {
    return new Class2({
      type: "readonly",
      innerType
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _templateLiteral(Class2, parts, params) {
    return new Class2({
      type: "template_literal",
      parts,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _lazy(Class2, getter) {
    return new Class2({
      type: "lazy",
      getter
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _promise(Class2, innerType) {
    return new Class2({
      type: "promise",
      innerType
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _custom(Class2, fn, _params) {
    const norm = normalizeParams(_params);
    norm.abort ?? (norm.abort = true);
    const schema = new Class2({
      type: "custom",
      check: "custom",
      fn,
      ...norm
    });
    return schema;
  }
  // @__NO_SIDE_EFFECTS__
  function _refine(Class2, fn, _params) {
    const schema = new Class2({
      type: "custom",
      check: "custom",
      fn,
      ...normalizeParams(_params)
    });
    return schema;
  }
  // @__NO_SIDE_EFFECTS__
  function _superRefine(fn) {
    const ch = /* @__PURE__ */ _check((payload) => {
      payload.addIssue = (issue2) => {
        if (typeof issue2 === "string") {
          payload.issues.push(issue(issue2, payload.value, ch._zod.def));
        } else {
          const _issue = issue2;
          if (_issue.fatal)
            _issue.continue = false;
          _issue.code ?? (_issue.code = "custom");
          _issue.input ?? (_issue.input = payload.value);
          _issue.inst ?? (_issue.inst = ch);
          _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
          payload.issues.push(issue(_issue));
        }
      };
      return fn(payload.value, payload);
    });
    return ch;
  }
  // @__NO_SIDE_EFFECTS__
  function _check(fn, params) {
    const ch = new $ZodCheck({
      check: "custom",
      ...normalizeParams(params)
    });
    ch._zod.check = fn;
    return ch;
  }
  // @__NO_SIDE_EFFECTS__
  function describe(description) {
    const ch = new $ZodCheck({ check: "describe" });
    ch._zod.onattach = [
      (inst) => {
        const existing = globalRegistry.get(inst) ?? {};
        globalRegistry.add(inst, { ...existing, description });
      }
    ];
    ch._zod.check = () => {
    };
    return ch;
  }
  // @__NO_SIDE_EFFECTS__
  function meta(metadata) {
    const ch = new $ZodCheck({ check: "meta" });
    ch._zod.onattach = [
      (inst) => {
        const existing = globalRegistry.get(inst) ?? {};
        globalRegistry.add(inst, { ...existing, ...metadata });
      }
    ];
    ch._zod.check = () => {
    };
    return ch;
  }
  // @__NO_SIDE_EFFECTS__
  function _stringbool(Classes, _params) {
    const params = normalizeParams(_params);
    let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
    let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
    if (params.case !== "sensitive") {
      truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
      falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    }
    const truthySet = new Set(truthyArray);
    const falsySet = new Set(falsyArray);
    const _Codec = Classes.Codec ?? $ZodCodec;
    const _Boolean = Classes.Boolean ?? $ZodBoolean;
    const _String = Classes.String ?? $ZodString;
    const stringSchema2 = new _String({ type: "string", error: params.error });
    const booleanSchema2 = new _Boolean({ type: "boolean", error: params.error });
    const codec2 = new _Codec({
      type: "pipe",
      in: stringSchema2,
      out: booleanSchema2,
      transform: ((input, payload) => {
        let data = input;
        if (params.case !== "sensitive")
          data = data.toLowerCase();
        if (truthySet.has(data)) {
          return true;
        } else if (falsySet.has(data)) {
          return false;
        } else {
          payload.issues.push({
            code: "invalid_value",
            expected: "stringbool",
            values: [...truthySet, ...falsySet],
            input: payload.value,
            inst: codec2,
            continue: false
          });
          return {};
        }
      }),
      reverseTransform: ((input, _payload) => {
        if (input === true) {
          return truthyArray[0] || "true";
        } else {
          return falsyArray[0] || "false";
        }
      }),
      error: params.error
    });
    return codec2;
  }
  // @__NO_SIDE_EFFECTS__
  function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
    const params = normalizeParams(_params);
    const def = {
      ...normalizeParams(_params),
      check: "string_format",
      type: "string",
      format,
      fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
      ...params
    };
    if (fnOrRegex instanceof RegExp) {
      def.pattern = fnOrRegex;
    }
    const inst = new Class2(def);
    return inst;
  }

  // node_modules/zod/v4/core/to-json-schema.js
  function initializeContext(params) {
    let target = params?.target ?? "draft-2020-12";
    if (target === "draft-4")
      target = "draft-04";
    if (target === "draft-7")
      target = "draft-07";
    return {
      processors: params.processors ?? {},
      metadataRegistry: params?.metadata ?? globalRegistry,
      target,
      unrepresentable: params?.unrepresentable ?? "throw",
      override: params?.override ?? (() => {
      }),
      io: params?.io ?? "output",
      counter: 0,
      seen: /* @__PURE__ */ new Map(),
      cycles: params?.cycles ?? "ref",
      reused: params?.reused ?? "inline",
      external: params?.external ?? void 0
    };
  }
  function process(schema, ctx, _params = { path: [], schemaPath: [] }) {
    var _a2;
    const def = schema._zod.def;
    const seen = ctx.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
    ctx.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      if (schema._zod.processJSONSchema) {
        schema._zod.processJSONSchema(ctx, result.schema, params);
      } else {
        const _json = result.schema;
        const processor = ctx.processors[def.type];
        if (!processor) {
          throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
        }
        processor(schema, ctx, _json, params);
      }
      const parent = schema._zod.parent;
      if (parent) {
        if (!result.ref)
          result.ref = parent;
        process(parent, ctx, params);
        ctx.seen.get(parent).isParent = true;
      }
    }
    const meta3 = ctx.metadataRegistry.get(schema);
    if (meta3)
      Object.assign(result.schema, meta3);
    if (ctx.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (ctx.io === "input" && result.schema._prefault)
      (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = ctx.seen.get(schema);
    return _result.schema;
  }
  function extractDefs(ctx, schema) {
    const root = ctx.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const idToSchema = /* @__PURE__ */ new Map();
    for (const entry of ctx.seen.entries()) {
      const id2 = ctx.metadataRegistry.get(entry[0])?.id;
      if (id2) {
        const existing = idToSchema.get(id2);
        if (existing && existing !== entry[0]) {
          throw new Error(`Duplicate schema id "${id2}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
        }
        idToSchema.set(id2, entry[0]);
      }
    }
    const makeURI = (entry) => {
      const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
      if (ctx.external) {
        const externalId = ctx.external.registry.get(entry[0])?.id;
        const uriGenerator = ctx.external.uri ?? ((id3) => id3);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id2 = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
        entry[1].defId = id2;
        return { defId: id2, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id2}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (ctx.cycles === "throw") {
      for (const entry of ctx.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      }
    }
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (ctx.external) {
        const ext = ctx.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id2 = ctx.metadataRegistry.get(entry[0])?.id;
      if (id2) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (ctx.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
  }
  function finalize(ctx, schema) {
    const root = ctx.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const flattenRef = (zodSchema) => {
      const seen = ctx.seen.get(zodSchema);
      if (seen.ref === null)
        return;
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref);
        const refSeen = ctx.seen.get(ref);
        const refSchema = refSeen.schema;
        if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
        }
        Object.assign(schema2, _cached);
        const isParentRef = zodSchema._zod.parent === ref;
        if (isParentRef) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (!(key in _cached)) {
              delete schema2[key];
            }
          }
        }
        if (refSchema.$ref && refSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
      const parent = zodSchema._zod.parent;
      if (parent && parent !== ref) {
        flattenRef(parent);
        const parentSeen = ctx.seen.get(parent);
        if (parentSeen?.schema.$ref) {
          schema2.$ref = parentSeen.schema.$ref;
          if (parentSeen.def) {
            for (const key in schema2) {
              if (key === "$ref" || key === "allOf")
                continue;
              if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
                delete schema2[key];
              }
            }
          }
        }
      }
      ctx.override({
        zodSchema,
        jsonSchema: schema2,
        path: seen.path ?? []
      });
    };
    for (const entry of [...ctx.seen.entries()].reverse()) {
      flattenRef(entry[0]);
    }
    const result = {};
    if (ctx.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (ctx.target === "draft-07") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (ctx.target === "draft-04") {
      result.$schema = "http://json-schema.org/draft-04/schema#";
    } else if (ctx.target === "openapi-3.0") {
    } else {
    }
    if (ctx.external?.uri) {
      const id2 = ctx.external.registry.get(schema)?.id;
      if (!id2)
        throw new Error("Schema is missing an `id` property");
      result.$id = ctx.external.uri(id2);
    }
    Object.assign(result, root.def ?? root.schema);
    const defs = ctx.external?.defs ?? {};
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (ctx.external) {
    } else {
      if (Object.keys(defs).length > 0) {
        if (ctx.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      const finalized = JSON.parse(JSON.stringify(result));
      Object.defineProperty(finalized, "~standard", {
        value: {
          ...schema["~standard"],
          jsonSchema: {
            input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
            output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
          }
        },
        enumerable: false,
        writable: false
      });
      return finalized;
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
  function isTransforming(_schema, _ctx) {
    const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
    if (ctx.seen.has(_schema))
      return false;
    ctx.seen.add(_schema);
    const def = _schema._zod.def;
    if (def.type === "transform")
      return true;
    if (def.type === "array")
      return isTransforming(def.element, ctx);
    if (def.type === "set")
      return isTransforming(def.valueType, ctx);
    if (def.type === "lazy")
      return isTransforming(def.getter(), ctx);
    if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
      return isTransforming(def.innerType, ctx);
    }
    if (def.type === "intersection") {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    if (def.type === "record" || def.type === "map") {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    if (def.type === "pipe") {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    if (def.type === "object") {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    if (def.type === "union") {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    if (def.type === "tuple") {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    return false;
  }
  var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
    const ctx = initializeContext({ ...params, processors });
    process(schema, ctx);
    extractDefs(ctx, schema);
    return finalize(ctx, schema);
  };
  var createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
    const { libraryOptions, target } = params ?? {};
    const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
    process(schema, ctx);
    extractDefs(ctx, schema);
    return finalize(ctx, schema);
  };

  // node_modules/zod/v4/core/json-schema-processors.js
  var formatMap = {
    guid: "uuid",
    url: "uri",
    datetime: "date-time",
    json_string: "json-string",
    regex: ""
    // do not set
  };
  var stringProcessor = (schema, ctx, _json, _params) => {
    const json3 = _json;
    json3.type = "string";
    const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
    if (typeof minimum === "number")
      json3.minLength = minimum;
    if (typeof maximum === "number")
      json3.maxLength = maximum;
    if (format) {
      json3.format = formatMap[format] ?? format;
      if (json3.format === "")
        delete json3.format;
      if (format === "time") {
        delete json3.format;
      }
    }
    if (contentEncoding)
      json3.contentEncoding = contentEncoding;
    if (patterns && patterns.size > 0) {
      const regexes = [...patterns];
      if (regexes.length === 1)
        json3.pattern = regexes[0].source;
      else if (regexes.length > 1) {
        json3.allOf = [
          ...regexes.map((regex) => ({
            ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
            pattern: regex.source
          }))
        ];
      }
    }
  };
  var numberProcessor = (schema, ctx, _json, _params) => {
    const json3 = _json;
    const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
    if (typeof format === "string" && format.includes("int"))
      json3.type = "integer";
    else
      json3.type = "number";
    if (typeof exclusiveMinimum === "number") {
      if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
        json3.minimum = exclusiveMinimum;
        json3.exclusiveMinimum = true;
      } else {
        json3.exclusiveMinimum = exclusiveMinimum;
      }
    }
    if (typeof minimum === "number") {
      json3.minimum = minimum;
      if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
        if (exclusiveMinimum >= minimum)
          delete json3.minimum;
        else
          delete json3.exclusiveMinimum;
      }
    }
    if (typeof exclusiveMaximum === "number") {
      if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
        json3.maximum = exclusiveMaximum;
        json3.exclusiveMaximum = true;
      } else {
        json3.exclusiveMaximum = exclusiveMaximum;
      }
    }
    if (typeof maximum === "number") {
      json3.maximum = maximum;
      if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
        if (exclusiveMaximum <= maximum)
          delete json3.maximum;
        else
          delete json3.exclusiveMaximum;
      }
    }
    if (typeof multipleOf === "number")
      json3.multipleOf = multipleOf;
  };
  var booleanProcessor = (_schema, _ctx, json3, _params) => {
    json3.type = "boolean";
  };
  var bigintProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("BigInt cannot be represented in JSON Schema");
    }
  };
  var symbolProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Symbols cannot be represented in JSON Schema");
    }
  };
  var nullProcessor = (_schema, ctx, json3, _params) => {
    if (ctx.target === "openapi-3.0") {
      json3.type = "string";
      json3.nullable = true;
      json3.enum = [null];
    } else {
      json3.type = "null";
    }
  };
  var undefinedProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Undefined cannot be represented in JSON Schema");
    }
  };
  var voidProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Void cannot be represented in JSON Schema");
    }
  };
  var neverProcessor = (_schema, _ctx, json3, _params) => {
    json3.not = {};
  };
  var anyProcessor = (_schema, _ctx, _json, _params) => {
  };
  var unknownProcessor = (_schema, _ctx, _json, _params) => {
  };
  var dateProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Date cannot be represented in JSON Schema");
    }
  };
  var enumProcessor = (schema, _ctx, json3, _params) => {
    const def = schema._zod.def;
    const values = getEnumValues(def.entries);
    if (values.every((v) => typeof v === "number"))
      json3.type = "number";
    if (values.every((v) => typeof v === "string"))
      json3.type = "string";
    json3.enum = values;
  };
  var literalProcessor = (schema, ctx, json3, _params) => {
    const def = schema._zod.def;
    const vals = [];
    for (const val of def.values) {
      if (val === void 0) {
        if (ctx.unrepresentable === "throw") {
          throw new Error("Literal `undefined` cannot be represented in JSON Schema");
        } else {
        }
      } else if (typeof val === "bigint") {
        if (ctx.unrepresentable === "throw") {
          throw new Error("BigInt literals cannot be represented in JSON Schema");
        } else {
          vals.push(Number(val));
        }
      } else {
        vals.push(val);
      }
    }
    if (vals.length === 0) {
    } else if (vals.length === 1) {
      const val = vals[0];
      json3.type = val === null ? "null" : typeof val;
      if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
        json3.enum = [val];
      } else {
        json3.const = val;
      }
    } else {
      if (vals.every((v) => typeof v === "number"))
        json3.type = "number";
      if (vals.every((v) => typeof v === "string"))
        json3.type = "string";
      if (vals.every((v) => typeof v === "boolean"))
        json3.type = "boolean";
      if (vals.every((v) => v === null))
        json3.type = "null";
      json3.enum = vals;
    }
  };
  var nanProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("NaN cannot be represented in JSON Schema");
    }
  };
  var templateLiteralProcessor = (schema, _ctx, json3, _params) => {
    const _json = json3;
    const pattern = schema._zod.pattern;
    if (!pattern)
      throw new Error("Pattern not found in template literal");
    _json.type = "string";
    _json.pattern = pattern.source;
  };
  var fileProcessor = (schema, _ctx, json3, _params) => {
    const _json = json3;
    const file2 = {
      type: "string",
      format: "binary",
      contentEncoding: "binary"
    };
    const { minimum, maximum, mime } = schema._zod.bag;
    if (minimum !== void 0)
      file2.minLength = minimum;
    if (maximum !== void 0)
      file2.maxLength = maximum;
    if (mime) {
      if (mime.length === 1) {
        file2.contentMediaType = mime[0];
        Object.assign(_json, file2);
      } else {
        Object.assign(_json, file2);
        _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
      }
    } else {
      Object.assign(_json, file2);
    }
  };
  var successProcessor = (_schema, _ctx, json3, _params) => {
    json3.type = "boolean";
  };
  var customProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Custom types cannot be represented in JSON Schema");
    }
  };
  var functionProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Function types cannot be represented in JSON Schema");
    }
  };
  var transformProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Transforms cannot be represented in JSON Schema");
    }
  };
  var mapProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Map cannot be represented in JSON Schema");
    }
  };
  var setProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Set cannot be represented in JSON Schema");
    }
  };
  var arrayProcessor = (schema, ctx, _json, params) => {
    const json3 = _json;
    const def = schema._zod.def;
    const { minimum, maximum } = schema._zod.bag;
    if (typeof minimum === "number")
      json3.minItems = minimum;
    if (typeof maximum === "number")
      json3.maxItems = maximum;
    json3.type = "array";
    json3.items = process(def.element, ctx, { ...params, path: [...params.path, "items"] });
  };
  var objectProcessor = (schema, ctx, _json, params) => {
    const json3 = _json;
    const def = schema._zod.def;
    json3.type = "object";
    json3.properties = {};
    const shape = def.shape;
    for (const key in shape) {
      json3.properties[key] = process(shape[key], ctx, {
        ...params,
        path: [...params.path, "properties", key]
      });
    }
    const allKeys = new Set(Object.keys(shape));
    const requiredKeys = new Set([...allKeys].filter((key) => {
      const v = def.shape[key]._zod;
      if (ctx.io === "input") {
        return v.optin === void 0;
      } else {
        return v.optout === void 0;
      }
    }));
    if (requiredKeys.size > 0) {
      json3.required = Array.from(requiredKeys);
    }
    if (def.catchall?._zod.def.type === "never") {
      json3.additionalProperties = false;
    } else if (!def.catchall) {
      if (ctx.io === "output")
        json3.additionalProperties = false;
    } else if (def.catchall) {
      json3.additionalProperties = process(def.catchall, ctx, {
        ...params,
        path: [...params.path, "additionalProperties"]
      });
    }
  };
  var unionProcessor = (schema, ctx, json3, params) => {
    const def = schema._zod.def;
    const isExclusive = def.inclusive === false;
    const options = def.options.map((x, i) => process(x, ctx, {
      ...params,
      path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
    }));
    if (isExclusive) {
      json3.oneOf = options;
    } else {
      json3.anyOf = options;
    }
  };
  var intersectionProcessor = (schema, ctx, json3, params) => {
    const def = schema._zod.def;
    const a = process(def.left, ctx, {
      ...params,
      path: [...params.path, "allOf", 0]
    });
    const b = process(def.right, ctx, {
      ...params,
      path: [...params.path, "allOf", 1]
    });
    const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
    const allOf = [
      ...isSimpleIntersection(a) ? a.allOf : [a],
      ...isSimpleIntersection(b) ? b.allOf : [b]
    ];
    json3.allOf = allOf;
  };
  var tupleProcessor = (schema, ctx, _json, params) => {
    const json3 = _json;
    const def = schema._zod.def;
    json3.type = "array";
    const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
    const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
    const prefixItems = def.items.map((x, i) => process(x, ctx, {
      ...params,
      path: [...params.path, prefixPath, i]
    }));
    const rest = def.rest ? process(def.rest, ctx, {
      ...params,
      path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
    }) : null;
    if (ctx.target === "draft-2020-12") {
      json3.prefixItems = prefixItems;
      if (rest) {
        json3.items = rest;
      }
    } else if (ctx.target === "openapi-3.0") {
      json3.items = {
        anyOf: prefixItems
      };
      if (rest) {
        json3.items.anyOf.push(rest);
      }
      json3.minItems = prefixItems.length;
      if (!rest) {
        json3.maxItems = prefixItems.length;
      }
    } else {
      json3.items = prefixItems;
      if (rest) {
        json3.additionalItems = rest;
      }
    }
    const { minimum, maximum } = schema._zod.bag;
    if (typeof minimum === "number")
      json3.minItems = minimum;
    if (typeof maximum === "number")
      json3.maxItems = maximum;
  };
  var recordProcessor = (schema, ctx, _json, params) => {
    const json3 = _json;
    const def = schema._zod.def;
    json3.type = "object";
    const keyType = def.keyType;
    const keyBag = keyType._zod.bag;
    const patterns = keyBag?.patterns;
    if (def.mode === "loose" && patterns && patterns.size > 0) {
      const valueSchema = process(def.valueType, ctx, {
        ...params,
        path: [...params.path, "patternProperties", "*"]
      });
      json3.patternProperties = {};
      for (const pattern of patterns) {
        json3.patternProperties[pattern.source] = valueSchema;
      }
    } else {
      if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
        json3.propertyNames = process(def.keyType, ctx, {
          ...params,
          path: [...params.path, "propertyNames"]
        });
      }
      json3.additionalProperties = process(def.valueType, ctx, {
        ...params,
        path: [...params.path, "additionalProperties"]
      });
    }
    const keyValues = keyType._zod.values;
    if (keyValues) {
      const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
      if (validKeyValues.length > 0) {
        json3.required = validKeyValues;
      }
    }
  };
  var nullableProcessor = (schema, ctx, json3, params) => {
    const def = schema._zod.def;
    const inner = process(def.innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    if (ctx.target === "openapi-3.0") {
      seen.ref = def.innerType;
      json3.nullable = true;
    } else {
      json3.anyOf = [inner, { type: "null" }];
    }
  };
  var nonoptionalProcessor = (schema, ctx, _json, params) => {
    const def = schema._zod.def;
    process(def.innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = def.innerType;
  };
  var defaultProcessor = (schema, ctx, json3, params) => {
    const def = schema._zod.def;
    process(def.innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = def.innerType;
    json3.default = JSON.parse(JSON.stringify(def.defaultValue));
  };
  var prefaultProcessor = (schema, ctx, json3, params) => {
    const def = schema._zod.def;
    process(def.innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = def.innerType;
    if (ctx.io === "input")
      json3._prefault = JSON.parse(JSON.stringify(def.defaultValue));
  };
  var catchProcessor = (schema, ctx, json3, params) => {
    const def = schema._zod.def;
    process(def.innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = def.innerType;
    let catchValue;
    try {
      catchValue = def.catchValue(void 0);
    } catch {
      throw new Error("Dynamic catch values are not supported in JSON Schema");
    }
    json3.default = catchValue;
  };
  var pipeProcessor = (schema, ctx, _json, params) => {
    const def = schema._zod.def;
    const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
    process(innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = innerType;
  };
  var readonlyProcessor = (schema, ctx, json3, params) => {
    const def = schema._zod.def;
    process(def.innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = def.innerType;
    json3.readOnly = true;
  };
  var promiseProcessor = (schema, ctx, _json, params) => {
    const def = schema._zod.def;
    process(def.innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = def.innerType;
  };
  var optionalProcessor = (schema, ctx, _json, params) => {
    const def = schema._zod.def;
    process(def.innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = def.innerType;
  };
  var lazyProcessor = (schema, ctx, _json, params) => {
    const innerType = schema._zod.innerType;
    process(innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = innerType;
  };
  var allProcessors = {
    string: stringProcessor,
    number: numberProcessor,
    boolean: booleanProcessor,
    bigint: bigintProcessor,
    symbol: symbolProcessor,
    null: nullProcessor,
    undefined: undefinedProcessor,
    void: voidProcessor,
    never: neverProcessor,
    any: anyProcessor,
    unknown: unknownProcessor,
    date: dateProcessor,
    enum: enumProcessor,
    literal: literalProcessor,
    nan: nanProcessor,
    template_literal: templateLiteralProcessor,
    file: fileProcessor,
    success: successProcessor,
    custom: customProcessor,
    function: functionProcessor,
    transform: transformProcessor,
    map: mapProcessor,
    set: setProcessor,
    array: arrayProcessor,
    object: objectProcessor,
    union: unionProcessor,
    intersection: intersectionProcessor,
    tuple: tupleProcessor,
    record: recordProcessor,
    nullable: nullableProcessor,
    nonoptional: nonoptionalProcessor,
    default: defaultProcessor,
    prefault: prefaultProcessor,
    catch: catchProcessor,
    pipe: pipeProcessor,
    readonly: readonlyProcessor,
    promise: promiseProcessor,
    optional: optionalProcessor,
    lazy: lazyProcessor
  };
  function toJSONSchema(input, params) {
    if ("_idmap" in input) {
      const registry2 = input;
      const ctx2 = initializeContext({ ...params, processors: allProcessors });
      const defs = {};
      for (const entry of registry2._idmap.entries()) {
        const [_, schema] = entry;
        process(schema, ctx2);
      }
      const schemas = {};
      const external = {
        registry: registry2,
        uri: params?.uri,
        defs
      };
      ctx2.external = external;
      for (const entry of registry2._idmap.entries()) {
        const [key, schema] = entry;
        extractDefs(ctx2, schema);
        schemas[key] = finalize(ctx2, schema);
      }
      if (Object.keys(defs).length > 0) {
        const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
        schemas.__shared = {
          [defsSegment]: defs
        };
      }
      return { schemas };
    }
    const ctx = initializeContext({ ...params, processors: allProcessors });
    process(input, ctx);
    extractDefs(ctx, input);
    return finalize(ctx, input);
  }

  // node_modules/zod/v4/core/json-schema-generator.js
  var JSONSchemaGenerator = class {
    /** @deprecated Access via ctx instead */
    get metadataRegistry() {
      return this.ctx.metadataRegistry;
    }
    /** @deprecated Access via ctx instead */
    get target() {
      return this.ctx.target;
    }
    /** @deprecated Access via ctx instead */
    get unrepresentable() {
      return this.ctx.unrepresentable;
    }
    /** @deprecated Access via ctx instead */
    get override() {
      return this.ctx.override;
    }
    /** @deprecated Access via ctx instead */
    get io() {
      return this.ctx.io;
    }
    /** @deprecated Access via ctx instead */
    get counter() {
      return this.ctx.counter;
    }
    set counter(value) {
      this.ctx.counter = value;
    }
    /** @deprecated Access via ctx instead */
    get seen() {
      return this.ctx.seen;
    }
    constructor(params) {
      let normalizedTarget = params?.target ?? "draft-2020-12";
      if (normalizedTarget === "draft-4")
        normalizedTarget = "draft-04";
      if (normalizedTarget === "draft-7")
        normalizedTarget = "draft-07";
      this.ctx = initializeContext({
        processors: allProcessors,
        target: normalizedTarget,
        ...params?.metadata && { metadata: params.metadata },
        ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
        ...params?.override && { override: params.override },
        ...params?.io && { io: params.io }
      });
    }
    /**
     * Process a schema to prepare it for JSON Schema generation.
     * This must be called before emit().
     */
    process(schema, _params = { path: [], schemaPath: [] }) {
      return process(schema, this.ctx, _params);
    }
    /**
     * Emit the final JSON Schema after processing.
     * Must call process() first.
     */
    emit(schema, _params) {
      if (_params) {
        if (_params.cycles)
          this.ctx.cycles = _params.cycles;
        if (_params.reused)
          this.ctx.reused = _params.reused;
        if (_params.external)
          this.ctx.external = _params.external;
      }
      extractDefs(this.ctx, schema);
      const result = finalize(this.ctx, schema);
      const { "~standard": _, ...plainResult } = result;
      return plainResult;
    }
  };

  // node_modules/zod/v4/core/json-schema.js
  var json_schema_exports = {};

  // node_modules/zod/v4/classic/schemas.js
  var schemas_exports2 = {};
  __export(schemas_exports2, {
    ZodAny: () => ZodAny,
    ZodArray: () => ZodArray,
    ZodBase64: () => ZodBase64,
    ZodBase64URL: () => ZodBase64URL,
    ZodBigInt: () => ZodBigInt,
    ZodBigIntFormat: () => ZodBigIntFormat,
    ZodBoolean: () => ZodBoolean,
    ZodCIDRv4: () => ZodCIDRv4,
    ZodCIDRv6: () => ZodCIDRv6,
    ZodCUID: () => ZodCUID,
    ZodCUID2: () => ZodCUID2,
    ZodCatch: () => ZodCatch,
    ZodCodec: () => ZodCodec,
    ZodCustom: () => ZodCustom,
    ZodCustomStringFormat: () => ZodCustomStringFormat,
    ZodDate: () => ZodDate,
    ZodDefault: () => ZodDefault,
    ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
    ZodE164: () => ZodE164,
    ZodEmail: () => ZodEmail,
    ZodEmoji: () => ZodEmoji,
    ZodEnum: () => ZodEnum,
    ZodExactOptional: () => ZodExactOptional,
    ZodFile: () => ZodFile,
    ZodFunction: () => ZodFunction,
    ZodGUID: () => ZodGUID,
    ZodIPv4: () => ZodIPv4,
    ZodIPv6: () => ZodIPv6,
    ZodIntersection: () => ZodIntersection,
    ZodJWT: () => ZodJWT,
    ZodKSUID: () => ZodKSUID,
    ZodLazy: () => ZodLazy,
    ZodLiteral: () => ZodLiteral,
    ZodMAC: () => ZodMAC,
    ZodMap: () => ZodMap,
    ZodNaN: () => ZodNaN,
    ZodNanoID: () => ZodNanoID,
    ZodNever: () => ZodNever,
    ZodNonOptional: () => ZodNonOptional,
    ZodNull: () => ZodNull,
    ZodNullable: () => ZodNullable,
    ZodNumber: () => ZodNumber,
    ZodNumberFormat: () => ZodNumberFormat,
    ZodObject: () => ZodObject,
    ZodOptional: () => ZodOptional,
    ZodPipe: () => ZodPipe,
    ZodPrefault: () => ZodPrefault,
    ZodPromise: () => ZodPromise,
    ZodReadonly: () => ZodReadonly,
    ZodRecord: () => ZodRecord,
    ZodSet: () => ZodSet,
    ZodString: () => ZodString,
    ZodStringFormat: () => ZodStringFormat,
    ZodSuccess: () => ZodSuccess,
    ZodSymbol: () => ZodSymbol,
    ZodTemplateLiteral: () => ZodTemplateLiteral,
    ZodTransform: () => ZodTransform,
    ZodTuple: () => ZodTuple,
    ZodType: () => ZodType,
    ZodULID: () => ZodULID,
    ZodURL: () => ZodURL,
    ZodUUID: () => ZodUUID,
    ZodUndefined: () => ZodUndefined,
    ZodUnion: () => ZodUnion,
    ZodUnknown: () => ZodUnknown,
    ZodVoid: () => ZodVoid,
    ZodXID: () => ZodXID,
    ZodXor: () => ZodXor,
    _ZodString: () => _ZodString,
    _default: () => _default2,
    _function: () => _function,
    any: () => any,
    array: () => array,
    base64: () => base642,
    base64url: () => base64url2,
    bigint: () => bigint2,
    boolean: () => boolean2,
    catch: () => _catch2,
    check: () => check,
    cidrv4: () => cidrv42,
    cidrv6: () => cidrv62,
    codec: () => codec,
    cuid: () => cuid3,
    cuid2: () => cuid22,
    custom: () => custom,
    date: () => date3,
    describe: () => describe2,
    discriminatedUnion: () => discriminatedUnion,
    e164: () => e1642,
    email: () => email2,
    emoji: () => emoji2,
    enum: () => _enum2,
    exactOptional: () => exactOptional,
    file: () => file,
    float32: () => float32,
    float64: () => float64,
    function: () => _function,
    guid: () => guid2,
    hash: () => hash,
    hex: () => hex2,
    hostname: () => hostname2,
    httpUrl: () => httpUrl,
    instanceof: () => _instanceof,
    int: () => int,
    int32: () => int32,
    int64: () => int64,
    intersection: () => intersection,
    ipv4: () => ipv42,
    ipv6: () => ipv62,
    json: () => json,
    jwt: () => jwt,
    keyof: () => keyof,
    ksuid: () => ksuid2,
    lazy: () => lazy,
    literal: () => literal,
    looseObject: () => looseObject,
    looseRecord: () => looseRecord,
    mac: () => mac2,
    map: () => map,
    meta: () => meta2,
    nan: () => nan,
    nanoid: () => nanoid2,
    nativeEnum: () => nativeEnum,
    never: () => never,
    nonoptional: () => nonoptional,
    null: () => _null3,
    nullable: () => nullable,
    nullish: () => nullish2,
    number: () => number2,
    object: () => object,
    optional: () => optional,
    partialRecord: () => partialRecord,
    pipe: () => pipe,
    prefault: () => prefault,
    preprocess: () => preprocess,
    promise: () => promise,
    readonly: () => readonly,
    record: () => record,
    refine: () => refine,
    set: () => set,
    strictObject: () => strictObject,
    string: () => string2,
    stringFormat: () => stringFormat,
    stringbool: () => stringbool,
    success: () => success,
    superRefine: () => superRefine,
    symbol: () => symbol,
    templateLiteral: () => templateLiteral,
    transform: () => transform,
    tuple: () => tuple,
    uint32: () => uint32,
    uint64: () => uint64,
    ulid: () => ulid2,
    undefined: () => _undefined3,
    union: () => union,
    unknown: () => unknown,
    url: () => url,
    uuid: () => uuid2,
    uuidv4: () => uuidv4,
    uuidv6: () => uuidv6,
    uuidv7: () => uuidv7,
    void: () => _void2,
    xid: () => xid2,
    xor: () => xor
  });

  // node_modules/zod/v4/classic/checks.js
  var checks_exports2 = {};
  __export(checks_exports2, {
    endsWith: () => _endsWith,
    gt: () => _gt,
    gte: () => _gte,
    includes: () => _includes,
    length: () => _length,
    lowercase: () => _lowercase,
    lt: () => _lt,
    lte: () => _lte,
    maxLength: () => _maxLength,
    maxSize: () => _maxSize,
    mime: () => _mime,
    minLength: () => _minLength,
    minSize: () => _minSize,
    multipleOf: () => _multipleOf,
    negative: () => _negative,
    nonnegative: () => _nonnegative,
    nonpositive: () => _nonpositive,
    normalize: () => _normalize,
    overwrite: () => _overwrite,
    positive: () => _positive,
    property: () => _property,
    regex: () => _regex,
    size: () => _size,
    slugify: () => _slugify,
    startsWith: () => _startsWith,
    toLowerCase: () => _toLowerCase,
    toUpperCase: () => _toUpperCase,
    trim: () => _trim,
    uppercase: () => _uppercase
  });

  // node_modules/zod/v4/classic/iso.js
  var iso_exports = {};
  __export(iso_exports, {
    ZodISODate: () => ZodISODate,
    ZodISODateTime: () => ZodISODateTime,
    ZodISODuration: () => ZodISODuration,
    ZodISOTime: () => ZodISOTime,
    date: () => date2,
    datetime: () => datetime2,
    duration: () => duration2,
    time: () => time2
  });
  var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
    $ZodISODateTime.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function datetime2(params) {
    return _isoDateTime(ZodISODateTime, params);
  }
  var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
    $ZodISODate.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function date2(params) {
    return _isoDate(ZodISODate, params);
  }
  var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
    $ZodISOTime.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function time2(params) {
    return _isoTime(ZodISOTime, params);
  }
  var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
    $ZodISODuration.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function duration2(params) {
    return _isoDuration(ZodISODuration, params);
  }

  // node_modules/zod/v4/classic/errors.js
  var initializer2 = (inst, issues) => {
    $ZodError.init(inst, issues);
    inst.name = "ZodError";
    Object.defineProperties(inst, {
      format: {
        value: (mapper) => formatError(inst, mapper)
        // enumerable: false,
      },
      flatten: {
        value: (mapper) => flattenError(inst, mapper)
        // enumerable: false,
      },
      addIssue: {
        value: (issue2) => {
          inst.issues.push(issue2);
          inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
        }
        // enumerable: false,
      },
      addIssues: {
        value: (issues2) => {
          inst.issues.push(...issues2);
          inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
        }
        // enumerable: false,
      },
      isEmpty: {
        get() {
          return inst.issues.length === 0;
        }
        // enumerable: false,
      }
    });
  };
  var ZodError = $constructor("ZodError", initializer2);
  var ZodRealError = $constructor("ZodError", initializer2, {
    Parent: Error
  });

  // node_modules/zod/v4/classic/parse.js
  var parse2 = /* @__PURE__ */ _parse(ZodRealError);
  var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
  var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
  var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
  var encode2 = /* @__PURE__ */ _encode(ZodRealError);
  var decode2 = /* @__PURE__ */ _decode(ZodRealError);
  var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
  var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
  var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
  var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
  var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
  var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

  // node_modules/zod/v4/classic/schemas.js
  var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
    $ZodType.init(inst, def);
    Object.assign(inst["~standard"], {
      jsonSchema: {
        input: createStandardJSONSchemaMethod(inst, "input"),
        output: createStandardJSONSchemaMethod(inst, "output")
      }
    });
    inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
    inst.def = def;
    inst.type = def.type;
    Object.defineProperty(inst, "_def", { value: def });
    inst.check = (...checks) => {
      return inst.clone(util_exports.mergeDefs(def, {
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }), {
        parent: true
      });
    };
    inst.with = inst.check;
    inst.clone = (def2, params) => clone(inst, def2, params);
    inst.brand = () => inst;
    inst.register = ((reg, meta3) => {
      reg.add(inst, meta3);
      return inst;
    });
    inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
    inst.safeParse = (data, params) => safeParse2(inst, data, params);
    inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
    inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
    inst.spa = inst.safeParseAsync;
    inst.encode = (data, params) => encode2(inst, data, params);
    inst.decode = (data, params) => decode2(inst, data, params);
    inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
    inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
    inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
    inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
    inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
    inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
    inst.refine = (check2, params) => inst.check(refine(check2, params));
    inst.superRefine = (refinement) => inst.check(superRefine(refinement));
    inst.overwrite = (fn) => inst.check(_overwrite(fn));
    inst.optional = () => optional(inst);
    inst.exactOptional = () => exactOptional(inst);
    inst.nullable = () => nullable(inst);
    inst.nullish = () => optional(nullable(inst));
    inst.nonoptional = (params) => nonoptional(inst, params);
    inst.array = () => array(inst);
    inst.or = (arg) => union([inst, arg]);
    inst.and = (arg) => intersection(inst, arg);
    inst.transform = (tx) => pipe(inst, transform(tx));
    inst.default = (def2) => _default2(inst, def2);
    inst.prefault = (def2) => prefault(inst, def2);
    inst.catch = (params) => _catch2(inst, params);
    inst.pipe = (target) => pipe(inst, target);
    inst.readonly = () => readonly(inst);
    inst.describe = (description) => {
      const cl = inst.clone();
      globalRegistry.add(cl, { description });
      return cl;
    };
    Object.defineProperty(inst, "description", {
      get() {
        return globalRegistry.get(inst)?.description;
      },
      configurable: true
    });
    inst.meta = (...args) => {
      if (args.length === 0) {
        return globalRegistry.get(inst);
      }
      const cl = inst.clone();
      globalRegistry.add(cl, args[0]);
      return cl;
    };
    inst.isOptional = () => inst.safeParse(void 0).success;
    inst.isNullable = () => inst.safeParse(null).success;
    inst.apply = (fn) => fn(inst);
    return inst;
  });
  var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
    $ZodString.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => stringProcessor(inst, ctx, json3, params);
    const bag = inst._zod.bag;
    inst.format = bag.format ?? null;
    inst.minLength = bag.minimum ?? null;
    inst.maxLength = bag.maximum ?? null;
    inst.regex = (...args) => inst.check(_regex(...args));
    inst.includes = (...args) => inst.check(_includes(...args));
    inst.startsWith = (...args) => inst.check(_startsWith(...args));
    inst.endsWith = (...args) => inst.check(_endsWith(...args));
    inst.min = (...args) => inst.check(_minLength(...args));
    inst.max = (...args) => inst.check(_maxLength(...args));
    inst.length = (...args) => inst.check(_length(...args));
    inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
    inst.lowercase = (params) => inst.check(_lowercase(params));
    inst.uppercase = (params) => inst.check(_uppercase(params));
    inst.trim = () => inst.check(_trim());
    inst.normalize = (...args) => inst.check(_normalize(...args));
    inst.toLowerCase = () => inst.check(_toLowerCase());
    inst.toUpperCase = () => inst.check(_toUpperCase());
    inst.slugify = () => inst.check(_slugify());
  });
  var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
    $ZodString.init(inst, def);
    _ZodString.init(inst, def);
    inst.email = (params) => inst.check(_email(ZodEmail, params));
    inst.url = (params) => inst.check(_url(ZodURL, params));
    inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
    inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
    inst.guid = (params) => inst.check(_guid(ZodGUID, params));
    inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
    inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
    inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
    inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
    inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
    inst.guid = (params) => inst.check(_guid(ZodGUID, params));
    inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
    inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
    inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
    inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
    inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
    inst.xid = (params) => inst.check(_xid(ZodXID, params));
    inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
    inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
    inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
    inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
    inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
    inst.e164 = (params) => inst.check(_e164(ZodE164, params));
    inst.datetime = (params) => inst.check(datetime2(params));
    inst.date = (params) => inst.check(date2(params));
    inst.time = (params) => inst.check(time2(params));
    inst.duration = (params) => inst.check(duration2(params));
  });
  function string2(params) {
    return _string(ZodString, params);
  }
  var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    _ZodString.init(inst, def);
  });
  var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
    $ZodEmail.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function email2(params) {
    return _email(ZodEmail, params);
  }
  var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
    $ZodGUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function guid2(params) {
    return _guid(ZodGUID, params);
  }
  var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
    $ZodUUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function uuid2(params) {
    return _uuid(ZodUUID, params);
  }
  function uuidv4(params) {
    return _uuidv4(ZodUUID, params);
  }
  function uuidv6(params) {
    return _uuidv6(ZodUUID, params);
  }
  function uuidv7(params) {
    return _uuidv7(ZodUUID, params);
  }
  var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
    $ZodURL.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function url(params) {
    return _url(ZodURL, params);
  }
  function httpUrl(params) {
    return _url(ZodURL, {
      protocol: /^https?$/,
      hostname: regexes_exports.domain,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
    $ZodEmoji.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function emoji2(params) {
    return _emoji2(ZodEmoji, params);
  }
  var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
    $ZodNanoID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function nanoid2(params) {
    return _nanoid(ZodNanoID, params);
  }
  var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
    $ZodCUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function cuid3(params) {
    return _cuid(ZodCUID, params);
  }
  var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
    $ZodCUID2.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function cuid22(params) {
    return _cuid2(ZodCUID2, params);
  }
  var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
    $ZodULID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function ulid2(params) {
    return _ulid(ZodULID, params);
  }
  var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
    $ZodXID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function xid2(params) {
    return _xid(ZodXID, params);
  }
  var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
    $ZodKSUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function ksuid2(params) {
    return _ksuid(ZodKSUID, params);
  }
  var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
    $ZodIPv4.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function ipv42(params) {
    return _ipv4(ZodIPv4, params);
  }
  var ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
    $ZodMAC.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function mac2(params) {
    return _mac(ZodMAC, params);
  }
  var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
    $ZodIPv6.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function ipv62(params) {
    return _ipv6(ZodIPv6, params);
  }
  var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
    $ZodCIDRv4.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function cidrv42(params) {
    return _cidrv4(ZodCIDRv4, params);
  }
  var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
    $ZodCIDRv6.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function cidrv62(params) {
    return _cidrv6(ZodCIDRv6, params);
  }
  var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
    $ZodBase64.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function base642(params) {
    return _base64(ZodBase64, params);
  }
  var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
    $ZodBase64URL.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function base64url2(params) {
    return _base64url(ZodBase64URL, params);
  }
  var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
    $ZodE164.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function e1642(params) {
    return _e164(ZodE164, params);
  }
  var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
    $ZodJWT.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function jwt(params) {
    return _jwt(ZodJWT, params);
  }
  var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
    $ZodCustomStringFormat.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function stringFormat(format, fnOrRegex, _params = {}) {
    return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
  }
  function hostname2(_params) {
    return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
  }
  function hex2(_params) {
    return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
  }
  function hash(alg, params) {
    const enc = params?.enc ?? "hex";
    const format = `${alg}_${enc}`;
    const regex = regexes_exports[format];
    if (!regex)
      throw new Error(`Unrecognized hash format: ${format}`);
    return _stringFormat(ZodCustomStringFormat, format, regex, params);
  }
  var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
    $ZodNumber.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => numberProcessor(inst, ctx, json3, params);
    inst.gt = (value, params) => inst.check(_gt(value, params));
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.lt = (value, params) => inst.check(_lt(value, params));
    inst.lte = (value, params) => inst.check(_lte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    inst.int = (params) => inst.check(int(params));
    inst.safe = (params) => inst.check(int(params));
    inst.positive = (params) => inst.check(_gt(0, params));
    inst.nonnegative = (params) => inst.check(_gte(0, params));
    inst.negative = (params) => inst.check(_lt(0, params));
    inst.nonpositive = (params) => inst.check(_lte(0, params));
    inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
    inst.step = (value, params) => inst.check(_multipleOf(value, params));
    inst.finite = () => inst;
    const bag = inst._zod.bag;
    inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
    inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
    inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
    inst.isFinite = true;
    inst.format = bag.format ?? null;
  });
  function number2(params) {
    return _number(ZodNumber, params);
  }
  var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
    $ZodNumberFormat.init(inst, def);
    ZodNumber.init(inst, def);
  });
  function int(params) {
    return _int(ZodNumberFormat, params);
  }
  function float32(params) {
    return _float32(ZodNumberFormat, params);
  }
  function float64(params) {
    return _float64(ZodNumberFormat, params);
  }
  function int32(params) {
    return _int32(ZodNumberFormat, params);
  }
  function uint32(params) {
    return _uint32(ZodNumberFormat, params);
  }
  var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
    $ZodBoolean.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => booleanProcessor(inst, ctx, json3, params);
  });
  function boolean2(params) {
    return _boolean(ZodBoolean, params);
  }
  var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
    $ZodBigInt.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => bigintProcessor(inst, ctx, json3, params);
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.gt = (value, params) => inst.check(_gt(value, params));
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.lt = (value, params) => inst.check(_lt(value, params));
    inst.lte = (value, params) => inst.check(_lte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    inst.positive = (params) => inst.check(_gt(BigInt(0), params));
    inst.negative = (params) => inst.check(_lt(BigInt(0), params));
    inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
    inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
    inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
    const bag = inst._zod.bag;
    inst.minValue = bag.minimum ?? null;
    inst.maxValue = bag.maximum ?? null;
    inst.format = bag.format ?? null;
  });
  function bigint2(params) {
    return _bigint(ZodBigInt, params);
  }
  var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
    $ZodBigIntFormat.init(inst, def);
    ZodBigInt.init(inst, def);
  });
  function int64(params) {
    return _int64(ZodBigIntFormat, params);
  }
  function uint64(params) {
    return _uint64(ZodBigIntFormat, params);
  }
  var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
    $ZodSymbol.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => symbolProcessor(inst, ctx, json3, params);
  });
  function symbol(params) {
    return _symbol(ZodSymbol, params);
  }
  var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
    $ZodUndefined.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => undefinedProcessor(inst, ctx, json3, params);
  });
  function _undefined3(params) {
    return _undefined2(ZodUndefined, params);
  }
  var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
    $ZodNull.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => nullProcessor(inst, ctx, json3, params);
  });
  function _null3(params) {
    return _null2(ZodNull, params);
  }
  var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
    $ZodAny.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => anyProcessor(inst, ctx, json3, params);
  });
  function any() {
    return _any(ZodAny);
  }
  var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
    $ZodUnknown.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => unknownProcessor(inst, ctx, json3, params);
  });
  function unknown() {
    return _unknown(ZodUnknown);
  }
  var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
    $ZodNever.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => neverProcessor(inst, ctx, json3, params);
  });
  function never(params) {
    return _never(ZodNever, params);
  }
  var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
    $ZodVoid.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => voidProcessor(inst, ctx, json3, params);
  });
  function _void2(params) {
    return _void(ZodVoid, params);
  }
  var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
    $ZodDate.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => dateProcessor(inst, ctx, json3, params);
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    const c = inst._zod.bag;
    inst.minDate = c.minimum ? new Date(c.minimum) : null;
    inst.maxDate = c.maximum ? new Date(c.maximum) : null;
  });
  function date3(params) {
    return _date(ZodDate, params);
  }
  var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
    $ZodArray.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => arrayProcessor(inst, ctx, json3, params);
    inst.element = def.element;
    inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
    inst.nonempty = (params) => inst.check(_minLength(1, params));
    inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
    inst.length = (len, params) => inst.check(_length(len, params));
    inst.unwrap = () => inst.element;
  });
  function array(element, params) {
    return _array(ZodArray, element, params);
  }
  function keyof(schema) {
    const shape = schema._zod.def.shape;
    return _enum2(Object.keys(shape));
  }
  var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
    $ZodObjectJIT.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => objectProcessor(inst, ctx, json3, params);
    util_exports.defineLazy(inst, "shape", () => {
      return def.shape;
    });
    inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
    inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
    inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
    inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
    inst.extend = (incoming) => {
      return util_exports.extend(inst, incoming);
    };
    inst.safeExtend = (incoming) => {
      return util_exports.safeExtend(inst, incoming);
    };
    inst.merge = (other) => util_exports.merge(inst, other);
    inst.pick = (mask) => util_exports.pick(inst, mask);
    inst.omit = (mask) => util_exports.omit(inst, mask);
    inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
    inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
  });
  function object(shape, params) {
    const def = {
      type: "object",
      shape: shape ?? {},
      ...util_exports.normalizeParams(params)
    };
    return new ZodObject(def);
  }
  function strictObject(shape, params) {
    return new ZodObject({
      type: "object",
      shape,
      catchall: never(),
      ...util_exports.normalizeParams(params)
    });
  }
  function looseObject(shape, params) {
    return new ZodObject({
      type: "object",
      shape,
      catchall: unknown(),
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
    $ZodUnion.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => unionProcessor(inst, ctx, json3, params);
    inst.options = def.options;
  });
  function union(options, params) {
    return new ZodUnion({
      type: "union",
      options,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
    ZodUnion.init(inst, def);
    $ZodXor.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => unionProcessor(inst, ctx, json3, params);
    inst.options = def.options;
  });
  function xor(options, params) {
    return new ZodXor({
      type: "union",
      options,
      inclusive: false,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
    ZodUnion.init(inst, def);
    $ZodDiscriminatedUnion.init(inst, def);
  });
  function discriminatedUnion(discriminator, options, params) {
    return new ZodDiscriminatedUnion({
      type: "union",
      options,
      discriminator,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
    $ZodIntersection.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => intersectionProcessor(inst, ctx, json3, params);
  });
  function intersection(left, right) {
    return new ZodIntersection({
      type: "intersection",
      left,
      right
    });
  }
  var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
    $ZodTuple.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => tupleProcessor(inst, ctx, json3, params);
    inst.rest = (rest) => inst.clone({
      ...inst._zod.def,
      rest
    });
  });
  function tuple(items, _paramsOrRest, _params) {
    const hasRest = _paramsOrRest instanceof $ZodType;
    const params = hasRest ? _params : _paramsOrRest;
    const rest = hasRest ? _paramsOrRest : null;
    return new ZodTuple({
      type: "tuple",
      items,
      rest,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
    $ZodRecord.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => recordProcessor(inst, ctx, json3, params);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
  });
  function record(keyType, valueType, params) {
    return new ZodRecord({
      type: "record",
      keyType,
      valueType,
      ...util_exports.normalizeParams(params)
    });
  }
  function partialRecord(keyType, valueType, params) {
    const k = clone(keyType);
    k._zod.values = void 0;
    return new ZodRecord({
      type: "record",
      keyType: k,
      valueType,
      ...util_exports.normalizeParams(params)
    });
  }
  function looseRecord(keyType, valueType, params) {
    return new ZodRecord({
      type: "record",
      keyType,
      valueType,
      mode: "loose",
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
    $ZodMap.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => mapProcessor(inst, ctx, json3, params);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
    inst.min = (...args) => inst.check(_minSize(...args));
    inst.nonempty = (params) => inst.check(_minSize(1, params));
    inst.max = (...args) => inst.check(_maxSize(...args));
    inst.size = (...args) => inst.check(_size(...args));
  });
  function map(keyType, valueType, params) {
    return new ZodMap({
      type: "map",
      keyType,
      valueType,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
    $ZodSet.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => setProcessor(inst, ctx, json3, params);
    inst.min = (...args) => inst.check(_minSize(...args));
    inst.nonempty = (params) => inst.check(_minSize(1, params));
    inst.max = (...args) => inst.check(_maxSize(...args));
    inst.size = (...args) => inst.check(_size(...args));
  });
  function set(valueType, params) {
    return new ZodSet({
      type: "set",
      valueType,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
    $ZodEnum.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => enumProcessor(inst, ctx, json3, params);
    inst.enum = def.entries;
    inst.options = Object.values(def.entries);
    const keys = new Set(Object.keys(def.entries));
    inst.extract = (values, params) => {
      const newEntries = {};
      for (const value of values) {
        if (keys.has(value)) {
          newEntries[value] = def.entries[value];
        } else
          throw new Error(`Key ${value} not found in enum`);
      }
      return new ZodEnum({
        ...def,
        checks: [],
        ...util_exports.normalizeParams(params),
        entries: newEntries
      });
    };
    inst.exclude = (values, params) => {
      const newEntries = { ...def.entries };
      for (const value of values) {
        if (keys.has(value)) {
          delete newEntries[value];
        } else
          throw new Error(`Key ${value} not found in enum`);
      }
      return new ZodEnum({
        ...def,
        checks: [],
        ...util_exports.normalizeParams(params),
        entries: newEntries
      });
    };
  });
  function _enum2(values, params) {
    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
    return new ZodEnum({
      type: "enum",
      entries,
      ...util_exports.normalizeParams(params)
    });
  }
  function nativeEnum(entries, params) {
    return new ZodEnum({
      type: "enum",
      entries,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
    $ZodLiteral.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => literalProcessor(inst, ctx, json3, params);
    inst.values = new Set(def.values);
    Object.defineProperty(inst, "value", {
      get() {
        if (def.values.length > 1) {
          throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
        }
        return def.values[0];
      }
    });
  });
  function literal(value, params) {
    return new ZodLiteral({
      type: "literal",
      values: Array.isArray(value) ? value : [value],
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
    $ZodFile.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => fileProcessor(inst, ctx, json3, params);
    inst.min = (size, params) => inst.check(_minSize(size, params));
    inst.max = (size, params) => inst.check(_maxSize(size, params));
    inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
  });
  function file(params) {
    return _file(ZodFile, params);
  }
  var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
    $ZodTransform.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => transformProcessor(inst, ctx, json3, params);
    inst._zod.parse = (payload, _ctx) => {
      if (_ctx.direction === "backward") {
        throw new $ZodEncodeError(inst.constructor.name);
      }
      payload.addIssue = (issue2) => {
        if (typeof issue2 === "string") {
          payload.issues.push(util_exports.issue(issue2, payload.value, def));
        } else {
          const _issue = issue2;
          if (_issue.fatal)
            _issue.continue = false;
          _issue.code ?? (_issue.code = "custom");
          _issue.input ?? (_issue.input = payload.value);
          _issue.inst ?? (_issue.inst = inst);
          payload.issues.push(util_exports.issue(_issue));
        }
      };
      const output = def.transform(payload.value, payload);
      if (output instanceof Promise) {
        return output.then((output2) => {
          payload.value = output2;
          return payload;
        });
      }
      payload.value = output;
      return payload;
    };
  });
  function transform(fn) {
    return new ZodTransform({
      type: "transform",
      transform: fn
    });
  }
  var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
    $ZodOptional.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => optionalProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function optional(innerType) {
    return new ZodOptional({
      type: "optional",
      innerType
    });
  }
  var ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
    $ZodExactOptional.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => optionalProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function exactOptional(innerType) {
    return new ZodExactOptional({
      type: "optional",
      innerType
    });
  }
  var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
    $ZodNullable.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => nullableProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function nullable(innerType) {
    return new ZodNullable({
      type: "nullable",
      innerType
    });
  }
  function nullish2(innerType) {
    return optional(nullable(innerType));
  }
  var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
    $ZodDefault.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => defaultProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeDefault = inst.unwrap;
  });
  function _default2(innerType, defaultValue) {
    return new ZodDefault({
      type: "default",
      innerType,
      get defaultValue() {
        return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
      }
    });
  }
  var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
    $ZodPrefault.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => prefaultProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function prefault(innerType, defaultValue) {
    return new ZodPrefault({
      type: "prefault",
      innerType,
      get defaultValue() {
        return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
      }
    });
  }
  var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
    $ZodNonOptional.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => nonoptionalProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function nonoptional(innerType, params) {
    return new ZodNonOptional({
      type: "nonoptional",
      innerType,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
    $ZodSuccess.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => successProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function success(innerType) {
    return new ZodSuccess({
      type: "success",
      innerType
    });
  }
  var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
    $ZodCatch.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => catchProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeCatch = inst.unwrap;
  });
  function _catch2(innerType, catchValue) {
    return new ZodCatch({
      type: "catch",
      innerType,
      catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
    });
  }
  var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
    $ZodNaN.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => nanProcessor(inst, ctx, json3, params);
  });
  function nan(params) {
    return _nan(ZodNaN, params);
  }
  var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
    $ZodPipe.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => pipeProcessor(inst, ctx, json3, params);
    inst.in = def.in;
    inst.out = def.out;
  });
  function pipe(in_, out) {
    return new ZodPipe({
      type: "pipe",
      in: in_,
      out
      // ...util.normalizeParams(params),
    });
  }
  var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
    ZodPipe.init(inst, def);
    $ZodCodec.init(inst, def);
  });
  function codec(in_, out, params) {
    return new ZodCodec({
      type: "pipe",
      in: in_,
      out,
      transform: params.decode,
      reverseTransform: params.encode
    });
  }
  var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
    $ZodReadonly.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => readonlyProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function readonly(innerType) {
    return new ZodReadonly({
      type: "readonly",
      innerType
    });
  }
  var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
    $ZodTemplateLiteral.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => templateLiteralProcessor(inst, ctx, json3, params);
  });
  function templateLiteral(parts, params) {
    return new ZodTemplateLiteral({
      type: "template_literal",
      parts,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
    $ZodLazy.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => lazyProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.getter();
  });
  function lazy(getter) {
    return new ZodLazy({
      type: "lazy",
      getter
    });
  }
  var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
    $ZodPromise.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => promiseProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function promise(innerType) {
    return new ZodPromise({
      type: "promise",
      innerType
    });
  }
  var ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
    $ZodFunction.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => functionProcessor(inst, ctx, json3, params);
  });
  function _function(params) {
    return new ZodFunction({
      type: "function",
      input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
      output: params?.output ?? unknown()
    });
  }
  var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
    $ZodCustom.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => customProcessor(inst, ctx, json3, params);
  });
  function check(fn) {
    const ch = new $ZodCheck({
      check: "custom"
      // ...util.normalizeParams(params),
    });
    ch._zod.check = fn;
    return ch;
  }
  function custom(fn, _params) {
    return _custom(ZodCustom, fn ?? (() => true), _params);
  }
  function refine(fn, _params = {}) {
    return _refine(ZodCustom, fn, _params);
  }
  function superRefine(fn) {
    return _superRefine(fn);
  }
  var describe2 = describe;
  var meta2 = meta;
  function _instanceof(cls, params = {}) {
    const inst = new ZodCustom({
      type: "custom",
      check: "custom",
      fn: (data) => data instanceof cls,
      abort: true,
      ...util_exports.normalizeParams(params)
    });
    inst._zod.bag.Class = cls;
    inst._zod.check = (payload) => {
      if (!(payload.value instanceof cls)) {
        payload.issues.push({
          code: "invalid_type",
          expected: cls.name,
          input: payload.value,
          inst,
          path: [...inst._zod.def.path ?? []]
        });
      }
    };
    return inst;
  }
  var stringbool = (...args) => _stringbool({
    Codec: ZodCodec,
    Boolean: ZodBoolean,
    String: ZodString
  }, ...args);
  function json(params) {
    const jsonSchema = lazy(() => {
      return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
    });
    return jsonSchema;
  }
  function preprocess(fn, schema) {
    return pipe(transform(fn), schema);
  }

  // node_modules/zod/v4/classic/compat.js
  var ZodIssueCode = {
    invalid_type: "invalid_type",
    too_big: "too_big",
    too_small: "too_small",
    invalid_format: "invalid_format",
    not_multiple_of: "not_multiple_of",
    unrecognized_keys: "unrecognized_keys",
    invalid_union: "invalid_union",
    invalid_key: "invalid_key",
    invalid_element: "invalid_element",
    invalid_value: "invalid_value",
    custom: "custom"
  };
  function setErrorMap(map2) {
    config({
      customError: map2
    });
  }
  function getErrorMap() {
    return config().customError;
  }
  var ZodFirstPartyTypeKind;
  /* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

  // node_modules/zod/v4/classic/from-json-schema.js
  var z = {
    ...schemas_exports2,
    ...checks_exports2,
    iso: iso_exports
  };
  var RECOGNIZED_KEYS = /* @__PURE__ */ new Set([
    // Schema identification
    "$schema",
    "$ref",
    "$defs",
    "definitions",
    // Core schema keywords
    "$id",
    "id",
    "$comment",
    "$anchor",
    "$vocabulary",
    "$dynamicRef",
    "$dynamicAnchor",
    // Type
    "type",
    "enum",
    "const",
    // Composition
    "anyOf",
    "oneOf",
    "allOf",
    "not",
    // Object
    "properties",
    "required",
    "additionalProperties",
    "patternProperties",
    "propertyNames",
    "minProperties",
    "maxProperties",
    // Array
    "items",
    "prefixItems",
    "additionalItems",
    "minItems",
    "maxItems",
    "uniqueItems",
    "contains",
    "minContains",
    "maxContains",
    // String
    "minLength",
    "maxLength",
    "pattern",
    "format",
    // Number
    "minimum",
    "maximum",
    "exclusiveMinimum",
    "exclusiveMaximum",
    "multipleOf",
    // Already handled metadata
    "description",
    "default",
    // Content
    "contentEncoding",
    "contentMediaType",
    "contentSchema",
    // Unsupported (error-throwing)
    "unevaluatedItems",
    "unevaluatedProperties",
    "if",
    "then",
    "else",
    "dependentSchemas",
    "dependentRequired",
    // OpenAPI
    "nullable",
    "readOnly"
  ]);
  function detectVersion(schema, defaultTarget) {
    const $schema = schema.$schema;
    if ($schema === "https://json-schema.org/draft/2020-12/schema") {
      return "draft-2020-12";
    }
    if ($schema === "http://json-schema.org/draft-07/schema#") {
      return "draft-7";
    }
    if ($schema === "http://json-schema.org/draft-04/schema#") {
      return "draft-4";
    }
    return defaultTarget ?? "draft-2020-12";
  }
  function resolveRef(ref, ctx) {
    if (!ref.startsWith("#")) {
      throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
    }
    const path = ref.slice(1).split("/").filter(Boolean);
    if (path.length === 0) {
      return ctx.rootSchema;
    }
    const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
    if (path[0] === defsKey) {
      const key = path[1];
      if (!key || !ctx.defs[key]) {
        throw new Error(`Reference not found: ${ref}`);
      }
      return ctx.defs[key];
    }
    throw new Error(`Reference not found: ${ref}`);
  }
  function convertBaseSchema(schema, ctx) {
    if (schema.not !== void 0) {
      if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
        return z.never();
      }
      throw new Error("not is not supported in Zod (except { not: {} } for never)");
    }
    if (schema.unevaluatedItems !== void 0) {
      throw new Error("unevaluatedItems is not supported");
    }
    if (schema.unevaluatedProperties !== void 0) {
      throw new Error("unevaluatedProperties is not supported");
    }
    if (schema.if !== void 0 || schema.then !== void 0 || schema.else !== void 0) {
      throw new Error("Conditional schemas (if/then/else) are not supported");
    }
    if (schema.dependentSchemas !== void 0 || schema.dependentRequired !== void 0) {
      throw new Error("dependentSchemas and dependentRequired are not supported");
    }
    if (schema.$ref) {
      const refPath = schema.$ref;
      if (ctx.refs.has(refPath)) {
        return ctx.refs.get(refPath);
      }
      if (ctx.processing.has(refPath)) {
        return z.lazy(() => {
          if (!ctx.refs.has(refPath)) {
            throw new Error(`Circular reference not resolved: ${refPath}`);
          }
          return ctx.refs.get(refPath);
        });
      }
      ctx.processing.add(refPath);
      const resolved = resolveRef(refPath, ctx);
      const zodSchema2 = convertSchema(resolved, ctx);
      ctx.refs.set(refPath, zodSchema2);
      ctx.processing.delete(refPath);
      return zodSchema2;
    }
    if (schema.enum !== void 0) {
      const enumValues = schema.enum;
      if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
        return z.null();
      }
      if (enumValues.length === 0) {
        return z.never();
      }
      if (enumValues.length === 1) {
        return z.literal(enumValues[0]);
      }
      if (enumValues.every((v) => typeof v === "string")) {
        return z.enum(enumValues);
      }
      const literalSchemas = enumValues.map((v) => z.literal(v));
      if (literalSchemas.length < 2) {
        return literalSchemas[0];
      }
      return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
    }
    if (schema.const !== void 0) {
      return z.literal(schema.const);
    }
    const type = schema.type;
    if (Array.isArray(type)) {
      const typeSchemas = type.map((t) => {
        const typeSchema = { ...schema, type: t };
        return convertBaseSchema(typeSchema, ctx);
      });
      if (typeSchemas.length === 0) {
        return z.never();
      }
      if (typeSchemas.length === 1) {
        return typeSchemas[0];
      }
      return z.union(typeSchemas);
    }
    if (!type) {
      return z.any();
    }
    let zodSchema;
    switch (type) {
      case "string": {
        let stringSchema2 = z.string();
        if (schema.format) {
          const format = schema.format;
          if (format === "email") {
            stringSchema2 = stringSchema2.check(z.email());
          } else if (format === "uri" || format === "uri-reference") {
            stringSchema2 = stringSchema2.check(z.url());
          } else if (format === "uuid" || format === "guid") {
            stringSchema2 = stringSchema2.check(z.uuid());
          } else if (format === "date-time") {
            stringSchema2 = stringSchema2.check(z.iso.datetime());
          } else if (format === "date") {
            stringSchema2 = stringSchema2.check(z.iso.date());
          } else if (format === "time") {
            stringSchema2 = stringSchema2.check(z.iso.time());
          } else if (format === "duration") {
            stringSchema2 = stringSchema2.check(z.iso.duration());
          } else if (format === "ipv4") {
            stringSchema2 = stringSchema2.check(z.ipv4());
          } else if (format === "ipv6") {
            stringSchema2 = stringSchema2.check(z.ipv6());
          } else if (format === "mac") {
            stringSchema2 = stringSchema2.check(z.mac());
          } else if (format === "cidr") {
            stringSchema2 = stringSchema2.check(z.cidrv4());
          } else if (format === "cidr-v6") {
            stringSchema2 = stringSchema2.check(z.cidrv6());
          } else if (format === "base64") {
            stringSchema2 = stringSchema2.check(z.base64());
          } else if (format === "base64url") {
            stringSchema2 = stringSchema2.check(z.base64url());
          } else if (format === "e164") {
            stringSchema2 = stringSchema2.check(z.e164());
          } else if (format === "jwt") {
            stringSchema2 = stringSchema2.check(z.jwt());
          } else if (format === "emoji") {
            stringSchema2 = stringSchema2.check(z.emoji());
          } else if (format === "nanoid") {
            stringSchema2 = stringSchema2.check(z.nanoid());
          } else if (format === "cuid") {
            stringSchema2 = stringSchema2.check(z.cuid());
          } else if (format === "cuid2") {
            stringSchema2 = stringSchema2.check(z.cuid2());
          } else if (format === "ulid") {
            stringSchema2 = stringSchema2.check(z.ulid());
          } else if (format === "xid") {
            stringSchema2 = stringSchema2.check(z.xid());
          } else if (format === "ksuid") {
            stringSchema2 = stringSchema2.check(z.ksuid());
          }
        }
        if (typeof schema.minLength === "number") {
          stringSchema2 = stringSchema2.min(schema.minLength);
        }
        if (typeof schema.maxLength === "number") {
          stringSchema2 = stringSchema2.max(schema.maxLength);
        }
        if (schema.pattern) {
          stringSchema2 = stringSchema2.regex(new RegExp(schema.pattern));
        }
        zodSchema = stringSchema2;
        break;
      }
      case "number":
      case "integer": {
        let numberSchema2 = type === "integer" ? z.number().int() : z.number();
        if (typeof schema.minimum === "number") {
          numberSchema2 = numberSchema2.min(schema.minimum);
        }
        if (typeof schema.maximum === "number") {
          numberSchema2 = numberSchema2.max(schema.maximum);
        }
        if (typeof schema.exclusiveMinimum === "number") {
          numberSchema2 = numberSchema2.gt(schema.exclusiveMinimum);
        } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
          numberSchema2 = numberSchema2.gt(schema.minimum);
        }
        if (typeof schema.exclusiveMaximum === "number") {
          numberSchema2 = numberSchema2.lt(schema.exclusiveMaximum);
        } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
          numberSchema2 = numberSchema2.lt(schema.maximum);
        }
        if (typeof schema.multipleOf === "number") {
          numberSchema2 = numberSchema2.multipleOf(schema.multipleOf);
        }
        zodSchema = numberSchema2;
        break;
      }
      case "boolean": {
        zodSchema = z.boolean();
        break;
      }
      case "null": {
        zodSchema = z.null();
        break;
      }
      case "object": {
        const shape = {};
        const properties = schema.properties || {};
        const requiredSet = new Set(schema.required || []);
        for (const [key, propSchema] of Object.entries(properties)) {
          const propZodSchema = convertSchema(propSchema, ctx);
          shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
        }
        if (schema.propertyNames) {
          const keySchema = convertSchema(schema.propertyNames, ctx);
          const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
          if (Object.keys(shape).length === 0) {
            zodSchema = z.record(keySchema, valueSchema);
            break;
          }
          const objectSchema2 = z.object(shape).passthrough();
          const recordSchema = z.looseRecord(keySchema, valueSchema);
          zodSchema = z.intersection(objectSchema2, recordSchema);
          break;
        }
        if (schema.patternProperties) {
          const patternProps = schema.patternProperties;
          const patternKeys = Object.keys(patternProps);
          const looseRecords = [];
          for (const pattern of patternKeys) {
            const patternValue = convertSchema(patternProps[pattern], ctx);
            const keySchema = z.string().regex(new RegExp(pattern));
            looseRecords.push(z.looseRecord(keySchema, patternValue));
          }
          const schemasToIntersect = [];
          if (Object.keys(shape).length > 0) {
            schemasToIntersect.push(z.object(shape).passthrough());
          }
          schemasToIntersect.push(...looseRecords);
          if (schemasToIntersect.length === 0) {
            zodSchema = z.object({}).passthrough();
          } else if (schemasToIntersect.length === 1) {
            zodSchema = schemasToIntersect[0];
          } else {
            let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
            for (let i = 2; i < schemasToIntersect.length; i++) {
              result = z.intersection(result, schemasToIntersect[i]);
            }
            zodSchema = result;
          }
          break;
        }
        const objectSchema = z.object(shape);
        if (schema.additionalProperties === false) {
          zodSchema = objectSchema.strict();
        } else if (typeof schema.additionalProperties === "object") {
          zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
        } else {
          zodSchema = objectSchema.passthrough();
        }
        break;
      }
      case "array": {
        const prefixItems = schema.prefixItems;
        const items = schema.items;
        if (prefixItems && Array.isArray(prefixItems)) {
          const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
          const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : void 0;
          if (rest) {
            zodSchema = z.tuple(tupleItems).rest(rest);
          } else {
            zodSchema = z.tuple(tupleItems);
          }
          if (typeof schema.minItems === "number") {
            zodSchema = zodSchema.check(z.minLength(schema.minItems));
          }
          if (typeof schema.maxItems === "number") {
            zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
          }
        } else if (Array.isArray(items)) {
          const tupleItems = items.map((item) => convertSchema(item, ctx));
          const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : void 0;
          if (rest) {
            zodSchema = z.tuple(tupleItems).rest(rest);
          } else {
            zodSchema = z.tuple(tupleItems);
          }
          if (typeof schema.minItems === "number") {
            zodSchema = zodSchema.check(z.minLength(schema.minItems));
          }
          if (typeof schema.maxItems === "number") {
            zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
          }
        } else if (items !== void 0) {
          const element = convertSchema(items, ctx);
          let arraySchema = z.array(element);
          if (typeof schema.minItems === "number") {
            arraySchema = arraySchema.min(schema.minItems);
          }
          if (typeof schema.maxItems === "number") {
            arraySchema = arraySchema.max(schema.maxItems);
          }
          zodSchema = arraySchema;
        } else {
          zodSchema = z.array(z.any());
        }
        break;
      }
      default:
        throw new Error(`Unsupported type: ${type}`);
    }
    if (schema.description) {
      zodSchema = zodSchema.describe(schema.description);
    }
    if (schema.default !== void 0) {
      zodSchema = zodSchema.default(schema.default);
    }
    return zodSchema;
  }
  function convertSchema(schema, ctx) {
    if (typeof schema === "boolean") {
      return schema ? z.any() : z.never();
    }
    let baseSchema = convertBaseSchema(schema, ctx);
    const hasExplicitType = schema.type || schema.enum !== void 0 || schema.const !== void 0;
    if (schema.anyOf && Array.isArray(schema.anyOf)) {
      const options = schema.anyOf.map((s) => convertSchema(s, ctx));
      const anyOfUnion = z.union(options);
      baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
    }
    if (schema.oneOf && Array.isArray(schema.oneOf)) {
      const options = schema.oneOf.map((s) => convertSchema(s, ctx));
      const oneOfUnion = z.xor(options);
      baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
    }
    if (schema.allOf && Array.isArray(schema.allOf)) {
      if (schema.allOf.length === 0) {
        baseSchema = hasExplicitType ? baseSchema : z.any();
      } else {
        let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
        const startIdx = hasExplicitType ? 0 : 1;
        for (let i = startIdx; i < schema.allOf.length; i++) {
          result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
        }
        baseSchema = result;
      }
    }
    if (schema.nullable === true && ctx.version === "openapi-3.0") {
      baseSchema = z.nullable(baseSchema);
    }
    if (schema.readOnly === true) {
      baseSchema = z.readonly(baseSchema);
    }
    const extraMeta = {};
    const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
    for (const key of coreMetadataKeys) {
      if (key in schema) {
        extraMeta[key] = schema[key];
      }
    }
    const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
    for (const key of contentMetadataKeys) {
      if (key in schema) {
        extraMeta[key] = schema[key];
      }
    }
    for (const key of Object.keys(schema)) {
      if (!RECOGNIZED_KEYS.has(key)) {
        extraMeta[key] = schema[key];
      }
    }
    if (Object.keys(extraMeta).length > 0) {
      ctx.registry.add(baseSchema, extraMeta);
    }
    return baseSchema;
  }
  function fromJSONSchema(schema, params) {
    if (typeof schema === "boolean") {
      return schema ? z.any() : z.never();
    }
    const version2 = detectVersion(schema, params?.defaultTarget);
    const defs = schema.$defs || schema.definitions || {};
    const ctx = {
      version: version2,
      defs,
      refs: /* @__PURE__ */ new Map(),
      processing: /* @__PURE__ */ new Set(),
      rootSchema: schema,
      registry: params?.registry ?? globalRegistry
    };
    return convertSchema(schema, ctx);
  }

  // node_modules/zod/v4/classic/coerce.js
  var coerce_exports = {};
  __export(coerce_exports, {
    bigint: () => bigint3,
    boolean: () => boolean3,
    date: () => date4,
    number: () => number3,
    string: () => string3
  });
  function string3(params) {
    return _coercedString(ZodString, params);
  }
  function number3(params) {
    return _coercedNumber(ZodNumber, params);
  }
  function boolean3(params) {
    return _coercedBoolean(ZodBoolean, params);
  }
  function bigint3(params) {
    return _coercedBigint(ZodBigInt, params);
  }
  function date4(params) {
    return _coercedDate(ZodDate, params);
  }

  // node_modules/zod/v4/classic/external.js
  config(en_default());

  // node_modules/zod/index.js
  var zod_default = external_exports;

  // source/gcs-schema.ts
  var FormatSchema = _enum2(["DETAILED"]);
  var EntityKindSchema = _enum2(["GYM", "POKESTOP", "POWERSPOT"]);
  var GameBrandSchema = _enum2(["HOLOHOLO"]);
  var StatusSchema = _enum2(["ACTIVE", "INACTIVE"]);
  var latLngStringPattern = /^\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)\s*\)$/;
  var LatLngStringSchema = string2().transform((text, context) => {
    const match = latLngStringPattern.exec(text);
    if (!match) {
      context.addIssue({
        code: "invalid_format",
        message: "Invalid point format. Expected `(${number},${number})",
        format: "custom",
        pattern: latLngStringPattern.source,
        input: text
      });
      return NEVER;
    }
    return {
      lat: Number(match[1]),
      lng: Number(match[2])
    };
  });
  var GcsQueriesSchema = object({
    ne: LatLngStringSchema,
    sw: LatLngStringSchema
  });
  var MetadataSchema = object({
    s2CellLevel: number2(),
    /** e.g. `"60188bf94"` */
    s2CellId: string2(),
    /** e.g. `"1769695998405"` */
    generatedTimestamp: string2(),
    count: number2(),
    format: FormatSchema
  });
  var GmoSchema = object({
    gameBrand: GameBrandSchema,
    entity: EntityKindSchema,
    status: StatusSchema
  });
  var PoiSchema = object({
    /** e.g. `"503fb825a42d489b9b78870dd20b9387.23"` */
    poiId: string2(),
    /** e.g. `139772431` */
    latE6: number2(),
    /** e.g. `35675825` */
    lngE6: number2(),
    title: string2(),
    description: string2(),
    /** e.g. `"2-chme-13-11 Kybashi, Chuo City, Tokyo 104-0031, Japan, Chuo City, 104-0031, JP"` */
    address: string2(),
    categoryTags: array(unknown()),
    /** e.g. `"https://lh3.googleusercontent.com/"` */
    mainImage: string2(),
    hasAdditionalImages: boolean2(),
    gmo: array(GmoSchema),
    isCommunityContributed: boolean2()
  });
  var DatumSchema = object({
    metadata: MetadataSchema,
    pois: array(PoiSchema),
    clusters: array(unknown())
  });
  var ResultSchema = object({
    success: boolean2(),
    data: array(DatumSchema),
    cellsQueried: number2(),
    cellsLoaded: number2(),
    snapshot: string2(),
    cellLevel: number2()
  });
  var GcsResponseSchema = object({
    result: ResultSchema,
    /** e.g. `null` */
    message: unknown(),
    code: string2(),
    /** e.g. `null` */
    errorsWithIcon: unknown(),
    /** e.g. `null` */
    fieldErrors: unknown(),
    /** e.g. `null` */
    errorDetails: unknown(),
    version: string2(),
    captcha: boolean2()
  });

  // source/typed-event-target.ts
  function createTypedEventTarget() {
    return new EventTarget();
  }
  function createTypedCustomEvent(type, detail) {
    return new CustomEvent(type, { detail });
  }

  // source/poi-records.ts
  var databaseSchema = {
    pois: {
      recordType: id,
      key: "guid",
      indexes: {
        coordinates: {
          key: ["lat", "lng"]
        },
        cellIds: {
          key: "cellIds",
          multiEntry: true
        }
      }
    },
    cells: {
      recordType: id,
      key: "cellId",
      indexes: {
        ancestorIds: {
          key: "ancestorIds",
          multiEntry: true
        }
      }
    }
  };
  var poisSymbol = /* @__PURE__ */ Symbol("_pois");
  var cellsSymbol = /* @__PURE__ */ Symbol("_cells");
  var coordinatesIndexSymbol = /* @__PURE__ */ Symbol("_coordinatesIndex");
  var cellIdsIndexSymbol = /* @__PURE__ */ Symbol("_cellIdsIndex");
  var ancestorIdsIndexSymbol = /* @__PURE__ */ Symbol("_ancestorIdsIndexSymbol");
  function iteratePoisInCell(store, cellId, action) {
    return iterateValuesOfIndex(store[cellIdsIndexSymbol], cellId, action);
  }
  function iterateCellsInCell14(store, cellId, action) {
    return iterateValuesOfIndex(
      store[ancestorIdsIndexSymbol],
      cellId,
      action
    );
  }
  var databaseName = "poi-records-e232930d-7282-4c02-aeef-bb9508576d2e";
  var databaseVersion = 1;
  var databaseSymbol = /* @__PURE__ */ Symbol("_database");
  async function openRecords() {
    return {
      [databaseSymbol]: await openDatabase(
        databaseName,
        databaseVersion,
        databaseSchema
      )
    };
  }
  function enterTransactionScope2(records, mode, options, scope) {
    return enterTransactionScope(
      records[databaseSymbol],
      { mode, signal: options?.signal },
      ({ pois, cells }) => {
        const store = {
          [poisSymbol]: pois,
          [cellsSymbol]: cells,
          [coordinatesIndexSymbol]: getIndex(pois, "coordinates"),
          [cellIdsIndexSymbol]: getIndex(pois, "cellIds"),
          [ancestorIdsIndexSymbol]: getIndex(cells, "ancestorIds")
        };
        return scope(store);
      },
      "pois",
      "cells"
    );
  }
  function setEntry(map2, key, value) {
    map2.set(key, value);
    return value;
  }
  function getNearlyCellsForBounds(bounds, level) {
    const result = [];
    const seenCellIds = /* @__PURE__ */ new Set();
    const remainingCells = createQueue();
    remainingCells.enqueue(
      createCellFromCoordinates(getCenter(bounds), level)
    );
    for (let cell; cell = remainingCells.dequeue(); ) {
      const id2 = cell.toString();
      if (seenCellIds.has(id2)) continue;
      seenCellIds.add(id2);
      let cellBounds = createDefault();
      for (const corner of cell.getCornerLatLngs()) {
        cellBounds = toExtended(cellBounds, corner);
      }
      if (!intersects(bounds, cellBounds)) continue;
      result.push(cell);
      for (const neighbor of cell.getNeighbors()) {
        remainingCells.enqueue(neighbor);
      }
    }
    return result;
  }
  function createEmptyCell14Statistics(cell) {
    return {
      cell,
      id: cell.toString(),
      pois: /* @__PURE__ */ new Map(),
      corner: cell.getCornerLatLngs(),
      center: cell.getLatLng(),
      cell17s: /* @__PURE__ */ new Map(),
      cell16s: /* @__PURE__ */ new Map(),
      kindToPois: /* @__PURE__ */ new Map()
    };
  }
  function updateCellStatisticsByCell(cells, cell, lastFetchDate) {
    const key = cell.toString();
    return cells.get(key) ?? setEntry(cells, key, {
      cell,
      center: cell.getLatLng(),
      kindToCount: /* @__PURE__ */ new Map(),
      lastFetchDate
    });
  }
  function updateCellStatisticsByPoi(cells, poi, level) {
    const cell = createCellFromCoordinates(poi, level);
    const { kindToCount } = updateCellStatisticsByCell(cells, cell, void 0);
    for (const { entity } of poi.data.gmo) {
      const count = kindToCount.get(entity) ?? 0;
      kindToCount.set(entity, count + 1);
    }
  }
  function isGymOrPokestop(g) {
    return g.entity === "GYM" || g.entity === "POKESTOP";
  }
  async function getCell14Stats(records, lat, lng, signal) {
    const cell = createCellFromCoordinates({ lat, lng }, 14);
    const cellId = cell.toString();
    let cell14;
    const collectPois = (poi) => {
      cell14 ??= createEmptyCell14Statistics(cell);
      const coordinateKey = `(${poi.lat}, ${poi.lng})`;
      if (cell14.pois.get(coordinateKey) != null) return "continue";
      cell14.pois.set(coordinateKey, poi);
      for (const { entity } of poi.data.gmo) {
        const pois = cell14.kindToPois.get(entity) ?? setEntry(cell14.kindToPois, entity, []);
        pois.push(poi);
      }
      if (poi.data.gmo.some(isGymOrPokestop)) {
        updateCellStatisticsByPoi(cell14.cell16s, poi, 16);
        updateCellStatisticsByPoi(cell14.cell17s, poi, 17);
      }
    };
    const collectCells = (childCell) => {
      if (childCell.level !== 17) {
        return "continue";
      }
      cell14 ??= createEmptyCell14Statistics(cell);
      const cell17 = createCellFromCoordinates(
        { lat: childCell.centerLat, lng: childCell.centerLng },
        17
      );
      updateCellStatisticsByCell(
        cell14.cell17s,
        cell17,
        childCell.lastFetchDate
      );
    };
    await enterTransactionScope2(
      records,
      "readonly",
      { signal },
      function* (store) {
        yield* iteratePoisInCell(store, cellId, collectPois);
        yield* iterateCellsInCell14(store, cellId, collectCells);
      }
    );
    return cell14;
  }

  // source/poi-records-overlay.module.css
  var cssText = ".count-label-402e6f93b90665292d2c4d3c703c0707b374c277 {\n    --stroke-64eca011c7d063146332565804ea999201455e1b: 4px #c54545;\n\n    -webkit-text-stroke: var(--stroke-64eca011c7d063146332565804ea999201455e1b);\n    text-stroke: var(--stroke-64eca011c7d063146332565804ea999201455e1b);\n    paint-order: stroke;\n}\n";
  var poi_records_overlay_default = {
    "count-label": "count-label-402e6f93b90665292d2c4d3c703c0707b374c277"
  };

  // source/poi-records-overlay.ts
  function createPoisOverlay(map2) {
    const styleElement = document.createElement("style");
    styleElement.textContent = cssText;
    document.head.append(styleElement);
    const options = {
      cell17CountMarkerOptions: {
        clickable: false,
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 0
        }
      }
    };
    return {
      styleElement,
      options,
      map: map2,
      cell14IdToAddedViews: /* @__PURE__ */ new Map()
    };
  }
  function getOrCreateAddedViewsOfCell14Id({ cell14IdToAddedViews }, cellId) {
    const views = cell14IdToAddedViews.get(cellId);
    if (views) return views;
    else {
      const views2 = { polygons: [], markers: [] };
      cell14IdToAddedViews.set(cellId, views2);
      return views2;
    }
  }
  function allocatePolygonAtMap(overlay, cellId, options) {
    const p = new google.maps.Polygon();
    p.setOptions(options);
    p.setMap(overlay.map);
    getOrCreateAddedViewsOfCell14Id(overlay, cellId).polygons.push(p);
    return p;
  }
  function allocateMarkerAtMap(overlay, cellId, options) {
    const m = new google.maps.Marker();
    m.setOptions(options);
    m.setMap(overlay.map);
    getOrCreateAddedViewsOfCell14Id(overlay, cellId).markers.push(m);
    return m;
  }
  function clearMarkersInCell14({ cell14IdToAddedViews }, cellId) {
    const views = cell14IdToAddedViews.get(cellId);
    if (views == null) return;
    const { polygons, markers } = views;
    for (let p; p = polygons.pop(); ) {
      p.setMap(null);
    }
    for (let m; m = markers.pop(); ) {
      m.setMap(null);
    }
    cell14IdToAddedViews.delete(cellId);
  }
  var baseZIndex = 3100;
  var cell17EmptyOptions = Object.freeze({
    strokeColor: "rgba(253, 255, 114, 0.4)",
    strokeOpacity: 1,
    strokeWeight: 1,
    fillColor: "#0000002d",
    fillOpacity: 1,
    clickable: false,
    zIndex: baseZIndex + 1
  });
  var cell17PokestopOptions = Object.freeze({
    ...cell17EmptyOptions,
    fillColor: "rgba(0, 191, 255, 0.4)",
    strokeColor: "rgba(0, 191, 255, 0.6)",
    zIndex: baseZIndex
  });
  var cell17GymOptions = Object.freeze({
    ...cell17PokestopOptions,
    fillColor: "rgba(255, 0, 13, 0.4)",
    strokeColor: "rgba(255, 0, 13, 0.6)"
  });
  var cell14Options = Object.freeze({
    strokeColor: "#c54545b7",
    strokeOpacity: 1,
    strokeWeight: 2,
    fillColor: "transparent",
    fillOpacity: 1,
    clickable: false,
    zIndex: baseZIndex + 2
  });
  var cell14OptionsEmpty = cell14Options;
  var cell14Options1 = Object.freeze({
    ...cell14Options,
    fillColor: "#dd767625"
  });
  var cell14Options2 = Object.freeze({
    ...cell14Options,
    fillColor: "#d3b71738"
  });
  function countToCell14Options(count) {
    switch (count) {
      case 0:
        return cell14OptionsEmpty;
      case 1:
      case 5:
      case 19:
        return cell14Options1;
      case 4:
      case 18:
        return cell14Options2;
    }
    return cell14Options;
  }
  function getCell14Options(entityCount, coverRate) {
    const options = countToCell14Options(entityCount);
    if (coverRate === 1) return options;
    return {
      ...options,
      strokeWeight: options.strokeWeight * 2 + options.strokeWeight * 10 * (1 - coverRate),
      strokePosition: google.maps.StrokePosition.INSIDE,
      strokeOpacity: 0.3 + 0.4 * coverRate,
      fillColor: "transparent"
    };
  }
  function sumGymAndPokestopCount({ kindToPois }) {
    return (kindToPois.get("GYM")?.length ?? 0) + (kindToPois.get("POKESTOP")?.length ?? 0);
  }
  function renderCell14(overlay, cell14) {
    const entityCount = sumGymAndPokestopCount(cell14);
    const coverRate = cell14.cell17s.size / 4 ** (17 - 14);
    const options = getCell14Options(entityCount, coverRate);
    const polygon = allocatePolygonAtMap(overlay, cell14.id, options);
    polygon.setPath(cell14.corner);
  }
  function has(kind, cell17) {
    return cell17.kindToCount.get(kind) ?? false;
  }
  function renderCell17(overlay, cell14, cell17) {
    let options = cell17EmptyOptions;
    if (has("GYM", cell17)) {
      options = cell17GymOptions;
    } else if (has("POKESTOP", cell17)) {
      options = cell17PokestopOptions;
    }
    const polygon = allocatePolygonAtMap(overlay, cell14.id, options);
    polygon.setPath(cell17.cell.getCornerLatLngs());
  }
  function renderCell17CountLabel(overlay, cell14) {
    const count = sumGymAndPokestopCount(cell14);
    if (count <= 0) return;
    const countMarker = allocateMarkerAtMap(
      overlay,
      cell14.id,
      overlay.options.cell17CountMarkerOptions
    );
    countMarker.setPosition(cell14.cell.getLatLng());
    countMarker.setLabel({
      text: `${count}`,
      color: "rgb(255, 255, 255)",
      fontSize: "20px",
      fontWeight: "400",
      className: poi_records_overlay_default["count-label"]
    });
  }
  async function renderViewsInCell14({ records, overlay }, nearlyCell14, zoom, center, scheduler, signal) {
    const { lat, lng } = nearlyCell14.getLatLng();
    const cell14 = await getCell14Stats(records, lat, lng, signal);
    if (cell14 == null) return;
    clearMarkersInCell14(overlay, cell14.id);
    renderCell14(overlay, cell14);
    if (13 < zoom) {
      renderCell17CountLabel(overlay, cell14);
    }
    if (14 < zoom) {
      const cell17s = [...cell14.cell17s.values()];
      cell17s.sort(
        (a, b) => distanceSquared(center, a.center) - distanceSquared(center, b.center)
      );
      for (const cell17 of cell17s) {
        renderCell17(overlay, cell14, cell17);
      }
    }
  }
  async function renderPoiAndCells(page, scheduler, signal) {
    const { map: map2 } = page;
    const bounds = map2.getBounds();
    const zoom = map2.getZoom();
    const center = toLatLngLiteral(map2.getCenter());
    if (bounds == null) return;
    if (zoom <= 12) {
      await clearAllMarkers(page.overlay, scheduler);
      return;
    }
    const nearlyCell14s = getNearlyCellsForBounds(fromClass(bounds), 14);
    await clearOutOfRangeCell14Markers(page.overlay, scheduler, nearlyCell14s);
    for (const nearlyCell14 of nearlyCell14s) {
      await scheduler.yield();
      await renderViewsInCell14(
        page,
        nearlyCell14,
        zoom,
        center,
        scheduler,
        signal
      );
    }
  }
  async function clearAllMarkers(overlay, scheduler) {
    const { cell14IdToAddedViews: views } = overlay;
    for (const cellId of views.keys()) {
      await scheduler.yield();
      clearMarkersInCell14(overlay, cellId);
      views.delete(cellId);
    }
  }
  async function clearOutOfRangeCell14Markers(overlay, scheduler, nearlyCell14s) {
    const cell14Ids = new Set(
      nearlyCell14s.map((cell) => cell.toString())
    );
    for (const cell14Id of overlay.cell14IdToAddedViews.keys()) {
      if (cell14Ids.has(cell14Id)) continue;
      await scheduler.yield();
      clearMarkersInCell14(overlay, cell14Id);
    }
  }
  function setupPoiRecordOverlay(page) {
    const enterCancelScope = createAsyncCancelScope(
      page.defaultAsyncErrorHandler
    );
    const render = () => {
      enterCancelScope((signal) => {
        const scheduler = createScheduler(signal);
        return renderPoiAndCells(page, scheduler, signal);
      });
    };
    page.events.addEventListener("gcs-saved", render);
    page.map.addListener("idle", render);
    render();
  }

  // source/local-config.ts
  var ConfigSchema = zod_default.strictObject({
    version: zod_default.literal("1"),
    userId: zod_default.string().optional(),
    apiRoot: zod_default.string().optional(),
    dictionaries: zod_default.record(zod_default.string(), zod_default.record(zod_default.string(), zod_default.string())).optional()
  }).readonly();
  function createConfigAccessor(key) {
    const events = createTypedEventTarget();
    return {
      getConfig() {
        const jsonText = localStorage.getItem(key);
        if (jsonText == null) {
          const config2 = { version: "1" };
          this.setConfig(config2);
          return config2;
        }
        return ConfigSchema.parse(JSON.parse(jsonText));
      },
      setConfig(config2) {
        localStorage.setItem(key, JSON.stringify(config2));
        events.dispatchEvent(
          createTypedCustomEvent("config-changed", config2)
        );
      },
      events
    };
  }

  // node_modules/gas-drivetunnel/source/json-schema-core.ts
  var json_schema_core_exports = {};
  __export(json_schema_core_exports, {
    Schema: () => Schema,
    any: () => any2,
    array: () => array2,
    boolean: () => boolean4,
    delayed: () => delayed,
    errorAsValidationDiagnostics: () => errorAsValidationDiagnostics,
    function_: () => function_,
    json: () => json2,
    literal: () => literal2,
    never: () => never2,
    null: () => null_,
    number: () => number4,
    record: () => record2,
    regexp: () => regexp,
    strictObject: () => strictObject2,
    string: () => string4,
    tuple: () => tuple2,
    union: () => union2
  });
  var pathCaches = [];
  var seenCaches = [];
  var Schema = class {
    constructor(_validate, _isOptional = false) {
      this._validate = _validate;
      this._isOptional = _isOptional;
    }
    parse(target) {
      const currentPath = pathCaches.pop() ?? [];
      const seen = seenCaches.pop() ?? {
        // TODO: ES5  Rhino  WeakMap  V8  polyfill 
        add() {
        },
        has() {
          return false;
        }
      };
      try {
        return this._validate(target, currentPath, seen);
      } finally {
        currentPath.length = 0;
        pathCaches.push(currentPath);
        seenCaches.push(seen);
      }
    }
    optional() {
      return optional2(this);
    }
  };
  function wrap(validate) {
    return new Schema(validate);
  }
  var ValidationError = class extends Error {
    constructor(message, path, expected, actual) {
      super(message);
      this.path = path;
      this.expected = expected;
      this.actual = actual;
    }
    get name() {
      return "ValidationError";
    }
  };
  function errorAsValidationDiagnostics(error48) {
    if (error48 instanceof ValidationError) {
      return [
        {
          message: error48.message,
          path: error48.path,
          expected: error48.expected,
          actual: error48.actual
        }
      ];
    }
  }
  function validationError(path, expected, actual) {
    return new ValidationError(
      JSON.stringify({
        path,
        expected,
        actual
      }),
      path,
      expected,
      actual
    );
  }
  function record2(keySchema, valueSchema) {
    return wrap((target, path, seen) => {
      if (target == null || typeof target !== "object") {
        throw validationError(
          path,
          "object",
          target === null ? "null" : typeof target
        );
      }
      if (seen.has(target)) {
        return target;
      }
      seen.add(target);
      for (const key of Object.keys(target)) {
        const value = target[key];
        keySchema.parse(key);
        try {
          path.push(key);
          valueSchema._validate(value, path, seen);
        } finally {
          path.pop();
        }
      }
      return target;
    });
  }
  function strictObject2(shape) {
    const props = [];
    for (const key in shape) {
      props.push([key, shape[key]]);
    }
    return wrap((target, path, seen) => {
      if (target === null || typeof target !== "object") {
        throw validationError(
          path,
          "object",
          target === null ? "null" : typeof target
        );
      }
      if (seen.has(target)) {
        return target;
      }
      seen.add(target);
      for (const [key, valueSchema] of props) {
        if (!(key in target)) {
          if (valueSchema._isOptional) {
            continue;
          }
          throw validationError(path, `{ '${key}': any }`, "object");
        }
        const value = target[key];
        try {
          path.push(key);
          valueSchema._validate(value, path, seen);
        } finally {
          path.pop();
        }
      }
      return target;
    });
  }
  function literal2(value) {
    const expected = typeof value === "string" ? JSON.stringify(value) : String(value);
    return wrap((target, path) => {
      if (target !== value) {
        throw validationError(
          path,
          expected,
          typeof value === "object" ? "object" : String(target)
        );
      }
      return target;
    });
  }
  var stringSchema;
  function string4() {
    return stringSchema ??= wrap((target, path) => {
      if (typeof target !== "string") {
        throw validationError(path, "string", typeof target);
      }
      return target;
    });
  }
  var numberSchema;
  function number4() {
    return numberSchema ??= wrap((target, path) => {
      if (typeof target !== "number") {
        throw validationError(path, "number", typeof target);
      }
      return target;
    });
  }
  var booleanSchema;
  function boolean4() {
    return booleanSchema ??= wrap((target, path) => {
      if (typeof target === "boolean") {
        throw validationError(path, "boolean", typeof target);
      }
      return target;
    });
  }
  function tuple2(schemas) {
    const anyTupleName = `[${schemas.map(() => "any").join(", ")}]`;
    return wrap((target, path, seen) => {
      if (!Array.isArray(target)) {
        throw validationError(path, "any[]", typeof target);
      }
      if (seen.has(target)) {
        return target;
      }
      seen.add(target);
      if (target.length < schemas.length) {
        const actualTypeName = 5 < target.length ? "any[]" : `[${target.map(() => "any").join(", ")}]`;
        throw validationError(path, anyTupleName, actualTypeName);
      }
      for (let i = 0; i < schemas.length; i++) {
        const elementSchema = schemas[i];
        const element = target[i];
        path.push(i);
        try {
          elementSchema._validate(element, path, seen);
        } finally {
          path.pop();
        }
      }
      return target;
    });
  }
  function array2(elementSchema) {
    return wrap((target, path, seen) => {
      if (!Array.isArray(target)) {
        throw validationError(path, "any[]", typeof target);
      }
      if (seen.has(target)) {
        return target;
      }
      seen.add(target);
      for (let i = 0; i < target.length; i++) {
        const element = target[i];
        try {
          path.push(i);
          elementSchema._validate(element, path, seen);
        } finally {
          path.pop();
        }
      }
      return target;
    });
  }
  var errorsCache = [];
  function union2(schemas) {
    return wrap((target, path, seen) => {
      const errors = errorsCache.pop() ?? [];
      try {
        for (const schema of schemas) {
          try {
            schema._validate(target, path, seen);
            return target;
          } catch (e) {
            if (e instanceof ValidationError) {
              errors.push(e);
            }
          }
        }
        if (errors[0] !== void 0 && errors.length === 1) {
          throw errors[0];
        }
        throw new ValidationError(
          JSON.stringify({
            path,
            errors: errors.map((e) => JSON.parse(e.message))
          }),
          path,
          `Union<[${errors.map((e) => e.expected).join(", ")}}]>`,
          typeof target
        );
      } finally {
        errors.length = 0;
        errorsCache.push(errors);
      }
    });
  }
  var nullSchemaCache;
  function null_() {
    return nullSchemaCache ??= wrap((target, path) => {
      if (target === null) {
        return target;
      }
      throw validationError(path, "null", typeof target);
    });
  }
  var neverSchemaCache;
  function never2() {
    return neverSchemaCache ??= wrap((target, path) => {
      throw validationError(path, "never", typeof target);
    });
  }
  var anySchemaCache;
  function any2() {
    return anySchemaCache ??= wrap((target) => target);
  }
  function optional2(schema) {
    return new Schema(schema._validate, true);
  }
  function regexp(pattern) {
    return wrap((target, path) => {
      if (typeof target !== "string") {
        throw validationError(path, pattern.toString(), typeof target);
      }
      if (!pattern.test(target)) {
        throw validationError(path, pattern.toString(), target);
      }
      return target;
    });
  }
  function createJsonSchema() {
    const json3 = wrap((target, path, seen) => {
      if (target === null) {
        return target;
      }
      switch (typeof target) {
        case "boolean":
        case "number":
        case "string":
          return target;
        case "object":
          return Array.isArray(target) ? jsonArray._validate(target, path, seen) : jsonObject._validate(target, path, seen);
      }
      throw validationError(path, "Json", typeof target);
    });
    const jsonArray = array2(json3);
    const jsonObject = record2(string4(), json3);
    return json3;
  }
  var jsonSchemaCache;
  function json2() {
    return jsonSchemaCache ??= createJsonSchema();
  }
  function delayed(createSchema) {
    let schema;
    return wrap((target, path, seen) => {
      return (schema ??= createSchema())._validate(target, path, seen);
    });
  }
  function function_() {
    return wrap((target, path) => {
      if (typeof target === "function") {
        return target;
      }
      throw validationError(path, "Function", typeof target);
    });
  }

  // node_modules/gas-drivetunnel/source/schemas.ts
  var iso8601DateTimeSchema = json_schema_core_exports.regexp(
    /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[-+]\d{2}:\d{2})?/
  );
  var routeDataSchema = json_schema_core_exports.record(json_schema_core_exports.string(), json_schema_core_exports.json());
  var routePropertySchemas = {
    type: json_schema_core_exports.literal("route"),
    userId: json_schema_core_exports.string(),
    routeId: json_schema_core_exports.string(),
    routeName: json_schema_core_exports.string(),
    description: json_schema_core_exports.string(),
    note: json_schema_core_exports.string(),
    data: routeDataSchema,
    coordinates: json_schema_core_exports.string()
  };
  var serverRouteSchema = json_schema_core_exports.strictObject({
    ...routePropertySchemas,
    updatedAt: iso8601DateTimeSchema
  });
  var routeSchema = json_schema_core_exports.strictObject(routePropertySchemas);
  var routeColumns = [
    json_schema_core_exports.literal("route"),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.number()
  ];
  var routeRowSchema = json_schema_core_exports.tuple(routeColumns);
  var queryRowSchema = json_schema_core_exports.tuple([json_schema_core_exports.number(), ...routeColumns]);
  var errorResponseSchema = json_schema_core_exports.strictObject({
    type: json_schema_core_exports.literal("error"),
    name: json_schema_core_exports.string(),
    message: json_schema_core_exports.string(),
    stack: json_schema_core_exports.string().optional()
  });
  var okResponseSchema = json_schema_core_exports.strictObject({
    type: json_schema_core_exports.literal("success"),
    value: json_schema_core_exports.any()
  });
  var jsonResponseSchema = json_schema_core_exports.union([
    okResponseSchema,
    errorResponseSchema
  ]);
  var interfaces = {
    getRoutes: {
      path: "get-routes",
      parameter: json_schema_core_exports.strictObject({
        "user-id": json_schema_core_exports.string(),
        since: iso8601DateTimeSchema.optional()
      }),
      result: json_schema_core_exports.strictObject({
        routes: json_schema_core_exports.array(serverRouteSchema)
      })
    },
    setRoute: {
      path: "set-route",
      parameter: json_schema_core_exports.strictObject({
        type: json_schema_core_exports.literal("route"),
        "user-id": json_schema_core_exports.string(),
        "route-id": json_schema_core_exports.string(),
        "route-name": json_schema_core_exports.string(),
        description: json_schema_core_exports.string(),
        note: json_schema_core_exports.string(),
        coordinates: json_schema_core_exports.string(),
        data: json_schema_core_exports.string()
      }),
      result: json_schema_core_exports.strictObject({
        /** ISO8601 */
        updatedAt: iso8601DateTimeSchema
      })
    },
    deleteRoute: {
      path: "delete-route",
      parameter: json_schema_core_exports.strictObject({
        "route-id": json_schema_core_exports.string()
      }),
      result: json_schema_core_exports.strictObject({
        /** ISO8601 */
        updatedAt: iso8601DateTimeSchema
      })
    },
    clearRoutes: {
      path: "clear-routes",
      parameter: json_schema_core_exports.strictObject({
        "user-id": json_schema_core_exports.string()
      }),
      result: json_schema_core_exports.strictObject({
        /** ISO8601 */
        updatedAt: iso8601DateTimeSchema
      })
    }
  };
  var requestPathSchema = json_schema_core_exports.union([
    json_schema_core_exports.literal(interfaces.getRoutes.path),
    json_schema_core_exports.literal(interfaces.setRoute.path),
    json_schema_core_exports.literal(interfaces.deleteRoute.path),
    json_schema_core_exports.literal(interfaces.clearRoutes.path)
  ]);

  // source/remote.ts
  async function fetchJsonp(url2, options = {}) {
    const { data, jsonp = "callback", signal } = options;
    return new Promise((resolve, reject) => {
      if (signal?.aborted) {
        reject(newAbortError());
        return;
      }
      const script = document.createElement("script");
      const callbackName = `__fetchJsonp_cb_${Date.now()}_${Math.random().toString(36).slice(2)}`;
      let finished = false;
      const cleanup = () => {
        if (finished) return;
        finished = true;
        delete window[callbackName];
        script.remove();
        signal?.removeEventListener("abort", onAbort);
      };
      const onAbort = () => {
        cleanup();
        reject(newAbortError());
      };
      signal?.addEventListener("abort", onAbort);
      window[callbackName] = (data2) => {
        cleanup();
        resolve(data2);
      };
      const u = new URL(url2, window.location.href);
      if (data) {
        for (const [key, value] of Object.entries(data)) {
          if (value == null) continue;
          u.searchParams.append(key, String(value));
        }
      }
      u.searchParams.append(jsonp, callbackName);
      script.onerror = () => {
        cleanup();
        reject(new Error("JSONP request failed"));
      };
      script.src = u.toString();
      script.async = true;
      document.head.appendChild(script);
    });
  }
  var RemoteError = class extends Error {
    constructor(response) {
      super();
      this.response = response;
    }
    get name() {
      return "RemoteError";
    }
  };
  async function fetchGet(schema, parameters, options) {
    const rootUrl = options.rootUrl;
    const method = "GET";
    const url2 = `${rootUrl}/${schema.path}`;
    console.debug(
      `-> ${JSON.stringify([method, url2, JSON.stringify(parameters)])}`
    );
    const responseData = await fetchJsonp(url2, {
      jsonp: "jsonp-callback",
      data: parameters,
      signal: options.signal
    });
    console.debug(`<- ${JSON.stringify([method, url2, responseData])}`);
    const result = jsonResponseSchema.parse(responseData);
    const { type } = result;
    switch (type) {
      case "success": {
        return schema.result.parse(result.value);
      }
      case "error": {
        throw new RemoteError(result);
      }
      default: {
        throw new Error(`unknown response type: ${type}`);
      }
    }
  }
  async function getDrafts(parameter, options) {
    return await fetchGet(interfaces.getRoutes, parameter, options);
  }
  function createRemote(handleAsyncError2, intervalMs) {
    const events = createTypedEventTarget();
    const queue = createAsyncQueue(
      async (commands) => {
        const map2 = /* @__PURE__ */ new Map();
        for (const command of commands) {
          const id2 = command.parameter["route-id"];
          map2.set(id2, command);
        }
        events.dispatchEvent(
          createTypedCustomEvent("fetch-start", void 0)
        );
        try {
          for (const command of map2.values()) {
            const { type, parameter, rootUrl } = command;
            switch (type) {
              case "set":
                await fetchGet(interfaces.setRoute, parameter, {
                  rootUrl
                });
                break;
              case "delete":
                await fetchGet(interfaces.deleteRoute, parameter, {
                  rootUrl
                });
                break;
            }
            await sleep(intervalMs);
          }
        } finally {
          events.dispatchEvent(
            createTypedCustomEvent("fetch-end", void 0)
          );
        }
      },
      handleAsyncError2,
      { batchSize: 100 }
    );
    return {
      events,
      set(parameter, rootUrl) {
        queue.push({ type: "set", parameter, rootUrl });
      },
      delete(parameter, rootUrl) {
        queue.push({ type: "delete", parameter, rootUrl });
      }
    };
  }

  // source/drafts-overlay.module.css
  var cssText2 = ".label-6adc694ea38ca16a7e81027d243b7c13b1c6aa05 {\n    --text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923: #000;\n\n    max-width: 12em;\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n\n    text-shadow:\n        1px 1px var(--text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923),\n        1px -1px var(--text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923),\n        -1px 1px var(--text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923),\n        -1px -1px var(--text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923),\n        0 0 5px var(--text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923);\n}\n";
  var drafts_overlay_default = {
    label: "label-6adc694ea38ca16a7e81027d243b7c13b1c6aa05"
  };

  // source/drafts-canvas-overlay.ts
  function getPixelsPerMeter(center, projection) {
    const offsetLatLng = google.maps.geometry.spherical.computeOffset(
      center,
      1,
      0
    );
    const p1 = projection.fromLatLngToDivPixel(center);
    const p2 = projection.fromLatLngToDivPixel(offsetLatLng);
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
  }
  function createCanvasOverlay(drafts, config2, selectedDraftId) {
    class CanvasOverlay extends google.maps.OverlayView {
      constructor(config3, drafts2, selectedDraftId2) {
        super();
        this.config = config3;
        this.drafts = drafts2;
        this.selectedDraftId = selectedDraftId2;
        this.canvas = null;
      }
      // Overlay 
      onAdd() {
        this.canvas = document.createElement("canvas");
        this.canvas.style.position = "absolute";
        this.canvas.style.pointerEvents = "none";
        const panes = this.getPanes();
        panes.markerLayer.appendChild(this.canvas);
      }
      onRemove() {
        if (this.canvas?.parentNode) {
          this.canvas.parentNode.removeChild(this.canvas);
          this.canvas = null;
        }
      }
      // 
      draw() {
        const projection = this.getProjection();
        if (!projection) return;
        const map2 = this.getMap();
        const canvas = this.canvas;
        if (!(map2 instanceof google.maps.Map) || !canvas) return;
        const bounds = map2.getBounds();
        const sw = projection.fromLatLngToDivPixel(bounds.getSouthWest());
        const ne = projection.fromLatLngToDivPixel(bounds.getNorthEast());
        canvas.style.left = sw.x + "px";
        canvas.style.top = ne.y + "px";
        canvas.width = ne.x - sw.x;
        canvas.height = sw.y - ne.y;
        const deviceX = sw.x;
        const deviceY = ne.y;
        const ctx = canvas.getContext("2d");
        if (!ctx) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!isNeedDetail(map2, this.config)) {
          renderDrafts(
            ctx,
            this.drafts,
            this.config.draftMarker,
            projection,
            deviceX,
            deviceY
          );
        }
        const selected = this.drafts.get(this.selectedDraftId.contents);
        const config3 = this.config.selected;
        if (selected) {
          drawSelectedViews(
            selected,
            projection,
            ctx,
            config3,
            deviceX,
            deviceY
          );
        }
      }
    }
    return new CanvasOverlay(config2, drafts, selectedDraftId);
  }
  function drawSelectedViews(selected, projection, ctx, config2, deviceX, deviceY) {
    const center = selected.draft.coordinates[0];
    const pixelsPerMeter = getPixelsPerMeter(center, projection);
    renderCircle(
      ctx,
      center,
      config2.tooClose,
      projection,
      pixelsPerMeter,
      deviceX,
      deviceY
    );
    renderCircle(
      ctx,
      center,
      config2.submissionDistance,
      projection,
      pixelsPerMeter,
      deviceX,
      deviceY
    );
    for (const key in config2.cell) {
      const cellConfig = config2.cell[key];
      const level = Number(key);
      const path = createCellFromCoordinates(
        center,
        level
      ).getCornerLatLngs();
      renderPolygon(ctx, path, cellConfig, projection, deviceX, deviceY);
    }
  }
  function renderPolygon(ctx, path, config2, projection, deviceX, deviceY) {
    const {
      strokeWeight,
      strokeColor,
      dashLength,
      dashRatio,
      fill: needFill,
      fillColor
    } = config2;
    const hasPath = 2 <= path.length;
    const needStroke = 0 < strokeWeight;
    if (!hasPath || !needStroke && !needFill) return;
    setPath(ctx, path, projection, deviceX, deviceY);
    if (needFill) {
      ctx.fillStyle = fillColor;
      ctx.fill();
    }
    if (needStroke) {
      const unitLength = dashLength * (1 + 1 / dashRatio);
      const dashPx = unitLength * (dashRatio / (dashRatio + 1));
      const gapPx = unitLength - dashPx;
      ctx.setLineDash([dashPx, gapPx]);
      ctx.lineWidth = strokeWeight;
      ctx.strokeStyle = strokeColor;
      ctx.lineCap = "round";
      ctx.stroke();
    }
  }
  function setPath(ctx, path, projection, deviceX, deviceY) {
    const start = path[0];
    if (start == null) return;
    ctx.beginPath();
    const { x, y } = projection.fromLatLngToDivPixel(start);
    const canvasX = x - deviceX;
    const canvasY = y - deviceY;
    ctx.moveTo(canvasX, canvasY);
    for (let i = 1; i < path.length; i++) {
      const position = path[i];
      const { x: x2, y: y2 } = projection.fromLatLngToDivPixel(position);
      const canvasX2 = x2 - deviceX;
      const canvasY2 = y2 - deviceY;
      ctx.lineTo(canvasX2, canvasY2);
    }
    ctx.closePath();
  }
  function renderDrafts(ctx, drafts, config2, projection, deviceX, deviceY) {
    const strokeStyle = config2.strokeColor;
    const fillStyle = config2.fillColor;
    const radius = config2.scale;
    const lineWidth = config2.strokeWeight;
    for (const draft of drafts.values()) {
      const position = draft.draft.coordinates[0];
      const pixel = projection.fromLatLngToDivPixel(position);
      const x = pixel.x - deviceX;
      const y = pixel.y - deviceY;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fillStyle = fillStyle;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x, y, radius + 2, 0, 2 * Math.PI);
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = strokeStyle;
      ctx.stroke();
    }
  }
  function renderCircle(ctx, center, config2, projection, pixelsPerMeter, deviceX, deviceY) {
    const {
      strokeColor,
      radius: radiusMeters,
      strokeWeight,
      dashRatio,
      dashLength
    } = config2;
    const radius = radiusMeters * pixelsPerMeter;
    const { x, y } = projection.fromLatLngToDivPixel(center);
    const centerX = x - deviceX;
    const centerY = y - deviceY;
    const circumference = 2 * Math.PI * radius;
    const targetUnitLength = dashLength * (1 + 1 / dashRatio);
    const numberOfUnits = Math.max(
      1,
      Math.round(circumference / targetUnitLength)
    );
    const actualUnitLength = circumference / numberOfUnits;
    const dashPx = actualUnitLength * (dashRatio / (dashRatio + 1));
    const gapPx = actualUnitLength - dashPx;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.setLineDash([dashPx, gapPx]);
    ctx.lineWidth = strokeWeight;
    ctx.strokeStyle = strokeColor;
    ctx.lineCap = "round";
    ctx.stroke();
  }

  // source/drafts-overlay.ts
  function createDefaultViewConfig() {
    const cell = {
      strokeColor: "rgba(240, 252, 249, 0.7)",
      strokeWeight: 4,
      dashLength: 30,
      dashRatio: 2,
      fillColor: "",
      fill: false
    };
    const cell17 = {
      strokeColor: "",
      strokeWeight: 0,
      dashLength: 30,
      dashRatio: 2,
      fillColor: "rgba(240, 252, 249, 0.4)",
      fill: true
    };
    return {
      minDetailZoom: 16,
      baseZIndex: 3100,
      draftMarker: {
        scale: 9,
        fillColor: "#00ffb380",
        strokeColor: "#ffffff80",
        strokeWeight: 2,
        label: {
          fillColor: "#FFFFBB",
          fontSize: "11px",
          className: drafts_overlay_default.label
        }
      },
      selected: {
        tooClose: {
          radius: 20,
          strokeColor: "rgb(240, 252, 249)",
          strokeWeight: 2,
          dashLength: 30,
          dashRatio: 3
        },
        submissionDistance: {
          radius: 10 * 1e3,
          strokeColor: "rgb(231, 18, 196)",
          strokeWeight: 5,
          dashLength: 50,
          dashRatio: 3
        },
        cell: {
          14: cell,
          16: cell,
          17: cell17
        }
      }
    };
  }
  function createOptionsCache(config2) {
    return {
      draftMarkerOptions: {
        zIndex: config2.baseZIndex,
        icon: {
          ...config2.draftMarker,
          labelOrigin: new google.maps.Point(0, 2),
          path: 0,
          fillOpacity: 1,
          strokeOpacity: 1
        }
      },
      draftMarkerLabel: {
        ...config2.draftMarker.label,
        text: "",
        color: config2.draftMarker.label.fillColor
      }
    };
  }
  function notifyDraftListUpdated(overlay) {
    overlay.asyncRouteListUpdateScope(async (_signal) => {
      const drafts = [];
      for (const v of overlay.drafts.values()) {
        drafts.push(v.draft);
      }
      overlay.events.dispatchEvent(
        createTypedCustomEvent("drafts-updated", drafts)
      );
    });
  }
  function getPosition(draft) {
    return draft.coordinates[0];
  }
  function includesIn(bounds, draft) {
    return bounds.contains(getPosition(draft));
  }
  function addDraft(overlay, draft) {
    overlay.drafts.set(draft.id, {
      draft,
      mapView: createMapView(overlay, draft)
    });
  }
  function deleteDraftCore(overlay, draftId) {
    const draftWithView = overlay.drafts.get(draftId);
    if (draftWithView) {
      draftWithView.mapView.marker.setMap(null);
      overlay.drafts.delete(draftId);
      if (overlay.selectedDraftId.contents === draftId) {
        overlay.selectedDraftId.contents = null;
        updateSelectedView(overlay);
      }
      notifyDraftListUpdated(overlay);
    }
  }
  function updateSelectedView(overlay) {
    overlay.draftsCanvasOverlay.draw();
  }
  function createMapView(overlay, draft) {
    const label = {
      ...overlay.cachedOptions.draftMarkerLabel,
      text: draft.name
    };
    const marker = new google.maps.Marker(
      overlay.cachedOptions.draftMarkerOptions
    );
    marker.setPosition(getPosition(draft));
    marker.setLabel(label);
    marker.addListener("click", () => {
      overlay.select(draft.id);
    });
    marker.addListener("dragend", () => {
      const newPosition = marker.getPosition();
      if (newPosition == null) return;
      draft.coordinates = [
        { lat: newPosition.lat(), lng: newPosition.lng() }
      ];
      overlay.updateDraftCoordinates(draft);
      overlay.events.dispatchEvent(
        createTypedCustomEvent("draft-updated", draft.id)
      );
    });
    return {
      label,
      marker
    };
  }
  function isNeedDetail(map2, config2) {
    return config2.minDetailZoom <= (map2.getZoom() ?? 0);
  }
  function updateMapView(overlay, { mapView, draft }) {
    const needDetail = isNeedDetail(overlay.map, overlay.config);
    const hasDetail = mapView.marker.getMap() != null;
    if (needDetail !== hasDetail) {
      if (needDetail) {
        mapView.marker.setMap(overlay.map);
      } else {
        mapView.marker.setLabel(null);
      }
    }
    mapView.marker.setDraggable(overlay.selectedDraftId.contents === draft.id);
  }
  function deleteDetailView(overlay, view) {
    overlay.addedMapViews.delete(view);
    view.marker.setMap(null);
  }
  async function renderDraftsInMap(overlay, scheduler) {
    const { drafts, map: map2 } = overlay;
    const bounds = map2.getBounds();
    if (bounds == null) return;
    const needDetail = isNeedDetail(overlay.map, overlay.config);
    if (!needDetail) {
      for (const oldView of overlay.addedMapViews) {
        deleteDetailView(overlay, oldView);
      }
      return;
    }
    const viewToDrafts = /* @__PURE__ */ new Map();
    const visibleBounds = padBounds(bounds, 0.2);
    for (const view of drafts.values()) {
      if (includesIn(visibleBounds, view.draft)) {
        viewToDrafts.set(view.mapView, view);
      }
    }
    for (const view of viewToDrafts.values()) {
      await scheduler.yield();
      updateMapView(overlay, view);
    }
    for (const oldView of overlay.addedMapViews) {
      await scheduler.yield();
      if (viewToDrafts.has(oldView)) {
        viewToDrafts.delete(oldView);
      } else {
        deleteDetailView(overlay, oldView);
      }
    }
    for (const view of viewToDrafts.keys()) {
      await scheduler.yield();
      view.marker.setMap(overlay.map);
      overlay.addedMapViews.add(view);
    }
  }
  function notifyMapRangeChanged(overlay) {
    overlay.asyncRenderDraftsInMapScope(async (signal) => {
      await sleep(100, { signal });
      const scheduler = createScheduler(signal);
      return await renderDraftsInMap(overlay, scheduler);
    });
  }
  function createDraftsOverlay(map2, asyncErrorHandler) {
    const config2 = createDefaultViewConfig();
    const drafts = /* @__PURE__ */ new Map();
    const selectedDraftId = { contents: null };
    const draftsCanvasOverlay = createCanvasOverlay(
      drafts,
      config2,
      selectedDraftId
    );
    return {
      events: createTypedEventTarget(),
      config: config2,
      cachedOptions: createOptionsCache(config2),
      map: map2,
      drafts,
      selectedDraftId,
      draftsCanvasOverlay,
      addedMapViews: /* @__PURE__ */ new Set(),
      asyncRouteListUpdateScope: createAsyncCancelScope(asyncErrorHandler),
      asyncRenderDraftsInMapScope: createAsyncCancelScope(asyncErrorHandler),
      updateDraftTitle(draft) {
        const draftWithView = this.drafts.get(draft.id);
        if (draftWithView) {
          draftWithView.draft.name = draft.name;
          draftWithView.mapView.marker.setLabel({
            ...draftWithView.mapView.label,
            text: draft.name
          });
          notifyMapRangeChanged(this);
        }
      },
      updateDraftCoordinates(draft) {
        const draftWithView = this.drafts.get(draft.id);
        if (draftWithView) {
          draftWithView.draft.coordinates = draft.coordinates;
          draftWithView.mapView.marker.setPosition(getPosition(draft));
          if (this.selectedDraftId.contents === draft.id) {
            updateSelectedView(this);
          }
          notifyMapRangeChanged(this);
        }
      },
      async addDrafts(drafts2, scheduler) {
        for (const draft of drafts2) {
          await scheduler.yield();
          addDraft(this, draft);
        }
        notifyDraftListUpdated(this);
        notifyMapRangeChanged(this);
      },
      addDraft(draft) {
        addDraft(this, draft);
        notifyDraftListUpdated(this);
        notifyMapRangeChanged(this);
      },
      deleteDraft(draftId) {
        deleteDraftCore(this, draftId);
        notifyMapRangeChanged(this);
      },
      select(draftId) {
        const draft = this.drafts.get(draftId)?.draft;
        if (draft == null) return;
        this.selectedDraftId.contents = draft.id;
        updateSelectedView(this);
        this.events.dispatchEvent(
          createTypedCustomEvent("selection-changed", draft.id)
        );
        notifyMapRangeChanged(this);
      }
    };
  }
  async function setupDraftsOverlay(overlay, local, scheduler) {
    const style = document.createElement("style");
    style.textContent = cssText2;
    document.body.append(style);
    overlay.draftsCanvasOverlay.setMap(overlay.map);
    overlay.map.addListener("idle", () => notifyMapRangeChanged(overlay));
    notifyMapRangeChanged(overlay);
    const { userId, apiRoot } = local.getConfig();
    if (userId && apiRoot) {
      const { routes } = await getDrafts(
        {
          "user-id": userId
        },
        { rootUrl: apiRoot }
      );
      const drafts = routes.map((route) => ({
        ...route,
        coordinates: parseCoordinates(route.coordinates),
        id: route.routeId,
        name: route.routeName
      }));
      await overlay.addDrafts(drafts, scheduler);
    }
  }

  // inline-worker:__inline-worker
  function inlineWorker(scriptText) {
    let blob = new Blob([scriptText], { type: "text/javascript" });
    let url2 = URL.createObjectURL(blob);
    let worker = new Worker(url2);
    URL.revokeObjectURL(url2);
    return worker;
  }

  // source/poi-records.worker.ts?worker
  function Worker2() {
    return inlineWorker('var nu=Object.defineProperty,Td=Object.defineProperties;var wd=Object.getOwnPropertyDescriptors;var Lt=Object.getOwnPropertySymbols;var ou=Object.prototype.hasOwnProperty,iu=Object.prototype.propertyIsEnumerable;var dn=(e,r)=>(r=Symbol[e])?r:Symbol.for("Symbol."+e),Pd=e=>{throw TypeError(e)};var ru=(e,r,n)=>r in e?nu(e,r,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[r]=n,f=(e,r)=>{for(var n in r||(r={}))ou.call(r,n)&&ru(e,n,r[n]);if(Lt)for(var n of Lt(r))iu.call(r,n)&&ru(e,n,r[n]);return e},I=(e,r)=>Td(e,wd(r));var au=(e,r)=>{var n={};for(var o in e)ou.call(e,o)&&r.indexOf(o)<0&&(n[o]=e[o]);if(e!=null&&Lt)for(var o of Lt(e))r.indexOf(o)<0&&iu.call(e,o)&&(n[o]=e[o]);return n};var ve=(e,r)=>{for(var n in r)nu(e,n,{get:r[n],enumerable:!0})};var Dd=function(e,r){this[0]=e,this[1]=r};var ue=e=>{var r=e[dn("asyncIterator")],n=!1,o,t={};return r==null?(r=e[dn("iterator")](),o=a=>t[a]=c=>r[a](c)):(r=r.call(e),o=a=>t[a]=c=>{if(n){if(n=!1,a==="throw")throw c;return c}return n=!0,{done:!1,value:new Dd(new Promise(m=>{var s=r[a](c);s instanceof Object||Pd("Object expected"),m(s)}),1)}}),t[dn("iterator")]=()=>t,o("next"),"throw"in r?o("throw"):t.throw=a=>{throw a},"return"in r&&o("return"),t};var uu=Symbol("Comlink.proxy"),jd=Symbol("Comlink.endpoint"),Od=Symbol("Comlink.releaseProxy"),mn=Symbol("Comlink.finalizer"),Rt=Symbol("Comlink.thrown"),lu=e=>typeof e=="object"&&e!==null||typeof e=="function",Ud={canHandle:e=>lu(e)&&e[uu],serialize(e){let{port1:r,port2:n}=new MessageChannel;return Vt(e,r),[n,[n]]},deserialize(e){return e.start(),fn(e)}},Nd={canHandle:e=>lu(e)&&Rt in e,serialize({value:e}){let r;return e instanceof Error?r={isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:r={isError:!1,value:e},[r,[]]},deserialize(e){throw e.isError?Object.assign(new Error(e.value.message),e.value):e.value}},su=new Map([["proxy",Ud],["throw",Nd]]);function Ed(e,r){for(let n of e)if(r===n||n==="*"||n instanceof RegExp&&n.test(r))return!0;return!1}function Vt(e,r=globalThis,n=["*"]){r.addEventListener("message",function o(t){if(!t||!t.data)return;if(!Ed(n,t.origin)){console.warn(`Invalid origin \'${t.origin}\' for comlink proxy`);return}let{id:a,type:c,path:m}=Object.assign({path:[]},t.data),s=(t.data.argumentList||[]).map(Te),u;try{let d=m.slice(0,-1).reduce((l,p)=>l[p],e),i=m.reduce((l,p)=>l[p],e);switch(c){case"GET":u=i;break;case"SET":d[m.slice(-1)[0]]=Te(t.data.value),u=!0;break;case"APPLY":u=i.apply(d,s);break;case"CONSTRUCT":{let l=new i(...s);u=Md(l)}break;case"ENDPOINT":{let{port1:l,port2:p}=new MessageChannel;Vt(e,p),u=Ad(l,[l])}break;case"RELEASE":u=void 0;break;default:return}}catch(d){u={value:d,[Rt]:0}}Promise.resolve(u).catch(d=>({value:d,[Rt]:0})).then(d=>{let[i,l]=Ft(d);r.postMessage(Object.assign(Object.assign({},i),{id:a}),l),c==="RELEASE"&&(r.removeEventListener("message",o),du(r),mn in e&&typeof e[mn]=="function"&&e[mn]())}).catch(d=>{let[i,l]=Ft({value:new TypeError("Unserializable return value"),[Rt]:0});r.postMessage(Object.assign(Object.assign({},i),{id:a}),l)})}),r.start&&r.start()}function Zd(e){return e.constructor.name==="MessagePort"}function du(e){Zd(e)&&e.close()}function fn(e,r){let n=new Map;return e.addEventListener("message",function(t){let{data:a}=t;if(!a||!a.id)return;let c=n.get(a.id);if(c)try{c(a)}finally{n.delete(a.id)}}),pn(e,n,[],r)}function Ct(e){if(e)throw new Error("Proxy has been released and is not useable")}function mu(e){return Ze(e,new Map,{type:"RELEASE"}).then(()=>{du(e)})}var At=new WeakMap,Mt="FinalizationRegistry"in globalThis&&new FinalizationRegistry(e=>{let r=(At.get(e)||0)-1;At.set(e,r),r===0&&mu(e)});function Ld(e,r){let n=(At.get(r)||0)+1;At.set(r,n),Mt&&Mt.register(e,r,e)}function Cd(e){Mt&&Mt.unregister(e)}function pn(e,r,n=[],o=function(){}){let t=!1,a=new Proxy(o,{get(c,m){if(Ct(t),m===Od)return()=>{Cd(a),mu(e),r.clear(),t=!0};if(m==="then"){if(n.length===0)return{then:()=>a};let s=Ze(e,r,{type:"GET",path:n.map(u=>u.toString())}).then(Te);return s.then.bind(s)}return pn(e,r,[...n,m])},set(c,m,s){Ct(t);let[u,d]=Ft(s);return Ze(e,r,{type:"SET",path:[...n,m].map(i=>i.toString()),value:u},d).then(Te)},apply(c,m,s){Ct(t);let u=n[n.length-1];if(u===jd)return Ze(e,r,{type:"ENDPOINT"}).then(Te);if(u==="bind")return pn(e,r,n.slice(0,-1));let[d,i]=cu(s);return Ze(e,r,{type:"APPLY",path:n.map(l=>l.toString()),argumentList:d},i).then(Te)},construct(c,m){Ct(t);let[s,u]=cu(m);return Ze(e,r,{type:"CONSTRUCT",path:n.map(d=>d.toString()),argumentList:s},u).then(Te)}});return Ld(a,e),a}function Rd(e){return Array.prototype.concat.apply([],e)}function cu(e){let r=e.map(Ft);return[r.map(n=>n[0]),Rd(r.map(n=>n[1]))]}var pu=new WeakMap;function Ad(e,r){return pu.set(e,r),e}function Md(e){return Object.assign(e,{[uu]:!0})}function Ft(e){for(let[r,n]of su)if(n.canHandle(e)){let[o,t]=n.serialize(e);return[{type:"HANDLER",name:r,value:o},t]}return[{type:"RAW",value:e},pu.get(e)||[]]}function Te(e){switch(e.type){case"HANDLER":return su.get(e.name).deserialize(e.value);case"RAW":return e.value}}function Ze(e,r,n,o){return new Promise(t=>{let a=Fd();r.set(a,t),e.start&&e.start(),e.postMessage(Object.assign({id:a},n),o)})}function Fd(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}function fu(e,r,{batchSize:n=10}={}){let o=[],t=!1,a=!1;function c(d){o.push(d),m()}function m(){a||(a=!0,queueMicrotask(()=>{a=!1,s().catch(r)}))}async function s(){if(t||o.length===0)return;t=!0;let d=o.splice(0,n);try{await e(d)}finally{t=!1,o.length&&m()}}function u(){o.length=0}return{push:c,close:u}}function gu(){return typeof window=="undefined"&&typeof self!="undefined"}function Kd(e,r){let n=performance.now(),o=null;return e.addEventListener("abort",()=>{o!=null&&(cancelAnimationFrame(o),o=null)},{once:!0}),{get isYieldRequested(){var a,c;return(c=(a=navigator.scheduling)==null?void 0:a.isInputPending)!=null&&c.call(a)?!0:performance.now()-n>=r},yield(){return this.isYieldRequested?new Promise(t=>{o=requestAnimationFrame(()=>{n=performance.now(),t()})}):null}}}function Jd(){return{isYieldRequested:!1,yield(){return null}}}function vu(e,r=10){return gu()?Jd():Kd(e,r)}var pe={};ve(pe,{$ZodAny:()=>ei,$ZodArray:()=>ii,$ZodAsyncError:()=>ne,$ZodBase64:()=>Ko,$ZodBase64URL:()=>Jo,$ZodBigInt:()=>gr,$ZodBigIntFormat:()=>Xo,$ZodBoolean:()=>dt,$ZodCIDRv4:()=>Mo,$ZodCIDRv6:()=>Fo,$ZodCUID:()=>Po,$ZodCUID2:()=>Do,$ZodCatch:()=>Si,$ZodCheck:()=>L,$ZodCheckBigIntFormat:()=>oo,$ZodCheckEndsWith:()=>ho,$ZodCheckGreaterThan:()=>ur,$ZodCheckIncludes:()=>go,$ZodCheckLengthEquals:()=>so,$ZodCheckLessThan:()=>cr,$ZodCheckLowerCase:()=>po,$ZodCheckMaxLength:()=>uo,$ZodCheckMaxSize:()=>io,$ZodCheckMimeType:()=>$o,$ZodCheckMinLength:()=>lo,$ZodCheckMinSize:()=>ao,$ZodCheckMultipleOf:()=>ro,$ZodCheckNumberFormat:()=>no,$ZodCheckOverwrite:()=>bo,$ZodCheckProperty:()=>yo,$ZodCheckRegex:()=>mo,$ZodCheckSizeEquals:()=>co,$ZodCheckStartsWith:()=>vo,$ZodCheckStringFormat:()=>Ke,$ZodCheckUpperCase:()=>fo,$ZodCodec:()=>pt,$ZodCustom:()=>ji,$ZodCustomStringFormat:()=>Wo,$ZodDate:()=>oi,$ZodDefault:()=>$i,$ZodDiscriminatedUnion:()=>ui,$ZodE164:()=>Bo,$ZodEmail:()=>Io,$ZodEmoji:()=>To,$ZodEncodeError:()=>he,$ZodEnum:()=>pi,$ZodError:()=>ct,$ZodExactOptional:()=>hi,$ZodFile:()=>gi,$ZodFunction:()=>wi,$ZodGUID:()=>So,$ZodIPv4:()=>Co,$ZodIPv6:()=>Ro,$ZodISODate:()=>Eo,$ZodISODateTime:()=>No,$ZodISODuration:()=>Lo,$ZodISOTime:()=>Zo,$ZodIntersection:()=>li,$ZodJWT:()=>Go,$ZodKSUID:()=>Uo,$ZodLazy:()=>Di,$ZodLiteral:()=>fi,$ZodMAC:()=>Ao,$ZodMap:()=>di,$ZodNaN:()=>ki,$ZodNanoID:()=>wo,$ZodNever:()=>ri,$ZodNonOptional:()=>xi,$ZodNull:()=>Ho,$ZodNullable:()=>yi,$ZodNumber:()=>fr,$ZodNumberFormat:()=>qo,$ZodObject:()=>Ju,$ZodObjectJIT:()=>ai,$ZodOptional:()=>hr,$ZodPipe:()=>Ii,$ZodPrefault:()=>bi,$ZodPromise:()=>Pi,$ZodReadonly:()=>zi,$ZodRealError:()=>G,$ZodRecord:()=>si,$ZodRegistry:()=>xr,$ZodSet:()=>mi,$ZodString:()=>De,$ZodStringFormat:()=>Z,$ZodSuccess:()=>_i,$ZodSymbol:()=>Qo,$ZodTemplateLiteral:()=>Ti,$ZodTransform:()=>vi,$ZodTuple:()=>vr,$ZodType:()=>P,$ZodULID:()=>jo,$ZodURL:()=>zo,$ZodUUID:()=>ko,$ZodUndefined:()=>Yo,$ZodUnion:()=>mt,$ZodUnknown:()=>ti,$ZodVoid:()=>ni,$ZodXID:()=>Oo,$ZodXor:()=>ci,$brand:()=>gn,$constructor:()=>g,$input:()=>Jl,$output:()=>Kl,Doc:()=>st,JSONSchema:()=>cc,JSONSchemaGenerator:()=>Jr,NEVER:()=>Kt,TimePrecision:()=>Bl,_any:()=>ra,_array:()=>fa,_base64:()=>Cr,_base64url:()=>Rr,_bigint:()=>qi,_boolean:()=>Gi,_catch:()=>mf,_check:()=>Gl,_cidrv4:()=>Zr,_cidrv6:()=>Lr,_coercedBigint:()=>Xi,_coercedBoolean:()=>Wi,_coercedDate:()=>ca,_coercedNumber:()=>Mi,_coercedString:()=>Ni,_cuid:()=>Pr,_cuid2:()=>Dr,_custom:()=>va,_date:()=>aa,_decode:()=>Yt,_decodeAsync:()=>er,_default:()=>lf,_discriminatedUnion:()=>Xp,_e164:()=>Ar,_email:()=>_r,_emoji:()=>Tr,_encode:()=>Qt,_encodeAsync:()=>Ht,_endsWith:()=>_t,_enum:()=>rf,_file:()=>ga,_float32:()=>Vi,_float64:()=>Ki,_gt:()=>de,_gte:()=>W,_guid:()=>gt,_includes:()=>bt,_int:()=>Fi,_int32:()=>Ji,_int64:()=>Qi,_intersection:()=>Qp,_ipv4:()=>Nr,_ipv6:()=>Er,_isoDate:()=>Li,_isoDateTime:()=>Zi,_isoDuration:()=>Ri,_isoTime:()=>Ci,_jwt:()=>Mr,_ksuid:()=>Ur,_lazy:()=>vf,_length:()=>qe,_literal:()=>of,_lowercase:()=>yt,_lt:()=>se,_lte:()=>te,_mac:()=>Ei,_map:()=>ef,_max:()=>te,_maxLength:()=>We,_maxSize:()=>Oe,_mime:()=>St,_min:()=>W,_minLength:()=>_e,_minSize:()=>me,_multipleOf:()=>je,_nan:()=>ua,_nanoid:()=>wr,_nativeEnum:()=>nf,_negative:()=>sa,_never:()=>oa,_nonnegative:()=>ma,_nonoptional:()=>sf,_nonpositive:()=>da,_normalize:()=>kt,_null:()=>ta,_nullable:()=>uf,_number:()=>Ai,_optional:()=>cf,_overwrite:()=>ie,_parse:()=>Ae,_parseAsync:()=>Me,_pipe:()=>pf,_positive:()=>la,_promise:()=>hf,_property:()=>pa,_readonly:()=>ff,_record:()=>Hp,_refine:()=>ha,_regex:()=>ht,_safeDecode:()=>rr,_safeDecodeAsync:()=>or,_safeEncode:()=>tr,_safeEncodeAsync:()=>nr,_safeParse:()=>Fe,_safeParseAsync:()=>Ve,_set:()=>tf,_size:()=>Ge,_slugify:()=>wt,_startsWith:()=>xt,_string:()=>Ui,_stringFormat:()=>Xe,_stringbool:()=>xa,_success:()=>df,_superRefine:()=>ya,_symbol:()=>Hi,_templateLiteral:()=>gf,_toLowerCase:()=>zt,_toUpperCase:()=>Tt,_transform:()=>af,_trim:()=>It,_tuple:()=>Yp,_uint32:()=>Bi,_uint64:()=>Yi,_ulid:()=>jr,_undefined:()=>ea,_union:()=>Wp,_unknown:()=>na,_uppercase:()=>$t,_url:()=>vt,_uuid:()=>Sr,_uuidv4:()=>kr,_uuidv6:()=>Ir,_uuidv7:()=>zr,_void:()=>ia,_xid:()=>Or,_xor:()=>qp,clone:()=>J,config:()=>M,createStandardJSONSchemaMethod:()=>Qe,createToJSONSchemaMethod:()=>_a,decode:()=>$m,decodeAsync:()=>xm,describe:()=>$a,encode:()=>ym,encodeAsync:()=>bm,extractDefs:()=>ke,finalize:()=>Ie,flattenError:()=>Gt,formatError:()=>Wt,globalConfig:()=>et,globalRegistry:()=>F,initializeContext:()=>Se,isValidBase64:()=>Vo,isValidBase64URL:()=>Mu,isValidJWT:()=>Fu,locales:()=>Be,meta:()=>ba,parse:()=>qt,parseAsync:()=>Xt,prettifyError:()=>Su,process:()=>E,regexes:()=>ee,registry:()=>Oi,safeDecode:()=>Sm,safeDecodeAsync:()=>Im,safeEncode:()=>_m,safeEncodeAsync:()=>km,safeParse:()=>zn,safeParseAsync:()=>Tn,toDotPath:()=>_u,toJSONSchema:()=>ac,treeifyError:()=>xu,util:()=>x,version:()=>xo});var Kt=Object.freeze({status:"aborted"});function g(e,r,n){var m;function o(s,u){if(s._zod||Object.defineProperty(s,"_zod",{value:{def:u,constr:c,traits:new Set},enumerable:!1}),s._zod.traits.has(e))return;s._zod.traits.add(e),r(s,u);let d=c.prototype,i=Object.keys(d);for(let l=0;l<i.length;l++){let p=i[l];p in s||(s[p]=d[p].bind(s))}}let t=(m=n==null?void 0:n.Parent)!=null?m:Object;class a extends t{}Object.defineProperty(a,"name",{value:e});function c(s){var i;var u;let d=n!=null&&n.Parent?new a:this;o(d,s),(i=(u=d._zod).deferred)!=null||(u.deferred=[]);for(let l of d._zod.deferred)l();return d}return Object.defineProperty(c,"init",{value:o}),Object.defineProperty(c,Symbol.hasInstance,{value:s=>{var u,d;return n!=null&&n.Parent&&s instanceof n.Parent?!0:(d=(u=s==null?void 0:s._zod)==null?void 0:u.traits)==null?void 0:d.has(e)}}),Object.defineProperty(c,"name",{value:e}),c}var gn=Symbol("zod_brand"),ne=class extends Error{constructor(){super("Encountered Promise during synchronous parse. Use .parseAsync() instead.")}},he=class extends Error{constructor(r){super(`Encountered unidirectional transform during encode: ${r}`),this.name="ZodEncodeError"}},et={};function M(e){return e&&Object.assign(et,e),et}var x={};ve(x,{BIGINT_FORMAT_RANGES:()=>In,Class:()=>hn,NUMBER_FORMAT_RANGES:()=>kn,aborted:()=>xe,allowsEval:()=>bn,assert:()=>Xd,assertEqual:()=>Bd,assertIs:()=>Wd,assertNever:()=>qd,assertNotEqual:()=>Gd,assignProp:()=>$e,base64ToUint8Array:()=>yu,base64urlToUint8Array:()=>pm,cached:()=>Ce,captureStackTrace:()=>Bt,cleanEnum:()=>mm,cleanRegex:()=>nt,clone:()=>J,cloneDef:()=>Yd,createTransparentProxy:()=>om,defineLazy:()=>O,esc:()=>Jt,escapeRegex:()=>H,extend:()=>cm,finalizeIssue:()=>B,floatSafeRemainder:()=>yn,getElementAtPath:()=>Hd,getEnumValues:()=>rt,getLengthableOrigin:()=>at,getParsedType:()=>nm,getSizableOrigin:()=>it,hexToUint8Array:()=>gm,isObject:()=>we,isPlainObject:()=>be,issue:()=>Re,joinValues:()=>h,jsonStringifyReplacer:()=>Le,merge:()=>lm,mergeDefs:()=>le,normalizeParams:()=>_,nullish:()=>ye,numKeys:()=>rm,objectClone:()=>Qd,omit:()=>am,optionalKeys:()=>Sn,parsedType:()=>b,partial:()=>sm,pick:()=>im,prefixIssues:()=>q,primitiveTypes:()=>_n,promiseAllObject:()=>em,propertyKeyTypes:()=>ot,randomString:()=>tm,required:()=>dm,safeExtend:()=>um,shallowClone:()=>xn,slugify:()=>$n,stringifyPrimitive:()=>$,uint8ArrayToBase64:()=>$u,uint8ArrayToBase64url:()=>fm,uint8ArrayToHex:()=>vm,unwrapMessage:()=>tt});function Bd(e){return e}function Gd(e){return e}function Wd(e){}function qd(e){throw new Error("Unexpected value in exhaustive check")}function Xd(e){}function rt(e){let r=Object.values(e).filter(o=>typeof o=="number");return Object.entries(e).filter(([o,t])=>r.indexOf(+o)===-1).map(([o,t])=>t)}function h(e,r="|"){return e.map(n=>$(n)).join(r)}function Le(e,r){return typeof r=="bigint"?r.toString():r}function Ce(e){return{get value(){{let n=e();return Object.defineProperty(this,"value",{value:n}),n}throw new Error("cached value already set")}}}function ye(e){return e==null}function nt(e){let r=e.startsWith("^")?1:0,n=e.endsWith("$")?e.length-1:e.length;return e.slice(r,n)}function yn(e,r){let n=(e.toString().split(".")[1]||"").length,o=r.toString(),t=(o.split(".")[1]||"").length;if(t===0&&/\\d?e-\\d?/.test(o)){let s=o.match(/\\d?e-(\\d?)/);s!=null&&s[1]&&(t=Number.parseInt(s[1]))}let a=n>t?n:t,c=Number.parseInt(e.toFixed(a).replace(".","")),m=Number.parseInt(r.toFixed(a).replace(".",""));return c%m/10**a}var hu=Symbol("evaluating");function O(e,r,n){let o;Object.defineProperty(e,r,{get(){if(o!==hu)return o===void 0&&(o=hu,o=n()),o},set(t){Object.defineProperty(e,r,{value:t})},configurable:!0})}function Qd(e){return Object.create(Object.getPrototypeOf(e),Object.getOwnPropertyDescriptors(e))}function $e(e,r,n){Object.defineProperty(e,r,{value:n,writable:!0,enumerable:!0,configurable:!0})}function le(...e){let r={};for(let n of e){let o=Object.getOwnPropertyDescriptors(n);Object.assign(r,o)}return Object.defineProperties({},r)}function Yd(e){return le(e._zod.def)}function Hd(e,r){return r?r.reduce((n,o)=>n==null?void 0:n[o],e):e}function em(e){let r=Object.keys(e),n=r.map(o=>e[o]);return Promise.all(n).then(o=>{let t={};for(let a=0;a<r.length;a++)t[r[a]]=o[a];return t})}function tm(e=10){let r="abcdefghijklmnopqrstuvwxyz",n="";for(let o=0;o<e;o++)n+=r[Math.floor(Math.random()*r.length)];return n}function Jt(e){return JSON.stringify(e)}function $n(e){return e.toLowerCase().trim().replace(/[^\\w\\s-]/g,"").replace(/[\\s_-]+/g,"-").replace(/^-+|-+$/g,"")}var Bt="captureStackTrace"in Error?Error.captureStackTrace:(...e)=>{};function we(e){return typeof e=="object"&&e!==null&&!Array.isArray(e)}var bn=Ce(()=>{var e;if(typeof navigator!="undefined"&&((e=navigator==null?void 0:navigator.userAgent)!=null&&e.includes("Cloudflare")))return!1;try{let r=Function;return new r(""),!0}catch(r){return!1}});function be(e){if(we(e)===!1)return!1;let r=e.constructor;if(r===void 0||typeof r!="function")return!0;let n=r.prototype;return!(we(n)===!1||Object.prototype.hasOwnProperty.call(n,"isPrototypeOf")===!1)}function xn(e){return be(e)?f({},e):Array.isArray(e)?[...e]:e}function rm(e){let r=0;for(let n in e)Object.prototype.hasOwnProperty.call(e,n)&&r++;return r}var nm=e=>{let r=typeof e;switch(r){case"undefined":return"undefined";case"string":return"string";case"number":return Number.isNaN(e)?"nan":"number";case"boolean":return"boolean";case"function":return"function";case"bigint":return"bigint";case"symbol":return"symbol";case"object":return Array.isArray(e)?"array":e===null?"null":e.then&&typeof e.then=="function"&&e.catch&&typeof e.catch=="function"?"promise":typeof Map!="undefined"&&e instanceof Map?"map":typeof Set!="undefined"&&e instanceof Set?"set":typeof Date!="undefined"&&e instanceof Date?"date":typeof File!="undefined"&&e instanceof File?"file":"object";default:throw new Error(`Unknown data type: ${r}`)}},ot=new Set(["string","number","symbol"]),_n=new Set(["string","number","bigint","boolean","symbol","undefined"]);function H(e){return e.replace(/[.*+?^${}()|[\\]\\\\]/g,"\\\\$&")}function J(e,r,n){let o=new e._zod.constr(r!=null?r:e._zod.def);return(!r||n!=null&&n.parent)&&(o._zod.parent=e),o}function _(e){let r=e;if(!r)return{};if(typeof r=="string")return{error:()=>r};if((r==null?void 0:r.message)!==void 0){if((r==null?void 0:r.error)!==void 0)throw new Error("Cannot specify both `message` and `error` params");r.error=r.message}return delete r.message,typeof r.error=="string"?I(f({},r),{error:()=>r.error}):r}function om(e){let r;return new Proxy({},{get(n,o,t){return r!=null||(r=e()),Reflect.get(r,o,t)},set(n,o,t,a){return r!=null||(r=e()),Reflect.set(r,o,t,a)},has(n,o){return r!=null||(r=e()),Reflect.has(r,o)},deleteProperty(n,o){return r!=null||(r=e()),Reflect.deleteProperty(r,o)},ownKeys(n){return r!=null||(r=e()),Reflect.ownKeys(r)},getOwnPropertyDescriptor(n,o){return r!=null||(r=e()),Reflect.getOwnPropertyDescriptor(r,o)},defineProperty(n,o,t){return r!=null||(r=e()),Reflect.defineProperty(r,o,t)}})}function $(e){return typeof e=="bigint"?e.toString()+"n":typeof e=="string"?`"${e}"`:`${e}`}function Sn(e){return Object.keys(e).filter(r=>e[r]._zod.optin==="optional"&&e[r]._zod.optout==="optional")}var kn={safeint:[Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER],int32:[-2147483648,2147483647],uint32:[0,4294967295],float32:[-34028234663852886e22,34028234663852886e22],float64:[-Number.MAX_VALUE,Number.MAX_VALUE]},In={int64:[BigInt("-9223372036854775808"),BigInt("9223372036854775807")],uint64:[BigInt(0),BigInt("18446744073709551615")]};function im(e,r){let n=e._zod.def,o=n.checks;if(o&&o.length>0)throw new Error(".pick() cannot be used on object schemas containing refinements");let a=le(e._zod.def,{get shape(){let c={};for(let m in r){if(!(m in n.shape))throw new Error(`Unrecognized key: "${m}"`);r[m]&&(c[m]=n.shape[m])}return $e(this,"shape",c),c},checks:[]});return J(e,a)}function am(e,r){let n=e._zod.def,o=n.checks;if(o&&o.length>0)throw new Error(".omit() cannot be used on object schemas containing refinements");let a=le(e._zod.def,{get shape(){let c=f({},e._zod.def.shape);for(let m in r){if(!(m in n.shape))throw new Error(`Unrecognized key: "${m}"`);r[m]&&delete c[m]}return $e(this,"shape",c),c},checks:[]});return J(e,a)}function cm(e,r){if(!be(r))throw new Error("Invalid input to extend: expected a plain object");let n=e._zod.def.checks;if(n&&n.length>0){let a=e._zod.def.shape;for(let c in r)if(Object.getOwnPropertyDescriptor(a,c)!==void 0)throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.")}let t=le(e._zod.def,{get shape(){let a=f(f({},e._zod.def.shape),r);return $e(this,"shape",a),a}});return J(e,t)}function um(e,r){if(!be(r))throw new Error("Invalid input to safeExtend: expected a plain object");let n=le(e._zod.def,{get shape(){let o=f(f({},e._zod.def.shape),r);return $e(this,"shape",o),o}});return J(e,n)}function lm(e,r){let n=le(e._zod.def,{get shape(){let o=f(f({},e._zod.def.shape),r._zod.def.shape);return $e(this,"shape",o),o},get catchall(){return r._zod.def.catchall},checks:[]});return J(e,n)}function sm(e,r,n){let t=r._zod.def.checks;if(t&&t.length>0)throw new Error(".partial() cannot be used on object schemas containing refinements");let c=le(r._zod.def,{get shape(){let m=r._zod.def.shape,s=f({},m);if(n)for(let u in n){if(!(u in m))throw new Error(`Unrecognized key: "${u}"`);n[u]&&(s[u]=e?new e({type:"optional",innerType:m[u]}):m[u])}else for(let u in m)s[u]=e?new e({type:"optional",innerType:m[u]}):m[u];return $e(this,"shape",s),s},checks:[]});return J(r,c)}function dm(e,r,n){let o=le(r._zod.def,{get shape(){let t=r._zod.def.shape,a=f({},t);if(n)for(let c in n){if(!(c in a))throw new Error(`Unrecognized key: "${c}"`);n[c]&&(a[c]=new e({type:"nonoptional",innerType:t[c]}))}else for(let c in t)a[c]=new e({type:"nonoptional",innerType:t[c]});return $e(this,"shape",a),a}});return J(r,o)}function xe(e,r=0){var n;if(e.aborted===!0)return!0;for(let o=r;o<e.issues.length;o++)if(((n=e.issues[o])==null?void 0:n.continue)!==!0)return!0;return!1}function q(e,r){return r.map(n=>{var t;var o;return(t=(o=n).path)!=null||(o.path=[]),n.path.unshift(e),n})}function tt(e){return typeof e=="string"?e:e==null?void 0:e.message}function B(e,r,n){var t,a,c,m,s,u,d,i,l,p,v;let o=I(f({},e),{path:(t=e.path)!=null?t:[]});if(!e.message){let y=(v=(p=(i=(u=tt((m=(c=(a=e.inst)==null?void 0:a._zod.def)==null?void 0:c.error)==null?void 0:m.call(c,e)))!=null?u:tt((s=r==null?void 0:r.error)==null?void 0:s.call(r,e)))!=null?i:tt((d=n.customError)==null?void 0:d.call(n,e)))!=null?p:tt((l=n.localeError)==null?void 0:l.call(n,e)))!=null?v:"Invalid input";o.message=y}return delete o.inst,delete o.continue,r!=null&&r.reportInput||delete o.input,o}function it(e){return e instanceof Set?"set":e instanceof Map?"map":e instanceof File?"file":"unknown"}function at(e){return Array.isArray(e)?"array":typeof e=="string"?"string":"unknown"}function b(e){let r=typeof e;switch(r){case"number":return Number.isNaN(e)?"nan":"number";case"object":{if(e===null)return"null";if(Array.isArray(e))return"array";let n=e;if(n&&Object.getPrototypeOf(n)!==Object.prototype&&"constructor"in n&&n.constructor)return n.constructor.name}}return r}function Re(...e){let[r,n,o]=e;return typeof r=="string"?{message:r,code:"custom",input:n,inst:o}:f({},r)}function mm(e){return Object.entries(e).filter(([r,n])=>Number.isNaN(Number.parseInt(r,10))).map(r=>r[1])}function yu(e){let r=atob(e),n=new Uint8Array(r.length);for(let o=0;o<r.length;o++)n[o]=r.charCodeAt(o);return n}function $u(e){let r="";for(let n=0;n<e.length;n++)r+=String.fromCharCode(e[n]);return btoa(r)}function pm(e){let r=e.replace(/-/g,"+").replace(/_/g,"/"),n="=".repeat((4-r.length%4)%4);return yu(r+n)}function fm(e){return $u(e).replace(/\\+/g,"-").replace(/\\//g,"_").replace(/=/g,"")}function gm(e){let r=e.replace(/^0x/,"");if(r.length%2!==0)throw new Error("Invalid hex string length");let n=new Uint8Array(r.length/2);for(let o=0;o<r.length;o+=2)n[o/2]=Number.parseInt(r.slice(o,o+2),16);return n}function vm(e){return Array.from(e).map(r=>r.toString(16).padStart(2,"0")).join("")}var hn=class{constructor(...r){}};var bu=(e,r)=>{e.name="$ZodError",Object.defineProperty(e,"_zod",{value:e._zod,enumerable:!1}),Object.defineProperty(e,"issues",{value:r,enumerable:!1}),e.message=JSON.stringify(r,Le,2),Object.defineProperty(e,"toString",{value:()=>e.message,enumerable:!1})},ct=g("$ZodError",bu),G=g("$ZodError",bu,{Parent:Error});function Gt(e,r=n=>n.message){let n={},o=[];for(let t of e.issues)t.path.length>0?(n[t.path[0]]=n[t.path[0]]||[],n[t.path[0]].push(r(t))):o.push(r(t));return{formErrors:o,fieldErrors:n}}function Wt(e,r=n=>n.message){let n={_errors:[]},o=t=>{for(let a of t.issues)if(a.code==="invalid_union"&&a.errors.length)a.errors.map(c=>o({issues:c}));else if(a.code==="invalid_key")o({issues:a.issues});else if(a.code==="invalid_element")o({issues:a.issues});else if(a.path.length===0)n._errors.push(r(a));else{let c=n,m=0;for(;m<a.path.length;){let s=a.path[m];m===a.path.length-1?(c[s]=c[s]||{_errors:[]},c[s]._errors.push(r(a))):c[s]=c[s]||{_errors:[]},c=c[s],m++}}};return o(e),n}function xu(e,r=n=>n.message){let n={errors:[]},o=(t,a=[])=>{var s,u,d,i;var c,m;for(let l of t.issues)if(l.code==="invalid_union"&&l.errors.length)l.errors.map(p=>o({issues:p},l.path));else if(l.code==="invalid_key")o({issues:l.issues},l.path);else if(l.code==="invalid_element")o({issues:l.issues},l.path);else{let p=[...a,...l.path];if(p.length===0){n.errors.push(r(l));continue}let v=n,y=0;for(;y<p.length;){let S=p[y],w=y===p.length-1;typeof S=="string"?((s=v.properties)!=null||(v.properties={}),(u=(c=v.properties)[S])!=null||(c[S]={errors:[]}),v=v.properties[S]):((d=v.items)!=null||(v.items=[]),(i=(m=v.items)[S])!=null||(m[S]={errors:[]}),v=v.items[S]),w&&v.errors.push(r(l)),y++}}};return o(e),n}function _u(e){let r=[],n=e.map(o=>typeof o=="object"?o.key:o);for(let o of n)typeof o=="number"?r.push(`[${o}]`):typeof o=="symbol"?r.push(`[${JSON.stringify(String(o))}]`):/[^\\w$]/.test(o)?r.push(`[${JSON.stringify(o)}]`):(r.length&&r.push("."),r.push(o));return r.join("")}function Su(e){var o;let r=[],n=[...e.issues].sort((t,a)=>{var c,m;return((c=t.path)!=null?c:[]).length-((m=a.path)!=null?m:[]).length});for(let t of n)r.push(`\\u2716 ${t.message}`),(o=t.path)!=null&&o.length&&r.push(`  \\u2192 at ${_u(t.path)}`);return r.join(`\n`)}var Ae=e=>(r,n,o,t)=>{var m;let a=o?Object.assign(o,{async:!1}):{async:!1},c=r._zod.run({value:n,issues:[]},a);if(c instanceof Promise)throw new ne;if(c.issues.length){let s=new((m=t==null?void 0:t.Err)!=null?m:e)(c.issues.map(u=>B(u,a,M())));throw Bt(s,t==null?void 0:t.callee),s}return c.value},qt=Ae(G),Me=e=>async(r,n,o,t)=>{var m;let a=o?Object.assign(o,{async:!0}):{async:!0},c=r._zod.run({value:n,issues:[]},a);if(c instanceof Promise&&(c=await c),c.issues.length){let s=new((m=t==null?void 0:t.Err)!=null?m:e)(c.issues.map(u=>B(u,a,M())));throw Bt(s,t==null?void 0:t.callee),s}return c.value},Xt=Me(G),Fe=e=>(r,n,o)=>{let t=o?I(f({},o),{async:!1}):{async:!1},a=r._zod.run({value:n,issues:[]},t);if(a instanceof Promise)throw new ne;return a.issues.length?{success:!1,error:new(e!=null?e:ct)(a.issues.map(c=>B(c,t,M())))}:{success:!0,data:a.value}},zn=Fe(G),Ve=e=>async(r,n,o)=>{let t=o?Object.assign(o,{async:!0}):{async:!0},a=r._zod.run({value:n,issues:[]},t);return a instanceof Promise&&(a=await a),a.issues.length?{success:!1,error:new e(a.issues.map(c=>B(c,t,M())))}:{success:!0,data:a.value}},Tn=Ve(G),Qt=e=>(r,n,o)=>{let t=o?Object.assign(o,{direction:"backward"}):{direction:"backward"};return Ae(e)(r,n,t)},ym=Qt(G),Yt=e=>(r,n,o)=>Ae(e)(r,n,o),$m=Yt(G),Ht=e=>async(r,n,o)=>{let t=o?Object.assign(o,{direction:"backward"}):{direction:"backward"};return Me(e)(r,n,t)},bm=Ht(G),er=e=>async(r,n,o)=>Me(e)(r,n,o),xm=er(G),tr=e=>(r,n,o)=>{let t=o?Object.assign(o,{direction:"backward"}):{direction:"backward"};return Fe(e)(r,n,t)},_m=tr(G),rr=e=>(r,n,o)=>Fe(e)(r,n,o),Sm=rr(G),nr=e=>async(r,n,o)=>{let t=o?Object.assign(o,{direction:"backward"}):{direction:"backward"};return Ve(e)(r,n,t)},km=nr(G),or=e=>async(r,n,o)=>Ve(e)(r,n,o),Im=or(G);var ee={};ve(ee,{base64:()=>Vn,base64url:()=>ir,bigint:()=>qn,boolean:()=>Qn,browserEmail:()=>Um,cidrv4:()=>Mn,cidrv6:()=>Fn,cuid:()=>wn,cuid2:()=>Pn,date:()=>Jn,datetime:()=>Gn,domain:()=>Zm,duration:()=>Nn,e164:()=>Kn,email:()=>Zn,emoji:()=>Ln,extendedDuration:()=>zm,guid:()=>En,hex:()=>Lm,hostname:()=>Em,html5Email:()=>Dm,idnEmail:()=>Om,integer:()=>Xn,ipv4:()=>Cn,ipv6:()=>Rn,ksuid:()=>On,lowercase:()=>eo,mac:()=>An,md5_base64:()=>Rm,md5_base64url:()=>Am,md5_hex:()=>Cm,nanoid:()=>Un,null:()=>Yn,number:()=>ar,rfc5322Email:()=>jm,sha1_base64:()=>Fm,sha1_base64url:()=>Vm,sha1_hex:()=>Mm,sha256_base64:()=>Jm,sha256_base64url:()=>Bm,sha256_hex:()=>Km,sha384_base64:()=>Wm,sha384_base64url:()=>qm,sha384_hex:()=>Gm,sha512_base64:()=>Qm,sha512_base64url:()=>Ym,sha512_hex:()=>Xm,string:()=>Wn,time:()=>Bn,ulid:()=>Dn,undefined:()=>Hn,unicodeEmail:()=>ku,uppercase:()=>to,uuid:()=>Pe,uuid4:()=>Tm,uuid6:()=>wm,uuid7:()=>Pm,xid:()=>jn});var wn=/^[cC][^\\s-]{8,}$/,Pn=/^[0-9a-z]+$/,Dn=/^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/,jn=/^[0-9a-vA-V]{20}$/,On=/^[A-Za-z0-9]{27}$/,Un=/^[a-zA-Z0-9_-]{21}$/,Nn=/^P(?:(\\d+W)|(?!.*W)(?=\\d|T\\d)(\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+([.,]\\d+)?S)?)?)$/,zm=/^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/,En=/^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/,Pe=e=>e?new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`):/^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,Tm=Pe(4),wm=Pe(6),Pm=Pe(7),Zn=/^(?!\\.)(?!.*\\.\\.)([A-Za-z0-9_\'+\\-\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\-]*\\.)+[A-Za-z]{2,}$/,Dm=/^[a-zA-Z0-9.!#$%&\'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,jm=/^(([^<>()\\[\\]\\\\.,;:\\s@"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@"]+)*)|(".+"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/,ku=/^[^\\s@"]{1,64}@[^\\s@]{1,255}$/u,Om=ku,Um=/^[a-zA-Z0-9.!#$%&\'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,Nm="^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$";function Ln(){return new RegExp(Nm,"u")}var Cn=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,Rn=/^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/,An=e=>{let r=H(e!=null?e:":");return new RegExp(`^(?:[0-9A-F]{2}${r}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${r}){5}[0-9a-f]{2}$`)},Mn=/^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/([0-9]|[1-2][0-9]|3[0-2])$/,Fn=/^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,Vn=/^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/,ir=/^[A-Za-z0-9_-]*$/,Em=/^(?=.{1,253}\\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\\.?$/,Zm=/^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$/,Kn=/^\\+[1-9]\\d{6,14}$/,Iu="(?:(?:\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\\\d|30)|(?:02)-(?:0[1-9]|1\\\\d|2[0-8])))",Jn=new RegExp(`^${Iu}$`);function zu(e){let r="(?:[01]\\\\d|2[0-3]):[0-5]\\\\d";return typeof e.precision=="number"?e.precision===-1?`${r}`:e.precision===0?`${r}:[0-5]\\\\d`:`${r}:[0-5]\\\\d\\\\.\\\\d{${e.precision}}`:`${r}(?::[0-5]\\\\d(?:\\\\.\\\\d+)?)?`}function Bn(e){return new RegExp(`^${zu(e)}$`)}function Gn(e){let r=zu({precision:e.precision}),n=["Z"];e.local&&n.push(""),e.offset&&n.push("([+-](?:[01]\\\\d|2[0-3]):[0-5]\\\\d)");let o=`${r}(?:${n.join("|")})`;return new RegExp(`^${Iu}T(?:${o})$`)}var Wn=e=>{var n,o;let r=e?`[\\\\s\\\\S]{${(n=e==null?void 0:e.minimum)!=null?n:0},${(o=e==null?void 0:e.maximum)!=null?o:""}}`:"[\\\\s\\\\S]*";return new RegExp(`^${r}$`)},qn=/^-?\\d+n?$/,Xn=/^-?\\d+$/,ar=/^-?\\d+(?:\\.\\d+)?$/,Qn=/^(?:true|false)$/i,Yn=/^null$/i;var Hn=/^undefined$/i;var eo=/^[^A-Z]*$/,to=/^[^a-z]*$/,Lm=/^[0-9a-fA-F]*$/;function ut(e,r){return new RegExp(`^[A-Za-z0-9+/]{${e}}${r}$`)}function lt(e){return new RegExp(`^[A-Za-z0-9_-]{${e}}$`)}var Cm=/^[0-9a-fA-F]{32}$/,Rm=ut(22,"=="),Am=lt(22),Mm=/^[0-9a-fA-F]{40}$/,Fm=ut(27,"="),Vm=lt(27),Km=/^[0-9a-fA-F]{64}$/,Jm=ut(43,"="),Bm=lt(43),Gm=/^[0-9a-fA-F]{96}$/,Wm=ut(64,""),qm=lt(64),Xm=/^[0-9a-fA-F]{128}$/,Qm=ut(86,"=="),Ym=lt(86);var L=g("$ZodCheck",(e,r)=>{var o,t;var n;(o=e._zod)!=null||(e._zod={}),e._zod.def=r,(t=(n=e._zod).onattach)!=null||(n.onattach=[])}),wu={number:"number",bigint:"bigint",object:"date"},cr=g("$ZodCheckLessThan",(e,r)=>{L.init(e,r);let n=wu[typeof r.value];e._zod.onattach.push(o=>{var c;let t=o._zod.bag,a=(c=r.inclusive?t.maximum:t.exclusiveMaximum)!=null?c:Number.POSITIVE_INFINITY;r.value<a&&(r.inclusive?t.maximum=r.value:t.exclusiveMaximum=r.value)}),e._zod.check=o=>{(r.inclusive?o.value<=r.value:o.value<r.value)||o.issues.push({origin:n,code:"too_big",maximum:typeof r.value=="object"?r.value.getTime():r.value,input:o.value,inclusive:r.inclusive,inst:e,continue:!r.abort})}}),ur=g("$ZodCheckGreaterThan",(e,r)=>{L.init(e,r);let n=wu[typeof r.value];e._zod.onattach.push(o=>{var c;let t=o._zod.bag,a=(c=r.inclusive?t.minimum:t.exclusiveMinimum)!=null?c:Number.NEGATIVE_INFINITY;r.value>a&&(r.inclusive?t.minimum=r.value:t.exclusiveMinimum=r.value)}),e._zod.check=o=>{(r.inclusive?o.value>=r.value:o.value>r.value)||o.issues.push({origin:n,code:"too_small",minimum:typeof r.value=="object"?r.value.getTime():r.value,input:o.value,inclusive:r.inclusive,inst:e,continue:!r.abort})}}),ro=g("$ZodCheckMultipleOf",(e,r)=>{L.init(e,r),e._zod.onattach.push(n=>{var t;var o;(t=(o=n._zod.bag).multipleOf)!=null||(o.multipleOf=r.value)}),e._zod.check=n=>{if(typeof n.value!=typeof r.value)throw new Error("Cannot mix number and bigint in multiple_of check.");(typeof n.value=="bigint"?n.value%r.value===BigInt(0):yn(n.value,r.value)===0)||n.issues.push({origin:typeof n.value,code:"not_multiple_of",divisor:r.value,input:n.value,inst:e,continue:!r.abort})}}),no=g("$ZodCheckNumberFormat",(e,r)=>{var c;L.init(e,r),r.format=r.format||"float64";let n=(c=r.format)==null?void 0:c.includes("int"),o=n?"int":"number",[t,a]=kn[r.format];e._zod.onattach.push(m=>{let s=m._zod.bag;s.format=r.format,s.minimum=t,s.maximum=a,n&&(s.pattern=Xn)}),e._zod.check=m=>{let s=m.value;if(n){if(!Number.isInteger(s)){m.issues.push({expected:o,format:r.format,code:"invalid_type",continue:!1,input:s,inst:e});return}if(!Number.isSafeInteger(s)){s>0?m.issues.push({input:s,code:"too_big",maximum:Number.MAX_SAFE_INTEGER,note:"Integers must be within the safe integer range.",inst:e,origin:o,inclusive:!0,continue:!r.abort}):m.issues.push({input:s,code:"too_small",minimum:Number.MIN_SAFE_INTEGER,note:"Integers must be within the safe integer range.",inst:e,origin:o,inclusive:!0,continue:!r.abort});return}}s<t&&m.issues.push({origin:"number",input:s,code:"too_small",minimum:t,inclusive:!0,inst:e,continue:!r.abort}),s>a&&m.issues.push({origin:"number",input:s,code:"too_big",maximum:a,inclusive:!0,inst:e,continue:!r.abort})}}),oo=g("$ZodCheckBigIntFormat",(e,r)=>{L.init(e,r);let[n,o]=In[r.format];e._zod.onattach.push(t=>{let a=t._zod.bag;a.format=r.format,a.minimum=n,a.maximum=o}),e._zod.check=t=>{let a=t.value;a<n&&t.issues.push({origin:"bigint",input:a,code:"too_small",minimum:n,inclusive:!0,inst:e,continue:!r.abort}),a>o&&t.issues.push({origin:"bigint",input:a,code:"too_big",maximum:o,inclusive:!0,inst:e,continue:!r.abort})}}),io=g("$ZodCheckMaxSize",(e,r)=>{var o;var n;L.init(e,r),(o=(n=e._zod.def).when)!=null||(n.when=t=>{let a=t.value;return!ye(a)&&a.size!==void 0}),e._zod.onattach.push(t=>{var c;let a=(c=t._zod.bag.maximum)!=null?c:Number.POSITIVE_INFINITY;r.maximum<a&&(t._zod.bag.maximum=r.maximum)}),e._zod.check=t=>{let a=t.value;a.size<=r.maximum||t.issues.push({origin:it(a),code:"too_big",maximum:r.maximum,inclusive:!0,input:a,inst:e,continue:!r.abort})}}),ao=g("$ZodCheckMinSize",(e,r)=>{var o;var n;L.init(e,r),(o=(n=e._zod.def).when)!=null||(n.when=t=>{let a=t.value;return!ye(a)&&a.size!==void 0}),e._zod.onattach.push(t=>{var c;let a=(c=t._zod.bag.minimum)!=null?c:Number.NEGATIVE_INFINITY;r.minimum>a&&(t._zod.bag.minimum=r.minimum)}),e._zod.check=t=>{let a=t.value;a.size>=r.minimum||t.issues.push({origin:it(a),code:"too_small",minimum:r.minimum,inclusive:!0,input:a,inst:e,continue:!r.abort})}}),co=g("$ZodCheckSizeEquals",(e,r)=>{var o;var n;L.init(e,r),(o=(n=e._zod.def).when)!=null||(n.when=t=>{let a=t.value;return!ye(a)&&a.size!==void 0}),e._zod.onattach.push(t=>{let a=t._zod.bag;a.minimum=r.size,a.maximum=r.size,a.size=r.size}),e._zod.check=t=>{let a=t.value,c=a.size;if(c===r.size)return;let m=c>r.size;t.issues.push(I(f({origin:it(a)},m?{code:"too_big",maximum:r.size}:{code:"too_small",minimum:r.size}),{inclusive:!0,exact:!0,input:t.value,inst:e,continue:!r.abort}))}}),uo=g("$ZodCheckMaxLength",(e,r)=>{var o;var n;L.init(e,r),(o=(n=e._zod.def).when)!=null||(n.when=t=>{let a=t.value;return!ye(a)&&a.length!==void 0}),e._zod.onattach.push(t=>{var c;let a=(c=t._zod.bag.maximum)!=null?c:Number.POSITIVE_INFINITY;r.maximum<a&&(t._zod.bag.maximum=r.maximum)}),e._zod.check=t=>{let a=t.value;if(a.length<=r.maximum)return;let m=at(a);t.issues.push({origin:m,code:"too_big",maximum:r.maximum,inclusive:!0,input:a,inst:e,continue:!r.abort})}}),lo=g("$ZodCheckMinLength",(e,r)=>{var o;var n;L.init(e,r),(o=(n=e._zod.def).when)!=null||(n.when=t=>{let a=t.value;return!ye(a)&&a.length!==void 0}),e._zod.onattach.push(t=>{var c;let a=(c=t._zod.bag.minimum)!=null?c:Number.NEGATIVE_INFINITY;r.minimum>a&&(t._zod.bag.minimum=r.minimum)}),e._zod.check=t=>{let a=t.value;if(a.length>=r.minimum)return;let m=at(a);t.issues.push({origin:m,code:"too_small",minimum:r.minimum,inclusive:!0,input:a,inst:e,continue:!r.abort})}}),so=g("$ZodCheckLengthEquals",(e,r)=>{var o;var n;L.init(e,r),(o=(n=e._zod.def).when)!=null||(n.when=t=>{let a=t.value;return!ye(a)&&a.length!==void 0}),e._zod.onattach.push(t=>{let a=t._zod.bag;a.minimum=r.length,a.maximum=r.length,a.length=r.length}),e._zod.check=t=>{let a=t.value,c=a.length;if(c===r.length)return;let m=at(a),s=c>r.length;t.issues.push(I(f({origin:m},s?{code:"too_big",maximum:r.length}:{code:"too_small",minimum:r.length}),{inclusive:!0,exact:!0,input:t.value,inst:e,continue:!r.abort}))}}),Ke=g("$ZodCheckStringFormat",(e,r)=>{var t,a;var n,o;L.init(e,r),e._zod.onattach.push(c=>{var s;let m=c._zod.bag;m.format=r.format,r.pattern&&((s=m.patterns)!=null||(m.patterns=new Set),m.patterns.add(r.pattern))}),r.pattern?(t=(n=e._zod).check)!=null||(n.check=c=>{r.pattern.lastIndex=0,!r.pattern.test(c.value)&&c.issues.push(I(f({origin:"string",code:"invalid_format",format:r.format,input:c.value},r.pattern?{pattern:r.pattern.toString()}:{}),{inst:e,continue:!r.abort}))}):(a=(o=e._zod).check)!=null||(o.check=()=>{})}),mo=g("$ZodCheckRegex",(e,r)=>{Ke.init(e,r),e._zod.check=n=>{r.pattern.lastIndex=0,!r.pattern.test(n.value)&&n.issues.push({origin:"string",code:"invalid_format",format:"regex",input:n.value,pattern:r.pattern.toString(),inst:e,continue:!r.abort})}}),po=g("$ZodCheckLowerCase",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=eo),Ke.init(e,r)}),fo=g("$ZodCheckUpperCase",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=to),Ke.init(e,r)}),go=g("$ZodCheckIncludes",(e,r)=>{L.init(e,r);let n=H(r.includes),o=new RegExp(typeof r.position=="number"?`^.{${r.position}}${n}`:n);r.pattern=o,e._zod.onattach.push(t=>{var c;let a=t._zod.bag;(c=a.patterns)!=null||(a.patterns=new Set),a.patterns.add(o)}),e._zod.check=t=>{t.value.includes(r.includes,r.position)||t.issues.push({origin:"string",code:"invalid_format",format:"includes",includes:r.includes,input:t.value,inst:e,continue:!r.abort})}}),vo=g("$ZodCheckStartsWith",(e,r)=>{var o;L.init(e,r);let n=new RegExp(`^${H(r.prefix)}.*`);(o=r.pattern)!=null||(r.pattern=n),e._zod.onattach.push(t=>{var c;let a=t._zod.bag;(c=a.patterns)!=null||(a.patterns=new Set),a.patterns.add(n)}),e._zod.check=t=>{t.value.startsWith(r.prefix)||t.issues.push({origin:"string",code:"invalid_format",format:"starts_with",prefix:r.prefix,input:t.value,inst:e,continue:!r.abort})}}),ho=g("$ZodCheckEndsWith",(e,r)=>{var o;L.init(e,r);let n=new RegExp(`.*${H(r.suffix)}$`);(o=r.pattern)!=null||(r.pattern=n),e._zod.onattach.push(t=>{var c;let a=t._zod.bag;(c=a.patterns)!=null||(a.patterns=new Set),a.patterns.add(n)}),e._zod.check=t=>{t.value.endsWith(r.suffix)||t.issues.push({origin:"string",code:"invalid_format",format:"ends_with",suffix:r.suffix,input:t.value,inst:e,continue:!r.abort})}});function Tu(e,r,n){e.issues.length&&r.issues.push(...q(n,e.issues))}var yo=g("$ZodCheckProperty",(e,r)=>{L.init(e,r),e._zod.check=n=>{let o=r.schema._zod.run({value:n.value[r.property],issues:[]},{});if(o instanceof Promise)return o.then(t=>Tu(t,n,r.property));Tu(o,n,r.property)}}),$o=g("$ZodCheckMimeType",(e,r)=>{L.init(e,r);let n=new Set(r.mime);e._zod.onattach.push(o=>{o._zod.bag.mime=r.mime}),e._zod.check=o=>{n.has(o.value.type)||o.issues.push({code:"invalid_value",values:r.mime,input:o.value.type,inst:e,continue:!r.abort})}}),bo=g("$ZodCheckOverwrite",(e,r)=>{L.init(e,r),e._zod.check=n=>{n.value=r.tx(n.value)}});var st=class{constructor(r=[]){this.content=[],this.indent=0,this&&(this.args=r)}indented(r){this.indent+=1,r(this),this.indent-=1}write(r){if(typeof r=="function"){r(this,{execution:"sync"}),r(this,{execution:"async"});return}let o=r.split(`\n`).filter(c=>c),t=Math.min(...o.map(c=>c.length-c.trimStart().length)),a=o.map(c=>c.slice(t)).map(c=>" ".repeat(this.indent*2)+c);for(let c of a)this.content.push(c)}compile(){var a;let r=Function,n=this==null?void 0:this.args,t=[...((a=this==null?void 0:this.content)!=null?a:[""]).map(c=>`  ${c}`)];return new r(...n,t.join(`\n`))}};var xo={major:4,minor:3,patch:6};var P=g("$ZodType",(e,r)=>{var t,a,c;var n;e!=null||(e={}),e._zod.def=r,e._zod.bag=e._zod.bag||{},e._zod.version=xo;let o=[...(t=e._zod.def.checks)!=null?t:[]];e._zod.traits.has("$ZodCheck")&&o.unshift(e);for(let m of o)for(let s of m._zod.onattach)s(e);if(o.length===0)(a=(n=e._zod).deferred)!=null||(n.deferred=[]),(c=e._zod.deferred)==null||c.push(()=>{e._zod.run=e._zod.parse});else{let m=(u,d,i)=>{let l=xe(u),p;for(let v of d){if(v._zod.def.when){if(!v._zod.def.when(u))continue}else if(l)continue;let y=u.issues.length,S=v._zod.check(u);if(S instanceof Promise&&(i==null?void 0:i.async)===!1)throw new ne;if(p||S instanceof Promise)p=(p!=null?p:Promise.resolve()).then(async()=>{await S,u.issues.length!==y&&(l||(l=xe(u,y)))});else{if(u.issues.length===y)continue;l||(l=xe(u,y))}}return p?p.then(()=>u):u},s=(u,d,i)=>{if(xe(u))return u.aborted=!0,u;let l=m(d,o,i);if(l instanceof Promise){if(i.async===!1)throw new ne;return l.then(p=>e._zod.parse(p,i))}return e._zod.parse(l,i)};e._zod.run=(u,d)=>{if(d.skipChecks)return e._zod.parse(u,d);if(d.direction==="backward"){let l=e._zod.parse({value:u.value,issues:[]},I(f({},d),{skipChecks:!0}));return l instanceof Promise?l.then(p=>s(p,u,d)):s(l,u,d)}let i=e._zod.parse(u,d);if(i instanceof Promise){if(d.async===!1)throw new ne;return i.then(l=>m(l,o,d))}return m(i,o,d)}}O(e,"~standard",()=>({validate:m=>{var s;try{let u=zn(e,m);return u.success?{value:u.data}:{issues:(s=u.error)==null?void 0:s.issues}}catch(u){return Tn(e,m).then(d=>{var i;return d.success?{value:d.data}:{issues:(i=d.error)==null?void 0:i.issues}})}},vendor:"zod",version:1}))}),De=g("$ZodString",(e,r)=>{var n,o,t;P.init(e,r),e._zod.pattern=(t=[...(o=(n=e==null?void 0:e._zod.bag)==null?void 0:n.patterns)!=null?o:[]].pop())!=null?t:Wn(e._zod.bag),e._zod.parse=(a,c)=>{if(r.coerce)try{a.value=String(a.value)}catch(m){}return typeof a.value=="string"||a.issues.push({expected:"string",code:"invalid_type",input:a.value,inst:e}),a}}),Z=g("$ZodStringFormat",(e,r)=>{Ke.init(e,r),De.init(e,r)}),So=g("$ZodGUID",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=En),Z.init(e,r)}),ko=g("$ZodUUID",(e,r)=>{var n,o;if(r.version){let a={v1:1,v2:2,v3:3,v4:4,v5:5,v6:6,v7:7,v8:8}[r.version];if(a===void 0)throw new Error(`Invalid UUID version: "${r.version}"`);(n=r.pattern)!=null||(r.pattern=Pe(a))}else(o=r.pattern)!=null||(r.pattern=Pe());Z.init(e,r)}),Io=g("$ZodEmail",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Zn),Z.init(e,r)}),zo=g("$ZodURL",(e,r)=>{Z.init(e,r),e._zod.check=n=>{try{let o=n.value.trim(),t=new URL(o);r.hostname&&(r.hostname.lastIndex=0,r.hostname.test(t.hostname)||n.issues.push({code:"invalid_format",format:"url",note:"Invalid hostname",pattern:r.hostname.source,input:n.value,inst:e,continue:!r.abort})),r.protocol&&(r.protocol.lastIndex=0,r.protocol.test(t.protocol.endsWith(":")?t.protocol.slice(0,-1):t.protocol)||n.issues.push({code:"invalid_format",format:"url",note:"Invalid protocol",pattern:r.protocol.source,input:n.value,inst:e,continue:!r.abort})),r.normalize?n.value=t.href:n.value=o;return}catch(o){n.issues.push({code:"invalid_format",format:"url",input:n.value,inst:e,continue:!r.abort})}}}),To=g("$ZodEmoji",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Ln()),Z.init(e,r)}),wo=g("$ZodNanoID",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Un),Z.init(e,r)}),Po=g("$ZodCUID",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=wn),Z.init(e,r)}),Do=g("$ZodCUID2",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Pn),Z.init(e,r)}),jo=g("$ZodULID",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Dn),Z.init(e,r)}),Oo=g("$ZodXID",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=jn),Z.init(e,r)}),Uo=g("$ZodKSUID",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=On),Z.init(e,r)}),No=g("$ZodISODateTime",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Gn(r)),Z.init(e,r)}),Eo=g("$ZodISODate",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Jn),Z.init(e,r)}),Zo=g("$ZodISOTime",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Bn(r)),Z.init(e,r)}),Lo=g("$ZodISODuration",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Nn),Z.init(e,r)}),Co=g("$ZodIPv4",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Cn),Z.init(e,r),e._zod.bag.format="ipv4"}),Ro=g("$ZodIPv6",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Rn),Z.init(e,r),e._zod.bag.format="ipv6",e._zod.check=o=>{try{new URL(`http://[${o.value}]`)}catch(t){o.issues.push({code:"invalid_format",format:"ipv6",input:o.value,inst:e,continue:!r.abort})}}}),Ao=g("$ZodMAC",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=An(r.delimiter)),Z.init(e,r),e._zod.bag.format="mac"}),Mo=g("$ZodCIDRv4",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Mn),Z.init(e,r)}),Fo=g("$ZodCIDRv6",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Fn),Z.init(e,r),e._zod.check=o=>{let t=o.value.split("/");try{if(t.length!==2)throw new Error;let[a,c]=t;if(!c)throw new Error;let m=Number(c);if(`${m}`!==c)throw new Error;if(m<0||m>128)throw new Error;new URL(`http://[${a}]`)}catch(a){o.issues.push({code:"invalid_format",format:"cidrv6",input:o.value,inst:e,continue:!r.abort})}}});function Vo(e){if(e==="")return!0;if(e.length%4!==0)return!1;try{return atob(e),!0}catch(r){return!1}}var Ko=g("$ZodBase64",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Vn),Z.init(e,r),e._zod.bag.contentEncoding="base64",e._zod.check=o=>{Vo(o.value)||o.issues.push({code:"invalid_format",format:"base64",input:o.value,inst:e,continue:!r.abort})}});function Mu(e){if(!ir.test(e))return!1;let r=e.replace(/[-_]/g,o=>o==="-"?"+":"/"),n=r.padEnd(Math.ceil(r.length/4)*4,"=");return Vo(n)}var Jo=g("$ZodBase64URL",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=ir),Z.init(e,r),e._zod.bag.contentEncoding="base64url",e._zod.check=o=>{Mu(o.value)||o.issues.push({code:"invalid_format",format:"base64url",input:o.value,inst:e,continue:!r.abort})}}),Bo=g("$ZodE164",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Kn),Z.init(e,r)});function Fu(e,r=null){try{let n=e.split(".");if(n.length!==3)return!1;let[o]=n;if(!o)return!1;let t=JSON.parse(atob(o));return!("typ"in t&&(t==null?void 0:t.typ)!=="JWT"||!t.alg||r&&(!("alg"in t)||t.alg!==r))}catch(n){return!1}}var Go=g("$ZodJWT",(e,r)=>{Z.init(e,r),e._zod.check=n=>{Fu(n.value,r.alg)||n.issues.push({code:"invalid_format",format:"jwt",input:n.value,inst:e,continue:!r.abort})}}),Wo=g("$ZodCustomStringFormat",(e,r)=>{Z.init(e,r),e._zod.check=n=>{r.fn(n.value)||n.issues.push({code:"invalid_format",format:r.format,input:n.value,inst:e,continue:!r.abort})}}),fr=g("$ZodNumber",(e,r)=>{var n;P.init(e,r),e._zod.pattern=(n=e._zod.bag.pattern)!=null?n:ar,e._zod.parse=(o,t)=>{if(r.coerce)try{o.value=Number(o.value)}catch(m){}let a=o.value;if(typeof a=="number"&&!Number.isNaN(a)&&Number.isFinite(a))return o;let c=typeof a=="number"?Number.isNaN(a)?"NaN":Number.isFinite(a)?void 0:"Infinity":void 0;return o.issues.push(f({expected:"number",code:"invalid_type",input:a,inst:e},c?{received:c}:{})),o}}),qo=g("$ZodNumberFormat",(e,r)=>{no.init(e,r),fr.init(e,r)}),dt=g("$ZodBoolean",(e,r)=>{P.init(e,r),e._zod.pattern=Qn,e._zod.parse=(n,o)=>{if(r.coerce)try{n.value=!!n.value}catch(a){}let t=n.value;return typeof t=="boolean"||n.issues.push({expected:"boolean",code:"invalid_type",input:t,inst:e}),n}}),gr=g("$ZodBigInt",(e,r)=>{P.init(e,r),e._zod.pattern=qn,e._zod.parse=(n,o)=>{if(r.coerce)try{n.value=BigInt(n.value)}catch(t){}return typeof n.value=="bigint"||n.issues.push({expected:"bigint",code:"invalid_type",input:n.value,inst:e}),n}}),Xo=g("$ZodBigIntFormat",(e,r)=>{oo.init(e,r),gr.init(e,r)}),Qo=g("$ZodSymbol",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{let t=n.value;return typeof t=="symbol"||n.issues.push({expected:"symbol",code:"invalid_type",input:t,inst:e}),n}}),Yo=g("$ZodUndefined",(e,r)=>{P.init(e,r),e._zod.pattern=Hn,e._zod.values=new Set([void 0]),e._zod.optin="optional",e._zod.optout="optional",e._zod.parse=(n,o)=>{let t=n.value;return typeof t=="undefined"||n.issues.push({expected:"undefined",code:"invalid_type",input:t,inst:e}),n}}),Ho=g("$ZodNull",(e,r)=>{P.init(e,r),e._zod.pattern=Yn,e._zod.values=new Set([null]),e._zod.parse=(n,o)=>{let t=n.value;return t===null||n.issues.push({expected:"null",code:"invalid_type",input:t,inst:e}),n}}),ei=g("$ZodAny",(e,r)=>{P.init(e,r),e._zod.parse=n=>n}),ti=g("$ZodUnknown",(e,r)=>{P.init(e,r),e._zod.parse=n=>n}),ri=g("$ZodNever",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>(n.issues.push({expected:"never",code:"invalid_type",input:n.value,inst:e}),n)}),ni=g("$ZodVoid",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{let t=n.value;return typeof t=="undefined"||n.issues.push({expected:"void",code:"invalid_type",input:t,inst:e}),n}}),oi=g("$ZodDate",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{if(r.coerce)try{n.value=new Date(n.value)}catch(m){}let t=n.value,a=t instanceof Date;return a&&!Number.isNaN(t.getTime())||n.issues.push(I(f({expected:"date",code:"invalid_type",input:t},a?{received:"Invalid Date"}:{}),{inst:e})),n}});function Du(e,r,n){e.issues.length&&r.issues.push(...q(n,e.issues)),r.value[n]=e.value}var ii=g("$ZodArray",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{let t=n.value;if(!Array.isArray(t))return n.issues.push({expected:"array",code:"invalid_type",input:t,inst:e}),n;n.value=Array(t.length);let a=[];for(let c=0;c<t.length;c++){let m=t[c],s=r.element._zod.run({value:m,issues:[]},o);s instanceof Promise?a.push(s.then(u=>Du(u,n,c))):Du(s,n,c)}return a.length?Promise.all(a).then(()=>n):n}});function pr(e,r,n,o,t){if(e.issues.length){if(t&&!(n in o))return;r.issues.push(...q(n,e.issues))}e.value===void 0?n in o&&(r.value[n]=void 0):r.value[n]=e.value}function Vu(e){var o,t,a,c;let r=Object.keys(e.shape);for(let m of r)if(!((c=(a=(t=(o=e.shape)==null?void 0:o[m])==null?void 0:t._zod)==null?void 0:a.traits)!=null&&c.has("$ZodType")))throw new Error(`Invalid element at key "${m}": expected a Zod schema`);let n=Sn(e.shape);return I(f({},e),{keys:r,keySet:new Set(r),numKeys:r.length,optionalKeys:new Set(n)})}function Ku(e,r,n,o,t,a){let c=[],m=t.keySet,s=t.catchall._zod,u=s.def.type,d=s.optout==="optional";for(let i in r){if(m.has(i))continue;if(u==="never"){c.push(i);continue}let l=s.run({value:r[i],issues:[]},o);l instanceof Promise?e.push(l.then(p=>pr(p,n,i,r,d))):pr(l,n,i,r,d)}return c.length&&n.issues.push({code:"unrecognized_keys",keys:c,input:r,inst:a}),e.length?Promise.all(e).then(()=>n):n}var Ju=g("$ZodObject",(e,r)=>{P.init(e,r);let n=Object.getOwnPropertyDescriptor(r,"shape");if(!(n!=null&&n.get)){let m=r.shape;Object.defineProperty(r,"shape",{get:()=>{let s=f({},m);return Object.defineProperty(r,"shape",{value:s}),s}})}let o=Ce(()=>Vu(r));O(e._zod,"propValues",()=>{var u;let m=r.shape,s={};for(let d in m){let i=m[d]._zod;if(i.values){(u=s[d])!=null||(s[d]=new Set);for(let l of i.values)s[d].add(l)}}return s});let t=we,a=r.catchall,c;e._zod.parse=(m,s)=>{c!=null||(c=o.value);let u=m.value;if(!t(u))return m.issues.push({expected:"object",code:"invalid_type",input:u,inst:e}),m;m.value={};let d=[],i=c.shape;for(let l of c.keys){let p=i[l],v=p._zod.optout==="optional",y=p._zod.run({value:u[l],issues:[]},s);y instanceof Promise?d.push(y.then(S=>pr(S,m,l,u,v))):pr(y,m,l,u,v)}return a?Ku(d,u,m,s,o.value,e):d.length?Promise.all(d).then(()=>m):m}}),ai=g("$ZodObjectJIT",(e,r)=>{Ju.init(e,r);let n=e._zod.parse,o=Ce(()=>Vu(r)),t=l=>{var N;let p=new st(["shape","payload","ctx"]),v=o.value,y=k=>{let T=Jt(k);return`shape[${T}]._zod.run({ value: input[${T}], issues: [] }, ctx)`};p.write("const input = payload.value;");let S=Object.create(null),w=0;for(let k of v.keys)S[k]=`key_${w++}`;p.write("const newResult = {};");for(let k of v.keys){let T=S[k],U=Jt(k),R=l[k],Ee=((N=R==null?void 0:R._zod)==null?void 0:N.optout)==="optional";p.write(`const ${T} = ${y(k)};`),Ee?p.write(`\n        if (${T}.issues.length) {\n          if (${U} in input) {\n            payload.issues = payload.issues.concat(${T}.issues.map(iss => ({\n              ...iss,\n              path: iss.path ? [${U}, ...iss.path] : [${U}]\n            })));\n          }\n        }\n        \n        if (${T}.value === undefined) {\n          if (${U} in input) {\n            newResult[${U}] = undefined;\n          }\n        } else {\n          newResult[${U}] = ${T}.value;\n        }\n        \n      `):p.write(`\n        if (${T}.issues.length) {\n          payload.issues = payload.issues.concat(${T}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${U}, ...iss.path] : [${U}]\n          })));\n        }\n        \n        if (${T}.value === undefined) {\n          if (${U} in input) {\n            newResult[${U}] = undefined;\n          }\n        } else {\n          newResult[${U}] = ${T}.value;\n        }\n        \n      `)}p.write("payload.value = newResult;"),p.write("return payload;");let D=p.compile();return(k,T)=>D(l,k,T)},a,c=we,m=!et.jitless,u=m&&bn.value,d=r.catchall,i;e._zod.parse=(l,p)=>{i!=null||(i=o.value);let v=l.value;return c(v)?m&&u&&(p==null?void 0:p.async)===!1&&p.jitless!==!0?(a||(a=t(r.shape)),l=a(l,p),d?Ku([],v,l,p,i,e):l):n(l,p):(l.issues.push({expected:"object",code:"invalid_type",input:v,inst:e}),l)}});function ju(e,r,n,o){for(let a of e)if(a.issues.length===0)return r.value=a.value,r;let t=e.filter(a=>!xe(a));return t.length===1?(r.value=t[0].value,t[0]):(r.issues.push({code:"invalid_union",input:r.value,inst:n,errors:e.map(a=>a.issues.map(c=>B(c,o,M())))}),r)}var mt=g("$ZodUnion",(e,r)=>{P.init(e,r),O(e._zod,"optin",()=>r.options.some(t=>t._zod.optin==="optional")?"optional":void 0),O(e._zod,"optout",()=>r.options.some(t=>t._zod.optout==="optional")?"optional":void 0),O(e._zod,"values",()=>{if(r.options.every(t=>t._zod.values))return new Set(r.options.flatMap(t=>Array.from(t._zod.values)))}),O(e._zod,"pattern",()=>{if(r.options.every(t=>t._zod.pattern)){let t=r.options.map(a=>a._zod.pattern);return new RegExp(`^(${t.map(a=>nt(a.source)).join("|")})$`)}});let n=r.options.length===1,o=r.options[0]._zod.run;e._zod.parse=(t,a)=>{if(n)return o(t,a);let c=!1,m=[];for(let s of r.options){let u=s._zod.run({value:t.value,issues:[]},a);if(u instanceof Promise)m.push(u),c=!0;else{if(u.issues.length===0)return u;m.push(u)}}return c?Promise.all(m).then(s=>ju(s,t,e,a)):ju(m,t,e,a)}});function Ou(e,r,n,o){let t=e.filter(a=>a.issues.length===0);return t.length===1?(r.value=t[0].value,r):(t.length===0?r.issues.push({code:"invalid_union",input:r.value,inst:n,errors:e.map(a=>a.issues.map(c=>B(c,o,M())))}):r.issues.push({code:"invalid_union",input:r.value,inst:n,errors:[],inclusive:!1}),r)}var ci=g("$ZodXor",(e,r)=>{mt.init(e,r),r.inclusive=!1;let n=r.options.length===1,o=r.options[0]._zod.run;e._zod.parse=(t,a)=>{if(n)return o(t,a);let c=!1,m=[];for(let s of r.options){let u=s._zod.run({value:t.value,issues:[]},a);u instanceof Promise?(m.push(u),c=!0):m.push(u)}return c?Promise.all(m).then(s=>Ou(s,t,e,a)):Ou(m,t,e,a)}}),ui=g("$ZodDiscriminatedUnion",(e,r)=>{r.inclusive=!1,mt.init(e,r);let n=e._zod.parse;O(e._zod,"propValues",()=>{let t={};for(let a of r.options){let c=a._zod.propValues;if(!c||Object.keys(c).length===0)throw new Error(`Invalid discriminated union option at index "${r.options.indexOf(a)}"`);for(let[m,s]of Object.entries(c)){t[m]||(t[m]=new Set);for(let u of s)t[m].add(u)}}return t});let o=Ce(()=>{var c;let t=r.options,a=new Map;for(let m of t){let s=(c=m._zod.propValues)==null?void 0:c[r.discriminator];if(!s||s.size===0)throw new Error(`Invalid discriminated union option at index "${r.options.indexOf(m)}"`);for(let u of s){if(a.has(u))throw new Error(`Duplicate discriminator value "${String(u)}"`);a.set(u,m)}}return a});e._zod.parse=(t,a)=>{let c=t.value;if(!we(c))return t.issues.push({code:"invalid_type",expected:"object",input:c,inst:e}),t;let m=o.value.get(c==null?void 0:c[r.discriminator]);return m?m._zod.run(t,a):r.unionFallback?n(t,a):(t.issues.push({code:"invalid_union",errors:[],note:"No matching discriminator",discriminator:r.discriminator,input:c,path:[r.discriminator],inst:e}),t)}}),li=g("$ZodIntersection",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{let t=n.value,a=r.left._zod.run({value:t,issues:[]},o),c=r.right._zod.run({value:t,issues:[]},o);return a instanceof Promise||c instanceof Promise?Promise.all([a,c]).then(([s,u])=>Uu(n,s,u)):Uu(n,a,c)}});function _o(e,r){if(e===r)return{valid:!0,data:e};if(e instanceof Date&&r instanceof Date&&+e==+r)return{valid:!0,data:e};if(be(e)&&be(r)){let n=Object.keys(r),o=Object.keys(e).filter(a=>n.indexOf(a)!==-1),t=f(f({},e),r);for(let a of o){let c=_o(e[a],r[a]);if(!c.valid)return{valid:!1,mergeErrorPath:[a,...c.mergeErrorPath]};t[a]=c.data}return{valid:!0,data:t}}if(Array.isArray(e)&&Array.isArray(r)){if(e.length!==r.length)return{valid:!1,mergeErrorPath:[]};let n=[];for(let o=0;o<e.length;o++){let t=e[o],a=r[o],c=_o(t,a);if(!c.valid)return{valid:!1,mergeErrorPath:[o,...c.mergeErrorPath]};n.push(c.data)}return{valid:!0,data:n}}return{valid:!1,mergeErrorPath:[]}}function Uu(e,r,n){let o=new Map,t;for(let m of r.issues)if(m.code==="unrecognized_keys"){t!=null||(t=m);for(let s of m.keys)o.has(s)||o.set(s,{}),o.get(s).l=!0}else e.issues.push(m);for(let m of n.issues)if(m.code==="unrecognized_keys")for(let s of m.keys)o.has(s)||o.set(s,{}),o.get(s).r=!0;else e.issues.push(m);let a=[...o].filter(([,m])=>m.l&&m.r).map(([m])=>m);if(a.length&&t&&e.issues.push(I(f({},t),{keys:a})),xe(e))return e;let c=_o(r.value,n.value);if(!c.valid)throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(c.mergeErrorPath)}`);return e.value=c.data,e}var vr=g("$ZodTuple",(e,r)=>{P.init(e,r);let n=r.items;e._zod.parse=(o,t)=>{let a=o.value;if(!Array.isArray(a))return o.issues.push({input:a,inst:e,expected:"tuple",code:"invalid_type"}),o;o.value=[];let c=[],m=[...n].reverse().findIndex(d=>d._zod.optin!=="optional"),s=m===-1?0:n.length-m;if(!r.rest){let d=a.length>n.length,i=a.length<s-1;if(d||i)return o.issues.push(I(f({},d?{code:"too_big",maximum:n.length,inclusive:!0}:{code:"too_small",minimum:n.length}),{input:a,inst:e,origin:"array"})),o}let u=-1;for(let d of n){if(u++,u>=a.length&&u>=s)continue;let i=d._zod.run({value:a[u],issues:[]},t);i instanceof Promise?c.push(i.then(l=>lr(l,o,u))):lr(i,o,u)}if(r.rest){let d=a.slice(n.length);for(let i of d){u++;let l=r.rest._zod.run({value:i,issues:[]},t);l instanceof Promise?c.push(l.then(p=>lr(p,o,u))):lr(l,o,u)}}return c.length?Promise.all(c).then(()=>o):o}});function lr(e,r,n){e.issues.length&&r.issues.push(...q(n,e.issues)),r.value[n]=e.value}var si=g("$ZodRecord",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{let t=n.value;if(!be(t))return n.issues.push({expected:"record",code:"invalid_type",input:t,inst:e}),n;let a=[],c=r.keyType._zod.values;if(c){n.value={};let m=new Set;for(let u of c)if(typeof u=="string"||typeof u=="number"||typeof u=="symbol"){m.add(typeof u=="number"?u.toString():u);let d=r.valueType._zod.run({value:t[u],issues:[]},o);d instanceof Promise?a.push(d.then(i=>{i.issues.length&&n.issues.push(...q(u,i.issues)),n.value[u]=i.value})):(d.issues.length&&n.issues.push(...q(u,d.issues)),n.value[u]=d.value)}let s;for(let u in t)m.has(u)||(s=s!=null?s:[],s.push(u));s&&s.length>0&&n.issues.push({code:"unrecognized_keys",input:t,inst:e,keys:s})}else{n.value={};for(let m of Reflect.ownKeys(t)){if(m==="__proto__")continue;let s=r.keyType._zod.run({value:m,issues:[]},o);if(s instanceof Promise)throw new Error("Async schemas not supported in object keys currently");if(typeof m=="string"&&ar.test(m)&&s.issues.length){let i=r.keyType._zod.run({value:Number(m),issues:[]},o);if(i instanceof Promise)throw new Error("Async schemas not supported in object keys currently");i.issues.length===0&&(s=i)}if(s.issues.length){r.mode==="loose"?n.value[m]=t[m]:n.issues.push({code:"invalid_key",origin:"record",issues:s.issues.map(i=>B(i,o,M())),input:m,path:[m],inst:e});continue}let d=r.valueType._zod.run({value:t[m],issues:[]},o);d instanceof Promise?a.push(d.then(i=>{i.issues.length&&n.issues.push(...q(m,i.issues)),n.value[s.value]=i.value})):(d.issues.length&&n.issues.push(...q(m,d.issues)),n.value[s.value]=d.value)}}return a.length?Promise.all(a).then(()=>n):n}}),di=g("$ZodMap",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{let t=n.value;if(!(t instanceof Map))return n.issues.push({expected:"map",code:"invalid_type",input:t,inst:e}),n;let a=[];n.value=new Map;for(let[c,m]of t){let s=r.keyType._zod.run({value:c,issues:[]},o),u=r.valueType._zod.run({value:m,issues:[]},o);s instanceof Promise||u instanceof Promise?a.push(Promise.all([s,u]).then(([d,i])=>{Nu(d,i,n,c,t,e,o)})):Nu(s,u,n,c,t,e,o)}return a.length?Promise.all(a).then(()=>n):n}});function Nu(e,r,n,o,t,a,c){e.issues.length&&(ot.has(typeof o)?n.issues.push(...q(o,e.issues)):n.issues.push({code:"invalid_key",origin:"map",input:t,inst:a,issues:e.issues.map(m=>B(m,c,M()))})),r.issues.length&&(ot.has(typeof o)?n.issues.push(...q(o,r.issues)):n.issues.push({origin:"map",code:"invalid_element",input:t,inst:a,key:o,issues:r.issues.map(m=>B(m,c,M()))})),n.value.set(e.value,r.value)}var mi=g("$ZodSet",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{let t=n.value;if(!(t instanceof Set))return n.issues.push({input:t,inst:e,expected:"set",code:"invalid_type"}),n;let a=[];n.value=new Set;for(let c of t){let m=r.valueType._zod.run({value:c,issues:[]},o);m instanceof Promise?a.push(m.then(s=>Eu(s,n))):Eu(m,n)}return a.length?Promise.all(a).then(()=>n):n}});function Eu(e,r){e.issues.length&&r.issues.push(...e.issues),r.value.add(e.value)}var pi=g("$ZodEnum",(e,r)=>{P.init(e,r);let n=rt(r.entries),o=new Set(n);e._zod.values=o,e._zod.pattern=new RegExp(`^(${n.filter(t=>ot.has(typeof t)).map(t=>typeof t=="string"?H(t):t.toString()).join("|")})$`),e._zod.parse=(t,a)=>{let c=t.value;return o.has(c)||t.issues.push({code:"invalid_value",values:n,input:c,inst:e}),t}}),fi=g("$ZodLiteral",(e,r)=>{if(P.init(e,r),r.values.length===0)throw new Error("Cannot create literal schema with no valid values");let n=new Set(r.values);e._zod.values=n,e._zod.pattern=new RegExp(`^(${r.values.map(o=>typeof o=="string"?H(o):o?H(o.toString()):String(o)).join("|")})$`),e._zod.parse=(o,t)=>{let a=o.value;return n.has(a)||o.issues.push({code:"invalid_value",values:r.values,input:a,inst:e}),o}}),gi=g("$ZodFile",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{let t=n.value;return t instanceof File||n.issues.push({expected:"file",code:"invalid_type",input:t,inst:e}),n}}),vi=g("$ZodTransform",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{if(o.direction==="backward")throw new he(e.constructor.name);let t=r.transform(n.value,n);if(o.async)return(t instanceof Promise?t:Promise.resolve(t)).then(c=>(n.value=c,n));if(t instanceof Promise)throw new ne;return n.value=t,n}});function Zu(e,r){return e.issues.length&&r===void 0?{issues:[],value:void 0}:e}var hr=g("$ZodOptional",(e,r)=>{P.init(e,r),e._zod.optin="optional",e._zod.optout="optional",O(e._zod,"values",()=>r.innerType._zod.values?new Set([...r.innerType._zod.values,void 0]):void 0),O(e._zod,"pattern",()=>{let n=r.innerType._zod.pattern;return n?new RegExp(`^(${nt(n.source)})?$`):void 0}),e._zod.parse=(n,o)=>{if(r.innerType._zod.optin==="optional"){let t=r.innerType._zod.run(n,o);return t instanceof Promise?t.then(a=>Zu(a,n.value)):Zu(t,n.value)}return n.value===void 0?n:r.innerType._zod.run(n,o)}}),hi=g("$ZodExactOptional",(e,r)=>{hr.init(e,r),O(e._zod,"values",()=>r.innerType._zod.values),O(e._zod,"pattern",()=>r.innerType._zod.pattern),e._zod.parse=(n,o)=>r.innerType._zod.run(n,o)}),yi=g("$ZodNullable",(e,r)=>{P.init(e,r),O(e._zod,"optin",()=>r.innerType._zod.optin),O(e._zod,"optout",()=>r.innerType._zod.optout),O(e._zod,"pattern",()=>{let n=r.innerType._zod.pattern;return n?new RegExp(`^(${nt(n.source)}|null)$`):void 0}),O(e._zod,"values",()=>r.innerType._zod.values?new Set([...r.innerType._zod.values,null]):void 0),e._zod.parse=(n,o)=>n.value===null?n:r.innerType._zod.run(n,o)}),$i=g("$ZodDefault",(e,r)=>{P.init(e,r),e._zod.optin="optional",O(e._zod,"values",()=>r.innerType._zod.values),e._zod.parse=(n,o)=>{if(o.direction==="backward")return r.innerType._zod.run(n,o);if(n.value===void 0)return n.value=r.defaultValue,n;let t=r.innerType._zod.run(n,o);return t instanceof Promise?t.then(a=>Lu(a,r)):Lu(t,r)}});function Lu(e,r){return e.value===void 0&&(e.value=r.defaultValue),e}var bi=g("$ZodPrefault",(e,r)=>{P.init(e,r),e._zod.optin="optional",O(e._zod,"values",()=>r.innerType._zod.values),e._zod.parse=(n,o)=>(o.direction==="backward"||n.value===void 0&&(n.value=r.defaultValue),r.innerType._zod.run(n,o))}),xi=g("$ZodNonOptional",(e,r)=>{P.init(e,r),O(e._zod,"values",()=>{let n=r.innerType._zod.values;return n?new Set([...n].filter(o=>o!==void 0)):void 0}),e._zod.parse=(n,o)=>{let t=r.innerType._zod.run(n,o);return t instanceof Promise?t.then(a=>Cu(a,e)):Cu(t,e)}});function Cu(e,r){return!e.issues.length&&e.value===void 0&&e.issues.push({code:"invalid_type",expected:"nonoptional",input:e.value,inst:r}),e}var _i=g("$ZodSuccess",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{if(o.direction==="backward")throw new he("ZodSuccess");let t=r.innerType._zod.run(n,o);return t instanceof Promise?t.then(a=>(n.value=a.issues.length===0,n)):(n.value=t.issues.length===0,n)}}),Si=g("$ZodCatch",(e,r)=>{P.init(e,r),O(e._zod,"optin",()=>r.innerType._zod.optin),O(e._zod,"optout",()=>r.innerType._zod.optout),O(e._zod,"values",()=>r.innerType._zod.values),e._zod.parse=(n,o)=>{if(o.direction==="backward")return r.innerType._zod.run(n,o);let t=r.innerType._zod.run(n,o);return t instanceof Promise?t.then(a=>(n.value=a.value,a.issues.length&&(n.value=r.catchValue(I(f({},n),{error:{issues:a.issues.map(c=>B(c,o,M()))},input:n.value})),n.issues=[]),n)):(n.value=t.value,t.issues.length&&(n.value=r.catchValue(I(f({},n),{error:{issues:t.issues.map(a=>B(a,o,M()))},input:n.value})),n.issues=[]),n)}}),ki=g("$ZodNaN",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>((typeof n.value!="number"||!Number.isNaN(n.value))&&n.issues.push({input:n.value,inst:e,expected:"nan",code:"invalid_type"}),n)}),Ii=g("$ZodPipe",(e,r)=>{P.init(e,r),O(e._zod,"values",()=>r.in._zod.values),O(e._zod,"optin",()=>r.in._zod.optin),O(e._zod,"optout",()=>r.out._zod.optout),O(e._zod,"propValues",()=>r.in._zod.propValues),e._zod.parse=(n,o)=>{if(o.direction==="backward"){let a=r.out._zod.run(n,o);return a instanceof Promise?a.then(c=>sr(c,r.in,o)):sr(a,r.in,o)}let t=r.in._zod.run(n,o);return t instanceof Promise?t.then(a=>sr(a,r.out,o)):sr(t,r.out,o)}});function sr(e,r,n){return e.issues.length?(e.aborted=!0,e):r._zod.run({value:e.value,issues:e.issues},n)}var pt=g("$ZodCodec",(e,r)=>{P.init(e,r),O(e._zod,"values",()=>r.in._zod.values),O(e._zod,"optin",()=>r.in._zod.optin),O(e._zod,"optout",()=>r.out._zod.optout),O(e._zod,"propValues",()=>r.in._zod.propValues),e._zod.parse=(n,o)=>{if((o.direction||"forward")==="forward"){let a=r.in._zod.run(n,o);return a instanceof Promise?a.then(c=>dr(c,r,o)):dr(a,r,o)}else{let a=r.out._zod.run(n,o);return a instanceof Promise?a.then(c=>dr(c,r,o)):dr(a,r,o)}}});function dr(e,r,n){if(e.issues.length)return e.aborted=!0,e;if((n.direction||"forward")==="forward"){let t=r.transform(e.value,e);return t instanceof Promise?t.then(a=>mr(e,a,r.out,n)):mr(e,t,r.out,n)}else{let t=r.reverseTransform(e.value,e);return t instanceof Promise?t.then(a=>mr(e,a,r.in,n)):mr(e,t,r.in,n)}}function mr(e,r,n,o){return e.issues.length?(e.aborted=!0,e):n._zod.run({value:r,issues:e.issues},o)}var zi=g("$ZodReadonly",(e,r)=>{P.init(e,r),O(e._zod,"propValues",()=>r.innerType._zod.propValues),O(e._zod,"values",()=>r.innerType._zod.values),O(e._zod,"optin",()=>{var n,o;return(o=(n=r.innerType)==null?void 0:n._zod)==null?void 0:o.optin}),O(e._zod,"optout",()=>{var n,o;return(o=(n=r.innerType)==null?void 0:n._zod)==null?void 0:o.optout}),e._zod.parse=(n,o)=>{if(o.direction==="backward")return r.innerType._zod.run(n,o);let t=r.innerType._zod.run(n,o);return t instanceof Promise?t.then(Ru):Ru(t)}});function Ru(e){return e.value=Object.freeze(e.value),e}var Ti=g("$ZodTemplateLiteral",(e,r)=>{P.init(e,r);let n=[];for(let o of r.parts)if(typeof o=="object"&&o!==null){if(!o._zod.pattern)throw new Error(`Invalid template literal part, no pattern found: ${[...o._zod.traits].shift()}`);let t=o._zod.pattern instanceof RegExp?o._zod.pattern.source:o._zod.pattern;if(!t)throw new Error(`Invalid template literal part: ${o._zod.traits}`);let a=t.startsWith("^")?1:0,c=t.endsWith("$")?t.length-1:t.length;n.push(t.slice(a,c))}else if(o===null||_n.has(typeof o))n.push(H(`${o}`));else throw new Error(`Invalid template literal part: ${o}`);e._zod.pattern=new RegExp(`^${n.join("")}$`),e._zod.parse=(o,t)=>{var a;return typeof o.value!="string"?(o.issues.push({input:o.value,inst:e,expected:"string",code:"invalid_type"}),o):(e._zod.pattern.lastIndex=0,e._zod.pattern.test(o.value)||o.issues.push({input:o.value,inst:e,code:"invalid_format",format:(a=r.format)!=null?a:"template_literal",pattern:e._zod.pattern.source}),o)}}),wi=g("$ZodFunction",(e,r)=>(P.init(e,r),e._def=r,e._zod.def=r,e.implement=n=>{if(typeof n!="function")throw new Error("implement() must be called with a function");return function(...o){let t=e._def.input?qt(e._def.input,o):o,a=Reflect.apply(n,this,t);return e._def.output?qt(e._def.output,a):a}},e.implementAsync=n=>{if(typeof n!="function")throw new Error("implementAsync() must be called with a function");return async function(...o){let t=e._def.input?await Xt(e._def.input,o):o,a=await Reflect.apply(n,this,t);return e._def.output?await Xt(e._def.output,a):a}},e._zod.parse=(n,o)=>typeof n.value!="function"?(n.issues.push({code:"invalid_type",expected:"function",input:n.value,inst:e}),n):(e._def.output&&e._def.output._zod.def.type==="promise"?n.value=e.implementAsync(n.value):n.value=e.implement(n.value),n),e.input=(...n)=>{let o=e.constructor;return Array.isArray(n[0])?new o({type:"function",input:new vr({type:"tuple",items:n[0],rest:n[1]}),output:e._def.output}):new o({type:"function",input:n[0],output:e._def.output})},e.output=n=>{let o=e.constructor;return new o({type:"function",input:e._def.input,output:n})},e)),Pi=g("$ZodPromise",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>Promise.resolve(n.value).then(t=>r.innerType._zod.run({value:t,issues:[]},o))}),Di=g("$ZodLazy",(e,r)=>{P.init(e,r),O(e._zod,"innerType",()=>r.getter()),O(e._zod,"pattern",()=>{var n,o;return(o=(n=e._zod.innerType)==null?void 0:n._zod)==null?void 0:o.pattern}),O(e._zod,"propValues",()=>{var n,o;return(o=(n=e._zod.innerType)==null?void 0:n._zod)==null?void 0:o.propValues}),O(e._zod,"optin",()=>{var n,o,t;return(t=(o=(n=e._zod.innerType)==null?void 0:n._zod)==null?void 0:o.optin)!=null?t:void 0}),O(e._zod,"optout",()=>{var n,o,t;return(t=(o=(n=e._zod.innerType)==null?void 0:n._zod)==null?void 0:o.optout)!=null?t:void 0}),e._zod.parse=(n,o)=>e._zod.innerType._zod.run(n,o)}),ji=g("$ZodCustom",(e,r)=>{L.init(e,r),P.init(e,r),e._zod.parse=(n,o)=>n,e._zod.check=n=>{let o=n.value,t=r.fn(o);if(t instanceof Promise)return t.then(a=>Au(a,n,o,e));Au(t,n,o,e)}});function Au(e,r,n,o){var t;if(!e){let a={code:"custom",input:n,inst:o,path:[...(t=o._zod.def.path)!=null?t:[]],continue:!o._zod.def.abort};o._zod.def.params&&(a.params=o._zod.def.params),r.issues.push(Re(a))}}var Be={};ve(Be,{ar:()=>Bu,az:()=>Gu,be:()=>qu,bg:()=>Xu,ca:()=>Qu,cs:()=>Yu,da:()=>Hu,de:()=>el,en:()=>yr,eo:()=>tl,es:()=>rl,fa:()=>nl,fi:()=>ol,fr:()=>il,frCA:()=>al,he:()=>cl,hu:()=>ul,hy:()=>sl,id:()=>dl,is:()=>ml,it:()=>pl,ja:()=>fl,ka:()=>gl,kh:()=>vl,km:()=>$r,ko:()=>hl,lt:()=>$l,mk:()=>bl,ms:()=>xl,nl:()=>_l,no:()=>Sl,ota:()=>kl,pl:()=>zl,ps:()=>Il,pt:()=>Tl,ru:()=>Pl,sl:()=>Dl,sv:()=>jl,ta:()=>Ol,th:()=>Ul,tr:()=>Nl,ua:()=>El,uk:()=>br,ur:()=>Zl,uz:()=>Ll,vi:()=>Cl,yo:()=>Ml,zhCN:()=>Rl,zhTW:()=>Al});var ep=()=>{let e={string:{unit:"\\u062D\\u0631\\u0641",verb:"\\u0623\\u0646 \\u064A\\u062D\\u0648\\u064A"},file:{unit:"\\u0628\\u0627\\u064A\\u062A",verb:"\\u0623\\u0646 \\u064A\\u062D\\u0648\\u064A"},array:{unit:"\\u0639\\u0646\\u0635\\u0631",verb:"\\u0623\\u0646 \\u064A\\u062D\\u0648\\u064A"},set:{unit:"\\u0639\\u0646\\u0635\\u0631",verb:"\\u0623\\u0646 \\u064A\\u062D\\u0648\\u064A"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0645\\u062F\\u062E\\u0644",email:"\\u0628\\u0631\\u064A\\u062F \\u0625\\u0644\\u0643\\u062A\\u0631\\u0648\\u0646\\u064A",url:"\\u0631\\u0627\\u0628\\u0637",emoji:"\\u0625\\u064A\\u0645\\u0648\\u062C\\u064A",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"\\u062A\\u0627\\u0631\\u064A\\u062E \\u0648\\u0648\\u0642\\u062A \\u0628\\u0645\\u0639\\u064A\\u0627\\u0631 ISO",date:"\\u062A\\u0627\\u0631\\u064A\\u062E \\u0628\\u0645\\u0639\\u064A\\u0627\\u0631 ISO",time:"\\u0648\\u0642\\u062A \\u0628\\u0645\\u0639\\u064A\\u0627\\u0631 ISO",duration:"\\u0645\\u062F\\u0629 \\u0628\\u0645\\u0639\\u064A\\u0627\\u0631 ISO",ipv4:"\\u0639\\u0646\\u0648\\u0627\\u0646 IPv4",ipv6:"\\u0639\\u0646\\u0648\\u0627\\u0646 IPv6",cidrv4:"\\u0645\\u062F\\u0649 \\u0639\\u0646\\u0627\\u0648\\u064A\\u0646 \\u0628\\u0635\\u064A\\u063A\\u0629 IPv4",cidrv6:"\\u0645\\u062F\\u0649 \\u0639\\u0646\\u0627\\u0648\\u064A\\u0646 \\u0628\\u0635\\u064A\\u063A\\u0629 IPv6",base64:"\\u0646\\u064E\\u0635 \\u0628\\u062A\\u0631\\u0645\\u064A\\u0632 base64-encoded",base64url:"\\u0646\\u064E\\u0635 \\u0628\\u062A\\u0631\\u0645\\u064A\\u0632 base64url-encoded",json_string:"\\u0646\\u064E\\u0635 \\u0639\\u0644\\u0649 \\u0647\\u064A\\u0626\\u0629 JSON",e164:"\\u0631\\u0642\\u0645 \\u0647\\u0627\\u062A\\u0641 \\u0628\\u0645\\u0639\\u064A\\u0627\\u0631 E.164",jwt:"JWT",template_literal:"\\u0645\\u062F\\u062E\\u0644"},o={nan:"NaN"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u0645\\u062F\\u062E\\u0644\\u0627\\u062A \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644\\u0629: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0625\\u062F\\u062E\\u0627\\u0644 instanceof ${t.expected}\\u060C \\u0648\\u0644\\u0643\\u0646 \\u062A\\u0645 \\u0625\\u062F\\u062E\\u0627\\u0644 ${p}`:`\\u0645\\u062F\\u062E\\u0644\\u0627\\u062A \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644\\u0629: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0625\\u062F\\u062E\\u0627\\u0644 ${i}\\u060C \\u0648\\u0644\\u0643\\u0646 \\u062A\\u0645 \\u0625\\u062F\\u062E\\u0627\\u0644 ${p}`}case"invalid_value":return t.values.length===1?`\\u0645\\u062F\\u062E\\u0644\\u0627\\u062A \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644\\u0629: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0625\\u062F\\u062E\\u0627\\u0644 ${$(t.values[0])}`:`\\u0627\\u062E\\u062A\\u064A\\u0627\\u0631 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062A\\u0648\\u0642\\u0639 \\u0627\\u0646\\u062A\\u0642\\u0627\\u0621 \\u0623\\u062D\\u062F \\u0647\\u0630\\u0647 \\u0627\\u0644\\u062E\\u064A\\u0627\\u0631\\u0627\\u062A: ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?` \\u0623\\u0643\\u0628\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0644\\u0627\\u0632\\u0645: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0623\\u0646 \\u062A\\u0643\\u0648\\u0646 ${(m=t.origin)!=null?m:"\\u0627\\u0644\\u0642\\u064A\\u0645\\u0629"} ${i} ${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0639\\u0646\\u0635\\u0631"}`:`\\u0623\\u0643\\u0628\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0644\\u0627\\u0632\\u0645: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0623\\u0646 \\u062A\\u0643\\u0648\\u0646 ${(u=t.origin)!=null?u:"\\u0627\\u0644\\u0642\\u064A\\u0645\\u0629"} ${i} ${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u0623\\u0635\\u063A\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0644\\u0627\\u0632\\u0645: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0644\\u0640 ${t.origin} \\u0623\\u0646 \\u064A\\u0643\\u0648\\u0646 ${i} ${t.minimum.toString()} ${l.unit}`:`\\u0623\\u0635\\u063A\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0644\\u0627\\u0632\\u0645: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0644\\u0640 ${t.origin} \\u0623\\u0646 \\u064A\\u0643\\u0648\\u0646 ${i} ${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u0646\\u064E\\u0635 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062C\\u0628 \\u0623\\u0646 \\u064A\\u0628\\u062F\\u0623 \\u0628\\u0640 "${t.prefix}"`:i.format==="ends_with"?`\\u0646\\u064E\\u0635 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062C\\u0628 \\u0623\\u0646 \\u064A\\u0646\\u062A\\u0647\\u064A \\u0628\\u0640 "${i.suffix}"`:i.format==="includes"?`\\u0646\\u064E\\u0635 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062C\\u0628 \\u0623\\u0646 \\u064A\\u062A\\u0636\\u0645\\u0651\\u064E\\u0646 "${i.includes}"`:i.format==="regex"?`\\u0646\\u064E\\u0635 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062C\\u0628 \\u0623\\u0646 \\u064A\\u0637\\u0627\\u0628\\u0642 \\u0627\\u0644\\u0646\\u0645\\u0637 ${i.pattern}`:`${(d=n[i.format])!=null?d:t.format} \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644`}case"not_multiple_of":return`\\u0631\\u0642\\u0645 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062C\\u0628 \\u0623\\u0646 \\u064A\\u0643\\u0648\\u0646 \\u0645\\u0646 \\u0645\\u0636\\u0627\\u0639\\u0641\\u0627\\u062A ${t.divisor}`;case"unrecognized_keys":return`\\u0645\\u0639\\u0631\\u0641${t.keys.length>1?"\\u0627\\u062A":""} \\u063A\\u0631\\u064A\\u0628${t.keys.length>1?"\\u0629":""}: ${h(t.keys,"\\u060C ")}`;case"invalid_key":return`\\u0645\\u0639\\u0631\\u0641 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644 \\u0641\\u064A ${t.origin}`;case"invalid_union":return"\\u0645\\u062F\\u062E\\u0644 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644";case"invalid_element":return`\\u0645\\u062F\\u062E\\u0644 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644 \\u0641\\u064A ${t.origin}`;default:return"\\u0645\\u062F\\u062E\\u0644 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644"}}};function Bu(){return{localeError:ep()}}var tp=()=>{let e={string:{unit:"simvol",verb:"olmal\\u0131d\\u0131r"},file:{unit:"bayt",verb:"olmal\\u0131d\\u0131r"},array:{unit:"element",verb:"olmal\\u0131d\\u0131r"},set:{unit:"element",verb:"olmal\\u0131d\\u0131r"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"input",email:"email address",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO datetime",date:"ISO date",time:"ISO time",duration:"ISO duration",ipv4:"IPv4 address",ipv6:"IPv6 address",cidrv4:"IPv4 range",cidrv6:"IPv6 range",base64:"base64-encoded string",base64url:"base64url-encoded string",json_string:"JSON string",e164:"E.164 number",jwt:"JWT",template_literal:"input"},o={nan:"NaN"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Yanl\\u0131\\u015F d\\u0259y\\u0259r: g\\xF6zl\\u0259nil\\u0259n instanceof ${t.expected}, daxil olan ${p}`:`Yanl\\u0131\\u015F d\\u0259y\\u0259r: g\\xF6zl\\u0259nil\\u0259n ${i}, daxil olan ${p}`}case"invalid_value":return t.values.length===1?`Yanl\\u0131\\u015F d\\u0259y\\u0259r: g\\xF6zl\\u0259nil\\u0259n ${$(t.values[0])}`:`Yanl\\u0131\\u015F se\\xE7im: a\\u015Fa\\u011F\\u0131dak\\u0131lardan biri olmal\\u0131d\\u0131r: ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\xC7ox b\\xF6y\\xFCk: g\\xF6zl\\u0259nil\\u0259n ${(m=t.origin)!=null?m:"d\\u0259y\\u0259r"} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"element"}`:`\\xC7ox b\\xF6y\\xFCk: g\\xF6zl\\u0259nil\\u0259n ${(u=t.origin)!=null?u:"d\\u0259y\\u0259r"} ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\xC7ox ki\\xE7ik: g\\xF6zl\\u0259nil\\u0259n ${t.origin} ${i}${t.minimum.toString()} ${l.unit}`:`\\xC7ox ki\\xE7ik: g\\xF6zl\\u0259nil\\u0259n ${t.origin} ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Yanl\\u0131\\u015F m\\u0259tn: "${i.prefix}" il\\u0259 ba\\u015Flamal\\u0131d\\u0131r`:i.format==="ends_with"?`Yanl\\u0131\\u015F m\\u0259tn: "${i.suffix}" il\\u0259 bitm\\u0259lidir`:i.format==="includes"?`Yanl\\u0131\\u015F m\\u0259tn: "${i.includes}" daxil olmal\\u0131d\\u0131r`:i.format==="regex"?`Yanl\\u0131\\u015F m\\u0259tn: ${i.pattern} \\u015Fablonuna uy\\u011Fun olmal\\u0131d\\u0131r`:`Yanl\\u0131\\u015F ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Yanl\\u0131\\u015F \\u0259d\\u0259d: ${t.divisor} il\\u0259 b\\xF6l\\xFCn\\u0259 bil\\u0259n olmal\\u0131d\\u0131r`;case"unrecognized_keys":return`Tan\\u0131nmayan a\\xE7ar${t.keys.length>1?"lar":""}: ${h(t.keys,", ")}`;case"invalid_key":return`${t.origin} daxilind\\u0259 yanl\\u0131\\u015F a\\xE7ar`;case"invalid_union":return"Yanl\\u0131\\u015F d\\u0259y\\u0259r";case"invalid_element":return`${t.origin} daxilind\\u0259 yanl\\u0131\\u015F d\\u0259y\\u0259r`;default:return"Yanl\\u0131\\u015F d\\u0259y\\u0259r"}}};function Gu(){return{localeError:tp()}}function Wu(e,r,n,o){let t=Math.abs(e),a=t%10,c=t%100;return c>=11&&c<=19?o:a===1?r:a>=2&&a<=4?n:o}var rp=()=>{let e={string:{unit:{one:"\\u0441\\u0456\\u043C\\u0432\\u0430\\u043B",few:"\\u0441\\u0456\\u043C\\u0432\\u0430\\u043B\\u044B",many:"\\u0441\\u0456\\u043C\\u0432\\u0430\\u043B\\u0430\\u045E"},verb:"\\u043C\\u0435\\u0446\\u044C"},array:{unit:{one:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442",few:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u044B",many:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430\\u045E"},verb:"\\u043C\\u0435\\u0446\\u044C"},set:{unit:{one:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442",few:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u044B",many:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430\\u045E"},verb:"\\u043C\\u0435\\u0446\\u044C"},file:{unit:{one:"\\u0431\\u0430\\u0439\\u0442",few:"\\u0431\\u0430\\u0439\\u0442\\u044B",many:"\\u0431\\u0430\\u0439\\u0442\\u0430\\u045E"},verb:"\\u043C\\u0435\\u0446\\u044C"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0443\\u0432\\u043E\\u0434",email:"email \\u0430\\u0434\\u0440\\u0430\\u0441",url:"URL",emoji:"\\u044D\\u043C\\u043E\\u0434\\u0437\\u0456",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO \\u0434\\u0430\\u0442\\u0430 \\u0456 \\u0447\\u0430\\u0441",date:"ISO \\u0434\\u0430\\u0442\\u0430",time:"ISO \\u0447\\u0430\\u0441",duration:"ISO \\u043F\\u0440\\u0430\\u0446\\u044F\\u0433\\u043B\\u0430\\u0441\\u0446\\u044C",ipv4:"IPv4 \\u0430\\u0434\\u0440\\u0430\\u0441",ipv6:"IPv6 \\u0430\\u0434\\u0440\\u0430\\u0441",cidrv4:"IPv4 \\u0434\\u044B\\u044F\\u043F\\u0430\\u0437\\u043E\\u043D",cidrv6:"IPv6 \\u0434\\u044B\\u044F\\u043F\\u0430\\u0437\\u043E\\u043D",base64:"\\u0440\\u0430\\u0434\\u043E\\u043A \\u0443 \\u0444\\u0430\\u0440\\u043C\\u0430\\u0446\\u0435 base64",base64url:"\\u0440\\u0430\\u0434\\u043E\\u043A \\u0443 \\u0444\\u0430\\u0440\\u043C\\u0430\\u0446\\u0435 base64url",json_string:"JSON \\u0440\\u0430\\u0434\\u043E\\u043A",e164:"\\u043D\\u0443\\u043C\\u0430\\u0440 E.164",jwt:"JWT",template_literal:"\\u0443\\u0432\\u043E\\u0434"},o={nan:"NaN",number:"\\u043B\\u0456\\u043A",array:"\\u043C\\u0430\\u0441\\u0456\\u045E"};return t=>{var a,c,m,s,u;switch(t.code){case"invalid_type":{let d=(a=o[t.expected])!=null?a:t.expected,i=b(t.input),l=(c=o[i])!=null?c:i;return/^[A-Z]/.test(t.expected)?`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u045E\\u0432\\u043E\\u0434: \\u0447\\u0430\\u043A\\u0430\\u045E\\u0441\\u044F instanceof ${t.expected}, \\u0430\\u0442\\u0440\\u044B\\u043C\\u0430\\u043D\\u0430 ${l}`:`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u045E\\u0432\\u043E\\u0434: \\u0447\\u0430\\u043A\\u0430\\u045E\\u0441\\u044F ${d}, \\u0430\\u0442\\u0440\\u044B\\u043C\\u0430\\u043D\\u0430 ${l}`}case"invalid_value":return t.values.length===1?`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u045E\\u0432\\u043E\\u0434: \\u0447\\u0430\\u043A\\u0430\\u043B\\u0430\\u0441\\u044F ${$(t.values[0])}`:`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u0432\\u0430\\u0440\\u044B\\u044F\\u043D\\u0442: \\u0447\\u0430\\u043A\\u0430\\u045E\\u0441\\u044F \\u0430\\u0434\\u0437\\u0456\\u043D \\u0437 ${h(t.values,"|")}`;case"too_big":{let d=t.inclusive?"<=":"<",i=r(t.origin);if(i){let l=Number(t.maximum),p=Wu(l,i.unit.one,i.unit.few,i.unit.many);return`\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u0430 \\u0432\\u044F\\u043B\\u0456\\u043A\\u0456: \\u0447\\u0430\\u043A\\u0430\\u043B\\u0430\\u0441\\u044F, \\u0448\\u0442\\u043E ${(m=t.origin)!=null?m:"\\u0437\\u043D\\u0430\\u0447\\u044D\\u043D\\u043D\\u0435"} \\u043F\\u0430\\u0432\\u0456\\u043D\\u043D\\u0430 ${i.verb} ${d}${t.maximum.toString()} ${p}`}return`\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u0430 \\u0432\\u044F\\u043B\\u0456\\u043A\\u0456: \\u0447\\u0430\\u043A\\u0430\\u043B\\u0430\\u0441\\u044F, \\u0448\\u0442\\u043E ${(s=t.origin)!=null?s:"\\u0437\\u043D\\u0430\\u0447\\u044D\\u043D\\u043D\\u0435"} \\u043F\\u0430\\u0432\\u0456\\u043D\\u043D\\u0430 \\u0431\\u044B\\u0446\\u044C ${d}${t.maximum.toString()}`}case"too_small":{let d=t.inclusive?">=":">",i=r(t.origin);if(i){let l=Number(t.minimum),p=Wu(l,i.unit.one,i.unit.few,i.unit.many);return`\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u0430 \\u043C\\u0430\\u043B\\u044B: \\u0447\\u0430\\u043A\\u0430\\u043B\\u0430\\u0441\\u044F, \\u0448\\u0442\\u043E ${t.origin} \\u043F\\u0430\\u0432\\u0456\\u043D\\u043D\\u0430 ${i.verb} ${d}${t.minimum.toString()} ${p}`}return`\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u0430 \\u043C\\u0430\\u043B\\u044B: \\u0447\\u0430\\u043A\\u0430\\u043B\\u0430\\u0441\\u044F, \\u0448\\u0442\\u043E ${t.origin} \\u043F\\u0430\\u0432\\u0456\\u043D\\u043D\\u0430 \\u0431\\u044B\\u0446\\u044C ${d}${t.minimum.toString()}`}case"invalid_format":{let d=t;return d.format==="starts_with"?`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u0440\\u0430\\u0434\\u043E\\u043A: \\u043F\\u0430\\u0432\\u0456\\u043D\\u0435\\u043D \\u043F\\u0430\\u0447\\u044B\\u043D\\u0430\\u0446\\u0446\\u0430 \\u0437 "${d.prefix}"`:d.format==="ends_with"?`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u0440\\u0430\\u0434\\u043E\\u043A: \\u043F\\u0430\\u0432\\u0456\\u043D\\u0435\\u043D \\u0437\\u0430\\u043A\\u0430\\u043D\\u0447\\u0432\\u0430\\u0446\\u0446\\u0430 \\u043D\\u0430 "${d.suffix}"`:d.format==="includes"?`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u0440\\u0430\\u0434\\u043E\\u043A: \\u043F\\u0430\\u0432\\u0456\\u043D\\u0435\\u043D \\u0437\\u043C\\u044F\\u0448\\u0447\\u0430\\u0446\\u044C "${d.includes}"`:d.format==="regex"?`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u0440\\u0430\\u0434\\u043E\\u043A: \\u043F\\u0430\\u0432\\u0456\\u043D\\u0435\\u043D \\u0430\\u0434\\u043F\\u0430\\u0432\\u044F\\u0434\\u0430\\u0446\\u044C \\u0448\\u0430\\u0431\\u043B\\u043E\\u043D\\u0443 ${d.pattern}`:`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B ${(u=n[d.format])!=null?u:t.format}`}case"not_multiple_of":return`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u043B\\u0456\\u043A: \\u043F\\u0430\\u0432\\u0456\\u043D\\u0435\\u043D \\u0431\\u044B\\u0446\\u044C \\u043A\\u0440\\u0430\\u0442\\u043D\\u044B\\u043C ${t.divisor}`;case"unrecognized_keys":return`\\u041D\\u0435\\u0440\\u0430\\u0441\\u043F\\u0430\\u0437\\u043D\\u0430\\u043D\\u044B ${t.keys.length>1?"\\u043A\\u043B\\u044E\\u0447\\u044B":"\\u043A\\u043B\\u044E\\u0447"}: ${h(t.keys,", ")}`;case"invalid_key":return`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u043A\\u043B\\u044E\\u0447 \\u0443 ${t.origin}`;case"invalid_union":return"\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u045E\\u0432\\u043E\\u0434";case"invalid_element":return`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u0430\\u0435 \\u0437\\u043D\\u0430\\u0447\\u044D\\u043D\\u043D\\u0435 \\u045E ${t.origin}`;default:return"\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u045E\\u0432\\u043E\\u0434"}}};function qu(){return{localeError:rp()}}var np=()=>{let e={string:{unit:"\\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u0430",verb:"\\u0434\\u0430 \\u0441\\u044A\\u0434\\u044A\\u0440\\u0436\\u0430"},file:{unit:"\\u0431\\u0430\\u0439\\u0442\\u0430",verb:"\\u0434\\u0430 \\u0441\\u044A\\u0434\\u044A\\u0440\\u0436\\u0430"},array:{unit:"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430",verb:"\\u0434\\u0430 \\u0441\\u044A\\u0434\\u044A\\u0440\\u0436\\u0430"},set:{unit:"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430",verb:"\\u0434\\u0430 \\u0441\\u044A\\u0434\\u044A\\u0440\\u0436\\u0430"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0432\\u0445\\u043E\\u0434",email:"\\u0438\\u043C\\u0435\\u0439\\u043B \\u0430\\u0434\\u0440\\u0435\\u0441",url:"URL",emoji:"\\u0435\\u043C\\u043E\\u0434\\u0436\\u0438",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO \\u0432\\u0440\\u0435\\u043C\\u0435",date:"ISO \\u0434\\u0430\\u0442\\u0430",time:"ISO \\u0432\\u0440\\u0435\\u043C\\u0435",duration:"ISO \\u043F\\u0440\\u043E\\u0434\\u044A\\u043B\\u0436\\u0438\\u0442\\u0435\\u043B\\u043D\\u043E\\u0441\\u0442",ipv4:"IPv4 \\u0430\\u0434\\u0440\\u0435\\u0441",ipv6:"IPv6 \\u0430\\u0434\\u0440\\u0435\\u0441",cidrv4:"IPv4 \\u0434\\u0438\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D",cidrv6:"IPv6 \\u0434\\u0438\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D",base64:"base64-\\u043A\\u043E\\u0434\\u0438\\u0440\\u0430\\u043D \\u043D\\u0438\\u0437",base64url:"base64url-\\u043A\\u043E\\u0434\\u0438\\u0440\\u0430\\u043D \\u043D\\u0438\\u0437",json_string:"JSON \\u043D\\u0438\\u0437",e164:"E.164 \\u043D\\u043E\\u043C\\u0435\\u0440",jwt:"JWT",template_literal:"\\u0432\\u0445\\u043E\\u0434"},o={nan:"NaN",number:"\\u0447\\u0438\\u0441\\u043B\\u043E",array:"\\u043C\\u0430\\u0441\\u0438\\u0432"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u0432\\u0445\\u043E\\u0434: \\u043E\\u0447\\u0430\\u043A\\u0432\\u0430\\u043D instanceof ${t.expected}, \\u043F\\u043E\\u043B\\u0443\\u0447\\u0435\\u043D ${p}`:`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u0432\\u0445\\u043E\\u0434: \\u043E\\u0447\\u0430\\u043A\\u0432\\u0430\\u043D ${i}, \\u043F\\u043E\\u043B\\u0443\\u0447\\u0435\\u043D ${p}`}case"invalid_value":return t.values.length===1?`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u0432\\u0445\\u043E\\u0434: \\u043E\\u0447\\u0430\\u043A\\u0432\\u0430\\u043D ${$(t.values[0])}`:`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u0430 \\u043E\\u043F\\u0446\\u0438\\u044F: \\u043E\\u0447\\u0430\\u043A\\u0432\\u0430\\u043D\\u043E \\u0435\\u0434\\u043D\\u043E \\u043E\\u0442 ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u0422\\u0432\\u044A\\u0440\\u0434\\u0435 \\u0433\\u043E\\u043B\\u044F\\u043C\\u043E: \\u043E\\u0447\\u0430\\u043A\\u0432\\u0430 \\u0441\\u0435 ${(m=t.origin)!=null?m:"\\u0441\\u0442\\u043E\\u0439\\u043D\\u043E\\u0441\\u0442"} \\u0434\\u0430 \\u0441\\u044A\\u0434\\u044A\\u0440\\u0436\\u0430 ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430"}`:`\\u0422\\u0432\\u044A\\u0440\\u0434\\u0435 \\u0433\\u043E\\u043B\\u044F\\u043C\\u043E: \\u043E\\u0447\\u0430\\u043A\\u0432\\u0430 \\u0441\\u0435 ${(u=t.origin)!=null?u:"\\u0441\\u0442\\u043E\\u0439\\u043D\\u043E\\u0441\\u0442"} \\u0434\\u0430 \\u0431\\u044A\\u0434\\u0435 ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u0422\\u0432\\u044A\\u0440\\u0434\\u0435 \\u043C\\u0430\\u043B\\u043A\\u043E: \\u043E\\u0447\\u0430\\u043A\\u0432\\u0430 \\u0441\\u0435 ${t.origin} \\u0434\\u0430 \\u0441\\u044A\\u0434\\u044A\\u0440\\u0436\\u0430 ${i}${t.minimum.toString()} ${l.unit}`:`\\u0422\\u0432\\u044A\\u0440\\u0434\\u0435 \\u043C\\u0430\\u043B\\u043A\\u043E: \\u043E\\u0447\\u0430\\u043A\\u0432\\u0430 \\u0441\\u0435 ${t.origin} \\u0434\\u0430 \\u0431\\u044A\\u0434\\u0435 ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;if(i.format==="starts_with")return`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u043D\\u0438\\u0437: \\u0442\\u0440\\u044F\\u0431\\u0432\\u0430 \\u0434\\u0430 \\u0437\\u0430\\u043F\\u043E\\u0447\\u0432\\u0430 \\u0441 "${i.prefix}"`;if(i.format==="ends_with")return`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u043D\\u0438\\u0437: \\u0442\\u0440\\u044F\\u0431\\u0432\\u0430 \\u0434\\u0430 \\u0437\\u0430\\u0432\\u044A\\u0440\\u0448\\u0432\\u0430 \\u0441 "${i.suffix}"`;if(i.format==="includes")return`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u043D\\u0438\\u0437: \\u0442\\u0440\\u044F\\u0431\\u0432\\u0430 \\u0434\\u0430 \\u0432\\u043A\\u043B\\u044E\\u0447\\u0432\\u0430 "${i.includes}"`;if(i.format==="regex")return`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u043D\\u0438\\u0437: \\u0442\\u0440\\u044F\\u0431\\u0432\\u0430 \\u0434\\u0430 \\u0441\\u044A\\u0432\\u043F\\u0430\\u0434\\u0430 \\u0441 ${i.pattern}`;let l="\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D";return i.format==="emoji"&&(l="\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u043E"),i.format==="datetime"&&(l="\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u043E"),i.format==="date"&&(l="\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u0430"),i.format==="time"&&(l="\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u043E"),i.format==="duration"&&(l="\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u0430"),`${l} ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u043E \\u0447\\u0438\\u0441\\u043B\\u043E: \\u0442\\u0440\\u044F\\u0431\\u0432\\u0430 \\u0434\\u0430 \\u0431\\u044A\\u0434\\u0435 \\u043A\\u0440\\u0430\\u0442\\u043D\\u043E \\u043D\\u0430 ${t.divisor}`;case"unrecognized_keys":return`\\u041D\\u0435\\u0440\\u0430\\u0437\\u043F\\u043E\\u0437\\u043D\\u0430\\u0442${t.keys.length>1?"\\u0438":""} \\u043A\\u043B\\u044E\\u0447${t.keys.length>1?"\\u043E\\u0432\\u0435":""}: ${h(t.keys,", ")}`;case"invalid_key":return`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u043A\\u043B\\u044E\\u0447 \\u0432 ${t.origin}`;case"invalid_union":return"\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u0432\\u0445\\u043E\\u0434";case"invalid_element":return`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u0430 \\u0441\\u0442\\u043E\\u0439\\u043D\\u043E\\u0441\\u0442 \\u0432 ${t.origin}`;default:return"\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u0432\\u0445\\u043E\\u0434"}}};function Xu(){return{localeError:np()}}var op=()=>{let e={string:{unit:"car\\xE0cters",verb:"contenir"},file:{unit:"bytes",verb:"contenir"},array:{unit:"elements",verb:"contenir"},set:{unit:"elements",verb:"contenir"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"entrada",email:"adre\\xE7a electr\\xF2nica",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"data i hora ISO",date:"data ISO",time:"hora ISO",duration:"durada ISO",ipv4:"adre\\xE7a IPv4",ipv6:"adre\\xE7a IPv6",cidrv4:"rang IPv4",cidrv6:"rang IPv6",base64:"cadena codificada en base64",base64url:"cadena codificada en base64url",json_string:"cadena JSON",e164:"n\\xFAmero E.164",jwt:"JWT",template_literal:"entrada"},o={nan:"NaN"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Tipus inv\\xE0lid: s\'esperava instanceof ${t.expected}, s\'ha rebut ${p}`:`Tipus inv\\xE0lid: s\'esperava ${i}, s\'ha rebut ${p}`}case"invalid_value":return t.values.length===1?`Valor inv\\xE0lid: s\'esperava ${$(t.values[0])}`:`Opci\\xF3 inv\\xE0lida: s\'esperava una de ${h(t.values," o ")}`;case"too_big":{let i=t.inclusive?"com a m\\xE0xim":"menys de",l=r(t.origin);return l?`Massa gran: s\'esperava que ${(m=t.origin)!=null?m:"el valor"} contingu\\xE9s ${i} ${t.maximum.toString()} ${(s=l.unit)!=null?s:"elements"}`:`Massa gran: s\'esperava que ${(u=t.origin)!=null?u:"el valor"} fos ${i} ${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?"com a m\\xEDnim":"m\\xE9s de",l=r(t.origin);return l?`Massa petit: s\'esperava que ${t.origin} contingu\\xE9s ${i} ${t.minimum.toString()} ${l.unit}`:`Massa petit: s\'esperava que ${t.origin} fos ${i} ${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Format inv\\xE0lid: ha de comen\\xE7ar amb "${i.prefix}"`:i.format==="ends_with"?`Format inv\\xE0lid: ha d\'acabar amb "${i.suffix}"`:i.format==="includes"?`Format inv\\xE0lid: ha d\'incloure "${i.includes}"`:i.format==="regex"?`Format inv\\xE0lid: ha de coincidir amb el patr\\xF3 ${i.pattern}`:`Format inv\\xE0lid per a ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`N\\xFAmero inv\\xE0lid: ha de ser m\\xFAltiple de ${t.divisor}`;case"unrecognized_keys":return`Clau${t.keys.length>1?"s":""} no reconeguda${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`Clau inv\\xE0lida a ${t.origin}`;case"invalid_union":return"Entrada inv\\xE0lida";case"invalid_element":return`Element inv\\xE0lid a ${t.origin}`;default:return"Entrada inv\\xE0lida"}}};function Qu(){return{localeError:op()}}var ip=()=>{let e={string:{unit:"znak\\u016F",verb:"m\\xEDt"},file:{unit:"bajt\\u016F",verb:"m\\xEDt"},array:{unit:"prvk\\u016F",verb:"m\\xEDt"},set:{unit:"prvk\\u016F",verb:"m\\xEDt"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"regul\\xE1rn\\xED v\\xFDraz",email:"e-mailov\\xE1 adresa",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"datum a \\u010Das ve form\\xE1tu ISO",date:"datum ve form\\xE1tu ISO",time:"\\u010Das ve form\\xE1tu ISO",duration:"doba trv\\xE1n\\xED ISO",ipv4:"IPv4 adresa",ipv6:"IPv6 adresa",cidrv4:"rozsah IPv4",cidrv6:"rozsah IPv6",base64:"\\u0159et\\u011Bzec zak\\xF3dovan\\xFD ve form\\xE1tu base64",base64url:"\\u0159et\\u011Bzec zak\\xF3dovan\\xFD ve form\\xE1tu base64url",json_string:"\\u0159et\\u011Bzec ve form\\xE1tu JSON",e164:"\\u010D\\xEDslo E.164",jwt:"JWT",template_literal:"vstup"},o={nan:"NaN",number:"\\u010D\\xEDslo",string:"\\u0159et\\u011Bzec",function:"funkce",array:"pole"};return t=>{var a,c,m,s,u,d,i,l,p;switch(t.code){case"invalid_type":{let v=(a=o[t.expected])!=null?a:t.expected,y=b(t.input),S=(c=o[y])!=null?c:y;return/^[A-Z]/.test(t.expected)?`Neplatn\\xFD vstup: o\\u010Dek\\xE1v\\xE1no instanceof ${t.expected}, obdr\\u017Eeno ${S}`:`Neplatn\\xFD vstup: o\\u010Dek\\xE1v\\xE1no ${v}, obdr\\u017Eeno ${S}`}case"invalid_value":return t.values.length===1?`Neplatn\\xFD vstup: o\\u010Dek\\xE1v\\xE1no ${$(t.values[0])}`:`Neplatn\\xE1 mo\\u017Enost: o\\u010Dek\\xE1v\\xE1na jedna z hodnot ${h(t.values,"|")}`;case"too_big":{let v=t.inclusive?"<=":"<",y=r(t.origin);return y?`Hodnota je p\\u0159\\xEDli\\u0161 velk\\xE1: ${(m=t.origin)!=null?m:"hodnota"} mus\\xED m\\xEDt ${v}${t.maximum.toString()} ${(s=y.unit)!=null?s:"prvk\\u016F"}`:`Hodnota je p\\u0159\\xEDli\\u0161 velk\\xE1: ${(u=t.origin)!=null?u:"hodnota"} mus\\xED b\\xFDt ${v}${t.maximum.toString()}`}case"too_small":{let v=t.inclusive?">=":">",y=r(t.origin);return y?`Hodnota je p\\u0159\\xEDli\\u0161 mal\\xE1: ${(d=t.origin)!=null?d:"hodnota"} mus\\xED m\\xEDt ${v}${t.minimum.toString()} ${(i=y.unit)!=null?i:"prvk\\u016F"}`:`Hodnota je p\\u0159\\xEDli\\u0161 mal\\xE1: ${(l=t.origin)!=null?l:"hodnota"} mus\\xED b\\xFDt ${v}${t.minimum.toString()}`}case"invalid_format":{let v=t;return v.format==="starts_with"?`Neplatn\\xFD \\u0159et\\u011Bzec: mus\\xED za\\u010D\\xEDnat na "${v.prefix}"`:v.format==="ends_with"?`Neplatn\\xFD \\u0159et\\u011Bzec: mus\\xED kon\\u010Dit na "${v.suffix}"`:v.format==="includes"?`Neplatn\\xFD \\u0159et\\u011Bzec: mus\\xED obsahovat "${v.includes}"`:v.format==="regex"?`Neplatn\\xFD \\u0159et\\u011Bzec: mus\\xED odpov\\xEDdat vzoru ${v.pattern}`:`Neplatn\\xFD form\\xE1t ${(p=n[v.format])!=null?p:t.format}`}case"not_multiple_of":return`Neplatn\\xE9 \\u010D\\xEDslo: mus\\xED b\\xFDt n\\xE1sobkem ${t.divisor}`;case"unrecognized_keys":return`Nezn\\xE1m\\xE9 kl\\xED\\u010De: ${h(t.keys,", ")}`;case"invalid_key":return`Neplatn\\xFD kl\\xED\\u010D v ${t.origin}`;case"invalid_union":return"Neplatn\\xFD vstup";case"invalid_element":return`Neplatn\\xE1 hodnota v ${t.origin}`;default:return"Neplatn\\xFD vstup"}}};function Yu(){return{localeError:ip()}}var ap=()=>{let e={string:{unit:"tegn",verb:"havde"},file:{unit:"bytes",verb:"havde"},array:{unit:"elementer",verb:"indeholdt"},set:{unit:"elementer",verb:"indeholdt"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"input",email:"e-mailadresse",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO dato- og klokkesl\\xE6t",date:"ISO-dato",time:"ISO-klokkesl\\xE6t",duration:"ISO-varighed",ipv4:"IPv4-omr\\xE5de",ipv6:"IPv6-omr\\xE5de",cidrv4:"IPv4-spektrum",cidrv6:"IPv6-spektrum",base64:"base64-kodet streng",base64url:"base64url-kodet streng",json_string:"JSON-streng",e164:"E.164-nummer",jwt:"JWT",template_literal:"input"},o={nan:"NaN",string:"streng",number:"tal",boolean:"boolean",array:"liste",object:"objekt",set:"s\\xE6t",file:"fil"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Ugyldigt input: forventede instanceof ${t.expected}, fik ${p}`:`Ugyldigt input: forventede ${i}, fik ${p}`}case"invalid_value":return t.values.length===1?`Ugyldig v\\xE6rdi: forventede ${$(t.values[0])}`:`Ugyldigt valg: forventede en af f\\xF8lgende ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin),p=(m=o[t.origin])!=null?m:t.origin;return l?`For stor: forventede ${p!=null?p:"value"} ${l.verb} ${i} ${t.maximum.toString()} ${(s=l.unit)!=null?s:"elementer"}`:`For stor: forventede ${p!=null?p:"value"} havde ${i} ${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin),p=(u=o[t.origin])!=null?u:t.origin;return l?`For lille: forventede ${p} ${l.verb} ${i} ${t.minimum.toString()} ${l.unit}`:`For lille: forventede ${p} havde ${i} ${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Ugyldig streng: skal starte med "${i.prefix}"`:i.format==="ends_with"?`Ugyldig streng: skal ende med "${i.suffix}"`:i.format==="includes"?`Ugyldig streng: skal indeholde "${i.includes}"`:i.format==="regex"?`Ugyldig streng: skal matche m\\xF8nsteret ${i.pattern}`:`Ugyldig ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Ugyldigt tal: skal v\\xE6re deleligt med ${t.divisor}`;case"unrecognized_keys":return`${t.keys.length>1?"Ukendte n\\xF8gler":"Ukendt n\\xF8gle"}: ${h(t.keys,", ")}`;case"invalid_key":return`Ugyldig n\\xF8gle i ${t.origin}`;case"invalid_union":return"Ugyldigt input: matcher ingen af de tilladte typer";case"invalid_element":return`Ugyldig v\\xE6rdi i ${t.origin}`;default:return"Ugyldigt input"}}};function Hu(){return{localeError:ap()}}var cp=()=>{let e={string:{unit:"Zeichen",verb:"zu haben"},file:{unit:"Bytes",verb:"zu haben"},array:{unit:"Elemente",verb:"zu haben"},set:{unit:"Elemente",verb:"zu haben"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"Eingabe",email:"E-Mail-Adresse",url:"URL",emoji:"Emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO-Datum und -Uhrzeit",date:"ISO-Datum",time:"ISO-Uhrzeit",duration:"ISO-Dauer",ipv4:"IPv4-Adresse",ipv6:"IPv6-Adresse",cidrv4:"IPv4-Bereich",cidrv6:"IPv6-Bereich",base64:"Base64-codierter String",base64url:"Base64-URL-codierter String",json_string:"JSON-String",e164:"E.164-Nummer",jwt:"JWT",template_literal:"Eingabe"},o={nan:"NaN",number:"Zahl",array:"Array"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Ung\\xFCltige Eingabe: erwartet instanceof ${t.expected}, erhalten ${p}`:`Ung\\xFCltige Eingabe: erwartet ${i}, erhalten ${p}`}case"invalid_value":return t.values.length===1?`Ung\\xFCltige Eingabe: erwartet ${$(t.values[0])}`:`Ung\\xFCltige Option: erwartet eine von ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Zu gro\\xDF: erwartet, dass ${(m=t.origin)!=null?m:"Wert"} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"Elemente"} hat`:`Zu gro\\xDF: erwartet, dass ${(u=t.origin)!=null?u:"Wert"} ${i}${t.maximum.toString()} ist`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Zu klein: erwartet, dass ${t.origin} ${i}${t.minimum.toString()} ${l.unit} hat`:`Zu klein: erwartet, dass ${t.origin} ${i}${t.minimum.toString()} ist`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Ung\\xFCltiger String: muss mit "${i.prefix}" beginnen`:i.format==="ends_with"?`Ung\\xFCltiger String: muss mit "${i.suffix}" enden`:i.format==="includes"?`Ung\\xFCltiger String: muss "${i.includes}" enthalten`:i.format==="regex"?`Ung\\xFCltiger String: muss dem Muster ${i.pattern} entsprechen`:`Ung\\xFCltig: ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Ung\\xFCltige Zahl: muss ein Vielfaches von ${t.divisor} sein`;case"unrecognized_keys":return`${t.keys.length>1?"Unbekannte Schl\\xFCssel":"Unbekannter Schl\\xFCssel"}: ${h(t.keys,", ")}`;case"invalid_key":return`Ung\\xFCltiger Schl\\xFCssel in ${t.origin}`;case"invalid_union":return"Ung\\xFCltige Eingabe";case"invalid_element":return`Ung\\xFCltiger Wert in ${t.origin}`;default:return"Ung\\xFCltige Eingabe"}}};function el(){return{localeError:cp()}}var up=()=>{let e={string:{unit:"characters",verb:"to have"},file:{unit:"bytes",verb:"to have"},array:{unit:"items",verb:"to have"},set:{unit:"items",verb:"to have"},map:{unit:"entries",verb:"to have"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"input",email:"email address",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO datetime",date:"ISO date",time:"ISO time",duration:"ISO duration",ipv4:"IPv4 address",ipv6:"IPv6 address",mac:"MAC address",cidrv4:"IPv4 range",cidrv6:"IPv6 range",base64:"base64-encoded string",base64url:"base64url-encoded string",json_string:"JSON string",e164:"E.164 number",jwt:"JWT",template_literal:"input"},o={nan:"NaN"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return`Invalid input: expected ${i}, received ${p}`}case"invalid_value":return t.values.length===1?`Invalid input: expected ${$(t.values[0])}`:`Invalid option: expected one of ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Too big: expected ${(m=t.origin)!=null?m:"value"} to have ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elements"}`:`Too big: expected ${(u=t.origin)!=null?u:"value"} to be ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Too small: expected ${t.origin} to have ${i}${t.minimum.toString()} ${l.unit}`:`Too small: expected ${t.origin} to be ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Invalid string: must start with "${i.prefix}"`:i.format==="ends_with"?`Invalid string: must end with "${i.suffix}"`:i.format==="includes"?`Invalid string: must include "${i.includes}"`:i.format==="regex"?`Invalid string: must match pattern ${i.pattern}`:`Invalid ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Invalid number: must be a multiple of ${t.divisor}`;case"unrecognized_keys":return`Unrecognized key${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`Invalid key in ${t.origin}`;case"invalid_union":return"Invalid input";case"invalid_element":return`Invalid value in ${t.origin}`;default:return"Invalid input"}}};function yr(){return{localeError:up()}}var lp=()=>{let e={string:{unit:"karaktrojn",verb:"havi"},file:{unit:"bajtojn",verb:"havi"},array:{unit:"elementojn",verb:"havi"},set:{unit:"elementojn",verb:"havi"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"enigo",email:"retadreso",url:"URL",emoji:"emo\\u011Dio",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO-datotempo",date:"ISO-dato",time:"ISO-tempo",duration:"ISO-da\\u016Dro",ipv4:"IPv4-adreso",ipv6:"IPv6-adreso",cidrv4:"IPv4-rango",cidrv6:"IPv6-rango",base64:"64-ume kodita karaktraro",base64url:"URL-64-ume kodita karaktraro",json_string:"JSON-karaktraro",e164:"E.164-nombro",jwt:"JWT",template_literal:"enigo"},o={nan:"NaN",number:"nombro",array:"tabelo",null:"senvalora"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Nevalida enigo: atendi\\u011Dis instanceof ${t.expected}, ricevi\\u011Dis ${p}`:`Nevalida enigo: atendi\\u011Dis ${i}, ricevi\\u011Dis ${p}`}case"invalid_value":return t.values.length===1?`Nevalida enigo: atendi\\u011Dis ${$(t.values[0])}`:`Nevalida opcio: atendi\\u011Dis unu el ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Tro granda: atendi\\u011Dis ke ${(m=t.origin)!=null?m:"valoro"} havu ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elementojn"}`:`Tro granda: atendi\\u011Dis ke ${(u=t.origin)!=null?u:"valoro"} havu ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Tro malgranda: atendi\\u011Dis ke ${t.origin} havu ${i}${t.minimum.toString()} ${l.unit}`:`Tro malgranda: atendi\\u011Dis ke ${t.origin} estu ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Nevalida karaktraro: devas komenci\\u011Di per "${i.prefix}"`:i.format==="ends_with"?`Nevalida karaktraro: devas fini\\u011Di per "${i.suffix}"`:i.format==="includes"?`Nevalida karaktraro: devas inkluzivi "${i.includes}"`:i.format==="regex"?`Nevalida karaktraro: devas kongrui kun la modelo ${i.pattern}`:`Nevalida ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Nevalida nombro: devas esti oblo de ${t.divisor}`;case"unrecognized_keys":return`Nekonata${t.keys.length>1?"j":""} \\u015Dlosilo${t.keys.length>1?"j":""}: ${h(t.keys,", ")}`;case"invalid_key":return`Nevalida \\u015Dlosilo en ${t.origin}`;case"invalid_union":return"Nevalida enigo";case"invalid_element":return`Nevalida valoro en ${t.origin}`;default:return"Nevalida enigo"}}};function tl(){return{localeError:lp()}}var sp=()=>{let e={string:{unit:"caracteres",verb:"tener"},file:{unit:"bytes",verb:"tener"},array:{unit:"elementos",verb:"tener"},set:{unit:"elementos",verb:"tener"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"entrada",email:"direcci\\xF3n de correo electr\\xF3nico",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"fecha y hora ISO",date:"fecha ISO",time:"hora ISO",duration:"duraci\\xF3n ISO",ipv4:"direcci\\xF3n IPv4",ipv6:"direcci\\xF3n IPv6",cidrv4:"rango IPv4",cidrv6:"rango IPv6",base64:"cadena codificada en base64",base64url:"URL codificada en base64",json_string:"cadena JSON",e164:"n\\xFAmero E.164",jwt:"JWT",template_literal:"entrada"},o={nan:"NaN",string:"texto",number:"n\\xFAmero",boolean:"booleano",array:"arreglo",object:"objeto",set:"conjunto",file:"archivo",date:"fecha",bigint:"n\\xFAmero grande",symbol:"s\\xEDmbolo",undefined:"indefinido",null:"nulo",function:"funci\\xF3n",map:"mapa",record:"registro",tuple:"tupla",enum:"enumeraci\\xF3n",union:"uni\\xF3n",literal:"literal",promise:"promesa",void:"vac\\xEDo",never:"nunca",unknown:"desconocido",any:"cualquiera"};return t=>{var a,c,m,s,u,d,i,l;switch(t.code){case"invalid_type":{let p=(a=o[t.expected])!=null?a:t.expected,v=b(t.input),y=(c=o[v])!=null?c:v;return/^[A-Z]/.test(t.expected)?`Entrada inv\\xE1lida: se esperaba instanceof ${t.expected}, recibido ${y}`:`Entrada inv\\xE1lida: se esperaba ${p}, recibido ${y}`}case"invalid_value":return t.values.length===1?`Entrada inv\\xE1lida: se esperaba ${$(t.values[0])}`:`Opci\\xF3n inv\\xE1lida: se esperaba una de ${h(t.values,"|")}`;case"too_big":{let p=t.inclusive?"<=":"<",v=r(t.origin),y=(m=o[t.origin])!=null?m:t.origin;return v?`Demasiado grande: se esperaba que ${y!=null?y:"valor"} tuviera ${p}${t.maximum.toString()} ${(s=v.unit)!=null?s:"elementos"}`:`Demasiado grande: se esperaba que ${y!=null?y:"valor"} fuera ${p}${t.maximum.toString()}`}case"too_small":{let p=t.inclusive?">=":">",v=r(t.origin),y=(u=o[t.origin])!=null?u:t.origin;return v?`Demasiado peque\\xF1o: se esperaba que ${y} tuviera ${p}${t.minimum.toString()} ${v.unit}`:`Demasiado peque\\xF1o: se esperaba que ${y} fuera ${p}${t.minimum.toString()}`}case"invalid_format":{let p=t;return p.format==="starts_with"?`Cadena inv\\xE1lida: debe comenzar con "${p.prefix}"`:p.format==="ends_with"?`Cadena inv\\xE1lida: debe terminar en "${p.suffix}"`:p.format==="includes"?`Cadena inv\\xE1lida: debe incluir "${p.includes}"`:p.format==="regex"?`Cadena inv\\xE1lida: debe coincidir con el patr\\xF3n ${p.pattern}`:`Inv\\xE1lido ${(d=n[p.format])!=null?d:t.format}`}case"not_multiple_of":return`N\\xFAmero inv\\xE1lido: debe ser m\\xFAltiplo de ${t.divisor}`;case"unrecognized_keys":return`Llave${t.keys.length>1?"s":""} desconocida${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`Llave inv\\xE1lida en ${(i=o[t.origin])!=null?i:t.origin}`;case"invalid_union":return"Entrada inv\\xE1lida";case"invalid_element":return`Valor inv\\xE1lido en ${(l=o[t.origin])!=null?l:t.origin}`;default:return"Entrada inv\\xE1lida"}}};function rl(){return{localeError:sp()}}var dp=()=>{let e={string:{unit:"\\u06A9\\u0627\\u0631\\u0627\\u06A9\\u062A\\u0631",verb:"\\u062F\\u0627\\u0634\\u062A\\u0647 \\u0628\\u0627\\u0634\\u062F"},file:{unit:"\\u0628\\u0627\\u06CC\\u062A",verb:"\\u062F\\u0627\\u0634\\u062A\\u0647 \\u0628\\u0627\\u0634\\u062F"},array:{unit:"\\u0622\\u06CC\\u062A\\u0645",verb:"\\u062F\\u0627\\u0634\\u062A\\u0647 \\u0628\\u0627\\u0634\\u062F"},set:{unit:"\\u0622\\u06CC\\u062A\\u0645",verb:"\\u062F\\u0627\\u0634\\u062A\\u0647 \\u0628\\u0627\\u0634\\u062F"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0648\\u0631\\u0648\\u062F\\u06CC",email:"\\u0622\\u062F\\u0631\\u0633 \\u0627\\u06CC\\u0645\\u06CC\\u0644",url:"URL",emoji:"\\u0627\\u06CC\\u0645\\u0648\\u062C\\u06CC",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"\\u062A\\u0627\\u0631\\u06CC\\u062E \\u0648 \\u0632\\u0645\\u0627\\u0646 \\u0627\\u06CC\\u0632\\u0648",date:"\\u062A\\u0627\\u0631\\u06CC\\u062E \\u0627\\u06CC\\u0632\\u0648",time:"\\u0632\\u0645\\u0627\\u0646 \\u0627\\u06CC\\u0632\\u0648",duration:"\\u0645\\u062F\\u062A \\u0632\\u0645\\u0627\\u0646 \\u0627\\u06CC\\u0632\\u0648",ipv4:"IPv4 \\u0622\\u062F\\u0631\\u0633",ipv6:"IPv6 \\u0622\\u062F\\u0631\\u0633",cidrv4:"IPv4 \\u062F\\u0627\\u0645\\u0646\\u0647",cidrv6:"IPv6 \\u062F\\u0627\\u0645\\u0646\\u0647",base64:"base64-encoded \\u0631\\u0634\\u062A\\u0647",base64url:"base64url-encoded \\u0631\\u0634\\u062A\\u0647",json_string:"JSON \\u0631\\u0634\\u062A\\u0647",e164:"E.164 \\u0639\\u062F\\u062F",jwt:"JWT",template_literal:"\\u0648\\u0631\\u0648\\u062F\\u06CC"},o={nan:"NaN",number:"\\u0639\\u062F\\u062F",array:"\\u0622\\u0631\\u0627\\u06CC\\u0647"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u0648\\u0631\\u0648\\u062F\\u06CC \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0645\\u06CC\\u200C\\u0628\\u0627\\u06CC\\u0633\\u062A instanceof ${t.expected} \\u0645\\u06CC\\u200C\\u0628\\u0648\\u062F\\u060C ${p} \\u062F\\u0631\\u06CC\\u0627\\u0641\\u062A \\u0634\\u062F`:`\\u0648\\u0631\\u0648\\u062F\\u06CC \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0645\\u06CC\\u200C\\u0628\\u0627\\u06CC\\u0633\\u062A ${i} \\u0645\\u06CC\\u200C\\u0628\\u0648\\u062F\\u060C ${p} \\u062F\\u0631\\u06CC\\u0627\\u0641\\u062A \\u0634\\u062F`}case"invalid_value":return t.values.length===1?`\\u0648\\u0631\\u0648\\u062F\\u06CC \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0645\\u06CC\\u200C\\u0628\\u0627\\u06CC\\u0633\\u062A ${$(t.values[0])} \\u0645\\u06CC\\u200C\\u0628\\u0648\\u062F`:`\\u06AF\\u0632\\u06CC\\u0646\\u0647 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0645\\u06CC\\u200C\\u0628\\u0627\\u06CC\\u0633\\u062A \\u06CC\\u06A9\\u06CC \\u0627\\u0632 ${h(t.values,"|")} \\u0645\\u06CC\\u200C\\u0628\\u0648\\u062F`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u062E\\u06CC\\u0644\\u06CC \\u0628\\u0632\\u0631\\u06AF: ${(m=t.origin)!=null?m:"\\u0645\\u0642\\u062F\\u0627\\u0631"} \\u0628\\u0627\\u06CC\\u062F ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0639\\u0646\\u0635\\u0631"} \\u0628\\u0627\\u0634\\u062F`:`\\u062E\\u06CC\\u0644\\u06CC \\u0628\\u0632\\u0631\\u06AF: ${(u=t.origin)!=null?u:"\\u0645\\u0642\\u062F\\u0627\\u0631"} \\u0628\\u0627\\u06CC\\u062F ${i}${t.maximum.toString()} \\u0628\\u0627\\u0634\\u062F`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u062E\\u06CC\\u0644\\u06CC \\u06A9\\u0648\\u0686\\u06A9: ${t.origin} \\u0628\\u0627\\u06CC\\u062F ${i}${t.minimum.toString()} ${l.unit} \\u0628\\u0627\\u0634\\u062F`:`\\u062E\\u06CC\\u0644\\u06CC \\u06A9\\u0648\\u0686\\u06A9: ${t.origin} \\u0628\\u0627\\u06CC\\u062F ${i}${t.minimum.toString()} \\u0628\\u0627\\u0634\\u062F`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u0631\\u0634\\u062A\\u0647 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0628\\u0627\\u06CC\\u062F \\u0628\\u0627 "${i.prefix}" \\u0634\\u0631\\u0648\\u0639 \\u0634\\u0648\\u062F`:i.format==="ends_with"?`\\u0631\\u0634\\u062A\\u0647 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0628\\u0627\\u06CC\\u062F \\u0628\\u0627 "${i.suffix}" \\u062A\\u0645\\u0627\\u0645 \\u0634\\u0648\\u062F`:i.format==="includes"?`\\u0631\\u0634\\u062A\\u0647 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0628\\u0627\\u06CC\\u062F \\u0634\\u0627\\u0645\\u0644 "${i.includes}" \\u0628\\u0627\\u0634\\u062F`:i.format==="regex"?`\\u0631\\u0634\\u062A\\u0647 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0628\\u0627\\u06CC\\u062F \\u0628\\u0627 \\u0627\\u0644\\u06AF\\u0648\\u06CC ${i.pattern} \\u0645\\u0637\\u0627\\u0628\\u0642\\u062A \\u062F\\u0627\\u0634\\u062A\\u0647 \\u0628\\u0627\\u0634\\u062F`:`${(d=n[i.format])!=null?d:t.format} \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631`}case"not_multiple_of":return`\\u0639\\u062F\\u062F \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0628\\u0627\\u06CC\\u062F \\u0645\\u0636\\u0631\\u0628 ${t.divisor} \\u0628\\u0627\\u0634\\u062F`;case"unrecognized_keys":return`\\u06A9\\u0644\\u06CC\\u062F${t.keys.length>1?"\\u0647\\u0627\\u06CC":""} \\u0646\\u0627\\u0634\\u0646\\u0627\\u0633: ${h(t.keys,", ")}`;case"invalid_key":return`\\u06A9\\u0644\\u06CC\\u062F \\u0646\\u0627\\u0634\\u0646\\u0627\\u0633 \\u062F\\u0631 ${t.origin}`;case"invalid_union":return"\\u0648\\u0631\\u0648\\u062F\\u06CC \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631";case"invalid_element":return`\\u0645\\u0642\\u062F\\u0627\\u0631 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631 \\u062F\\u0631 ${t.origin}`;default:return"\\u0648\\u0631\\u0648\\u062F\\u06CC \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631"}}};function nl(){return{localeError:dp()}}var mp=()=>{let e={string:{unit:"merkki\\xE4",subject:"merkkijonon"},file:{unit:"tavua",subject:"tiedoston"},array:{unit:"alkiota",subject:"listan"},set:{unit:"alkiota",subject:"joukon"},number:{unit:"",subject:"luvun"},bigint:{unit:"",subject:"suuren kokonaisluvun"},int:{unit:"",subject:"kokonaisluvun"},date:{unit:"",subject:"p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4n"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"s\\xE4\\xE4nn\\xF6llinen lauseke",email:"s\\xE4hk\\xF6postiosoite",url:"URL-osoite",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO-aikaleima",date:"ISO-p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4",time:"ISO-aika",duration:"ISO-kesto",ipv4:"IPv4-osoite",ipv6:"IPv6-osoite",cidrv4:"IPv4-alue",cidrv6:"IPv6-alue",base64:"base64-koodattu merkkijono",base64url:"base64url-koodattu merkkijono",json_string:"JSON-merkkijono",e164:"E.164-luku",jwt:"JWT",template_literal:"templaattimerkkijono"},o={nan:"NaN"};return t=>{var a,c,m;switch(t.code){case"invalid_type":{let s=(a=o[t.expected])!=null?a:t.expected,u=b(t.input),d=(c=o[u])!=null?c:u;return/^[A-Z]/.test(t.expected)?`Virheellinen tyyppi: odotettiin instanceof ${t.expected}, oli ${d}`:`Virheellinen tyyppi: odotettiin ${s}, oli ${d}`}case"invalid_value":return t.values.length===1?`Virheellinen sy\\xF6te: t\\xE4ytyy olla ${$(t.values[0])}`:`Virheellinen valinta: t\\xE4ytyy olla yksi seuraavista: ${h(t.values,"|")}`;case"too_big":{let s=t.inclusive?"<=":"<",u=r(t.origin);return u?`Liian suuri: ${u.subject} t\\xE4ytyy olla ${s}${t.maximum.toString()} ${u.unit}`.trim():`Liian suuri: arvon t\\xE4ytyy olla ${s}${t.maximum.toString()}`}case"too_small":{let s=t.inclusive?">=":">",u=r(t.origin);return u?`Liian pieni: ${u.subject} t\\xE4ytyy olla ${s}${t.minimum.toString()} ${u.unit}`.trim():`Liian pieni: arvon t\\xE4ytyy olla ${s}${t.minimum.toString()}`}case"invalid_format":{let s=t;return s.format==="starts_with"?`Virheellinen sy\\xF6te: t\\xE4ytyy alkaa "${s.prefix}"`:s.format==="ends_with"?`Virheellinen sy\\xF6te: t\\xE4ytyy loppua "${s.suffix}"`:s.format==="includes"?`Virheellinen sy\\xF6te: t\\xE4ytyy sis\\xE4lt\\xE4\\xE4 "${s.includes}"`:s.format==="regex"?`Virheellinen sy\\xF6te: t\\xE4ytyy vastata s\\xE4\\xE4nn\\xF6llist\\xE4 lauseketta ${s.pattern}`:`Virheellinen ${(m=n[s.format])!=null?m:t.format}`}case"not_multiple_of":return`Virheellinen luku: t\\xE4ytyy olla luvun ${t.divisor} monikerta`;case"unrecognized_keys":return`${t.keys.length>1?"Tuntemattomat avaimet":"Tuntematon avain"}: ${h(t.keys,", ")}`;case"invalid_key":return"Virheellinen avain tietueessa";case"invalid_union":return"Virheellinen unioni";case"invalid_element":return"Virheellinen arvo joukossa";default:return"Virheellinen sy\\xF6te"}}};function ol(){return{localeError:mp()}}var pp=()=>{let e={string:{unit:"caract\\xE8res",verb:"avoir"},file:{unit:"octets",verb:"avoir"},array:{unit:"\\xE9l\\xE9ments",verb:"avoir"},set:{unit:"\\xE9l\\xE9ments",verb:"avoir"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"entr\\xE9e",email:"adresse e-mail",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"date et heure ISO",date:"date ISO",time:"heure ISO",duration:"dur\\xE9e ISO",ipv4:"adresse IPv4",ipv6:"adresse IPv6",cidrv4:"plage IPv4",cidrv6:"plage IPv6",base64:"cha\\xEEne encod\\xE9e en base64",base64url:"cha\\xEEne encod\\xE9e en base64url",json_string:"cha\\xEEne JSON",e164:"num\\xE9ro E.164",jwt:"JWT",template_literal:"entr\\xE9e"},o={nan:"NaN",number:"nombre",array:"tableau"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Entr\\xE9e invalide : instanceof ${t.expected} attendu, ${p} re\\xE7u`:`Entr\\xE9e invalide : ${i} attendu, ${p} re\\xE7u`}case"invalid_value":return t.values.length===1?`Entr\\xE9e invalide : ${$(t.values[0])} attendu`:`Option invalide : une valeur parmi ${h(t.values,"|")} attendue`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Trop grand : ${(m=t.origin)!=null?m:"valeur"} doit ${l.verb} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\xE9l\\xE9ment(s)"}`:`Trop grand : ${(u=t.origin)!=null?u:"valeur"} doit \\xEAtre ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Trop petit : ${t.origin} doit ${l.verb} ${i}${t.minimum.toString()} ${l.unit}`:`Trop petit : ${t.origin} doit \\xEAtre ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Cha\\xEEne invalide : doit commencer par "${i.prefix}"`:i.format==="ends_with"?`Cha\\xEEne invalide : doit se terminer par "${i.suffix}"`:i.format==="includes"?`Cha\\xEEne invalide : doit inclure "${i.includes}"`:i.format==="regex"?`Cha\\xEEne invalide : doit correspondre au mod\\xE8le ${i.pattern}`:`${(d=n[i.format])!=null?d:t.format} invalide`}case"not_multiple_of":return`Nombre invalide : doit \\xEAtre un multiple de ${t.divisor}`;case"unrecognized_keys":return`Cl\\xE9${t.keys.length>1?"s":""} non reconnue${t.keys.length>1?"s":""} : ${h(t.keys,", ")}`;case"invalid_key":return`Cl\\xE9 invalide dans ${t.origin}`;case"invalid_union":return"Entr\\xE9e invalide";case"invalid_element":return`Valeur invalide dans ${t.origin}`;default:return"Entr\\xE9e invalide"}}};function il(){return{localeError:pp()}}var fp=()=>{let e={string:{unit:"caract\\xE8res",verb:"avoir"},file:{unit:"octets",verb:"avoir"},array:{unit:"\\xE9l\\xE9ments",verb:"avoir"},set:{unit:"\\xE9l\\xE9ments",verb:"avoir"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"entr\\xE9e",email:"adresse courriel",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"date-heure ISO",date:"date ISO",time:"heure ISO",duration:"dur\\xE9e ISO",ipv4:"adresse IPv4",ipv6:"adresse IPv6",cidrv4:"plage IPv4",cidrv6:"plage IPv6",base64:"cha\\xEEne encod\\xE9e en base64",base64url:"cha\\xEEne encod\\xE9e en base64url",json_string:"cha\\xEEne JSON",e164:"num\\xE9ro E.164",jwt:"JWT",template_literal:"entr\\xE9e"},o={nan:"NaN"};return t=>{var a,c,m,s,u;switch(t.code){case"invalid_type":{let d=(a=o[t.expected])!=null?a:t.expected,i=b(t.input),l=(c=o[i])!=null?c:i;return/^[A-Z]/.test(t.expected)?`Entr\\xE9e invalide : attendu instanceof ${t.expected}, re\\xE7u ${l}`:`Entr\\xE9e invalide : attendu ${d}, re\\xE7u ${l}`}case"invalid_value":return t.values.length===1?`Entr\\xE9e invalide : attendu ${$(t.values[0])}`:`Option invalide : attendu l\'une des valeurs suivantes ${h(t.values,"|")}`;case"too_big":{let d=t.inclusive?"\\u2264":"<",i=r(t.origin);return i?`Trop grand : attendu que ${(m=t.origin)!=null?m:"la valeur"} ait ${d}${t.maximum.toString()} ${i.unit}`:`Trop grand : attendu que ${(s=t.origin)!=null?s:"la valeur"} soit ${d}${t.maximum.toString()}`}case"too_small":{let d=t.inclusive?"\\u2265":">",i=r(t.origin);return i?`Trop petit : attendu que ${t.origin} ait ${d}${t.minimum.toString()} ${i.unit}`:`Trop petit : attendu que ${t.origin} soit ${d}${t.minimum.toString()}`}case"invalid_format":{let d=t;return d.format==="starts_with"?`Cha\\xEEne invalide : doit commencer par "${d.prefix}"`:d.format==="ends_with"?`Cha\\xEEne invalide : doit se terminer par "${d.suffix}"`:d.format==="includes"?`Cha\\xEEne invalide : doit inclure "${d.includes}"`:d.format==="regex"?`Cha\\xEEne invalide : doit correspondre au motif ${d.pattern}`:`${(u=n[d.format])!=null?u:t.format} invalide`}case"not_multiple_of":return`Nombre invalide : doit \\xEAtre un multiple de ${t.divisor}`;case"unrecognized_keys":return`Cl\\xE9${t.keys.length>1?"s":""} non reconnue${t.keys.length>1?"s":""} : ${h(t.keys,", ")}`;case"invalid_key":return`Cl\\xE9 invalide dans ${t.origin}`;case"invalid_union":return"Entr\\xE9e invalide";case"invalid_element":return`Valeur invalide dans ${t.origin}`;default:return"Entr\\xE9e invalide"}}};function al(){return{localeError:fp()}}var gp=()=>{let e={string:{label:"\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA",gender:"f"},number:{label:"\\u05DE\\u05E1\\u05E4\\u05E8",gender:"m"},boolean:{label:"\\u05E2\\u05E8\\u05DA \\u05D1\\u05D5\\u05DC\\u05D9\\u05D0\\u05E0\\u05D9",gender:"m"},bigint:{label:"BigInt",gender:"m"},date:{label:"\\u05EA\\u05D0\\u05E8\\u05D9\\u05DA",gender:"m"},array:{label:"\\u05DE\\u05E2\\u05E8\\u05DA",gender:"m"},object:{label:"\\u05D0\\u05D5\\u05D1\\u05D9\\u05D9\\u05E7\\u05D8",gender:"m"},null:{label:"\\u05E2\\u05E8\\u05DA \\u05E8\\u05D9\\u05E7 (null)",gender:"m"},undefined:{label:"\\u05E2\\u05E8\\u05DA \\u05DC\\u05D0 \\u05DE\\u05D5\\u05D2\\u05D3\\u05E8 (undefined)",gender:"m"},symbol:{label:"\\u05E1\\u05D9\\u05DE\\u05D1\\u05D5\\u05DC (Symbol)",gender:"m"},function:{label:"\\u05E4\\u05D5\\u05E0\\u05E7\\u05E6\\u05D9\\u05D4",gender:"f"},map:{label:"\\u05DE\\u05E4\\u05D4 (Map)",gender:"f"},set:{label:"\\u05E7\\u05D1\\u05D5\\u05E6\\u05D4 (Set)",gender:"f"},file:{label:"\\u05E7\\u05D5\\u05D1\\u05E5",gender:"m"},promise:{label:"Promise",gender:"m"},NaN:{label:"NaN",gender:"m"},unknown:{label:"\\u05E2\\u05E8\\u05DA \\u05DC\\u05D0 \\u05D9\\u05D3\\u05D5\\u05E2",gender:"m"},value:{label:"\\u05E2\\u05E8\\u05DA",gender:"m"}},r={string:{unit:"\\u05EA\\u05D5\\u05D5\\u05D9\\u05DD",shortLabel:"\\u05E7\\u05E6\\u05E8",longLabel:"\\u05D0\\u05E8\\u05D5\\u05DA"},file:{unit:"\\u05D1\\u05D9\\u05D9\\u05D8\\u05D9\\u05DD",shortLabel:"\\u05E7\\u05D8\\u05DF",longLabel:"\\u05D2\\u05D3\\u05D5\\u05DC"},array:{unit:"\\u05E4\\u05E8\\u05D9\\u05D8\\u05D9\\u05DD",shortLabel:"\\u05E7\\u05D8\\u05DF",longLabel:"\\u05D2\\u05D3\\u05D5\\u05DC"},set:{unit:"\\u05E4\\u05E8\\u05D9\\u05D8\\u05D9\\u05DD",shortLabel:"\\u05E7\\u05D8\\u05DF",longLabel:"\\u05D2\\u05D3\\u05D5\\u05DC"},number:{unit:"",shortLabel:"\\u05E7\\u05D8\\u05DF",longLabel:"\\u05D2\\u05D3\\u05D5\\u05DC"}},n=u=>u?e[u]:void 0,o=u=>{let d=n(u);return d?d.label:u!=null?u:e.unknown.label},t=u=>`\\u05D4${o(u)}`,a=u=>{var l;let d=n(u);return((l=d==null?void 0:d.gender)!=null?l:"m")==="f"?"\\u05E6\\u05E8\\u05D9\\u05DB\\u05D4 \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA":"\\u05E6\\u05E8\\u05D9\\u05DA \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA"},c=u=>{var d;return u&&(d=r[u])!=null?d:null},m={regex:{label:"\\u05E7\\u05DC\\u05D8",gender:"m"},email:{label:"\\u05DB\\u05EA\\u05D5\\u05D1\\u05EA \\u05D0\\u05D9\\u05DE\\u05D9\\u05D9\\u05DC",gender:"f"},url:{label:"\\u05DB\\u05EA\\u05D5\\u05D1\\u05EA \\u05E8\\u05E9\\u05EA",gender:"f"},emoji:{label:"\\u05D0\\u05D9\\u05DE\\u05D5\\u05D2\'\\u05D9",gender:"m"},uuid:{label:"UUID",gender:"m"},nanoid:{label:"nanoid",gender:"m"},guid:{label:"GUID",gender:"m"},cuid:{label:"cuid",gender:"m"},cuid2:{label:"cuid2",gender:"m"},ulid:{label:"ULID",gender:"m"},xid:{label:"XID",gender:"m"},ksuid:{label:"KSUID",gender:"m"},datetime:{label:"\\u05EA\\u05D0\\u05E8\\u05D9\\u05DA \\u05D5\\u05D6\\u05DE\\u05DF ISO",gender:"m"},date:{label:"\\u05EA\\u05D0\\u05E8\\u05D9\\u05DA ISO",gender:"m"},time:{label:"\\u05D6\\u05DE\\u05DF ISO",gender:"m"},duration:{label:"\\u05DE\\u05E9\\u05DA \\u05D6\\u05DE\\u05DF ISO",gender:"m"},ipv4:{label:"\\u05DB\\u05EA\\u05D5\\u05D1\\u05EA IPv4",gender:"f"},ipv6:{label:"\\u05DB\\u05EA\\u05D5\\u05D1\\u05EA IPv6",gender:"f"},cidrv4:{label:"\\u05D8\\u05D5\\u05D5\\u05D7 IPv4",gender:"m"},cidrv6:{label:"\\u05D8\\u05D5\\u05D5\\u05D7 IPv6",gender:"m"},base64:{label:"\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05D1\\u05D1\\u05E1\\u05D9\\u05E1 64",gender:"f"},base64url:{label:"\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05D1\\u05D1\\u05E1\\u05D9\\u05E1 64 \\u05DC\\u05DB\\u05EA\\u05D5\\u05D1\\u05D5\\u05EA \\u05E8\\u05E9\\u05EA",gender:"f"},json_string:{label:"\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA JSON",gender:"f"},e164:{label:"\\u05DE\\u05E1\\u05E4\\u05E8 E.164",gender:"m"},jwt:{label:"JWT",gender:"m"},ends_with:{label:"\\u05E7\\u05DC\\u05D8",gender:"m"},includes:{label:"\\u05E7\\u05DC\\u05D8",gender:"m"},lowercase:{label:"\\u05E7\\u05DC\\u05D8",gender:"m"},starts_with:{label:"\\u05E7\\u05DC\\u05D8",gender:"m"},uppercase:{label:"\\u05E7\\u05DC\\u05D8",gender:"m"}},s={nan:"NaN"};return u=>{var d,i,l,p,v,y,S,w,D,N,k,T,U,R,Ee,Xc,Qc,Yc,Hc,eu,tu;switch(u.code){case"invalid_type":{let z=u.expected,A=(d=s[z!=null?z:""])!=null?d:o(z),Y=b(u.input),re=(p=(l=s[Y])!=null?l:(i=e[Y])==null?void 0:i.label)!=null?p:Y;return/^[A-Z]/.test(u.expected)?`\\u05E7\\u05DC\\u05D8 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF: \\u05E6\\u05E8\\u05D9\\u05DA \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA instanceof ${u.expected}, \\u05D4\\u05EA\\u05E7\\u05D1\\u05DC ${re}`:`\\u05E7\\u05DC\\u05D8 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF: \\u05E6\\u05E8\\u05D9\\u05DA \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA ${A}, \\u05D4\\u05EA\\u05E7\\u05D1\\u05DC ${re}`}case"invalid_value":{if(u.values.length===1)return`\\u05E2\\u05E8\\u05DA \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF: \\u05D4\\u05E2\\u05E8\\u05DA \\u05D7\\u05D9\\u05D9\\u05D1 \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA ${$(u.values[0])}`;let z=u.values.map(re=>$(re));if(u.values.length===2)return`\\u05E2\\u05E8\\u05DA \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF: \\u05D4\\u05D0\\u05E4\\u05E9\\u05E8\\u05D5\\u05D9\\u05D5\\u05EA \\u05D4\\u05DE\\u05EA\\u05D0\\u05D9\\u05DE\\u05D5\\u05EA \\u05D4\\u05DF ${z[0]} \\u05D0\\u05D5 ${z[1]}`;let A=z[z.length-1];return`\\u05E2\\u05E8\\u05DA \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF: \\u05D4\\u05D0\\u05E4\\u05E9\\u05E8\\u05D5\\u05D9\\u05D5\\u05EA \\u05D4\\u05DE\\u05EA\\u05D0\\u05D9\\u05DE\\u05D5\\u05EA \\u05D4\\u05DF ${z.slice(0,-1).join(", ")} \\u05D0\\u05D5 ${A}`}case"too_big":{let z=c(u.origin),A=t((v=u.origin)!=null?v:"value");if(u.origin==="string")return`${(y=z==null?void 0:z.longLabel)!=null?y:"\\u05D0\\u05E8\\u05D5\\u05DA"} \\u05DE\\u05D3\\u05D9: ${A} \\u05E6\\u05E8\\u05D9\\u05DB\\u05D4 \\u05DC\\u05D4\\u05DB\\u05D9\\u05DC ${u.maximum.toString()} ${(S=z==null?void 0:z.unit)!=null?S:""} ${u.inclusive?"\\u05D0\\u05D5 \\u05E4\\u05D7\\u05D5\\u05EA":"\\u05DC\\u05DB\\u05DC \\u05D4\\u05D9\\u05D5\\u05EA\\u05E8"}`.trim();if(u.origin==="number"){let oe=u.inclusive?`\\u05E7\\u05D8\\u05DF \\u05D0\\u05D5 \\u05E9\\u05D5\\u05D5\\u05D4 \\u05DC-${u.maximum}`:`\\u05E7\\u05D8\\u05DF \\u05DE-${u.maximum}`;return`\\u05D2\\u05D3\\u05D5\\u05DC \\u05DE\\u05D3\\u05D9: ${A} \\u05E6\\u05E8\\u05D9\\u05DA \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA ${oe}`}if(u.origin==="array"||u.origin==="set"){let oe=u.origin==="set"?"\\u05E6\\u05E8\\u05D9\\u05DB\\u05D4":"\\u05E6\\u05E8\\u05D9\\u05DA",sn=u.inclusive?`${u.maximum} ${(w=z==null?void 0:z.unit)!=null?w:""} \\u05D0\\u05D5 \\u05E4\\u05D7\\u05D5\\u05EA`:`\\u05E4\\u05D7\\u05D5\\u05EA \\u05DE-${u.maximum} ${(D=z==null?void 0:z.unit)!=null?D:""}`;return`\\u05D2\\u05D3\\u05D5\\u05DC \\u05DE\\u05D3\\u05D9: ${A} ${oe} \\u05DC\\u05D4\\u05DB\\u05D9\\u05DC ${sn}`.trim()}let Y=u.inclusive?"<=":"<",re=a((N=u.origin)!=null?N:"value");return z!=null&&z.unit?`${z.longLabel} \\u05DE\\u05D3\\u05D9: ${A} ${re} ${Y}${u.maximum.toString()} ${z.unit}`:`${(k=z==null?void 0:z.longLabel)!=null?k:"\\u05D2\\u05D3\\u05D5\\u05DC"} \\u05DE\\u05D3\\u05D9: ${A} ${re} ${Y}${u.maximum.toString()}`}case"too_small":{let z=c(u.origin),A=t((T=u.origin)!=null?T:"value");if(u.origin==="string")return`${(U=z==null?void 0:z.shortLabel)!=null?U:"\\u05E7\\u05E6\\u05E8"} \\u05DE\\u05D3\\u05D9: ${A} \\u05E6\\u05E8\\u05D9\\u05DB\\u05D4 \\u05DC\\u05D4\\u05DB\\u05D9\\u05DC ${u.minimum.toString()} ${(R=z==null?void 0:z.unit)!=null?R:""} ${u.inclusive?"\\u05D0\\u05D5 \\u05D9\\u05D5\\u05EA\\u05E8":"\\u05DC\\u05E4\\u05D7\\u05D5\\u05EA"}`.trim();if(u.origin==="number"){let oe=u.inclusive?`\\u05D2\\u05D3\\u05D5\\u05DC \\u05D0\\u05D5 \\u05E9\\u05D5\\u05D5\\u05D4 \\u05DC-${u.minimum}`:`\\u05D2\\u05D3\\u05D5\\u05DC \\u05DE-${u.minimum}`;return`\\u05E7\\u05D8\\u05DF \\u05DE\\u05D3\\u05D9: ${A} \\u05E6\\u05E8\\u05D9\\u05DA \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA ${oe}`}if(u.origin==="array"||u.origin==="set"){let oe=u.origin==="set"?"\\u05E6\\u05E8\\u05D9\\u05DB\\u05D4":"\\u05E6\\u05E8\\u05D9\\u05DA";if(u.minimum===1&&u.inclusive){let zd=(u.origin==="set","\\u05DC\\u05E4\\u05D7\\u05D5\\u05EA \\u05E4\\u05E8\\u05D9\\u05D8 \\u05D0\\u05D7\\u05D3");return`\\u05E7\\u05D8\\u05DF \\u05DE\\u05D3\\u05D9: ${A} ${oe} \\u05DC\\u05D4\\u05DB\\u05D9\\u05DC ${zd}`}let sn=u.inclusive?`${u.minimum} ${(Ee=z==null?void 0:z.unit)!=null?Ee:""} \\u05D0\\u05D5 \\u05D9\\u05D5\\u05EA\\u05E8`:`\\u05D9\\u05D5\\u05EA\\u05E8 \\u05DE-${u.minimum} ${(Xc=z==null?void 0:z.unit)!=null?Xc:""}`;return`\\u05E7\\u05D8\\u05DF \\u05DE\\u05D3\\u05D9: ${A} ${oe} \\u05DC\\u05D4\\u05DB\\u05D9\\u05DC ${sn}`.trim()}let Y=u.inclusive?">=":">",re=a((Qc=u.origin)!=null?Qc:"value");return z!=null&&z.unit?`${z.shortLabel} \\u05DE\\u05D3\\u05D9: ${A} ${re} ${Y}${u.minimum.toString()} ${z.unit}`:`${(Yc=z==null?void 0:z.shortLabel)!=null?Yc:"\\u05E7\\u05D8\\u05DF"} \\u05DE\\u05D3\\u05D9: ${A} ${re} ${Y}${u.minimum.toString()}`}case"invalid_format":{let z=u;if(z.format==="starts_with")return`\\u05D4\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05D7\\u05D9\\u05D9\\u05D1\\u05EA \\u05DC\\u05D4\\u05EA\\u05D7\\u05D9\\u05DC \\u05D1 "${z.prefix}"`;if(z.format==="ends_with")return`\\u05D4\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05D7\\u05D9\\u05D9\\u05D1\\u05EA \\u05DC\\u05D4\\u05E1\\u05EA\\u05D9\\u05D9\\u05DD \\u05D1 "${z.suffix}"`;if(z.format==="includes")return`\\u05D4\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05D7\\u05D9\\u05D9\\u05D1\\u05EA \\u05DC\\u05DB\\u05DC\\u05D5\\u05DC "${z.includes}"`;if(z.format==="regex")return`\\u05D4\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05D7\\u05D9\\u05D9\\u05D1\\u05EA \\u05DC\\u05D4\\u05EA\\u05D0\\u05D9\\u05DD \\u05DC\\u05EA\\u05D1\\u05E0\\u05D9\\u05EA ${z.pattern}`;let A=m[z.format],Y=(Hc=A==null?void 0:A.label)!=null?Hc:z.format,oe=((eu=A==null?void 0:A.gender)!=null?eu:"m")==="f"?"\\u05EA\\u05E7\\u05D9\\u05E0\\u05D4":"\\u05EA\\u05E7\\u05D9\\u05DF";return`${Y} \\u05DC\\u05D0 ${oe}`}case"not_multiple_of":return`\\u05DE\\u05E1\\u05E4\\u05E8 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF: \\u05D7\\u05D9\\u05D9\\u05D1 \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA \\u05DE\\u05DB\\u05E4\\u05DC\\u05D4 \\u05E9\\u05DC ${u.divisor}`;case"unrecognized_keys":return`\\u05DE\\u05E4\\u05EA\\u05D7${u.keys.length>1?"\\u05D5\\u05EA":""} \\u05DC\\u05D0 \\u05DE\\u05D6\\u05D5\\u05D4${u.keys.length>1?"\\u05D9\\u05DD":"\\u05D4"}: ${h(u.keys,", ")}`;case"invalid_key":return"\\u05E9\\u05D3\\u05D4 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF \\u05D1\\u05D0\\u05D5\\u05D1\\u05D9\\u05D9\\u05E7\\u05D8";case"invalid_union":return"\\u05E7\\u05DC\\u05D8 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF";case"invalid_element":return`\\u05E2\\u05E8\\u05DA \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF \\u05D1${t((tu=u.origin)!=null?tu:"array")}`;default:return"\\u05E7\\u05DC\\u05D8 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF"}}};function cl(){return{localeError:gp()}}var vp=()=>{let e={string:{unit:"karakter",verb:"legyen"},file:{unit:"byte",verb:"legyen"},array:{unit:"elem",verb:"legyen"},set:{unit:"elem",verb:"legyen"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"bemenet",email:"email c\\xEDm",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO id\\u0151b\\xE9lyeg",date:"ISO d\\xE1tum",time:"ISO id\\u0151",duration:"ISO id\\u0151intervallum",ipv4:"IPv4 c\\xEDm",ipv6:"IPv6 c\\xEDm",cidrv4:"IPv4 tartom\\xE1ny",cidrv6:"IPv6 tartom\\xE1ny",base64:"base64-k\\xF3dolt string",base64url:"base64url-k\\xF3dolt string",json_string:"JSON string",e164:"E.164 sz\\xE1m",jwt:"JWT",template_literal:"bemenet"},o={nan:"NaN",number:"sz\\xE1m",array:"t\\xF6mb"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\xC9rv\\xE9nytelen bemenet: a v\\xE1rt \\xE9rt\\xE9k instanceof ${t.expected}, a kapott \\xE9rt\\xE9k ${p}`:`\\xC9rv\\xE9nytelen bemenet: a v\\xE1rt \\xE9rt\\xE9k ${i}, a kapott \\xE9rt\\xE9k ${p}`}case"invalid_value":return t.values.length===1?`\\xC9rv\\xE9nytelen bemenet: a v\\xE1rt \\xE9rt\\xE9k ${$(t.values[0])}`:`\\xC9rv\\xE9nytelen opci\\xF3: valamelyik \\xE9rt\\xE9k v\\xE1rt ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`T\\xFAl nagy: ${(m=t.origin)!=null?m:"\\xE9rt\\xE9k"} m\\xE9rete t\\xFAl nagy ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elem"}`:`T\\xFAl nagy: a bemeneti \\xE9rt\\xE9k ${(u=t.origin)!=null?u:"\\xE9rt\\xE9k"} t\\xFAl nagy: ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`T\\xFAl kicsi: a bemeneti \\xE9rt\\xE9k ${t.origin} m\\xE9rete t\\xFAl kicsi ${i}${t.minimum.toString()} ${l.unit}`:`T\\xFAl kicsi: a bemeneti \\xE9rt\\xE9k ${t.origin} t\\xFAl kicsi ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\xC9rv\\xE9nytelen string: "${i.prefix}" \\xE9rt\\xE9kkel kell kezd\\u0151dnie`:i.format==="ends_with"?`\\xC9rv\\xE9nytelen string: "${i.suffix}" \\xE9rt\\xE9kkel kell v\\xE9gz\\u0151dnie`:i.format==="includes"?`\\xC9rv\\xE9nytelen string: "${i.includes}" \\xE9rt\\xE9ket kell tartalmaznia`:i.format==="regex"?`\\xC9rv\\xE9nytelen string: ${i.pattern} mint\\xE1nak kell megfelelnie`:`\\xC9rv\\xE9nytelen ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\xC9rv\\xE9nytelen sz\\xE1m: ${t.divisor} t\\xF6bbsz\\xF6r\\xF6s\\xE9nek kell lennie`;case"unrecognized_keys":return`Ismeretlen kulcs${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`\\xC9rv\\xE9nytelen kulcs ${t.origin}`;case"invalid_union":return"\\xC9rv\\xE9nytelen bemenet";case"invalid_element":return`\\xC9rv\\xE9nytelen \\xE9rt\\xE9k: ${t.origin}`;default:return"\\xC9rv\\xE9nytelen bemenet"}}};function ul(){return{localeError:vp()}}function ll(e,r,n){return Math.abs(e)===1?r:n}function Je(e){if(!e)return"";let r=["\\u0561","\\u0565","\\u0568","\\u056B","\\u0578","\\u0578\\u0582","\\u0585"],n=e[e.length-1];return e+(r.includes(n)?"\\u0576":"\\u0568")}var hp=()=>{let e={string:{unit:{one:"\\u0576\\u0577\\u0561\\u0576",many:"\\u0576\\u0577\\u0561\\u0576\\u0576\\u0565\\u0580"},verb:"\\u0578\\u0582\\u0576\\u0565\\u0576\\u0561\\u056C"},file:{unit:{one:"\\u0562\\u0561\\u0575\\u0569",many:"\\u0562\\u0561\\u0575\\u0569\\u0565\\u0580"},verb:"\\u0578\\u0582\\u0576\\u0565\\u0576\\u0561\\u056C"},array:{unit:{one:"\\u057F\\u0561\\u0580\\u0580",many:"\\u057F\\u0561\\u0580\\u0580\\u0565\\u0580"},verb:"\\u0578\\u0582\\u0576\\u0565\\u0576\\u0561\\u056C"},set:{unit:{one:"\\u057F\\u0561\\u0580\\u0580",many:"\\u057F\\u0561\\u0580\\u0580\\u0565\\u0580"},verb:"\\u0578\\u0582\\u0576\\u0565\\u0576\\u0561\\u056C"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0574\\u0578\\u0582\\u057F\\u0584",email:"\\u0567\\u056C. \\u0570\\u0561\\u057D\\u0581\\u0565",url:"URL",emoji:"\\u0567\\u0574\\u0578\\u057B\\u056B",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO \\u0561\\u0574\\u057D\\u0561\\u0569\\u056B\\u057E \\u0587 \\u056A\\u0561\\u0574",date:"ISO \\u0561\\u0574\\u057D\\u0561\\u0569\\u056B\\u057E",time:"ISO \\u056A\\u0561\\u0574",duration:"ISO \\u057F\\u0587\\u0578\\u0572\\u0578\\u0582\\u0569\\u0575\\u0578\\u0582\\u0576",ipv4:"IPv4 \\u0570\\u0561\\u057D\\u0581\\u0565",ipv6:"IPv6 \\u0570\\u0561\\u057D\\u0581\\u0565",cidrv4:"IPv4 \\u0574\\u056B\\u057B\\u0561\\u056F\\u0561\\u0575\\u0584",cidrv6:"IPv6 \\u0574\\u056B\\u057B\\u0561\\u056F\\u0561\\u0575\\u0584",base64:"base64 \\u0571\\u0587\\u0561\\u0579\\u0561\\u0583\\u0578\\u057E \\u057F\\u0578\\u0572",base64url:"base64url \\u0571\\u0587\\u0561\\u0579\\u0561\\u0583\\u0578\\u057E \\u057F\\u0578\\u0572",json_string:"JSON \\u057F\\u0578\\u0572",e164:"E.164 \\u0570\\u0561\\u0574\\u0561\\u0580",jwt:"JWT",template_literal:"\\u0574\\u0578\\u0582\\u057F\\u0584"},o={nan:"NaN",number:"\\u0569\\u056B\\u057E",array:"\\u0566\\u0561\\u0576\\u0563\\u057E\\u0561\\u056E"};return t=>{var a,c,m,s,u;switch(t.code){case"invalid_type":{let d=(a=o[t.expected])!=null?a:t.expected,i=b(t.input),l=(c=o[i])!=null?c:i;return/^[A-Z]/.test(t.expected)?`\\u054D\\u056D\\u0561\\u056C \\u0574\\u0578\\u0582\\u057F\\u0584\\u0561\\u0563\\u0580\\u0578\\u0582\\u0574\\u2024 \\u057D\\u057A\\u0561\\u057D\\u057E\\u0578\\u0582\\u0574 \\u0567\\u0580 instanceof ${t.expected}, \\u057D\\u057F\\u0561\\u0581\\u057E\\u0565\\u056C \\u0567 ${l}`:`\\u054D\\u056D\\u0561\\u056C \\u0574\\u0578\\u0582\\u057F\\u0584\\u0561\\u0563\\u0580\\u0578\\u0582\\u0574\\u2024 \\u057D\\u057A\\u0561\\u057D\\u057E\\u0578\\u0582\\u0574 \\u0567\\u0580 ${d}, \\u057D\\u057F\\u0561\\u0581\\u057E\\u0565\\u056C \\u0567 ${l}`}case"invalid_value":return t.values.length===1?`\\u054D\\u056D\\u0561\\u056C \\u0574\\u0578\\u0582\\u057F\\u0584\\u0561\\u0563\\u0580\\u0578\\u0582\\u0574\\u2024 \\u057D\\u057A\\u0561\\u057D\\u057E\\u0578\\u0582\\u0574 \\u0567\\u0580 ${$(t.values[1])}`:`\\u054D\\u056D\\u0561\\u056C \\u057F\\u0561\\u0580\\u0562\\u0565\\u0580\\u0561\\u056F\\u2024 \\u057D\\u057A\\u0561\\u057D\\u057E\\u0578\\u0582\\u0574 \\u0567\\u0580 \\u0570\\u0565\\u057F\\u0587\\u0575\\u0561\\u056C\\u0576\\u0565\\u0580\\u056B\\u0581 \\u0574\\u0565\\u056F\\u0568\\u055D ${h(t.values,"|")}`;case"too_big":{let d=t.inclusive?"<=":"<",i=r(t.origin);if(i){let l=Number(t.maximum),p=ll(l,i.unit.one,i.unit.many);return`\\u0549\\u0561\\u0583\\u0561\\u0566\\u0561\\u0576\\u0581 \\u0574\\u0565\\u056E \\u0561\\u0580\\u056A\\u0565\\u0584\\u2024 \\u057D\\u057A\\u0561\\u057D\\u057E\\u0578\\u0582\\u0574 \\u0567, \\u0578\\u0580 ${Je((m=t.origin)!=null?m:"\\u0561\\u0580\\u056A\\u0565\\u0584")} \\u056F\\u0578\\u0582\\u0576\\u0565\\u0576\\u0561 ${d}${t.maximum.toString()} ${p}`}return`\\u0549\\u0561\\u0583\\u0561\\u0566\\u0561\\u0576\\u0581 \\u0574\\u0565\\u056E \\u0561\\u0580\\u056A\\u0565\\u0584\\u2024 \\u057D\\u057A\\u0561\\u057D\\u057E\\u0578\\u0582\\u0574 \\u0567, \\u0578\\u0580 ${Je((s=t.origin)!=null?s:"\\u0561\\u0580\\u056A\\u0565\\u0584")} \\u056C\\u056B\\u0576\\u056B ${d}${t.maximum.toString()}`}case"too_small":{let d=t.inclusive?">=":">",i=r(t.origin);if(i){let l=Number(t.minimum),p=ll(l,i.unit.one,i.unit.many);return`\\u0549\\u0561\\u0583\\u0561\\u0566\\u0561\\u0576\\u0581 \\u0583\\u0578\\u0584\\u0580 \\u0561\\u0580\\u056A\\u0565\\u0584\\u2024 \\u057D\\u057A\\u0561\\u057D\\u057E\\u0578\\u0582\\u0574 \\u0567, \\u0578\\u0580 ${Je(t.origin)} \\u056F\\u0578\\u0582\\u0576\\u0565\\u0576\\u0561 ${d}${t.minimum.toString()} ${p}`}return`\\u0549\\u0561\\u0583\\u0561\\u0566\\u0561\\u0576\\u0581 \\u0583\\u0578\\u0584\\u0580 \\u0561\\u0580\\u056A\\u0565\\u0584\\u2024 \\u057D\\u057A\\u0561\\u057D\\u057E\\u0578\\u0582\\u0574 \\u0567, \\u0578\\u0580 ${Je(t.origin)} \\u056C\\u056B\\u0576\\u056B ${d}${t.minimum.toString()}`}case"invalid_format":{let d=t;return d.format==="starts_with"?`\\u054D\\u056D\\u0561\\u056C \\u057F\\u0578\\u0572\\u2024 \\u057A\\u0565\\u057F\\u0584 \\u0567 \\u057D\\u056F\\u057D\\u057E\\u056B "${d.prefix}"-\\u0578\\u057E`:d.format==="ends_with"?`\\u054D\\u056D\\u0561\\u056C \\u057F\\u0578\\u0572\\u2024 \\u057A\\u0565\\u057F\\u0584 \\u0567 \\u0561\\u057E\\u0561\\u0580\\u057F\\u057E\\u056B "${d.suffix}"-\\u0578\\u057E`:d.format==="includes"?`\\u054D\\u056D\\u0561\\u056C \\u057F\\u0578\\u0572\\u2024 \\u057A\\u0565\\u057F\\u0584 \\u0567 \\u057A\\u0561\\u0580\\u0578\\u0582\\u0576\\u0561\\u056F\\u056B "${d.includes}"`:d.format==="regex"?`\\u054D\\u056D\\u0561\\u056C \\u057F\\u0578\\u0572\\u2024 \\u057A\\u0565\\u057F\\u0584 \\u0567 \\u0570\\u0561\\u0574\\u0561\\u057A\\u0561\\u057F\\u0561\\u057D\\u056D\\u0561\\u0576\\u056B ${d.pattern} \\u0571\\u0587\\u0561\\u0579\\u0561\\u0583\\u056B\\u0576`:`\\u054D\\u056D\\u0561\\u056C ${(u=n[d.format])!=null?u:t.format}`}case"not_multiple_of":return`\\u054D\\u056D\\u0561\\u056C \\u0569\\u056B\\u057E\\u2024 \\u057A\\u0565\\u057F\\u0584 \\u0567 \\u0562\\u0561\\u0566\\u0574\\u0561\\u057A\\u0561\\u057F\\u056B\\u056F \\u056C\\u056B\\u0576\\u056B ${t.divisor}-\\u056B`;case"unrecognized_keys":return`\\u0549\\u0573\\u0561\\u0576\\u0561\\u0579\\u057E\\u0561\\u056E \\u0562\\u0561\\u0576\\u0561\\u056C\\u056B${t.keys.length>1?"\\u0576\\u0565\\u0580":""}. ${h(t.keys,", ")}`;case"invalid_key":return`\\u054D\\u056D\\u0561\\u056C \\u0562\\u0561\\u0576\\u0561\\u056C\\u056B ${Je(t.origin)}-\\u0578\\u0582\\u0574`;case"invalid_union":return"\\u054D\\u056D\\u0561\\u056C \\u0574\\u0578\\u0582\\u057F\\u0584\\u0561\\u0563\\u0580\\u0578\\u0582\\u0574";case"invalid_element":return`\\u054D\\u056D\\u0561\\u056C \\u0561\\u0580\\u056A\\u0565\\u0584 ${Je(t.origin)}-\\u0578\\u0582\\u0574`;default:return"\\u054D\\u056D\\u0561\\u056C \\u0574\\u0578\\u0582\\u057F\\u0584\\u0561\\u0563\\u0580\\u0578\\u0582\\u0574"}}};function sl(){return{localeError:hp()}}var yp=()=>{let e={string:{unit:"karakter",verb:"memiliki"},file:{unit:"byte",verb:"memiliki"},array:{unit:"item",verb:"memiliki"},set:{unit:"item",verb:"memiliki"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"input",email:"alamat email",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"tanggal dan waktu format ISO",date:"tanggal format ISO",time:"jam format ISO",duration:"durasi format ISO",ipv4:"alamat IPv4",ipv6:"alamat IPv6",cidrv4:"rentang alamat IPv4",cidrv6:"rentang alamat IPv6",base64:"string dengan enkode base64",base64url:"string dengan enkode base64url",json_string:"string JSON",e164:"angka E.164",jwt:"JWT",template_literal:"input"},o={nan:"NaN"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Input tidak valid: diharapkan instanceof ${t.expected}, diterima ${p}`:`Input tidak valid: diharapkan ${i}, diterima ${p}`}case"invalid_value":return t.values.length===1?`Input tidak valid: diharapkan ${$(t.values[0])}`:`Pilihan tidak valid: diharapkan salah satu dari ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Terlalu besar: diharapkan ${(m=t.origin)!=null?m:"value"} memiliki ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elemen"}`:`Terlalu besar: diharapkan ${(u=t.origin)!=null?u:"value"} menjadi ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Terlalu kecil: diharapkan ${t.origin} memiliki ${i}${t.minimum.toString()} ${l.unit}`:`Terlalu kecil: diharapkan ${t.origin} menjadi ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`String tidak valid: harus dimulai dengan "${i.prefix}"`:i.format==="ends_with"?`String tidak valid: harus berakhir dengan "${i.suffix}"`:i.format==="includes"?`String tidak valid: harus menyertakan "${i.includes}"`:i.format==="regex"?`String tidak valid: harus sesuai pola ${i.pattern}`:`${(d=n[i.format])!=null?d:t.format} tidak valid`}case"not_multiple_of":return`Angka tidak valid: harus kelipatan dari ${t.divisor}`;case"unrecognized_keys":return`Kunci tidak dikenali ${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`Kunci tidak valid di ${t.origin}`;case"invalid_union":return"Input tidak valid";case"invalid_element":return`Nilai tidak valid di ${t.origin}`;default:return"Input tidak valid"}}};function dl(){return{localeError:yp()}}var $p=()=>{let e={string:{unit:"stafi",verb:"a\\xF0 hafa"},file:{unit:"b\\xE6ti",verb:"a\\xF0 hafa"},array:{unit:"hluti",verb:"a\\xF0 hafa"},set:{unit:"hluti",verb:"a\\xF0 hafa"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"gildi",email:"netfang",url:"vefsl\\xF3\\xF0",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO dagsetning og t\\xEDmi",date:"ISO dagsetning",time:"ISO t\\xEDmi",duration:"ISO t\\xEDmalengd",ipv4:"IPv4 address",ipv6:"IPv6 address",cidrv4:"IPv4 range",cidrv6:"IPv6 range",base64:"base64-encoded strengur",base64url:"base64url-encoded strengur",json_string:"JSON strengur",e164:"E.164 t\\xF6lugildi",jwt:"JWT",template_literal:"gildi"},o={nan:"NaN",number:"n\\xFAmer",array:"fylki"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Rangt gildi: \\xDE\\xFA sl\\xF3st inn ${p} \\xFEar sem \\xE1 a\\xF0 vera instanceof ${t.expected}`:`Rangt gildi: \\xDE\\xFA sl\\xF3st inn ${p} \\xFEar sem \\xE1 a\\xF0 vera ${i}`}case"invalid_value":return t.values.length===1?`Rangt gildi: gert r\\xE1\\xF0 fyrir ${$(t.values[0])}`:`\\xD3gilt val: m\\xE1 vera eitt af eftirfarandi ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Of st\\xF3rt: gert er r\\xE1\\xF0 fyrir a\\xF0 ${(m=t.origin)!=null?m:"gildi"} hafi ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"hluti"}`:`Of st\\xF3rt: gert er r\\xE1\\xF0 fyrir a\\xF0 ${(u=t.origin)!=null?u:"gildi"} s\\xE9 ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Of l\\xEDti\\xF0: gert er r\\xE1\\xF0 fyrir a\\xF0 ${t.origin} hafi ${i}${t.minimum.toString()} ${l.unit}`:`Of l\\xEDti\\xF0: gert er r\\xE1\\xF0 fyrir a\\xF0 ${t.origin} s\\xE9 ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\xD3gildur strengur: ver\\xF0ur a\\xF0 byrja \\xE1 "${i.prefix}"`:i.format==="ends_with"?`\\xD3gildur strengur: ver\\xF0ur a\\xF0 enda \\xE1 "${i.suffix}"`:i.format==="includes"?`\\xD3gildur strengur: ver\\xF0ur a\\xF0 innihalda "${i.includes}"`:i.format==="regex"?`\\xD3gildur strengur: ver\\xF0ur a\\xF0 fylgja mynstri ${i.pattern}`:`Rangt ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`R\\xF6ng tala: ver\\xF0ur a\\xF0 vera margfeldi af ${t.divisor}`;case"unrecognized_keys":return`\\xD3\\xFEekkt ${t.keys.length>1?"ir lyklar":"ur lykill"}: ${h(t.keys,", ")}`;case"invalid_key":return`Rangur lykill \\xED ${t.origin}`;case"invalid_union":return"Rangt gildi";case"invalid_element":return`Rangt gildi \\xED ${t.origin}`;default:return"Rangt gildi"}}};function ml(){return{localeError:$p()}}var bp=()=>{let e={string:{unit:"caratteri",verb:"avere"},file:{unit:"byte",verb:"avere"},array:{unit:"elementi",verb:"avere"},set:{unit:"elementi",verb:"avere"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"input",email:"indirizzo email",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"data e ora ISO",date:"data ISO",time:"ora ISO",duration:"durata ISO",ipv4:"indirizzo IPv4",ipv6:"indirizzo IPv6",cidrv4:"intervallo IPv4",cidrv6:"intervallo IPv6",base64:"stringa codificata in base64",base64url:"URL codificata in base64",json_string:"stringa JSON",e164:"numero E.164",jwt:"JWT",template_literal:"input"},o={nan:"NaN",number:"numero",array:"vettore"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Input non valido: atteso instanceof ${t.expected}, ricevuto ${p}`:`Input non valido: atteso ${i}, ricevuto ${p}`}case"invalid_value":return t.values.length===1?`Input non valido: atteso ${$(t.values[0])}`:`Opzione non valida: atteso uno tra ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Troppo grande: ${(m=t.origin)!=null?m:"valore"} deve avere ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elementi"}`:`Troppo grande: ${(u=t.origin)!=null?u:"valore"} deve essere ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Troppo piccolo: ${t.origin} deve avere ${i}${t.minimum.toString()} ${l.unit}`:`Troppo piccolo: ${t.origin} deve essere ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Stringa non valida: deve iniziare con "${i.prefix}"`:i.format==="ends_with"?`Stringa non valida: deve terminare con "${i.suffix}"`:i.format==="includes"?`Stringa non valida: deve includere "${i.includes}"`:i.format==="regex"?`Stringa non valida: deve corrispondere al pattern ${i.pattern}`:`Invalid ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Numero non valido: deve essere un multiplo di ${t.divisor}`;case"unrecognized_keys":return`Chiav${t.keys.length>1?"i":"e"} non riconosciut${t.keys.length>1?"e":"a"}: ${h(t.keys,", ")}`;case"invalid_key":return`Chiave non valida in ${t.origin}`;case"invalid_union":return"Input non valido";case"invalid_element":return`Valore non valido in ${t.origin}`;default:return"Input non valido"}}};function pl(){return{localeError:bp()}}var xp=()=>{let e={string:{unit:"\\u6587\\u5B57",verb:"\\u3067\\u3042\\u308B"},file:{unit:"\\u30D0\\u30A4\\u30C8",verb:"\\u3067\\u3042\\u308B"},array:{unit:"\\u8981\\u7D20",verb:"\\u3067\\u3042\\u308B"},set:{unit:"\\u8981\\u7D20",verb:"\\u3067\\u3042\\u308B"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u5165\\u529B\\u5024",email:"\\u30E1\\u30FC\\u30EB\\u30A2\\u30C9\\u30EC\\u30B9",url:"URL",emoji:"\\u7D75\\u6587\\u5B57",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO\\u65E5\\u6642",date:"ISO\\u65E5\\u4ED8",time:"ISO\\u6642\\u523B",duration:"ISO\\u671F\\u9593",ipv4:"IPv4\\u30A2\\u30C9\\u30EC\\u30B9",ipv6:"IPv6\\u30A2\\u30C9\\u30EC\\u30B9",cidrv4:"IPv4\\u7BC4\\u56F2",cidrv6:"IPv6\\u7BC4\\u56F2",base64:"base64\\u30A8\\u30F3\\u30B3\\u30FC\\u30C9\\u6587\\u5B57\\u5217",base64url:"base64url\\u30A8\\u30F3\\u30B3\\u30FC\\u30C9\\u6587\\u5B57\\u5217",json_string:"JSON\\u6587\\u5B57\\u5217",e164:"E.164\\u756A\\u53F7",jwt:"JWT",template_literal:"\\u5165\\u529B\\u5024"},o={nan:"NaN",number:"\\u6570\\u5024",array:"\\u914D\\u5217"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u7121\\u52B9\\u306A\\u5165\\u529B: instanceof ${t.expected}\\u304C\\u671F\\u5F85\\u3055\\u308C\\u307E\\u3057\\u305F\\u304C\\u3001${p}\\u304C\\u5165\\u529B\\u3055\\u308C\\u307E\\u3057\\u305F`:`\\u7121\\u52B9\\u306A\\u5165\\u529B: ${i}\\u304C\\u671F\\u5F85\\u3055\\u308C\\u307E\\u3057\\u305F\\u304C\\u3001${p}\\u304C\\u5165\\u529B\\u3055\\u308C\\u307E\\u3057\\u305F`}case"invalid_value":return t.values.length===1?`\\u7121\\u52B9\\u306A\\u5165\\u529B: ${$(t.values[0])}\\u304C\\u671F\\u5F85\\u3055\\u308C\\u307E\\u3057\\u305F`:`\\u7121\\u52B9\\u306A\\u9078\\u629E: ${h(t.values,"\\u3001")}\\u306E\\u3044\\u305A\\u308C\\u304B\\u3067\\u3042\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`;case"too_big":{let i=t.inclusive?"\\u4EE5\\u4E0B\\u3067\\u3042\\u308B":"\\u3088\\u308A\\u5C0F\\u3055\\u3044",l=r(t.origin);return l?`\\u5927\\u304D\\u3059\\u304E\\u308B\\u5024: ${(m=t.origin)!=null?m:"\\u5024"}\\u306F${t.maximum.toString()}${(s=l.unit)!=null?s:"\\u8981\\u7D20"}${i}\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`:`\\u5927\\u304D\\u3059\\u304E\\u308B\\u5024: ${(u=t.origin)!=null?u:"\\u5024"}\\u306F${t.maximum.toString()}${i}\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`}case"too_small":{let i=t.inclusive?"\\u4EE5\\u4E0A\\u3067\\u3042\\u308B":"\\u3088\\u308A\\u5927\\u304D\\u3044",l=r(t.origin);return l?`\\u5C0F\\u3055\\u3059\\u304E\\u308B\\u5024: ${t.origin}\\u306F${t.minimum.toString()}${l.unit}${i}\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`:`\\u5C0F\\u3055\\u3059\\u304E\\u308B\\u5024: ${t.origin}\\u306F${t.minimum.toString()}${i}\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u7121\\u52B9\\u306A\\u6587\\u5B57\\u5217: "${i.prefix}"\\u3067\\u59CB\\u307E\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`:i.format==="ends_with"?`\\u7121\\u52B9\\u306A\\u6587\\u5B57\\u5217: "${i.suffix}"\\u3067\\u7D42\\u308F\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`:i.format==="includes"?`\\u7121\\u52B9\\u306A\\u6587\\u5B57\\u5217: "${i.includes}"\\u3092\\u542B\\u3080\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`:i.format==="regex"?`\\u7121\\u52B9\\u306A\\u6587\\u5B57\\u5217: \\u30D1\\u30BF\\u30FC\\u30F3${i.pattern}\\u306B\\u4E00\\u81F4\\u3059\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`:`\\u7121\\u52B9\\u306A${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u7121\\u52B9\\u306A\\u6570\\u5024: ${t.divisor}\\u306E\\u500D\\u6570\\u3067\\u3042\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`;case"unrecognized_keys":return`\\u8A8D\\u8B58\\u3055\\u308C\\u3066\\u3044\\u306A\\u3044\\u30AD\\u30FC${t.keys.length>1?"\\u7FA4":""}: ${h(t.keys,"\\u3001")}`;case"invalid_key":return`${t.origin}\\u5185\\u306E\\u7121\\u52B9\\u306A\\u30AD\\u30FC`;case"invalid_union":return"\\u7121\\u52B9\\u306A\\u5165\\u529B";case"invalid_element":return`${t.origin}\\u5185\\u306E\\u7121\\u52B9\\u306A\\u5024`;default:return"\\u7121\\u52B9\\u306A\\u5165\\u529B"}}};function fl(){return{localeError:xp()}}var _p=()=>{let e={string:{unit:"\\u10E1\\u10D8\\u10DB\\u10D1\\u10DD\\u10DA\\u10DD",verb:"\\u10E3\\u10DC\\u10D3\\u10D0 \\u10E8\\u10D4\\u10D8\\u10EA\\u10D0\\u10D5\\u10D3\\u10D4\\u10E1"},file:{unit:"\\u10D1\\u10D0\\u10D8\\u10E2\\u10D8",verb:"\\u10E3\\u10DC\\u10D3\\u10D0 \\u10E8\\u10D4\\u10D8\\u10EA\\u10D0\\u10D5\\u10D3\\u10D4\\u10E1"},array:{unit:"\\u10D4\\u10DA\\u10D4\\u10DB\\u10D4\\u10DC\\u10E2\\u10D8",verb:"\\u10E3\\u10DC\\u10D3\\u10D0 \\u10E8\\u10D4\\u10D8\\u10EA\\u10D0\\u10D5\\u10D3\\u10D4\\u10E1"},set:{unit:"\\u10D4\\u10DA\\u10D4\\u10DB\\u10D4\\u10DC\\u10E2\\u10D8",verb:"\\u10E3\\u10DC\\u10D3\\u10D0 \\u10E8\\u10D4\\u10D8\\u10EA\\u10D0\\u10D5\\u10D3\\u10D4\\u10E1"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u10E8\\u10D4\\u10E7\\u10D5\\u10D0\\u10DC\\u10D0",email:"\\u10D4\\u10DA-\\u10E4\\u10DD\\u10E1\\u10E2\\u10D8\\u10E1 \\u10DB\\u10D8\\u10E1\\u10D0\\u10DB\\u10D0\\u10E0\\u10D7\\u10D8",url:"URL",emoji:"\\u10D4\\u10DB\\u10DD\\u10EF\\u10D8",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"\\u10D7\\u10D0\\u10E0\\u10D8\\u10E6\\u10D8-\\u10D3\\u10E0\\u10DD",date:"\\u10D7\\u10D0\\u10E0\\u10D8\\u10E6\\u10D8",time:"\\u10D3\\u10E0\\u10DD",duration:"\\u10EE\\u10D0\\u10DC\\u10D2\\u10E0\\u10EB\\u10DA\\u10D8\\u10D5\\u10DD\\u10D1\\u10D0",ipv4:"IPv4 \\u10DB\\u10D8\\u10E1\\u10D0\\u10DB\\u10D0\\u10E0\\u10D7\\u10D8",ipv6:"IPv6 \\u10DB\\u10D8\\u10E1\\u10D0\\u10DB\\u10D0\\u10E0\\u10D7\\u10D8",cidrv4:"IPv4 \\u10D3\\u10D8\\u10D0\\u10DE\\u10D0\\u10D6\\u10DD\\u10DC\\u10D8",cidrv6:"IPv6 \\u10D3\\u10D8\\u10D0\\u10DE\\u10D0\\u10D6\\u10DD\\u10DC\\u10D8",base64:"base64-\\u10D9\\u10DD\\u10D3\\u10D8\\u10E0\\u10D4\\u10D1\\u10E3\\u10DA\\u10D8 \\u10E1\\u10E2\\u10E0\\u10D8\\u10DC\\u10D2\\u10D8",base64url:"base64url-\\u10D9\\u10DD\\u10D3\\u10D8\\u10E0\\u10D4\\u10D1\\u10E3\\u10DA\\u10D8 \\u10E1\\u10E2\\u10E0\\u10D8\\u10DC\\u10D2\\u10D8",json_string:"JSON \\u10E1\\u10E2\\u10E0\\u10D8\\u10DC\\u10D2\\u10D8",e164:"E.164 \\u10DC\\u10DD\\u10DB\\u10D4\\u10E0\\u10D8",jwt:"JWT",template_literal:"\\u10E8\\u10D4\\u10E7\\u10D5\\u10D0\\u10DC\\u10D0"},o={nan:"NaN",number:"\\u10E0\\u10D8\\u10EA\\u10EE\\u10D5\\u10D8",string:"\\u10E1\\u10E2\\u10E0\\u10D8\\u10DC\\u10D2\\u10D8",boolean:"\\u10D1\\u10E3\\u10DA\\u10D4\\u10D0\\u10DC\\u10D8",function:"\\u10E4\\u10E3\\u10DC\\u10E5\\u10EA\\u10D8\\u10D0",array:"\\u10DB\\u10D0\\u10E1\\u10D8\\u10D5\\u10D8"};return t=>{var a,c,m,s,u;switch(t.code){case"invalid_type":{let d=(a=o[t.expected])!=null?a:t.expected,i=b(t.input),l=(c=o[i])!=null?c:i;return/^[A-Z]/.test(t.expected)?`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E8\\u10D4\\u10E7\\u10D5\\u10D0\\u10DC\\u10D0: \\u10DB\\u10DD\\u10E1\\u10D0\\u10DA\\u10DD\\u10D3\\u10DC\\u10D4\\u10DA\\u10D8 instanceof ${t.expected}, \\u10DB\\u10D8\\u10E6\\u10D4\\u10D1\\u10E3\\u10DA\\u10D8 ${l}`:`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E8\\u10D4\\u10E7\\u10D5\\u10D0\\u10DC\\u10D0: \\u10DB\\u10DD\\u10E1\\u10D0\\u10DA\\u10DD\\u10D3\\u10DC\\u10D4\\u10DA\\u10D8 ${d}, \\u10DB\\u10D8\\u10E6\\u10D4\\u10D1\\u10E3\\u10DA\\u10D8 ${l}`}case"invalid_value":return t.values.length===1?`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E8\\u10D4\\u10E7\\u10D5\\u10D0\\u10DC\\u10D0: \\u10DB\\u10DD\\u10E1\\u10D0\\u10DA\\u10DD\\u10D3\\u10DC\\u10D4\\u10DA\\u10D8 ${$(t.values[0])}`:`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10D5\\u10D0\\u10E0\\u10D8\\u10D0\\u10DC\\u10E2\\u10D8: \\u10DB\\u10DD\\u10E1\\u10D0\\u10DA\\u10DD\\u10D3\\u10DC\\u10D4\\u10DA\\u10D8\\u10D0 \\u10D4\\u10E0\\u10D7-\\u10D4\\u10E0\\u10D7\\u10D8 ${h(t.values,"|")}-\\u10D3\\u10D0\\u10DC`;case"too_big":{let d=t.inclusive?"<=":"<",i=r(t.origin);return i?`\\u10D6\\u10D4\\u10D3\\u10DB\\u10D4\\u10E2\\u10D0\\u10D3 \\u10D3\\u10D8\\u10D3\\u10D8: \\u10DB\\u10DD\\u10E1\\u10D0\\u10DA\\u10DD\\u10D3\\u10DC\\u10D4\\u10DA\\u10D8 ${(m=t.origin)!=null?m:"\\u10DB\\u10DC\\u10D8\\u10E8\\u10D5\\u10DC\\u10D4\\u10DA\\u10DD\\u10D1\\u10D0"} ${i.verb} ${d}${t.maximum.toString()} ${i.unit}`:`\\u10D6\\u10D4\\u10D3\\u10DB\\u10D4\\u10E2\\u10D0\\u10D3 \\u10D3\\u10D8\\u10D3\\u10D8: \\u10DB\\u10DD\\u10E1\\u10D0\\u10DA\\u10DD\\u10D3\\u10DC\\u10D4\\u10DA\\u10D8 ${(s=t.origin)!=null?s:"\\u10DB\\u10DC\\u10D8\\u10E8\\u10D5\\u10DC\\u10D4\\u10DA\\u10DD\\u10D1\\u10D0"} \\u10D8\\u10E7\\u10DD\\u10E1 ${d}${t.maximum.toString()}`}case"too_small":{let d=t.inclusive?">=":">",i=r(t.origin);return i?`\\u10D6\\u10D4\\u10D3\\u10DB\\u10D4\\u10E2\\u10D0\\u10D3 \\u10DE\\u10D0\\u10E2\\u10D0\\u10E0\\u10D0: \\u10DB\\u10DD\\u10E1\\u10D0\\u10DA\\u10DD\\u10D3\\u10DC\\u10D4\\u10DA\\u10D8 ${t.origin} ${i.verb} ${d}${t.minimum.toString()} ${i.unit}`:`\\u10D6\\u10D4\\u10D3\\u10DB\\u10D4\\u10E2\\u10D0\\u10D3 \\u10DE\\u10D0\\u10E2\\u10D0\\u10E0\\u10D0: \\u10DB\\u10DD\\u10E1\\u10D0\\u10DA\\u10DD\\u10D3\\u10DC\\u10D4\\u10DA\\u10D8 ${t.origin} \\u10D8\\u10E7\\u10DD\\u10E1 ${d}${t.minimum.toString()}`}case"invalid_format":{let d=t;return d.format==="starts_with"?`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E1\\u10E2\\u10E0\\u10D8\\u10DC\\u10D2\\u10D8: \\u10E3\\u10DC\\u10D3\\u10D0 \\u10D8\\u10EC\\u10E7\\u10D4\\u10D1\\u10DD\\u10D3\\u10D4\\u10E1 "${d.prefix}"-\\u10D8\\u10D7`:d.format==="ends_with"?`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E1\\u10E2\\u10E0\\u10D8\\u10DC\\u10D2\\u10D8: \\u10E3\\u10DC\\u10D3\\u10D0 \\u10DB\\u10D7\\u10D0\\u10D5\\u10E0\\u10D3\\u10D4\\u10D1\\u10DD\\u10D3\\u10D4\\u10E1 "${d.suffix}"-\\u10D8\\u10D7`:d.format==="includes"?`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E1\\u10E2\\u10E0\\u10D8\\u10DC\\u10D2\\u10D8: \\u10E3\\u10DC\\u10D3\\u10D0 \\u10E8\\u10D4\\u10D8\\u10EA\\u10D0\\u10D5\\u10D3\\u10D4\\u10E1 "${d.includes}"-\\u10E1`:d.format==="regex"?`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E1\\u10E2\\u10E0\\u10D8\\u10DC\\u10D2\\u10D8: \\u10E3\\u10DC\\u10D3\\u10D0 \\u10E8\\u10D4\\u10D4\\u10E1\\u10D0\\u10D1\\u10D0\\u10DB\\u10D4\\u10D1\\u10DD\\u10D3\\u10D4\\u10E1 \\u10E8\\u10D0\\u10D1\\u10DA\\u10DD\\u10DC\\u10E1 ${d.pattern}`:`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 ${(u=n[d.format])!=null?u:t.format}`}case"not_multiple_of":return`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E0\\u10D8\\u10EA\\u10EE\\u10D5\\u10D8: \\u10E3\\u10DC\\u10D3\\u10D0 \\u10D8\\u10E7\\u10DD\\u10E1 ${t.divisor}-\\u10D8\\u10E1 \\u10EF\\u10D4\\u10E0\\u10D0\\u10D3\\u10D8`;case"unrecognized_keys":return`\\u10E3\\u10EA\\u10DC\\u10DD\\u10D1\\u10D8 \\u10D2\\u10D0\\u10E1\\u10D0\\u10E6\\u10D4\\u10D1${t.keys.length>1?"\\u10D4\\u10D1\\u10D8":"\\u10D8"}: ${h(t.keys,", ")}`;case"invalid_key":return`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10D2\\u10D0\\u10E1\\u10D0\\u10E6\\u10D4\\u10D1\\u10D8 ${t.origin}-\\u10E8\\u10D8`;case"invalid_union":return"\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E8\\u10D4\\u10E7\\u10D5\\u10D0\\u10DC\\u10D0";case"invalid_element":return`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10DB\\u10DC\\u10D8\\u10E8\\u10D5\\u10DC\\u10D4\\u10DA\\u10DD\\u10D1\\u10D0 ${t.origin}-\\u10E8\\u10D8`;default:return"\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E8\\u10D4\\u10E7\\u10D5\\u10D0\\u10DC\\u10D0"}}};function gl(){return{localeError:_p()}}var Sp=()=>{let e={string:{unit:"\\u178F\\u17BD\\u17A2\\u1780\\u17D2\\u179F\\u179A",verb:"\\u1782\\u17BD\\u179A\\u1798\\u17B6\\u1793"},file:{unit:"\\u1794\\u17C3",verb:"\\u1782\\u17BD\\u179A\\u1798\\u17B6\\u1793"},array:{unit:"\\u1792\\u17B6\\u178F\\u17BB",verb:"\\u1782\\u17BD\\u179A\\u1798\\u17B6\\u1793"},set:{unit:"\\u1792\\u17B6\\u178F\\u17BB",verb:"\\u1782\\u17BD\\u179A\\u1798\\u17B6\\u1793"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1794\\u1789\\u17D2\\u1785\\u17BC\\u179B",email:"\\u17A2\\u17B6\\u179F\\u1799\\u178A\\u17D2\\u178B\\u17B6\\u1793\\u17A2\\u17CA\\u17B8\\u1798\\u17C2\\u179B",url:"URL",emoji:"\\u179F\\u1789\\u17D2\\u1789\\u17B6\\u17A2\\u17B6\\u179A\\u1798\\u17D2\\u1798\\u178E\\u17CD",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"\\u1780\\u17B6\\u179B\\u1794\\u179A\\u17B7\\u1785\\u17D2\\u1786\\u17C1\\u1791 \\u1793\\u17B7\\u1784\\u1798\\u17C9\\u17C4\\u1784 ISO",date:"\\u1780\\u17B6\\u179B\\u1794\\u179A\\u17B7\\u1785\\u17D2\\u1786\\u17C1\\u1791 ISO",time:"\\u1798\\u17C9\\u17C4\\u1784 ISO",duration:"\\u179A\\u1799\\u17C8\\u1796\\u17C1\\u179B ISO",ipv4:"\\u17A2\\u17B6\\u179F\\u1799\\u178A\\u17D2\\u178B\\u17B6\\u1793 IPv4",ipv6:"\\u17A2\\u17B6\\u179F\\u1799\\u178A\\u17D2\\u178B\\u17B6\\u1793 IPv6",cidrv4:"\\u178A\\u17C2\\u1793\\u17A2\\u17B6\\u179F\\u1799\\u178A\\u17D2\\u178B\\u17B6\\u1793 IPv4",cidrv6:"\\u178A\\u17C2\\u1793\\u17A2\\u17B6\\u179F\\u1799\\u178A\\u17D2\\u178B\\u17B6\\u1793 IPv6",base64:"\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u17A2\\u17CA\\u17B7\\u1780\\u17BC\\u178A base64",base64url:"\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u17A2\\u17CA\\u17B7\\u1780\\u17BC\\u178A base64url",json_string:"\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A JSON",e164:"\\u179B\\u17C1\\u1781 E.164",jwt:"JWT",template_literal:"\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1794\\u1789\\u17D2\\u1785\\u17BC\\u179B"},o={nan:"NaN",number:"\\u179B\\u17C1\\u1781",array:"\\u17A2\\u17B6\\u179A\\u17C1 (Array)",null:"\\u1782\\u17D2\\u1798\\u17B6\\u1793\\u178F\\u1798\\u17D2\\u179B\\u17C3 (null)"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1794\\u1789\\u17D2\\u1785\\u17BC\\u179B\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A instanceof ${t.expected} \\u1794\\u17C9\\u17BB\\u1793\\u17D2\\u178F\\u17C2\\u1791\\u1791\\u17BD\\u179B\\u1794\\u17B6\\u1793 ${p}`:`\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1794\\u1789\\u17D2\\u1785\\u17BC\\u179B\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${i} \\u1794\\u17C9\\u17BB\\u1793\\u17D2\\u178F\\u17C2\\u1791\\u1791\\u17BD\\u179B\\u1794\\u17B6\\u1793 ${p}`}case"invalid_value":return t.values.length===1?`\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1794\\u1789\\u17D2\\u1785\\u17BC\\u179B\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${$(t.values[0])}`:`\\u1787\\u1798\\u17D2\\u179A\\u17BE\\u179F\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1787\\u17B6\\u1798\\u17BD\\u1799\\u1780\\u17D2\\u1793\\u17BB\\u1784\\u1785\\u17C6\\u178E\\u17C4\\u1798 ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u1792\\u17C6\\u1796\\u17C1\\u1780\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${(m=t.origin)!=null?m:"\\u178F\\u1798\\u17D2\\u179B\\u17C3"} ${i} ${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u1792\\u17B6\\u178F\\u17BB"}`:`\\u1792\\u17C6\\u1796\\u17C1\\u1780\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${(u=t.origin)!=null?u:"\\u178F\\u1798\\u17D2\\u179B\\u17C3"} ${i} ${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u178F\\u17BC\\u1785\\u1796\\u17C1\\u1780\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${t.origin} ${i} ${t.minimum.toString()} ${l.unit}`:`\\u178F\\u17BC\\u1785\\u1796\\u17C1\\u1780\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${t.origin} ${i} ${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1785\\u17B6\\u1794\\u17CB\\u1795\\u17D2\\u178F\\u17BE\\u1798\\u178A\\u17C4\\u1799 "${i.prefix}"`:i.format==="ends_with"?`\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1794\\u1789\\u17D2\\u1785\\u1794\\u17CB\\u178A\\u17C4\\u1799 "${i.suffix}"`:i.format==="includes"?`\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1798\\u17B6\\u1793 "${i.includes}"`:i.format==="regex"?`\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u178F\\u17C2\\u1795\\u17D2\\u1782\\u17BC\\u1795\\u17D2\\u1782\\u1784\\u1793\\u17B9\\u1784\\u1791\\u1798\\u17D2\\u179A\\u1784\\u17CB\\u178A\\u17C2\\u179B\\u1794\\u17B6\\u1793\\u1780\\u17C6\\u178E\\u178F\\u17CB ${i.pattern}`:`\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u179B\\u17C1\\u1781\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u178F\\u17C2\\u1787\\u17B6\\u1796\\u17A0\\u17BB\\u1782\\u17BB\\u178E\\u1793\\u17C3 ${t.divisor}`;case"unrecognized_keys":return`\\u179A\\u1780\\u1783\\u17BE\\u1789\\u179F\\u17C4\\u1798\\u17B7\\u1793\\u179F\\u17D2\\u1782\\u17B6\\u179B\\u17CB\\u17D6 ${h(t.keys,", ")}`;case"invalid_key":return`\\u179F\\u17C4\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1793\\u17C5\\u1780\\u17D2\\u1793\\u17BB\\u1784 ${t.origin}`;case"invalid_union":return"\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C";case"invalid_element":return`\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1793\\u17C5\\u1780\\u17D2\\u1793\\u17BB\\u1784 ${t.origin}`;default:return"\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C"}}};function $r(){return{localeError:Sp()}}function vl(){return $r()}var kp=()=>{let e={string:{unit:"\\uBB38\\uC790",verb:"to have"},file:{unit:"\\uBC14\\uC774\\uD2B8",verb:"to have"},array:{unit:"\\uAC1C",verb:"to have"},set:{unit:"\\uAC1C",verb:"to have"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\uC785\\uB825",email:"\\uC774\\uBA54\\uC77C \\uC8FC\\uC18C",url:"URL",emoji:"\\uC774\\uBAA8\\uC9C0",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO \\uB0A0\\uC9DC\\uC2DC\\uAC04",date:"ISO \\uB0A0\\uC9DC",time:"ISO \\uC2DC\\uAC04",duration:"ISO \\uAE30\\uAC04",ipv4:"IPv4 \\uC8FC\\uC18C",ipv6:"IPv6 \\uC8FC\\uC18C",cidrv4:"IPv4 \\uBC94\\uC704",cidrv6:"IPv6 \\uBC94\\uC704",base64:"base64 \\uC778\\uCF54\\uB529 \\uBB38\\uC790\\uC5F4",base64url:"base64url \\uC778\\uCF54\\uB529 \\uBB38\\uC790\\uC5F4",json_string:"JSON \\uBB38\\uC790\\uC5F4",e164:"E.164 \\uBC88\\uD638",jwt:"JWT",template_literal:"\\uC785\\uB825"},o={nan:"NaN"};return t=>{var a,c,m,s,u,d,i,l,p;switch(t.code){case"invalid_type":{let v=(a=o[t.expected])!=null?a:t.expected,y=b(t.input),S=(c=o[y])!=null?c:y;return/^[A-Z]/.test(t.expected)?`\\uC798\\uBABB\\uB41C \\uC785\\uB825: \\uC608\\uC0C1 \\uD0C0\\uC785\\uC740 instanceof ${t.expected}, \\uBC1B\\uC740 \\uD0C0\\uC785\\uC740 ${S}\\uC785\\uB2C8\\uB2E4`:`\\uC798\\uBABB\\uB41C \\uC785\\uB825: \\uC608\\uC0C1 \\uD0C0\\uC785\\uC740 ${v}, \\uBC1B\\uC740 \\uD0C0\\uC785\\uC740 ${S}\\uC785\\uB2C8\\uB2E4`}case"invalid_value":return t.values.length===1?`\\uC798\\uBABB\\uB41C \\uC785\\uB825: \\uAC12\\uC740 ${$(t.values[0])} \\uC774\\uC5B4\\uC57C \\uD569\\uB2C8\\uB2E4`:`\\uC798\\uBABB\\uB41C \\uC635\\uC158: ${h(t.values,"\\uB610\\uB294 ")} \\uC911 \\uD558\\uB098\\uC5EC\\uC57C \\uD569\\uB2C8\\uB2E4`;case"too_big":{let v=t.inclusive?"\\uC774\\uD558":"\\uBBF8\\uB9CC",y=v==="\\uBBF8\\uB9CC"?"\\uC774\\uC5B4\\uC57C \\uD569\\uB2C8\\uB2E4":"\\uC5EC\\uC57C \\uD569\\uB2C8\\uB2E4",S=r(t.origin),w=(m=S==null?void 0:S.unit)!=null?m:"\\uC694\\uC18C";return S?`${(s=t.origin)!=null?s:"\\uAC12"}\\uC774 \\uB108\\uBB34 \\uD07D\\uB2C8\\uB2E4: ${t.maximum.toString()}${w} ${v}${y}`:`${(u=t.origin)!=null?u:"\\uAC12"}\\uC774 \\uB108\\uBB34 \\uD07D\\uB2C8\\uB2E4: ${t.maximum.toString()} ${v}${y}`}case"too_small":{let v=t.inclusive?"\\uC774\\uC0C1":"\\uCD08\\uACFC",y=v==="\\uC774\\uC0C1"?"\\uC774\\uC5B4\\uC57C \\uD569\\uB2C8\\uB2E4":"\\uC5EC\\uC57C \\uD569\\uB2C8\\uB2E4",S=r(t.origin),w=(d=S==null?void 0:S.unit)!=null?d:"\\uC694\\uC18C";return S?`${(i=t.origin)!=null?i:"\\uAC12"}\\uC774 \\uB108\\uBB34 \\uC791\\uC2B5\\uB2C8\\uB2E4: ${t.minimum.toString()}${w} ${v}${y}`:`${(l=t.origin)!=null?l:"\\uAC12"}\\uC774 \\uB108\\uBB34 \\uC791\\uC2B5\\uB2C8\\uB2E4: ${t.minimum.toString()} ${v}${y}`}case"invalid_format":{let v=t;return v.format==="starts_with"?`\\uC798\\uBABB\\uB41C \\uBB38\\uC790\\uC5F4: "${v.prefix}"(\\uC73C)\\uB85C \\uC2DC\\uC791\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4`:v.format==="ends_with"?`\\uC798\\uBABB\\uB41C \\uBB38\\uC790\\uC5F4: "${v.suffix}"(\\uC73C)\\uB85C \\uB05D\\uB098\\uC57C \\uD569\\uB2C8\\uB2E4`:v.format==="includes"?`\\uC798\\uBABB\\uB41C \\uBB38\\uC790\\uC5F4: "${v.includes}"\\uC744(\\uB97C) \\uD3EC\\uD568\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4`:v.format==="regex"?`\\uC798\\uBABB\\uB41C \\uBB38\\uC790\\uC5F4: \\uC815\\uADDC\\uC2DD ${v.pattern} \\uD328\\uD134\\uACFC \\uC77C\\uCE58\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4`:`\\uC798\\uBABB\\uB41C ${(p=n[v.format])!=null?p:t.format}`}case"not_multiple_of":return`\\uC798\\uBABB\\uB41C \\uC22B\\uC790: ${t.divisor}\\uC758 \\uBC30\\uC218\\uC5EC\\uC57C \\uD569\\uB2C8\\uB2E4`;case"unrecognized_keys":return`\\uC778\\uC2DD\\uD560 \\uC218 \\uC5C6\\uB294 \\uD0A4: ${h(t.keys,", ")}`;case"invalid_key":return`\\uC798\\uBABB\\uB41C \\uD0A4: ${t.origin}`;case"invalid_union":return"\\uC798\\uBABB\\uB41C \\uC785\\uB825";case"invalid_element":return`\\uC798\\uBABB\\uB41C \\uAC12: ${t.origin}`;default:return"\\uC798\\uBABB\\uB41C \\uC785\\uB825"}}};function hl(){return{localeError:kp()}}var ft=e=>e.charAt(0).toUpperCase()+e.slice(1);function yl(e){let r=Math.abs(e),n=r%10,o=r%100;return o>=11&&o<=19||n===0?"many":n===1?"one":"few"}var Ip=()=>{let e={string:{unit:{one:"simbolis",few:"simboliai",many:"simboli\\u0173"},verb:{smaller:{inclusive:"turi b\\u016Bti ne ilgesn\\u0117 kaip",notInclusive:"turi b\\u016Bti trumpesn\\u0117 kaip"},bigger:{inclusive:"turi b\\u016Bti ne trumpesn\\u0117 kaip",notInclusive:"turi b\\u016Bti ilgesn\\u0117 kaip"}}},file:{unit:{one:"baitas",few:"baitai",many:"bait\\u0173"},verb:{smaller:{inclusive:"turi b\\u016Bti ne didesnis kaip",notInclusive:"turi b\\u016Bti ma\\u017Eesnis kaip"},bigger:{inclusive:"turi b\\u016Bti ne ma\\u017Eesnis kaip",notInclusive:"turi b\\u016Bti didesnis kaip"}}},array:{unit:{one:"element\\u0105",few:"elementus",many:"element\\u0173"},verb:{smaller:{inclusive:"turi tur\\u0117ti ne daugiau kaip",notInclusive:"turi tur\\u0117ti ma\\u017Eiau kaip"},bigger:{inclusive:"turi tur\\u0117ti ne ma\\u017Eiau kaip",notInclusive:"turi tur\\u0117ti daugiau kaip"}}},set:{unit:{one:"element\\u0105",few:"elementus",many:"element\\u0173"},verb:{smaller:{inclusive:"turi tur\\u0117ti ne daugiau kaip",notInclusive:"turi tur\\u0117ti ma\\u017Eiau kaip"},bigger:{inclusive:"turi tur\\u0117ti ne ma\\u017Eiau kaip",notInclusive:"turi tur\\u0117ti daugiau kaip"}}}};function r(t,a,c,m){var u;let s=(u=e[t])!=null?u:null;return s===null?s:{unit:s.unit[a],verb:s.verb[m][c?"inclusive":"notInclusive"]}}let n={regex:"\\u012Fvestis",email:"el. pa\\u0161to adresas",url:"URL",emoji:"jaustukas",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO data ir laikas",date:"ISO data",time:"ISO laikas",duration:"ISO trukm\\u0117",ipv4:"IPv4 adresas",ipv6:"IPv6 adresas",cidrv4:"IPv4 tinklo prefiksas (CIDR)",cidrv6:"IPv6 tinklo prefiksas (CIDR)",base64:"base64 u\\u017Ekoduota eilut\\u0117",base64url:"base64url u\\u017Ekoduota eilut\\u0117",json_string:"JSON eilut\\u0117",e164:"E.164 numeris",jwt:"JWT",template_literal:"\\u012Fvestis"},o={nan:"NaN",number:"skai\\u010Dius",bigint:"sveikasis skai\\u010Dius",string:"eilut\\u0117",boolean:"login\\u0117 reik\\u0161m\\u0117",undefined:"neapibr\\u0117\\u017Eta reik\\u0161m\\u0117",function:"funkcija",symbol:"simbolis",array:"masyvas",object:"objektas",null:"nulin\\u0117 reik\\u0161m\\u0117"};return t=>{var a,c,m,s,u,d,i,l,p,v,y,S,w,D,N;switch(t.code){case"invalid_type":{let k=(a=o[t.expected])!=null?a:t.expected,T=b(t.input),U=(c=o[T])!=null?c:T;return/^[A-Z]/.test(t.expected)?`Gautas tipas ${U}, o tik\\u0117tasi - instanceof ${t.expected}`:`Gautas tipas ${U}, o tik\\u0117tasi - ${k}`}case"invalid_value":return t.values.length===1?`Privalo b\\u016Bti ${$(t.values[0])}`:`Privalo b\\u016Bti vienas i\\u0161 ${h(t.values,"|")} pasirinkim\\u0173`;case"too_big":{let k=(m=o[t.origin])!=null?m:t.origin,T=r(t.origin,yl(Number(t.maximum)),(s=t.inclusive)!=null?s:!1,"smaller");if(T!=null&&T.verb)return`${ft((u=k!=null?k:t.origin)!=null?u:"reik\\u0161m\\u0117")} ${T.verb} ${t.maximum.toString()} ${(d=T.unit)!=null?d:"element\\u0173"}`;let U=t.inclusive?"ne didesnis kaip":"ma\\u017Eesnis kaip";return`${ft((i=k!=null?k:t.origin)!=null?i:"reik\\u0161m\\u0117")} turi b\\u016Bti ${U} ${t.maximum.toString()} ${T==null?void 0:T.unit}`}case"too_small":{let k=(l=o[t.origin])!=null?l:t.origin,T=r(t.origin,yl(Number(t.minimum)),(p=t.inclusive)!=null?p:!1,"bigger");if(T!=null&&T.verb)return`${ft((v=k!=null?k:t.origin)!=null?v:"reik\\u0161m\\u0117")} ${T.verb} ${t.minimum.toString()} ${(y=T.unit)!=null?y:"element\\u0173"}`;let U=t.inclusive?"ne ma\\u017Eesnis kaip":"didesnis kaip";return`${ft((S=k!=null?k:t.origin)!=null?S:"reik\\u0161m\\u0117")} turi b\\u016Bti ${U} ${t.minimum.toString()} ${T==null?void 0:T.unit}`}case"invalid_format":{let k=t;return k.format==="starts_with"?`Eilut\\u0117 privalo prasid\\u0117ti "${k.prefix}"`:k.format==="ends_with"?`Eilut\\u0117 privalo pasibaigti "${k.suffix}"`:k.format==="includes"?`Eilut\\u0117 privalo \\u012Ftraukti "${k.includes}"`:k.format==="regex"?`Eilut\\u0117 privalo atitikti ${k.pattern}`:`Neteisingas ${(w=n[k.format])!=null?w:t.format}`}case"not_multiple_of":return`Skai\\u010Dius privalo b\\u016Bti ${t.divisor} kartotinis.`;case"unrecognized_keys":return`Neatpa\\u017Eint${t.keys.length>1?"i":"as"} rakt${t.keys.length>1?"ai":"as"}: ${h(t.keys,", ")}`;case"invalid_key":return"Rastas klaidingas raktas";case"invalid_union":return"Klaidinga \\u012Fvestis";case"invalid_element":{let k=(D=o[t.origin])!=null?D:t.origin;return`${ft((N=k!=null?k:t.origin)!=null?N:"reik\\u0161m\\u0117")} turi klaiding\\u0105 \\u012Fvest\\u012F`}default:return"Klaidinga \\u012Fvestis"}}};function $l(){return{localeError:Ip()}}var zp=()=>{let e={string:{unit:"\\u0437\\u043D\\u0430\\u0446\\u0438",verb:"\\u0434\\u0430 \\u0438\\u043C\\u0430\\u0430\\u0442"},file:{unit:"\\u0431\\u0430\\u0458\\u0442\\u0438",verb:"\\u0434\\u0430 \\u0438\\u043C\\u0430\\u0430\\u0442"},array:{unit:"\\u0441\\u0442\\u0430\\u0432\\u043A\\u0438",verb:"\\u0434\\u0430 \\u0438\\u043C\\u0430\\u0430\\u0442"},set:{unit:"\\u0441\\u0442\\u0430\\u0432\\u043A\\u0438",verb:"\\u0434\\u0430 \\u0438\\u043C\\u0430\\u0430\\u0442"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0432\\u043D\\u0435\\u0441",email:"\\u0430\\u0434\\u0440\\u0435\\u0441\\u0430 \\u043D\\u0430 \\u0435-\\u043F\\u043E\\u0448\\u0442\\u0430",url:"URL",emoji:"\\u0435\\u043C\\u043E\\u045F\\u0438",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO \\u0434\\u0430\\u0442\\u0443\\u043C \\u0438 \\u0432\\u0440\\u0435\\u043C\\u0435",date:"ISO \\u0434\\u0430\\u0442\\u0443\\u043C",time:"ISO \\u0432\\u0440\\u0435\\u043C\\u0435",duration:"ISO \\u0432\\u0440\\u0435\\u043C\\u0435\\u0442\\u0440\\u0430\\u0435\\u045A\\u0435",ipv4:"IPv4 \\u0430\\u0434\\u0440\\u0435\\u0441\\u0430",ipv6:"IPv6 \\u0430\\u0434\\u0440\\u0435\\u0441\\u0430",cidrv4:"IPv4 \\u043E\\u043F\\u0441\\u0435\\u0433",cidrv6:"IPv6 \\u043E\\u043F\\u0441\\u0435\\u0433",base64:"base64-\\u0435\\u043D\\u043A\\u043E\\u0434\\u0438\\u0440\\u0430\\u043D\\u0430 \\u043D\\u0438\\u0437\\u0430",base64url:"base64url-\\u0435\\u043D\\u043A\\u043E\\u0434\\u0438\\u0440\\u0430\\u043D\\u0430 \\u043D\\u0438\\u0437\\u0430",json_string:"JSON \\u043D\\u0438\\u0437\\u0430",e164:"E.164 \\u0431\\u0440\\u043E\\u0458",jwt:"JWT",template_literal:"\\u0432\\u043D\\u0435\\u0441"},o={nan:"NaN",number:"\\u0431\\u0440\\u043E\\u0458",array:"\\u043D\\u0438\\u0437\\u0430"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u0413\\u0440\\u0435\\u0448\\u0435\\u043D \\u0432\\u043D\\u0435\\u0441: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 instanceof ${t.expected}, \\u043F\\u0440\\u0438\\u043C\\u0435\\u043D\\u043E ${p}`:`\\u0413\\u0440\\u0435\\u0448\\u0435\\u043D \\u0432\\u043D\\u0435\\u0441: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 ${i}, \\u043F\\u0440\\u0438\\u043C\\u0435\\u043D\\u043E ${p}`}case"invalid_value":return t.values.length===1?`Invalid input: expected ${$(t.values[0])}`:`\\u0413\\u0440\\u0435\\u0448\\u0430\\u043D\\u0430 \\u043E\\u043F\\u0446\\u0438\\u0458\\u0430: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 \\u0435\\u0434\\u043D\\u0430 ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u041F\\u0440\\u0435\\u043C\\u043D\\u043E\\u0433\\u0443 \\u0433\\u043E\\u043B\\u0435\\u043C: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 ${(m=t.origin)!=null?m:"\\u0432\\u0440\\u0435\\u0434\\u043D\\u043E\\u0441\\u0442\\u0430"} \\u0434\\u0430 \\u0438\\u043C\\u0430 ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0438"}`:`\\u041F\\u0440\\u0435\\u043C\\u043D\\u043E\\u0433\\u0443 \\u0433\\u043E\\u043B\\u0435\\u043C: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 ${(u=t.origin)!=null?u:"\\u0432\\u0440\\u0435\\u0434\\u043D\\u043E\\u0441\\u0442\\u0430"} \\u0434\\u0430 \\u0431\\u0438\\u0434\\u0435 ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u041F\\u0440\\u0435\\u043C\\u043D\\u043E\\u0433\\u0443 \\u043C\\u0430\\u043B: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 ${t.origin} \\u0434\\u0430 \\u0438\\u043C\\u0430 ${i}${t.minimum.toString()} ${l.unit}`:`\\u041F\\u0440\\u0435\\u043C\\u043D\\u043E\\u0433\\u0443 \\u043C\\u0430\\u043B: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 ${t.origin} \\u0434\\u0430 \\u0431\\u0438\\u0434\\u0435 ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u041D\\u0435\\u0432\\u0430\\u0436\\u0435\\u0447\\u043A\\u0430 \\u043D\\u0438\\u0437\\u0430: \\u043C\\u043E\\u0440\\u0430 \\u0434\\u0430 \\u0437\\u0430\\u043F\\u043E\\u0447\\u043D\\u0443\\u0432\\u0430 \\u0441\\u043E "${i.prefix}"`:i.format==="ends_with"?`\\u041D\\u0435\\u0432\\u0430\\u0436\\u0435\\u0447\\u043A\\u0430 \\u043D\\u0438\\u0437\\u0430: \\u043C\\u043E\\u0440\\u0430 \\u0434\\u0430 \\u0437\\u0430\\u0432\\u0440\\u0448\\u0443\\u0432\\u0430 \\u0441\\u043E "${i.suffix}"`:i.format==="includes"?`\\u041D\\u0435\\u0432\\u0430\\u0436\\u0435\\u0447\\u043A\\u0430 \\u043D\\u0438\\u0437\\u0430: \\u043C\\u043E\\u0440\\u0430 \\u0434\\u0430 \\u0432\\u043A\\u043B\\u0443\\u0447\\u0443\\u0432\\u0430 "${i.includes}"`:i.format==="regex"?`\\u041D\\u0435\\u0432\\u0430\\u0436\\u0435\\u0447\\u043A\\u0430 \\u043D\\u0438\\u0437\\u0430: \\u043C\\u043E\\u0440\\u0430 \\u0434\\u0430 \\u043E\\u0434\\u0433\\u043E\\u0430\\u0440\\u0430 \\u043D\\u0430 \\u043F\\u0430\\u0442\\u0435\\u0440\\u043D\\u043E\\u0442 ${i.pattern}`:`Invalid ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u0413\\u0440\\u0435\\u0448\\u0435\\u043D \\u0431\\u0440\\u043E\\u0458: \\u043C\\u043E\\u0440\\u0430 \\u0434\\u0430 \\u0431\\u0438\\u0434\\u0435 \\u0434\\u0435\\u043B\\u0438\\u0432 \\u0441\\u043E ${t.divisor}`;case"unrecognized_keys":return`${t.keys.length>1?"\\u041D\\u0435\\u043F\\u0440\\u0435\\u043F\\u043E\\u0437\\u043D\\u0430\\u0435\\u043D\\u0438 \\u043A\\u043B\\u0443\\u0447\\u0435\\u0432\\u0438":"\\u041D\\u0435\\u043F\\u0440\\u0435\\u043F\\u043E\\u0437\\u043D\\u0430\\u0435\\u043D \\u043A\\u043B\\u0443\\u0447"}: ${h(t.keys,", ")}`;case"invalid_key":return`\\u0413\\u0440\\u0435\\u0448\\u0435\\u043D \\u043A\\u043B\\u0443\\u0447 \\u0432\\u043E ${t.origin}`;case"invalid_union":return"\\u0413\\u0440\\u0435\\u0448\\u0435\\u043D \\u0432\\u043D\\u0435\\u0441";case"invalid_element":return`\\u0413\\u0440\\u0435\\u0448\\u043D\\u0430 \\u0432\\u0440\\u0435\\u0434\\u043D\\u043E\\u0441\\u0442 \\u0432\\u043E ${t.origin}`;default:return"\\u0413\\u0440\\u0435\\u0448\\u0435\\u043D \\u0432\\u043D\\u0435\\u0441"}}};function bl(){return{localeError:zp()}}var Tp=()=>{let e={string:{unit:"aksara",verb:"mempunyai"},file:{unit:"bait",verb:"mempunyai"},array:{unit:"elemen",verb:"mempunyai"},set:{unit:"elemen",verb:"mempunyai"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"input",email:"alamat e-mel",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"tarikh masa ISO",date:"tarikh ISO",time:"masa ISO",duration:"tempoh ISO",ipv4:"alamat IPv4",ipv6:"alamat IPv6",cidrv4:"julat IPv4",cidrv6:"julat IPv6",base64:"string dikodkan base64",base64url:"string dikodkan base64url",json_string:"string JSON",e164:"nombor E.164",jwt:"JWT",template_literal:"input"},o={nan:"NaN",number:"nombor"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Input tidak sah: dijangka instanceof ${t.expected}, diterima ${p}`:`Input tidak sah: dijangka ${i}, diterima ${p}`}case"invalid_value":return t.values.length===1?`Input tidak sah: dijangka ${$(t.values[0])}`:`Pilihan tidak sah: dijangka salah satu daripada ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Terlalu besar: dijangka ${(m=t.origin)!=null?m:"nilai"} ${l.verb} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elemen"}`:`Terlalu besar: dijangka ${(u=t.origin)!=null?u:"nilai"} adalah ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Terlalu kecil: dijangka ${t.origin} ${l.verb} ${i}${t.minimum.toString()} ${l.unit}`:`Terlalu kecil: dijangka ${t.origin} adalah ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`String tidak sah: mesti bermula dengan "${i.prefix}"`:i.format==="ends_with"?`String tidak sah: mesti berakhir dengan "${i.suffix}"`:i.format==="includes"?`String tidak sah: mesti mengandungi "${i.includes}"`:i.format==="regex"?`String tidak sah: mesti sepadan dengan corak ${i.pattern}`:`${(d=n[i.format])!=null?d:t.format} tidak sah`}case"not_multiple_of":return`Nombor tidak sah: perlu gandaan ${t.divisor}`;case"unrecognized_keys":return`Kunci tidak dikenali: ${h(t.keys,", ")}`;case"invalid_key":return`Kunci tidak sah dalam ${t.origin}`;case"invalid_union":return"Input tidak sah";case"invalid_element":return`Nilai tidak sah dalam ${t.origin}`;default:return"Input tidak sah"}}};function xl(){return{localeError:Tp()}}var wp=()=>{let e={string:{unit:"tekens",verb:"heeft"},file:{unit:"bytes",verb:"heeft"},array:{unit:"elementen",verb:"heeft"},set:{unit:"elementen",verb:"heeft"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"invoer",email:"emailadres",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO datum en tijd",date:"ISO datum",time:"ISO tijd",duration:"ISO duur",ipv4:"IPv4-adres",ipv6:"IPv6-adres",cidrv4:"IPv4-bereik",cidrv6:"IPv6-bereik",base64:"base64-gecodeerde tekst",base64url:"base64 URL-gecodeerde tekst",json_string:"JSON string",e164:"E.164-nummer",jwt:"JWT",template_literal:"invoer"},o={nan:"NaN",number:"getal"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Ongeldige invoer: verwacht instanceof ${t.expected}, ontving ${p}`:`Ongeldige invoer: verwacht ${i}, ontving ${p}`}case"invalid_value":return t.values.length===1?`Ongeldige invoer: verwacht ${$(t.values[0])}`:`Ongeldige optie: verwacht \\xE9\\xE9n van ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin),p=t.origin==="date"?"laat":t.origin==="string"?"lang":"groot";return l?`Te ${p}: verwacht dat ${(m=t.origin)!=null?m:"waarde"} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elementen"} ${l.verb}`:`Te ${p}: verwacht dat ${(u=t.origin)!=null?u:"waarde"} ${i}${t.maximum.toString()} is`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin),p=t.origin==="date"?"vroeg":t.origin==="string"?"kort":"klein";return l?`Te ${p}: verwacht dat ${t.origin} ${i}${t.minimum.toString()} ${l.unit} ${l.verb}`:`Te ${p}: verwacht dat ${t.origin} ${i}${t.minimum.toString()} is`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Ongeldige tekst: moet met "${i.prefix}" beginnen`:i.format==="ends_with"?`Ongeldige tekst: moet op "${i.suffix}" eindigen`:i.format==="includes"?`Ongeldige tekst: moet "${i.includes}" bevatten`:i.format==="regex"?`Ongeldige tekst: moet overeenkomen met patroon ${i.pattern}`:`Ongeldig: ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Ongeldig getal: moet een veelvoud van ${t.divisor} zijn`;case"unrecognized_keys":return`Onbekende key${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`Ongeldige key in ${t.origin}`;case"invalid_union":return"Ongeldige invoer";case"invalid_element":return`Ongeldige waarde in ${t.origin}`;default:return"Ongeldige invoer"}}};function _l(){return{localeError:wp()}}var Pp=()=>{let e={string:{unit:"tegn",verb:"\\xE5 ha"},file:{unit:"bytes",verb:"\\xE5 ha"},array:{unit:"elementer",verb:"\\xE5 inneholde"},set:{unit:"elementer",verb:"\\xE5 inneholde"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"input",email:"e-postadresse",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO dato- og klokkeslett",date:"ISO-dato",time:"ISO-klokkeslett",duration:"ISO-varighet",ipv4:"IPv4-omr\\xE5de",ipv6:"IPv6-omr\\xE5de",cidrv4:"IPv4-spekter",cidrv6:"IPv6-spekter",base64:"base64-enkodet streng",base64url:"base64url-enkodet streng",json_string:"JSON-streng",e164:"E.164-nummer",jwt:"JWT",template_literal:"input"},o={nan:"NaN",number:"tall",array:"liste"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Ugyldig input: forventet instanceof ${t.expected}, fikk ${p}`:`Ugyldig input: forventet ${i}, fikk ${p}`}case"invalid_value":return t.values.length===1?`Ugyldig verdi: forventet ${$(t.values[0])}`:`Ugyldig valg: forventet en av ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`For stor(t): forventet ${(m=t.origin)!=null?m:"value"} til \\xE5 ha ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elementer"}`:`For stor(t): forventet ${(u=t.origin)!=null?u:"value"} til \\xE5 ha ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`For lite(n): forventet ${t.origin} til \\xE5 ha ${i}${t.minimum.toString()} ${l.unit}`:`For lite(n): forventet ${t.origin} til \\xE5 ha ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Ugyldig streng: m\\xE5 starte med "${i.prefix}"`:i.format==="ends_with"?`Ugyldig streng: m\\xE5 ende med "${i.suffix}"`:i.format==="includes"?`Ugyldig streng: m\\xE5 inneholde "${i.includes}"`:i.format==="regex"?`Ugyldig streng: m\\xE5 matche m\\xF8nsteret ${i.pattern}`:`Ugyldig ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Ugyldig tall: m\\xE5 v\\xE6re et multiplum av ${t.divisor}`;case"unrecognized_keys":return`${t.keys.length>1?"Ukjente n\\xF8kler":"Ukjent n\\xF8kkel"}: ${h(t.keys,", ")}`;case"invalid_key":return`Ugyldig n\\xF8kkel i ${t.origin}`;case"invalid_union":return"Ugyldig input";case"invalid_element":return`Ugyldig verdi i ${t.origin}`;default:return"Ugyldig input"}}};function Sl(){return{localeError:Pp()}}var Dp=()=>{let e={string:{unit:"harf",verb:"olmal\\u0131d\\u0131r"},file:{unit:"bayt",verb:"olmal\\u0131d\\u0131r"},array:{unit:"unsur",verb:"olmal\\u0131d\\u0131r"},set:{unit:"unsur",verb:"olmal\\u0131d\\u0131r"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"giren",email:"epostag\\xE2h",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO heng\\xE2m\\u0131",date:"ISO tarihi",time:"ISO zaman\\u0131",duration:"ISO m\\xFCddeti",ipv4:"IPv4 ni\\u015F\\xE2n\\u0131",ipv6:"IPv6 ni\\u015F\\xE2n\\u0131",cidrv4:"IPv4 menzili",cidrv6:"IPv6 menzili",base64:"base64-\\u015Fifreli metin",base64url:"base64url-\\u015Fifreli metin",json_string:"JSON metin",e164:"E.164 say\\u0131s\\u0131",jwt:"JWT",template_literal:"giren"},o={nan:"NaN",number:"numara",array:"saf",null:"gayb"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`F\\xE2sit giren: umulan instanceof ${t.expected}, al\\u0131nan ${p}`:`F\\xE2sit giren: umulan ${i}, al\\u0131nan ${p}`}case"invalid_value":return t.values.length===1?`F\\xE2sit giren: umulan ${$(t.values[0])}`:`F\\xE2sit tercih: m\\xFBteberler ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Fazla b\\xFCy\\xFCk: ${(m=t.origin)!=null?m:"value"}, ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elements"} sahip olmal\\u0131yd\\u0131.`:`Fazla b\\xFCy\\xFCk: ${(u=t.origin)!=null?u:"value"}, ${i}${t.maximum.toString()} olmal\\u0131yd\\u0131.`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Fazla k\\xFC\\xE7\\xFCk: ${t.origin}, ${i}${t.minimum.toString()} ${l.unit} sahip olmal\\u0131yd\\u0131.`:`Fazla k\\xFC\\xE7\\xFCk: ${t.origin}, ${i}${t.minimum.toString()} olmal\\u0131yd\\u0131.`}case"invalid_format":{let i=t;return i.format==="starts_with"?`F\\xE2sit metin: "${i.prefix}" ile ba\\u015Flamal\\u0131.`:i.format==="ends_with"?`F\\xE2sit metin: "${i.suffix}" ile bitmeli.`:i.format==="includes"?`F\\xE2sit metin: "${i.includes}" ihtiv\\xE2 etmeli.`:i.format==="regex"?`F\\xE2sit metin: ${i.pattern} nak\\u015F\\u0131na uymal\\u0131.`:`F\\xE2sit ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`F\\xE2sit say\\u0131: ${t.divisor} kat\\u0131 olmal\\u0131yd\\u0131.`;case"unrecognized_keys":return`Tan\\u0131nmayan anahtar ${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`${t.origin} i\\xE7in tan\\u0131nmayan anahtar var.`;case"invalid_union":return"Giren tan\\u0131namad\\u0131.";case"invalid_element":return`${t.origin} i\\xE7in tan\\u0131nmayan k\\u0131ymet var.`;default:return"K\\u0131ymet tan\\u0131namad\\u0131."}}};function kl(){return{localeError:Dp()}}var jp=()=>{let e={string:{unit:"\\u062A\\u0648\\u06A9\\u064A",verb:"\\u0648\\u0644\\u0631\\u064A"},file:{unit:"\\u0628\\u0627\\u06CC\\u067C\\u0633",verb:"\\u0648\\u0644\\u0631\\u064A"},array:{unit:"\\u062A\\u0648\\u06A9\\u064A",verb:"\\u0648\\u0644\\u0631\\u064A"},set:{unit:"\\u062A\\u0648\\u06A9\\u064A",verb:"\\u0648\\u0644\\u0631\\u064A"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0648\\u0631\\u0648\\u062F\\u064A",email:"\\u0628\\u0631\\u06CC\\u069A\\u0646\\u0627\\u0644\\u06CC\\u06A9",url:"\\u06CC\\u0648 \\u0622\\u0631 \\u0627\\u0644",emoji:"\\u0627\\u06CC\\u0645\\u0648\\u062C\\u064A",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"\\u0646\\u06CC\\u067C\\u0647 \\u0627\\u0648 \\u0648\\u062E\\u062A",date:"\\u0646\\u06D0\\u067C\\u0647",time:"\\u0648\\u062E\\u062A",duration:"\\u0645\\u0648\\u062F\\u0647",ipv4:"\\u062F IPv4 \\u067E\\u062A\\u0647",ipv6:"\\u062F IPv6 \\u067E\\u062A\\u0647",cidrv4:"\\u062F IPv4 \\u0633\\u0627\\u062D\\u0647",cidrv6:"\\u062F IPv6 \\u0633\\u0627\\u062D\\u0647",base64:"base64-encoded \\u0645\\u062A\\u0646",base64url:"base64url-encoded \\u0645\\u062A\\u0646",json_string:"JSON \\u0645\\u062A\\u0646",e164:"\\u062F E.164 \\u0634\\u0645\\u06D0\\u0631\\u0647",jwt:"JWT",template_literal:"\\u0648\\u0631\\u0648\\u062F\\u064A"},o={nan:"NaN",number:"\\u0639\\u062F\\u062F",array:"\\u0627\\u0631\\u06D0"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u0646\\u0627\\u0633\\u0645 \\u0648\\u0631\\u0648\\u062F\\u064A: \\u0628\\u0627\\u06CC\\u062F instanceof ${t.expected} \\u0648\\u0627\\u06CC, \\u0645\\u06AB\\u0631 ${p} \\u062A\\u0631\\u0644\\u0627\\u0633\\u0647 \\u0634\\u0648`:`\\u0646\\u0627\\u0633\\u0645 \\u0648\\u0631\\u0648\\u062F\\u064A: \\u0628\\u0627\\u06CC\\u062F ${i} \\u0648\\u0627\\u06CC, \\u0645\\u06AB\\u0631 ${p} \\u062A\\u0631\\u0644\\u0627\\u0633\\u0647 \\u0634\\u0648`}case"invalid_value":return t.values.length===1?`\\u0646\\u0627\\u0633\\u0645 \\u0648\\u0631\\u0648\\u062F\\u064A: \\u0628\\u0627\\u06CC\\u062F ${$(t.values[0])} \\u0648\\u0627\\u06CC`:`\\u0646\\u0627\\u0633\\u0645 \\u0627\\u0646\\u062A\\u062E\\u0627\\u0628: \\u0628\\u0627\\u06CC\\u062F \\u06CC\\u0648 \\u0644\\u0647 ${h(t.values,"|")} \\u0685\\u062E\\u0647 \\u0648\\u0627\\u06CC`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u0689\\u06CC\\u0631 \\u0644\\u0648\\u06CC: ${(m=t.origin)!=null?m:"\\u0627\\u0631\\u0632\\u069A\\u062A"} \\u0628\\u0627\\u06CC\\u062F ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0639\\u0646\\u0635\\u0631\\u0648\\u0646\\u0647"} \\u0648\\u0644\\u0631\\u064A`:`\\u0689\\u06CC\\u0631 \\u0644\\u0648\\u06CC: ${(u=t.origin)!=null?u:"\\u0627\\u0631\\u0632\\u069A\\u062A"} \\u0628\\u0627\\u06CC\\u062F ${i}${t.maximum.toString()} \\u0648\\u064A`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u0689\\u06CC\\u0631 \\u06A9\\u0648\\u0686\\u0646\\u06CC: ${t.origin} \\u0628\\u0627\\u06CC\\u062F ${i}${t.minimum.toString()} ${l.unit} \\u0648\\u0644\\u0631\\u064A`:`\\u0689\\u06CC\\u0631 \\u06A9\\u0648\\u0686\\u0646\\u06CC: ${t.origin} \\u0628\\u0627\\u06CC\\u062F ${i}${t.minimum.toString()} \\u0648\\u064A`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u0646\\u0627\\u0633\\u0645 \\u0645\\u062A\\u0646: \\u0628\\u0627\\u06CC\\u062F \\u062F "${i.prefix}" \\u0633\\u0631\\u0647 \\u067E\\u06CC\\u0644 \\u0634\\u064A`:i.format==="ends_with"?`\\u0646\\u0627\\u0633\\u0645 \\u0645\\u062A\\u0646: \\u0628\\u0627\\u06CC\\u062F \\u062F "${i.suffix}" \\u0633\\u0631\\u0647 \\u067E\\u0627\\u06CC \\u062A\\u0647 \\u0648\\u0631\\u0633\\u064A\\u0696\\u064A`:i.format==="includes"?`\\u0646\\u0627\\u0633\\u0645 \\u0645\\u062A\\u0646: \\u0628\\u0627\\u06CC\\u062F "${i.includes}" \\u0648\\u0644\\u0631\\u064A`:i.format==="regex"?`\\u0646\\u0627\\u0633\\u0645 \\u0645\\u062A\\u0646: \\u0628\\u0627\\u06CC\\u062F \\u062F ${i.pattern} \\u0633\\u0631\\u0647 \\u0645\\u0637\\u0627\\u0628\\u0642\\u062A \\u0648\\u0644\\u0631\\u064A`:`${(d=n[i.format])!=null?d:t.format} \\u0646\\u0627\\u0633\\u0645 \\u062F\\u06CC`}case"not_multiple_of":return`\\u0646\\u0627\\u0633\\u0645 \\u0639\\u062F\\u062F: \\u0628\\u0627\\u06CC\\u062F \\u062F ${t.divisor} \\u0645\\u0636\\u0631\\u0628 \\u0648\\u064A`;case"unrecognized_keys":return`\\u0646\\u0627\\u0633\\u0645 ${t.keys.length>1?"\\u06A9\\u0644\\u06CC\\u0689\\u0648\\u0646\\u0647":"\\u06A9\\u0644\\u06CC\\u0689"}: ${h(t.keys,", ")}`;case"invalid_key":return`\\u0646\\u0627\\u0633\\u0645 \\u06A9\\u0644\\u06CC\\u0689 \\u067E\\u0647 ${t.origin} \\u06A9\\u06D0`;case"invalid_union":return"\\u0646\\u0627\\u0633\\u0645\\u0647 \\u0648\\u0631\\u0648\\u062F\\u064A";case"invalid_element":return`\\u0646\\u0627\\u0633\\u0645 \\u0639\\u0646\\u0635\\u0631 \\u067E\\u0647 ${t.origin} \\u06A9\\u06D0`;default:return"\\u0646\\u0627\\u0633\\u0645\\u0647 \\u0648\\u0631\\u0648\\u062F\\u064A"}}};function Il(){return{localeError:jp()}}var Op=()=>{let e={string:{unit:"znak\\xF3w",verb:"mie\\u0107"},file:{unit:"bajt\\xF3w",verb:"mie\\u0107"},array:{unit:"element\\xF3w",verb:"mie\\u0107"},set:{unit:"element\\xF3w",verb:"mie\\u0107"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"wyra\\u017Cenie",email:"adres email",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"data i godzina w formacie ISO",date:"data w formacie ISO",time:"godzina w formacie ISO",duration:"czas trwania ISO",ipv4:"adres IPv4",ipv6:"adres IPv6",cidrv4:"zakres IPv4",cidrv6:"zakres IPv6",base64:"ci\\u0105g znak\\xF3w zakodowany w formacie base64",base64url:"ci\\u0105g znak\\xF3w zakodowany w formacie base64url",json_string:"ci\\u0105g znak\\xF3w w formacie JSON",e164:"liczba E.164",jwt:"JWT",template_literal:"wej\\u015Bcie"},o={nan:"NaN",number:"liczba",array:"tablica"};return t=>{var a,c,m,s,u,d,i,l,p;switch(t.code){case"invalid_type":{let v=(a=o[t.expected])!=null?a:t.expected,y=b(t.input),S=(c=o[y])!=null?c:y;return/^[A-Z]/.test(t.expected)?`Nieprawid\\u0142owe dane wej\\u015Bciowe: oczekiwano instanceof ${t.expected}, otrzymano ${S}`:`Nieprawid\\u0142owe dane wej\\u015Bciowe: oczekiwano ${v}, otrzymano ${S}`}case"invalid_value":return t.values.length===1?`Nieprawid\\u0142owe dane wej\\u015Bciowe: oczekiwano ${$(t.values[0])}`:`Nieprawid\\u0142owa opcja: oczekiwano jednej z warto\\u015Bci ${h(t.values,"|")}`;case"too_big":{let v=t.inclusive?"<=":"<",y=r(t.origin);return y?`Za du\\u017Ca warto\\u015B\\u0107: oczekiwano, \\u017Ce ${(m=t.origin)!=null?m:"warto\\u015B\\u0107"} b\\u0119dzie mie\\u0107 ${v}${t.maximum.toString()} ${(s=y.unit)!=null?s:"element\\xF3w"}`:`Zbyt du\\u017C(y/a/e): oczekiwano, \\u017Ce ${(u=t.origin)!=null?u:"warto\\u015B\\u0107"} b\\u0119dzie wynosi\\u0107 ${v}${t.maximum.toString()}`}case"too_small":{let v=t.inclusive?">=":">",y=r(t.origin);return y?`Za ma\\u0142a warto\\u015B\\u0107: oczekiwano, \\u017Ce ${(d=t.origin)!=null?d:"warto\\u015B\\u0107"} b\\u0119dzie mie\\u0107 ${v}${t.minimum.toString()} ${(i=y.unit)!=null?i:"element\\xF3w"}`:`Zbyt ma\\u0142(y/a/e): oczekiwano, \\u017Ce ${(l=t.origin)!=null?l:"warto\\u015B\\u0107"} b\\u0119dzie wynosi\\u0107 ${v}${t.minimum.toString()}`}case"invalid_format":{let v=t;return v.format==="starts_with"?`Nieprawid\\u0142owy ci\\u0105g znak\\xF3w: musi zaczyna\\u0107 si\\u0119 od "${v.prefix}"`:v.format==="ends_with"?`Nieprawid\\u0142owy ci\\u0105g znak\\xF3w: musi ko\\u0144czy\\u0107 si\\u0119 na "${v.suffix}"`:v.format==="includes"?`Nieprawid\\u0142owy ci\\u0105g znak\\xF3w: musi zawiera\\u0107 "${v.includes}"`:v.format==="regex"?`Nieprawid\\u0142owy ci\\u0105g znak\\xF3w: musi odpowiada\\u0107 wzorcowi ${v.pattern}`:`Nieprawid\\u0142ow(y/a/e) ${(p=n[v.format])!=null?p:t.format}`}case"not_multiple_of":return`Nieprawid\\u0142owa liczba: musi by\\u0107 wielokrotno\\u015Bci\\u0105 ${t.divisor}`;case"unrecognized_keys":return`Nierozpoznane klucze${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`Nieprawid\\u0142owy klucz w ${t.origin}`;case"invalid_union":return"Nieprawid\\u0142owe dane wej\\u015Bciowe";case"invalid_element":return`Nieprawid\\u0142owa warto\\u015B\\u0107 w ${t.origin}`;default:return"Nieprawid\\u0142owe dane wej\\u015Bciowe"}}};function zl(){return{localeError:Op()}}var Up=()=>{let e={string:{unit:"caracteres",verb:"ter"},file:{unit:"bytes",verb:"ter"},array:{unit:"itens",verb:"ter"},set:{unit:"itens",verb:"ter"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"padr\\xE3o",email:"endere\\xE7o de e-mail",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"data e hora ISO",date:"data ISO",time:"hora ISO",duration:"dura\\xE7\\xE3o ISO",ipv4:"endere\\xE7o IPv4",ipv6:"endere\\xE7o IPv6",cidrv4:"faixa de IPv4",cidrv6:"faixa de IPv6",base64:"texto codificado em base64",base64url:"URL codificada em base64",json_string:"texto JSON",e164:"n\\xFAmero E.164",jwt:"JWT",template_literal:"entrada"},o={nan:"NaN",number:"n\\xFAmero",null:"nulo"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Tipo inv\\xE1lido: esperado instanceof ${t.expected}, recebido ${p}`:`Tipo inv\\xE1lido: esperado ${i}, recebido ${p}`}case"invalid_value":return t.values.length===1?`Entrada inv\\xE1lida: esperado ${$(t.values[0])}`:`Op\\xE7\\xE3o inv\\xE1lida: esperada uma das ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Muito grande: esperado que ${(m=t.origin)!=null?m:"valor"} tivesse ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elementos"}`:`Muito grande: esperado que ${(u=t.origin)!=null?u:"valor"} fosse ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Muito pequeno: esperado que ${t.origin} tivesse ${i}${t.minimum.toString()} ${l.unit}`:`Muito pequeno: esperado que ${t.origin} fosse ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Texto inv\\xE1lido: deve come\\xE7ar com "${i.prefix}"`:i.format==="ends_with"?`Texto inv\\xE1lido: deve terminar com "${i.suffix}"`:i.format==="includes"?`Texto inv\\xE1lido: deve incluir "${i.includes}"`:i.format==="regex"?`Texto inv\\xE1lido: deve corresponder ao padr\\xE3o ${i.pattern}`:`${(d=n[i.format])!=null?d:t.format} inv\\xE1lido`}case"not_multiple_of":return`N\\xFAmero inv\\xE1lido: deve ser m\\xFAltiplo de ${t.divisor}`;case"unrecognized_keys":return`Chave${t.keys.length>1?"s":""} desconhecida${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`Chave inv\\xE1lida em ${t.origin}`;case"invalid_union":return"Entrada inv\\xE1lida";case"invalid_element":return`Valor inv\\xE1lido em ${t.origin}`;default:return"Campo inv\\xE1lido"}}};function Tl(){return{localeError:Up()}}function wl(e,r,n,o){let t=Math.abs(e),a=t%10,c=t%100;return c>=11&&c<=19?o:a===1?r:a>=2&&a<=4?n:o}var Np=()=>{let e={string:{unit:{one:"\\u0441\\u0438\\u043C\\u0432\\u043E\\u043B",few:"\\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u0430",many:"\\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u043E\\u0432"},verb:"\\u0438\\u043C\\u0435\\u0442\\u044C"},file:{unit:{one:"\\u0431\\u0430\\u0439\\u0442",few:"\\u0431\\u0430\\u0439\\u0442\\u0430",many:"\\u0431\\u0430\\u0439\\u0442"},verb:"\\u0438\\u043C\\u0435\\u0442\\u044C"},array:{unit:{one:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442",few:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430",many:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u043E\\u0432"},verb:"\\u0438\\u043C\\u0435\\u0442\\u044C"},set:{unit:{one:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442",few:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430",many:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u043E\\u0432"},verb:"\\u0438\\u043C\\u0435\\u0442\\u044C"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0432\\u0432\\u043E\\u0434",email:"email \\u0430\\u0434\\u0440\\u0435\\u0441",url:"URL",emoji:"\\u044D\\u043C\\u043E\\u0434\\u0437\\u0438",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO \\u0434\\u0430\\u0442\\u0430 \\u0438 \\u0432\\u0440\\u0435\\u043C\\u044F",date:"ISO \\u0434\\u0430\\u0442\\u0430",time:"ISO \\u0432\\u0440\\u0435\\u043C\\u044F",duration:"ISO \\u0434\\u043B\\u0438\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u044C",ipv4:"IPv4 \\u0430\\u0434\\u0440\\u0435\\u0441",ipv6:"IPv6 \\u0430\\u0434\\u0440\\u0435\\u0441",cidrv4:"IPv4 \\u0434\\u0438\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D",cidrv6:"IPv6 \\u0434\\u0438\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D",base64:"\\u0441\\u0442\\u0440\\u043E\\u043A\\u0430 \\u0432 \\u0444\\u043E\\u0440\\u043C\\u0430\\u0442\\u0435 base64",base64url:"\\u0441\\u0442\\u0440\\u043E\\u043A\\u0430 \\u0432 \\u0444\\u043E\\u0440\\u043C\\u0430\\u0442\\u0435 base64url",json_string:"JSON \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430",e164:"\\u043D\\u043E\\u043C\\u0435\\u0440 E.164",jwt:"JWT",template_literal:"\\u0432\\u0432\\u043E\\u0434"},o={nan:"NaN",number:"\\u0447\\u0438\\u0441\\u043B\\u043E",array:"\\u043C\\u0430\\u0441\\u0441\\u0438\\u0432"};return t=>{var a,c,m,s,u;switch(t.code){case"invalid_type":{let d=(a=o[t.expected])!=null?a:t.expected,i=b(t.input),l=(c=o[i])!=null?c:i;return/^[A-Z]/.test(t.expected)?`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0439 \\u0432\\u0432\\u043E\\u0434: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C instanceof ${t.expected}, \\u043F\\u043E\\u043B\\u0443\\u0447\\u0435\\u043D\\u043E ${l}`:`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0439 \\u0432\\u0432\\u043E\\u0434: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C ${d}, \\u043F\\u043E\\u043B\\u0443\\u0447\\u0435\\u043D\\u043E ${l}`}case"invalid_value":return t.values.length===1?`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0439 \\u0432\\u0432\\u043E\\u0434: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C ${$(t.values[0])}`:`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0439 \\u0432\\u0430\\u0440\\u0438\\u0430\\u043D\\u0442: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C \\u043E\\u0434\\u043D\\u043E \\u0438\\u0437 ${h(t.values,"|")}`;case"too_big":{let d=t.inclusive?"<=":"<",i=r(t.origin);if(i){let l=Number(t.maximum),p=wl(l,i.unit.one,i.unit.few,i.unit.many);return`\\u0421\\u043B\\u0438\\u0448\\u043A\\u043E\\u043C \\u0431\\u043E\\u043B\\u044C\\u0448\\u043E\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C, \\u0447\\u0442\\u043E ${(m=t.origin)!=null?m:"\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435"} \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0438\\u043C\\u0435\\u0442\\u044C ${d}${t.maximum.toString()} ${p}`}return`\\u0421\\u043B\\u0438\\u0448\\u043A\\u043E\\u043C \\u0431\\u043E\\u043B\\u044C\\u0448\\u043E\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C, \\u0447\\u0442\\u043E ${(s=t.origin)!=null?s:"\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435"} \\u0431\\u0443\\u0434\\u0435\\u0442 ${d}${t.maximum.toString()}`}case"too_small":{let d=t.inclusive?">=":">",i=r(t.origin);if(i){let l=Number(t.minimum),p=wl(l,i.unit.one,i.unit.few,i.unit.many);return`\\u0421\\u043B\\u0438\\u0448\\u043A\\u043E\\u043C \\u043C\\u0430\\u043B\\u0435\\u043D\\u044C\\u043A\\u043E\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C, \\u0447\\u0442\\u043E ${t.origin} \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0438\\u043C\\u0435\\u0442\\u044C ${d}${t.minimum.toString()} ${p}`}return`\\u0421\\u043B\\u0438\\u0448\\u043A\\u043E\\u043C \\u043C\\u0430\\u043B\\u0435\\u043D\\u044C\\u043A\\u043E\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C, \\u0447\\u0442\\u043E ${t.origin} \\u0431\\u0443\\u0434\\u0435\\u0442 ${d}${t.minimum.toString()}`}case"invalid_format":{let d=t;return d.format==="starts_with"?`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u0430\\u044F \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430: \\u0434\\u043E\\u043B\\u0436\\u043D\\u0430 \\u043D\\u0430\\u0447\\u0438\\u043D\\u0430\\u0442\\u044C\\u0441\\u044F \\u0441 "${d.prefix}"`:d.format==="ends_with"?`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u0430\\u044F \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430: \\u0434\\u043E\\u043B\\u0436\\u043D\\u0430 \\u0437\\u0430\\u043A\\u0430\\u043D\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430 "${d.suffix}"`:d.format==="includes"?`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u0430\\u044F \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430: \\u0434\\u043E\\u043B\\u0436\\u043D\\u0430 \\u0441\\u043E\\u0434\\u0435\\u0440\\u0436\\u0430\\u0442\\u044C "${d.includes}"`:d.format==="regex"?`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u0430\\u044F \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430: \\u0434\\u043E\\u043B\\u0436\\u043D\\u0430 \\u0441\\u043E\\u043E\\u0442\\u0432\\u0435\\u0442\\u0441\\u0442\\u0432\\u043E\\u0432\\u0430\\u0442\\u044C \\u0448\\u0430\\u0431\\u043B\\u043E\\u043D\\u0443 ${d.pattern}`:`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0439 ${(u=n[d.format])!=null?u:t.format}`}case"not_multiple_of":return`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u043E\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E: \\u0434\\u043E\\u043B\\u0436\\u043D\\u043E \\u0431\\u044B\\u0442\\u044C \\u043A\\u0440\\u0430\\u0442\\u043D\\u044B\\u043C ${t.divisor}`;case"unrecognized_keys":return`\\u041D\\u0435\\u0440\\u0430\\u0441\\u043F\\u043E\\u0437\\u043D\\u0430\\u043D\\u043D${t.keys.length>1?"\\u044B\\u0435":"\\u044B\\u0439"} \\u043A\\u043B\\u044E\\u0447${t.keys.length>1?"\\u0438":""}: ${h(t.keys,", ")}`;case"invalid_key":return`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0439 \\u043A\\u043B\\u044E\\u0447 \\u0432 ${t.origin}`;case"invalid_union":return"\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435";case"invalid_element":return`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u043E\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 \\u0432 ${t.origin}`;default:return"\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435"}}};function Pl(){return{localeError:Np()}}var Ep=()=>{let e={string:{unit:"znakov",verb:"imeti"},file:{unit:"bajtov",verb:"imeti"},array:{unit:"elementov",verb:"imeti"},set:{unit:"elementov",verb:"imeti"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"vnos",email:"e-po\\u0161tni naslov",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO datum in \\u010Das",date:"ISO datum",time:"ISO \\u010Das",duration:"ISO trajanje",ipv4:"IPv4 naslov",ipv6:"IPv6 naslov",cidrv4:"obseg IPv4",cidrv6:"obseg IPv6",base64:"base64 kodiran niz",base64url:"base64url kodiran niz",json_string:"JSON niz",e164:"E.164 \\u0161tevilka",jwt:"JWT",template_literal:"vnos"},o={nan:"NaN",number:"\\u0161tevilo",array:"tabela"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Neveljaven vnos: pri\\u010Dakovano instanceof ${t.expected}, prejeto ${p}`:`Neveljaven vnos: pri\\u010Dakovano ${i}, prejeto ${p}`}case"invalid_value":return t.values.length===1?`Neveljaven vnos: pri\\u010Dakovano ${$(t.values[0])}`:`Neveljavna mo\\u017Enost: pri\\u010Dakovano eno izmed ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Preveliko: pri\\u010Dakovano, da bo ${(m=t.origin)!=null?m:"vrednost"} imelo ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elementov"}`:`Preveliko: pri\\u010Dakovano, da bo ${(u=t.origin)!=null?u:"vrednost"} ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Premajhno: pri\\u010Dakovano, da bo ${t.origin} imelo ${i}${t.minimum.toString()} ${l.unit}`:`Premajhno: pri\\u010Dakovano, da bo ${t.origin} ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Neveljaven niz: mora se za\\u010Deti z "${i.prefix}"`:i.format==="ends_with"?`Neveljaven niz: mora se kon\\u010Dati z "${i.suffix}"`:i.format==="includes"?`Neveljaven niz: mora vsebovati "${i.includes}"`:i.format==="regex"?`Neveljaven niz: mora ustrezati vzorcu ${i.pattern}`:`Neveljaven ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Neveljavno \\u0161tevilo: mora biti ve\\u010Dkratnik ${t.divisor}`;case"unrecognized_keys":return`Neprepoznan${t.keys.length>1?"i klju\\u010Di":" klju\\u010D"}: ${h(t.keys,", ")}`;case"invalid_key":return`Neveljaven klju\\u010D v ${t.origin}`;case"invalid_union":return"Neveljaven vnos";case"invalid_element":return`Neveljavna vrednost v ${t.origin}`;default:return"Neveljaven vnos"}}};function Dl(){return{localeError:Ep()}}var Zp=()=>{let e={string:{unit:"tecken",verb:"att ha"},file:{unit:"bytes",verb:"att ha"},array:{unit:"objekt",verb:"att inneh\\xE5lla"},set:{unit:"objekt",verb:"att inneh\\xE5lla"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"regulj\\xE4rt uttryck",email:"e-postadress",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO-datum och tid",date:"ISO-datum",time:"ISO-tid",duration:"ISO-varaktighet",ipv4:"IPv4-intervall",ipv6:"IPv6-intervall",cidrv4:"IPv4-spektrum",cidrv6:"IPv6-spektrum",base64:"base64-kodad str\\xE4ng",base64url:"base64url-kodad str\\xE4ng",json_string:"JSON-str\\xE4ng",e164:"E.164-nummer",jwt:"JWT",template_literal:"mall-literal"},o={nan:"NaN",number:"antal",array:"lista"};return t=>{var a,c,m,s,u,d,i,l,p,v;switch(t.code){case"invalid_type":{let y=(a=o[t.expected])!=null?a:t.expected,S=b(t.input),w=(c=o[S])!=null?c:S;return/^[A-Z]/.test(t.expected)?`Ogiltig inmatning: f\\xF6rv\\xE4ntat instanceof ${t.expected}, fick ${w}`:`Ogiltig inmatning: f\\xF6rv\\xE4ntat ${y}, fick ${w}`}case"invalid_value":return t.values.length===1?`Ogiltig inmatning: f\\xF6rv\\xE4ntat ${$(t.values[0])}`:`Ogiltigt val: f\\xF6rv\\xE4ntade en av ${h(t.values,"|")}`;case"too_big":{let y=t.inclusive?"<=":"<",S=r(t.origin);return S?`F\\xF6r stor(t): f\\xF6rv\\xE4ntade ${(m=t.origin)!=null?m:"v\\xE4rdet"} att ha ${y}${t.maximum.toString()} ${(s=S.unit)!=null?s:"element"}`:`F\\xF6r stor(t): f\\xF6rv\\xE4ntat ${(u=t.origin)!=null?u:"v\\xE4rdet"} att ha ${y}${t.maximum.toString()}`}case"too_small":{let y=t.inclusive?">=":">",S=r(t.origin);return S?`F\\xF6r lite(t): f\\xF6rv\\xE4ntade ${(d=t.origin)!=null?d:"v\\xE4rdet"} att ha ${y}${t.minimum.toString()} ${S.unit}`:`F\\xF6r lite(t): f\\xF6rv\\xE4ntade ${(i=t.origin)!=null?i:"v\\xE4rdet"} att ha ${y}${t.minimum.toString()}`}case"invalid_format":{let y=t;return y.format==="starts_with"?`Ogiltig str\\xE4ng: m\\xE5ste b\\xF6rja med "${y.prefix}"`:y.format==="ends_with"?`Ogiltig str\\xE4ng: m\\xE5ste sluta med "${y.suffix}"`:y.format==="includes"?`Ogiltig str\\xE4ng: m\\xE5ste inneh\\xE5lla "${y.includes}"`:y.format==="regex"?`Ogiltig str\\xE4ng: m\\xE5ste matcha m\\xF6nstret "${y.pattern}"`:`Ogiltig(t) ${(l=n[y.format])!=null?l:t.format}`}case"not_multiple_of":return`Ogiltigt tal: m\\xE5ste vara en multipel av ${t.divisor}`;case"unrecognized_keys":return`${t.keys.length>1?"Ok\\xE4nda nycklar":"Ok\\xE4nd nyckel"}: ${h(t.keys,", ")}`;case"invalid_key":return`Ogiltig nyckel i ${(p=t.origin)!=null?p:"v\\xE4rdet"}`;case"invalid_union":return"Ogiltig input";case"invalid_element":return`Ogiltigt v\\xE4rde i ${(v=t.origin)!=null?v:"v\\xE4rdet"}`;default:return"Ogiltig input"}}};function jl(){return{localeError:Zp()}}var Lp=()=>{let e={string:{unit:"\\u0B8E\\u0BB4\\u0BC1\\u0BA4\\u0BCD\\u0BA4\\u0BC1\\u0B95\\u0BCD\\u0B95\\u0BB3\\u0BCD",verb:"\\u0B95\\u0BCA\\u0BA3\\u0BCD\\u0B9F\\u0BBF\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD"},file:{unit:"\\u0BAA\\u0BC8\\u0B9F\\u0BCD\\u0B9F\\u0BC1\\u0B95\\u0BB3\\u0BCD",verb:"\\u0B95\\u0BCA\\u0BA3\\u0BCD\\u0B9F\\u0BBF\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD"},array:{unit:"\\u0B89\\u0BB1\\u0BC1\\u0BAA\\u0BCD\\u0BAA\\u0BC1\\u0B95\\u0BB3\\u0BCD",verb:"\\u0B95\\u0BCA\\u0BA3\\u0BCD\\u0B9F\\u0BBF\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD"},set:{unit:"\\u0B89\\u0BB1\\u0BC1\\u0BAA\\u0BCD\\u0BAA\\u0BC1\\u0B95\\u0BB3\\u0BCD",verb:"\\u0B95\\u0BCA\\u0BA3\\u0BCD\\u0B9F\\u0BBF\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0BC0\\u0B9F\\u0BC1",email:"\\u0BAE\\u0BBF\\u0BA9\\u0BCD\\u0BA9\\u0B9E\\u0BCD\\u0B9A\\u0BB2\\u0BCD \\u0BAE\\u0BC1\\u0B95\\u0BB5\\u0BB0\\u0BBF",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO \\u0BA4\\u0BC7\\u0BA4\\u0BBF \\u0BA8\\u0BC7\\u0BB0\\u0BAE\\u0BCD",date:"ISO \\u0BA4\\u0BC7\\u0BA4\\u0BBF",time:"ISO \\u0BA8\\u0BC7\\u0BB0\\u0BAE\\u0BCD",duration:"ISO \\u0B95\\u0BBE\\u0BB2 \\u0B85\\u0BB3\\u0BB5\\u0BC1",ipv4:"IPv4 \\u0BAE\\u0BC1\\u0B95\\u0BB5\\u0BB0\\u0BBF",ipv6:"IPv6 \\u0BAE\\u0BC1\\u0B95\\u0BB5\\u0BB0\\u0BBF",cidrv4:"IPv4 \\u0BB5\\u0BB0\\u0BAE\\u0BCD\\u0BAA\\u0BC1",cidrv6:"IPv6 \\u0BB5\\u0BB0\\u0BAE\\u0BCD\\u0BAA\\u0BC1",base64:"base64-encoded \\u0B9A\\u0BB0\\u0BAE\\u0BCD",base64url:"base64url-encoded \\u0B9A\\u0BB0\\u0BAE\\u0BCD",json_string:"JSON \\u0B9A\\u0BB0\\u0BAE\\u0BCD",e164:"E.164 \\u0B8E\\u0BA3\\u0BCD",jwt:"JWT",template_literal:"input"},o={nan:"NaN",number:"\\u0B8E\\u0BA3\\u0BCD",array:"\\u0B85\\u0BA3\\u0BBF",null:"\\u0BB5\\u0BC6\\u0BB1\\u0BC1\\u0BAE\\u0BC8"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0BC0\\u0B9F\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 instanceof ${t.expected}, \\u0BAA\\u0BC6\\u0BB1\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${p}`:`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0BC0\\u0B9F\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${i}, \\u0BAA\\u0BC6\\u0BB1\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${p}`}case"invalid_value":return t.values.length===1?`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0BC0\\u0B9F\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${$(t.values[0])}`:`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0BB5\\u0BBF\\u0BB0\\u0BC1\\u0BAA\\u0BCD\\u0BAA\\u0BAE\\u0BCD: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${h(t.values,"|")} \\u0B87\\u0BB2\\u0BCD \\u0B92\\u0BA9\\u0BCD\\u0BB1\\u0BC1`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u0BAE\\u0BBF\\u0B95 \\u0BAA\\u0BC6\\u0BB0\\u0BBF\\u0BAF\\u0BA4\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${(m=t.origin)!=null?m:"\\u0BAE\\u0BA4\\u0BBF\\u0BAA\\u0BCD\\u0BAA\\u0BC1"} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0B89\\u0BB1\\u0BC1\\u0BAA\\u0BCD\\u0BAA\\u0BC1\\u0B95\\u0BB3\\u0BCD"} \\u0B86\\u0B95 \\u0B87\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`:`\\u0BAE\\u0BBF\\u0B95 \\u0BAA\\u0BC6\\u0BB0\\u0BBF\\u0BAF\\u0BA4\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${(u=t.origin)!=null?u:"\\u0BAE\\u0BA4\\u0BBF\\u0BAA\\u0BCD\\u0BAA\\u0BC1"} ${i}${t.maximum.toString()} \\u0B86\\u0B95 \\u0B87\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u0BAE\\u0BBF\\u0B95\\u0B9A\\u0BCD \\u0B9A\\u0BBF\\u0BB1\\u0BBF\\u0BAF\\u0BA4\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${t.origin} ${i}${t.minimum.toString()} ${l.unit} \\u0B86\\u0B95 \\u0B87\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`:`\\u0BAE\\u0BBF\\u0B95\\u0B9A\\u0BCD \\u0B9A\\u0BBF\\u0BB1\\u0BBF\\u0BAF\\u0BA4\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${t.origin} ${i}${t.minimum.toString()} \\u0B86\\u0B95 \\u0B87\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B9A\\u0BB0\\u0BAE\\u0BCD: "${i.prefix}" \\u0B87\\u0BB2\\u0BCD \\u0BA4\\u0BCA\\u0B9F\\u0B99\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`:i.format==="ends_with"?`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B9A\\u0BB0\\u0BAE\\u0BCD: "${i.suffix}" \\u0B87\\u0BB2\\u0BCD \\u0BAE\\u0BC1\\u0B9F\\u0BBF\\u0BB5\\u0B9F\\u0BC8\\u0BAF \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`:i.format==="includes"?`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B9A\\u0BB0\\u0BAE\\u0BCD: "${i.includes}" \\u0B90 \\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0B9F\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`:i.format==="regex"?`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B9A\\u0BB0\\u0BAE\\u0BCD: ${i.pattern} \\u0BAE\\u0BC1\\u0BB1\\u0BC8\\u0BAA\\u0BBE\\u0B9F\\u0BCD\\u0B9F\\u0BC1\\u0B9F\\u0BA9\\u0BCD \\u0BAA\\u0BCA\\u0BB0\\u0BC1\\u0BA8\\u0BCD\\u0BA4 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`:`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B8E\\u0BA3\\u0BCD: ${t.divisor} \\u0B87\\u0BA9\\u0BCD \\u0BAA\\u0BB2\\u0BAE\\u0BBE\\u0B95 \\u0B87\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`;case"unrecognized_keys":return`\\u0B85\\u0B9F\\u0BC8\\u0BAF\\u0BBE\\u0BB3\\u0BAE\\u0BCD \\u0BA4\\u0BC6\\u0BB0\\u0BBF\\u0BAF\\u0BBE\\u0BA4 \\u0BB5\\u0BBF\\u0B9A\\u0BC8${t.keys.length>1?"\\u0B95\\u0BB3\\u0BCD":""}: ${h(t.keys,", ")}`;case"invalid_key":return`${t.origin} \\u0B87\\u0BB2\\u0BCD \\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0BB5\\u0BBF\\u0B9A\\u0BC8`;case"invalid_union":return"\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0BC0\\u0B9F\\u0BC1";case"invalid_element":return`${t.origin} \\u0B87\\u0BB2\\u0BCD \\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0BAE\\u0BA4\\u0BBF\\u0BAA\\u0BCD\\u0BAA\\u0BC1`;default:return"\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0BC0\\u0B9F\\u0BC1"}}};function Ol(){return{localeError:Lp()}}var Cp=()=>{let e={string:{unit:"\\u0E15\\u0E31\\u0E27\\u0E2D\\u0E31\\u0E01\\u0E29\\u0E23",verb:"\\u0E04\\u0E27\\u0E23\\u0E21\\u0E35"},file:{unit:"\\u0E44\\u0E1A\\u0E15\\u0E4C",verb:"\\u0E04\\u0E27\\u0E23\\u0E21\\u0E35"},array:{unit:"\\u0E23\\u0E32\\u0E22\\u0E01\\u0E32\\u0E23",verb:"\\u0E04\\u0E27\\u0E23\\u0E21\\u0E35"},set:{unit:"\\u0E23\\u0E32\\u0E22\\u0E01\\u0E32\\u0E23",verb:"\\u0E04\\u0E27\\u0E23\\u0E21\\u0E35"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E17\\u0E35\\u0E48\\u0E1B\\u0E49\\u0E2D\\u0E19",email:"\\u0E17\\u0E35\\u0E48\\u0E2D\\u0E22\\u0E39\\u0E48\\u0E2D\\u0E35\\u0E40\\u0E21\\u0E25",url:"URL",emoji:"\\u0E2D\\u0E34\\u0E42\\u0E21\\u0E08\\u0E34",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"\\u0E27\\u0E31\\u0E19\\u0E17\\u0E35\\u0E48\\u0E40\\u0E27\\u0E25\\u0E32\\u0E41\\u0E1A\\u0E1A ISO",date:"\\u0E27\\u0E31\\u0E19\\u0E17\\u0E35\\u0E48\\u0E41\\u0E1A\\u0E1A ISO",time:"\\u0E40\\u0E27\\u0E25\\u0E32\\u0E41\\u0E1A\\u0E1A ISO",duration:"\\u0E0A\\u0E48\\u0E27\\u0E07\\u0E40\\u0E27\\u0E25\\u0E32\\u0E41\\u0E1A\\u0E1A ISO",ipv4:"\\u0E17\\u0E35\\u0E48\\u0E2D\\u0E22\\u0E39\\u0E48 IPv4",ipv6:"\\u0E17\\u0E35\\u0E48\\u0E2D\\u0E22\\u0E39\\u0E48 IPv6",cidrv4:"\\u0E0A\\u0E48\\u0E27\\u0E07 IP \\u0E41\\u0E1A\\u0E1A IPv4",cidrv6:"\\u0E0A\\u0E48\\u0E27\\u0E07 IP \\u0E41\\u0E1A\\u0E1A IPv6",base64:"\\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E41\\u0E1A\\u0E1A Base64",base64url:"\\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E41\\u0E1A\\u0E1A Base64 \\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A URL",json_string:"\\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E41\\u0E1A\\u0E1A JSON",e164:"\\u0E40\\u0E1A\\u0E2D\\u0E23\\u0E4C\\u0E42\\u0E17\\u0E23\\u0E28\\u0E31\\u0E1E\\u0E17\\u0E4C\\u0E23\\u0E30\\u0E2B\\u0E27\\u0E48\\u0E32\\u0E07\\u0E1B\\u0E23\\u0E30\\u0E40\\u0E17\\u0E28 (E.164)",jwt:"\\u0E42\\u0E17\\u0E40\\u0E04\\u0E19 JWT",template_literal:"\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E17\\u0E35\\u0E48\\u0E1B\\u0E49\\u0E2D\\u0E19"},o={nan:"NaN",number:"\\u0E15\\u0E31\\u0E27\\u0E40\\u0E25\\u0E02",array:"\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C (Array)",null:"\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E04\\u0E48\\u0E32 (null)"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u0E1B\\u0E23\\u0E30\\u0E40\\u0E20\\u0E17\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E04\\u0E27\\u0E23\\u0E40\\u0E1B\\u0E47\\u0E19 instanceof ${t.expected} \\u0E41\\u0E15\\u0E48\\u0E44\\u0E14\\u0E49\\u0E23\\u0E31\\u0E1A ${p}`:`\\u0E1B\\u0E23\\u0E30\\u0E40\\u0E20\\u0E17\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E04\\u0E27\\u0E23\\u0E40\\u0E1B\\u0E47\\u0E19 ${i} \\u0E41\\u0E15\\u0E48\\u0E44\\u0E14\\u0E49\\u0E23\\u0E31\\u0E1A ${p}`}case"invalid_value":return t.values.length===1?`\\u0E04\\u0E48\\u0E32\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E04\\u0E27\\u0E23\\u0E40\\u0E1B\\u0E47\\u0E19 ${$(t.values[0])}`:`\\u0E15\\u0E31\\u0E27\\u0E40\\u0E25\\u0E37\\u0E2D\\u0E01\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E04\\u0E27\\u0E23\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E43\\u0E19 ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"\\u0E44\\u0E21\\u0E48\\u0E40\\u0E01\\u0E34\\u0E19":"\\u0E19\\u0E49\\u0E2D\\u0E22\\u0E01\\u0E27\\u0E48\\u0E32",l=r(t.origin);return l?`\\u0E40\\u0E01\\u0E34\\u0E19\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14: ${(m=t.origin)!=null?m:"\\u0E04\\u0E48\\u0E32"} \\u0E04\\u0E27\\u0E23\\u0E21\\u0E35${i} ${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0E23\\u0E32\\u0E22\\u0E01\\u0E32\\u0E23"}`:`\\u0E40\\u0E01\\u0E34\\u0E19\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14: ${(u=t.origin)!=null?u:"\\u0E04\\u0E48\\u0E32"} \\u0E04\\u0E27\\u0E23\\u0E21\\u0E35${i} ${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?"\\u0E2D\\u0E22\\u0E48\\u0E32\\u0E07\\u0E19\\u0E49\\u0E2D\\u0E22":"\\u0E21\\u0E32\\u0E01\\u0E01\\u0E27\\u0E48\\u0E32",l=r(t.origin);return l?`\\u0E19\\u0E49\\u0E2D\\u0E22\\u0E01\\u0E27\\u0E48\\u0E32\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14: ${t.origin} \\u0E04\\u0E27\\u0E23\\u0E21\\u0E35${i} ${t.minimum.toString()} ${l.unit}`:`\\u0E19\\u0E49\\u0E2D\\u0E22\\u0E01\\u0E27\\u0E48\\u0E32\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14: ${t.origin} \\u0E04\\u0E27\\u0E23\\u0E21\\u0E35${i} ${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E02\\u0E36\\u0E49\\u0E19\\u0E15\\u0E49\\u0E19\\u0E14\\u0E49\\u0E27\\u0E22 "${i.prefix}"`:i.format==="ends_with"?`\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E25\\u0E07\\u0E17\\u0E49\\u0E32\\u0E22\\u0E14\\u0E49\\u0E27\\u0E22 "${i.suffix}"`:i.format==="includes"?`\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35 "${i.includes}" \\u0E2D\\u0E22\\u0E39\\u0E48\\u0E43\\u0E19\\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21`:i.format==="regex"?`\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E07\\u0E01\\u0E31\\u0E1A\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14 ${i.pattern}`:`\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u0E15\\u0E31\\u0E27\\u0E40\\u0E25\\u0E02\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E15\\u0E49\\u0E2D\\u0E07\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E33\\u0E19\\u0E27\\u0E19\\u0E17\\u0E35\\u0E48\\u0E2B\\u0E32\\u0E23\\u0E14\\u0E49\\u0E27\\u0E22 ${t.divisor} \\u0E44\\u0E14\\u0E49\\u0E25\\u0E07\\u0E15\\u0E31\\u0E27`;case"unrecognized_keys":return`\\u0E1E\\u0E1A\\u0E04\\u0E35\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E44\\u0E21\\u0E48\\u0E23\\u0E39\\u0E49\\u0E08\\u0E31\\u0E01: ${h(t.keys,", ")}`;case"invalid_key":return`\\u0E04\\u0E35\\u0E22\\u0E4C\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19 ${t.origin}`;case"invalid_union":return"\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E44\\u0E21\\u0E48\\u0E15\\u0E23\\u0E07\\u0E01\\u0E31\\u0E1A\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E22\\u0E39\\u0E40\\u0E19\\u0E35\\u0E22\\u0E19\\u0E17\\u0E35\\u0E48\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14\\u0E44\\u0E27\\u0E49";case"invalid_element":return`\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19 ${t.origin}`;default:return"\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07"}}};function Ul(){return{localeError:Cp()}}var Rp=()=>{let e={string:{unit:"karakter",verb:"olmal\\u0131"},file:{unit:"bayt",verb:"olmal\\u0131"},array:{unit:"\\xF6\\u011Fe",verb:"olmal\\u0131"},set:{unit:"\\xF6\\u011Fe",verb:"olmal\\u0131"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"girdi",email:"e-posta adresi",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO tarih ve saat",date:"ISO tarih",time:"ISO saat",duration:"ISO s\\xFCre",ipv4:"IPv4 adresi",ipv6:"IPv6 adresi",cidrv4:"IPv4 aral\\u0131\\u011F\\u0131",cidrv6:"IPv6 aral\\u0131\\u011F\\u0131",base64:"base64 ile \\u015Fifrelenmi\\u015F metin",base64url:"base64url ile \\u015Fifrelenmi\\u015F metin",json_string:"JSON dizesi",e164:"E.164 say\\u0131s\\u0131",jwt:"JWT",template_literal:"\\u015Eablon dizesi"},o={nan:"NaN"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Ge\\xE7ersiz de\\u011Fer: beklenen instanceof ${t.expected}, al\\u0131nan ${p}`:`Ge\\xE7ersiz de\\u011Fer: beklenen ${i}, al\\u0131nan ${p}`}case"invalid_value":return t.values.length===1?`Ge\\xE7ersiz de\\u011Fer: beklenen ${$(t.values[0])}`:`Ge\\xE7ersiz se\\xE7enek: a\\u015Fa\\u011F\\u0131dakilerden biri olmal\\u0131: ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\xC7ok b\\xFCy\\xFCk: beklenen ${(m=t.origin)!=null?m:"de\\u011Fer"} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\xF6\\u011Fe"}`:`\\xC7ok b\\xFCy\\xFCk: beklenen ${(u=t.origin)!=null?u:"de\\u011Fer"} ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\xC7ok k\\xFC\\xE7\\xFCk: beklenen ${t.origin} ${i}${t.minimum.toString()} ${l.unit}`:`\\xC7ok k\\xFC\\xE7\\xFCk: beklenen ${t.origin} ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Ge\\xE7ersiz metin: "${i.prefix}" ile ba\\u015Flamal\\u0131`:i.format==="ends_with"?`Ge\\xE7ersiz metin: "${i.suffix}" ile bitmeli`:i.format==="includes"?`Ge\\xE7ersiz metin: "${i.includes}" i\\xE7ermeli`:i.format==="regex"?`Ge\\xE7ersiz metin: ${i.pattern} desenine uymal\\u0131`:`Ge\\xE7ersiz ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Ge\\xE7ersiz say\\u0131: ${t.divisor} ile tam b\\xF6l\\xFCnebilmeli`;case"unrecognized_keys":return`Tan\\u0131nmayan anahtar${t.keys.length>1?"lar":""}: ${h(t.keys,", ")}`;case"invalid_key":return`${t.origin} i\\xE7inde ge\\xE7ersiz anahtar`;case"invalid_union":return"Ge\\xE7ersiz de\\u011Fer";case"invalid_element":return`${t.origin} i\\xE7inde ge\\xE7ersiz de\\u011Fer`;default:return"Ge\\xE7ersiz de\\u011Fer"}}};function Nl(){return{localeError:Rp()}}var Ap=()=>{let e={string:{unit:"\\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u0456\\u0432",verb:"\\u043C\\u0430\\u0442\\u0438\\u043C\\u0435"},file:{unit:"\\u0431\\u0430\\u0439\\u0442\\u0456\\u0432",verb:"\\u043C\\u0430\\u0442\\u0438\\u043C\\u0435"},array:{unit:"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0456\\u0432",verb:"\\u043C\\u0430\\u0442\\u0438\\u043C\\u0435"},set:{unit:"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0456\\u0432",verb:"\\u043C\\u0430\\u0442\\u0438\\u043C\\u0435"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456",email:"\\u0430\\u0434\\u0440\\u0435\\u0441\\u0430 \\u0435\\u043B\\u0435\\u043A\\u0442\\u0440\\u043E\\u043D\\u043D\\u043E\\u0457 \\u043F\\u043E\\u0448\\u0442\\u0438",url:"URL",emoji:"\\u0435\\u043C\\u043E\\u0434\\u0437\\u0456",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"\\u0434\\u0430\\u0442\\u0430 \\u0442\\u0430 \\u0447\\u0430\\u0441 ISO",date:"\\u0434\\u0430\\u0442\\u0430 ISO",time:"\\u0447\\u0430\\u0441 ISO",duration:"\\u0442\\u0440\\u0438\\u0432\\u0430\\u043B\\u0456\\u0441\\u0442\\u044C ISO",ipv4:"\\u0430\\u0434\\u0440\\u0435\\u0441\\u0430 IPv4",ipv6:"\\u0430\\u0434\\u0440\\u0435\\u0441\\u0430 IPv6",cidrv4:"\\u0434\\u0456\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D IPv4",cidrv6:"\\u0434\\u0456\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D IPv6",base64:"\\u0440\\u044F\\u0434\\u043E\\u043A \\u0443 \\u043A\\u043E\\u0434\\u0443\\u0432\\u0430\\u043D\\u043D\\u0456 base64",base64url:"\\u0440\\u044F\\u0434\\u043E\\u043A \\u0443 \\u043A\\u043E\\u0434\\u0443\\u0432\\u0430\\u043D\\u043D\\u0456 base64url",json_string:"\\u0440\\u044F\\u0434\\u043E\\u043A JSON",e164:"\\u043D\\u043E\\u043C\\u0435\\u0440 E.164",jwt:"JWT",template_literal:"\\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456"},o={nan:"NaN",number:"\\u0447\\u0438\\u0441\\u043B\\u043E",array:"\\u043C\\u0430\\u0441\\u0438\\u0432"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0456 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F instanceof ${t.expected}, \\u043E\\u0442\\u0440\\u0438\\u043C\\u0430\\u043D\\u043E ${p}`:`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0456 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F ${i}, \\u043E\\u0442\\u0440\\u0438\\u043C\\u0430\\u043D\\u043E ${p}`}case"invalid_value":return t.values.length===1?`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0456 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F ${$(t.values[0])}`:`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0430 \\u043E\\u043F\\u0446\\u0456\\u044F: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F \\u043E\\u0434\\u043D\\u0435 \\u0437 ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u043E \\u0432\\u0435\\u043B\\u0438\\u043A\\u0435: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F, \\u0449\\u043E ${(m=t.origin)!=null?m:"\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F"} ${l.verb} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0456\\u0432"}`:`\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u043E \\u0432\\u0435\\u043B\\u0438\\u043A\\u0435: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F, \\u0449\\u043E ${(u=t.origin)!=null?u:"\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F"} \\u0431\\u0443\\u0434\\u0435 ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u043E \\u043C\\u0430\\u043B\\u0435: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F, \\u0449\\u043E ${t.origin} ${l.verb} ${i}${t.minimum.toString()} ${l.unit}`:`\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u043E \\u043C\\u0430\\u043B\\u0435: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F, \\u0449\\u043E ${t.origin} \\u0431\\u0443\\u0434\\u0435 ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 \\u0440\\u044F\\u0434\\u043E\\u043A: \\u043F\\u043E\\u0432\\u0438\\u043D\\u0435\\u043D \\u043F\\u043E\\u0447\\u0438\\u043D\\u0430\\u0442\\u0438\\u0441\\u044F \\u0437 "${i.prefix}"`:i.format==="ends_with"?`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 \\u0440\\u044F\\u0434\\u043E\\u043A: \\u043F\\u043E\\u0432\\u0438\\u043D\\u0435\\u043D \\u0437\\u0430\\u043A\\u0456\\u043D\\u0447\\u0443\\u0432\\u0430\\u0442\\u0438\\u0441\\u044F \\u043D\\u0430 "${i.suffix}"`:i.format==="includes"?`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 \\u0440\\u044F\\u0434\\u043E\\u043A: \\u043F\\u043E\\u0432\\u0438\\u043D\\u0435\\u043D \\u043C\\u0456\\u0441\\u0442\\u0438\\u0442\\u0438 "${i.includes}"`:i.format==="regex"?`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 \\u0440\\u044F\\u0434\\u043E\\u043A: \\u043F\\u043E\\u0432\\u0438\\u043D\\u0435\\u043D \\u0432\\u0456\\u0434\\u043F\\u043E\\u0432\\u0456\\u0434\\u0430\\u0442\\u0438 \\u0448\\u0430\\u0431\\u043B\\u043E\\u043D\\u0443 ${i.pattern}`:`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E: \\u043F\\u043E\\u0432\\u0438\\u043D\\u043D\\u043E \\u0431\\u0443\\u0442\\u0438 \\u043A\\u0440\\u0430\\u0442\\u043D\\u0438\\u043C ${t.divisor}`;case"unrecognized_keys":return`\\u041D\\u0435\\u0440\\u043E\\u0437\\u043F\\u0456\\u0437\\u043D\\u0430\\u043D\\u0438\\u0439 \\u043A\\u043B\\u044E\\u0447${t.keys.length>1?"\\u0456":""}: ${h(t.keys,", ")}`;case"invalid_key":return`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 \\u043A\\u043B\\u044E\\u0447 \\u0443 ${t.origin}`;case"invalid_union":return"\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0456 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456";case"invalid_element":return`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F \\u0443 ${t.origin}`;default:return"\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0456 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456"}}};function br(){return{localeError:Ap()}}function El(){return br()}var Mp=()=>{let e={string:{unit:"\\u062D\\u0631\\u0648\\u0641",verb:"\\u06C1\\u0648\\u0646\\u0627"},file:{unit:"\\u0628\\u0627\\u0626\\u0679\\u0633",verb:"\\u06C1\\u0648\\u0646\\u0627"},array:{unit:"\\u0622\\u0626\\u0679\\u0645\\u0632",verb:"\\u06C1\\u0648\\u0646\\u0627"},set:{unit:"\\u0622\\u0626\\u0679\\u0645\\u0632",verb:"\\u06C1\\u0648\\u0646\\u0627"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0627\\u0646 \\u067E\\u0679",email:"\\u0627\\u06CC \\u0645\\u06CC\\u0644 \\u0627\\u06CC\\u0688\\u0631\\u06CC\\u0633",url:"\\u06CC\\u0648 \\u0622\\u0631 \\u0627\\u06CC\\u0644",emoji:"\\u0627\\u06CC\\u0645\\u0648\\u062C\\u06CC",uuid:"\\u06CC\\u0648 \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC",uuidv4:"\\u06CC\\u0648 \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC \\u0648\\u06CC 4",uuidv6:"\\u06CC\\u0648 \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC \\u0648\\u06CC 6",nanoid:"\\u0646\\u06CC\\u0646\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC",guid:"\\u062C\\u06CC \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC",cuid:"\\u0633\\u06CC \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC",cuid2:"\\u0633\\u06CC \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC 2",ulid:"\\u06CC\\u0648 \\u0627\\u06CC\\u0644 \\u0622\\u0626\\u06CC \\u0688\\u06CC",xid:"\\u0627\\u06CC\\u06A9\\u0633 \\u0622\\u0626\\u06CC \\u0688\\u06CC",ksuid:"\\u06A9\\u06D2 \\u0627\\u06CC\\u0633 \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC",datetime:"\\u0622\\u0626\\u06CC \\u0627\\u06CC\\u0633 \\u0627\\u0648 \\u0688\\u06CC\\u0679 \\u0679\\u0627\\u0626\\u0645",date:"\\u0622\\u0626\\u06CC \\u0627\\u06CC\\u0633 \\u0627\\u0648 \\u062A\\u0627\\u0631\\u06CC\\u062E",time:"\\u0622\\u0626\\u06CC \\u0627\\u06CC\\u0633 \\u0627\\u0648 \\u0648\\u0642\\u062A",duration:"\\u0622\\u0626\\u06CC \\u0627\\u06CC\\u0633 \\u0627\\u0648 \\u0645\\u062F\\u062A",ipv4:"\\u0622\\u0626\\u06CC \\u067E\\u06CC \\u0648\\u06CC 4 \\u0627\\u06CC\\u0688\\u0631\\u06CC\\u0633",ipv6:"\\u0622\\u0626\\u06CC \\u067E\\u06CC \\u0648\\u06CC 6 \\u0627\\u06CC\\u0688\\u0631\\u06CC\\u0633",cidrv4:"\\u0622\\u0626\\u06CC \\u067E\\u06CC \\u0648\\u06CC 4 \\u0631\\u06CC\\u0646\\u062C",cidrv6:"\\u0622\\u0626\\u06CC \\u067E\\u06CC \\u0648\\u06CC 6 \\u0631\\u06CC\\u0646\\u062C",base64:"\\u0628\\u06CC\\u0633 64 \\u0627\\u0646 \\u06A9\\u0648\\u0688\\u0688 \\u0633\\u0679\\u0631\\u0646\\u06AF",base64url:"\\u0628\\u06CC\\u0633 64 \\u06CC\\u0648 \\u0622\\u0631 \\u0627\\u06CC\\u0644 \\u0627\\u0646 \\u06A9\\u0648\\u0688\\u0688 \\u0633\\u0679\\u0631\\u0646\\u06AF",json_string:"\\u062C\\u06D2 \\u0627\\u06CC\\u0633 \\u0627\\u0648 \\u0627\\u06CC\\u0646 \\u0633\\u0679\\u0631\\u0646\\u06AF",e164:"\\u0627\\u06CC 164 \\u0646\\u0645\\u0628\\u0631",jwt:"\\u062C\\u06D2 \\u0688\\u0628\\u0644\\u06CC\\u0648 \\u0679\\u06CC",template_literal:"\\u0627\\u0646 \\u067E\\u0679"},o={nan:"NaN",number:"\\u0646\\u0645\\u0628\\u0631",array:"\\u0622\\u0631\\u06D2",null:"\\u0646\\u0644"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u063A\\u0644\\u0637 \\u0627\\u0646 \\u067E\\u0679: instanceof ${t.expected} \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u0627\\u060C ${p} \\u0645\\u0648\\u0635\\u0648\\u0644 \\u06C1\\u0648\\u0627`:`\\u063A\\u0644\\u0637 \\u0627\\u0646 \\u067E\\u0679: ${i} \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u0627\\u060C ${p} \\u0645\\u0648\\u0635\\u0648\\u0644 \\u06C1\\u0648\\u0627`}case"invalid_value":return t.values.length===1?`\\u063A\\u0644\\u0637 \\u0627\\u0646 \\u067E\\u0679: ${$(t.values[0])} \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u0627`:`\\u063A\\u0644\\u0637 \\u0622\\u067E\\u0634\\u0646: ${h(t.values,"|")} \\u0645\\u06CC\\u06BA \\u0633\\u06D2 \\u0627\\u06CC\\u06A9 \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u0627`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u0628\\u06C1\\u062A \\u0628\\u0691\\u0627: ${(m=t.origin)!=null?m:"\\u0648\\u06CC\\u0644\\u06CC\\u0648"} \\u06A9\\u06D2 ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0639\\u0646\\u0627\\u0635\\u0631"} \\u06C1\\u0648\\u0646\\u06D2 \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u06D2`:`\\u0628\\u06C1\\u062A \\u0628\\u0691\\u0627: ${(u=t.origin)!=null?u:"\\u0648\\u06CC\\u0644\\u06CC\\u0648"} \\u06A9\\u0627 ${i}${t.maximum.toString()} \\u06C1\\u0648\\u0646\\u0627 \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u0627`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u0628\\u06C1\\u062A \\u0686\\u06BE\\u0648\\u0679\\u0627: ${t.origin} \\u06A9\\u06D2 ${i}${t.minimum.toString()} ${l.unit} \\u06C1\\u0648\\u0646\\u06D2 \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u06D2`:`\\u0628\\u06C1\\u062A \\u0686\\u06BE\\u0648\\u0679\\u0627: ${t.origin} \\u06A9\\u0627 ${i}${t.minimum.toString()} \\u06C1\\u0648\\u0646\\u0627 \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u0627`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u063A\\u0644\\u0637 \\u0633\\u0679\\u0631\\u0646\\u06AF: "${i.prefix}" \\u0633\\u06D2 \\u0634\\u0631\\u0648\\u0639 \\u06C1\\u0648\\u0646\\u0627 \\u0686\\u0627\\u06C1\\u06CC\\u06D2`:i.format==="ends_with"?`\\u063A\\u0644\\u0637 \\u0633\\u0679\\u0631\\u0646\\u06AF: "${i.suffix}" \\u067E\\u0631 \\u062E\\u062A\\u0645 \\u06C1\\u0648\\u0646\\u0627 \\u0686\\u0627\\u06C1\\u06CC\\u06D2`:i.format==="includes"?`\\u063A\\u0644\\u0637 \\u0633\\u0679\\u0631\\u0646\\u06AF: "${i.includes}" \\u0634\\u0627\\u0645\\u0644 \\u06C1\\u0648\\u0646\\u0627 \\u0686\\u0627\\u06C1\\u06CC\\u06D2`:i.format==="regex"?`\\u063A\\u0644\\u0637 \\u0633\\u0679\\u0631\\u0646\\u06AF: \\u067E\\u06CC\\u0679\\u0631\\u0646 ${i.pattern} \\u0633\\u06D2 \\u0645\\u06CC\\u0686 \\u06C1\\u0648\\u0646\\u0627 \\u0686\\u0627\\u06C1\\u06CC\\u06D2`:`\\u063A\\u0644\\u0637 ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u063A\\u0644\\u0637 \\u0646\\u0645\\u0628\\u0631: ${t.divisor} \\u06A9\\u0627 \\u0645\\u0636\\u0627\\u0639\\u0641 \\u06C1\\u0648\\u0646\\u0627 \\u0686\\u0627\\u06C1\\u06CC\\u06D2`;case"unrecognized_keys":return`\\u063A\\u06CC\\u0631 \\u062A\\u0633\\u0644\\u06CC\\u0645 \\u0634\\u062F\\u06C1 \\u06A9\\u06CC${t.keys.length>1?"\\u0632":""}: ${h(t.keys,"\\u060C ")}`;case"invalid_key":return`${t.origin} \\u0645\\u06CC\\u06BA \\u063A\\u0644\\u0637 \\u06A9\\u06CC`;case"invalid_union":return"\\u063A\\u0644\\u0637 \\u0627\\u0646 \\u067E\\u0679";case"invalid_element":return`${t.origin} \\u0645\\u06CC\\u06BA \\u063A\\u0644\\u0637 \\u0648\\u06CC\\u0644\\u06CC\\u0648`;default:return"\\u063A\\u0644\\u0637 \\u0627\\u0646 \\u067E\\u0679"}}};function Zl(){return{localeError:Mp()}}var Fp=()=>{let e={string:{unit:"belgi",verb:"bo\\u2018lishi kerak"},file:{unit:"bayt",verb:"bo\\u2018lishi kerak"},array:{unit:"element",verb:"bo\\u2018lishi kerak"},set:{unit:"element",verb:"bo\\u2018lishi kerak"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"kirish",email:"elektron pochta manzili",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO sana va vaqti",date:"ISO sana",time:"ISO vaqt",duration:"ISO davomiylik",ipv4:"IPv4 manzil",ipv6:"IPv6 manzil",mac:"MAC manzil",cidrv4:"IPv4 diapazon",cidrv6:"IPv6 diapazon",base64:"base64 kodlangan satr",base64url:"base64url kodlangan satr",json_string:"JSON satr",e164:"E.164 raqam",jwt:"JWT",template_literal:"kirish"},o={nan:"NaN",number:"raqam",array:"massiv"};return t=>{var a,c,m,s,u;switch(t.code){case"invalid_type":{let d=(a=o[t.expected])!=null?a:t.expected,i=b(t.input),l=(c=o[i])!=null?c:i;return/^[A-Z]/.test(t.expected)?`Noto\\u2018g\\u2018ri kirish: kutilgan instanceof ${t.expected}, qabul qilingan ${l}`:`Noto\\u2018g\\u2018ri kirish: kutilgan ${d}, qabul qilingan ${l}`}case"invalid_value":return t.values.length===1?`Noto\\u2018g\\u2018ri kirish: kutilgan ${$(t.values[0])}`:`Noto\\u2018g\\u2018ri variant: quyidagilardan biri kutilgan ${h(t.values,"|")}`;case"too_big":{let d=t.inclusive?"<=":"<",i=r(t.origin);return i?`Juda katta: kutilgan ${(m=t.origin)!=null?m:"qiymat"} ${d}${t.maximum.toString()} ${i.unit} ${i.verb}`:`Juda katta: kutilgan ${(s=t.origin)!=null?s:"qiymat"} ${d}${t.maximum.toString()}`}case"too_small":{let d=t.inclusive?">=":">",i=r(t.origin);return i?`Juda kichik: kutilgan ${t.origin} ${d}${t.minimum.toString()} ${i.unit} ${i.verb}`:`Juda kichik: kutilgan ${t.origin} ${d}${t.minimum.toString()}`}case"invalid_format":{let d=t;return d.format==="starts_with"?`Noto\\u2018g\\u2018ri satr: "${d.prefix}" bilan boshlanishi kerak`:d.format==="ends_with"?`Noto\\u2018g\\u2018ri satr: "${d.suffix}" bilan tugashi kerak`:d.format==="includes"?`Noto\\u2018g\\u2018ri satr: "${d.includes}" ni o\\u2018z ichiga olishi kerak`:d.format==="regex"?`Noto\\u2018g\\u2018ri satr: ${d.pattern} shabloniga mos kelishi kerak`:`Noto\\u2018g\\u2018ri ${(u=n[d.format])!=null?u:t.format}`}case"not_multiple_of":return`Noto\\u2018g\\u2018ri raqam: ${t.divisor} ning karralisi bo\\u2018lishi kerak`;case"unrecognized_keys":return`Noma\\u2019lum kalit${t.keys.length>1?"lar":""}: ${h(t.keys,", ")}`;case"invalid_key":return`${t.origin} dagi kalit noto\\u2018g\\u2018ri`;case"invalid_union":return"Noto\\u2018g\\u2018ri kirish";case"invalid_element":return`${t.origin} da noto\\u2018g\\u2018ri qiymat`;default:return"Noto\\u2018g\\u2018ri kirish"}}};function Ll(){return{localeError:Fp()}}var Vp=()=>{let e={string:{unit:"k\\xFD t\\u1EF1",verb:"c\\xF3"},file:{unit:"byte",verb:"c\\xF3"},array:{unit:"ph\\u1EA7n t\\u1EED",verb:"c\\xF3"},set:{unit:"ph\\u1EA7n t\\u1EED",verb:"c\\xF3"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0111\\u1EA7u v\\xE0o",email:"\\u0111\\u1ECBa ch\\u1EC9 email",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ng\\xE0y gi\\u1EDD ISO",date:"ng\\xE0y ISO",time:"gi\\u1EDD ISO",duration:"kho\\u1EA3ng th\\u1EDDi gian ISO",ipv4:"\\u0111\\u1ECBa ch\\u1EC9 IPv4",ipv6:"\\u0111\\u1ECBa ch\\u1EC9 IPv6",cidrv4:"d\\u1EA3i IPv4",cidrv6:"d\\u1EA3i IPv6",base64:"chu\\u1ED7i m\\xE3 h\\xF3a base64",base64url:"chu\\u1ED7i m\\xE3 h\\xF3a base64url",json_string:"chu\\u1ED7i JSON",e164:"s\\u1ED1 E.164",jwt:"JWT",template_literal:"\\u0111\\u1EA7u v\\xE0o"},o={nan:"NaN",number:"s\\u1ED1",array:"m\\u1EA3ng"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u0110\\u1EA7u v\\xE0o kh\\xF4ng h\\u1EE3p l\\u1EC7: mong \\u0111\\u1EE3i instanceof ${t.expected}, nh\\u1EADn \\u0111\\u01B0\\u1EE3c ${p}`:`\\u0110\\u1EA7u v\\xE0o kh\\xF4ng h\\u1EE3p l\\u1EC7: mong \\u0111\\u1EE3i ${i}, nh\\u1EADn \\u0111\\u01B0\\u1EE3c ${p}`}case"invalid_value":return t.values.length===1?`\\u0110\\u1EA7u v\\xE0o kh\\xF4ng h\\u1EE3p l\\u1EC7: mong \\u0111\\u1EE3i ${$(t.values[0])}`:`T\\xF9y ch\\u1ECDn kh\\xF4ng h\\u1EE3p l\\u1EC7: mong \\u0111\\u1EE3i m\\u1ED9t trong c\\xE1c gi\\xE1 tr\\u1ECB ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Qu\\xE1 l\\u1EDBn: mong \\u0111\\u1EE3i ${(m=t.origin)!=null?m:"gi\\xE1 tr\\u1ECB"} ${l.verb} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"ph\\u1EA7n t\\u1EED"}`:`Qu\\xE1 l\\u1EDBn: mong \\u0111\\u1EE3i ${(u=t.origin)!=null?u:"gi\\xE1 tr\\u1ECB"} ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Qu\\xE1 nh\\u1ECF: mong \\u0111\\u1EE3i ${t.origin} ${l.verb} ${i}${t.minimum.toString()} ${l.unit}`:`Qu\\xE1 nh\\u1ECF: mong \\u0111\\u1EE3i ${t.origin} ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Chu\\u1ED7i kh\\xF4ng h\\u1EE3p l\\u1EC7: ph\\u1EA3i b\\u1EAFt \\u0111\\u1EA7u b\\u1EB1ng "${i.prefix}"`:i.format==="ends_with"?`Chu\\u1ED7i kh\\xF4ng h\\u1EE3p l\\u1EC7: ph\\u1EA3i k\\u1EBFt th\\xFAc b\\u1EB1ng "${i.suffix}"`:i.format==="includes"?`Chu\\u1ED7i kh\\xF4ng h\\u1EE3p l\\u1EC7: ph\\u1EA3i bao g\\u1ED3m "${i.includes}"`:i.format==="regex"?`Chu\\u1ED7i kh\\xF4ng h\\u1EE3p l\\u1EC7: ph\\u1EA3i kh\\u1EDBp v\\u1EDBi m\\u1EABu ${i.pattern}`:`${(d=n[i.format])!=null?d:t.format} kh\\xF4ng h\\u1EE3p l\\u1EC7`}case"not_multiple_of":return`S\\u1ED1 kh\\xF4ng h\\u1EE3p l\\u1EC7: ph\\u1EA3i l\\xE0 b\\u1ED9i s\\u1ED1 c\\u1EE7a ${t.divisor}`;case"unrecognized_keys":return`Kh\\xF3a kh\\xF4ng \\u0111\\u01B0\\u1EE3c nh\\u1EADn d\\u1EA1ng: ${h(t.keys,", ")}`;case"invalid_key":return`Kh\\xF3a kh\\xF4ng h\\u1EE3p l\\u1EC7 trong ${t.origin}`;case"invalid_union":return"\\u0110\\u1EA7u v\\xE0o kh\\xF4ng h\\u1EE3p l\\u1EC7";case"invalid_element":return`Gi\\xE1 tr\\u1ECB kh\\xF4ng h\\u1EE3p l\\u1EC7 trong ${t.origin}`;default:return"\\u0110\\u1EA7u v\\xE0o kh\\xF4ng h\\u1EE3p l\\u1EC7"}}};function Cl(){return{localeError:Vp()}}var Kp=()=>{let e={string:{unit:"\\u5B57\\u7B26",verb:"\\u5305\\u542B"},file:{unit:"\\u5B57\\u8282",verb:"\\u5305\\u542B"},array:{unit:"\\u9879",verb:"\\u5305\\u542B"},set:{unit:"\\u9879",verb:"\\u5305\\u542B"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u8F93\\u5165",email:"\\u7535\\u5B50\\u90AE\\u4EF6",url:"URL",emoji:"\\u8868\\u60C5\\u7B26\\u53F7",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO\\u65E5\\u671F\\u65F6\\u95F4",date:"ISO\\u65E5\\u671F",time:"ISO\\u65F6\\u95F4",duration:"ISO\\u65F6\\u957F",ipv4:"IPv4\\u5730\\u5740",ipv6:"IPv6\\u5730\\u5740",cidrv4:"IPv4\\u7F51\\u6BB5",cidrv6:"IPv6\\u7F51\\u6BB5",base64:"base64\\u7F16\\u7801\\u5B57\\u7B26\\u4E32",base64url:"base64url\\u7F16\\u7801\\u5B57\\u7B26\\u4E32",json_string:"JSON\\u5B57\\u7B26\\u4E32",e164:"E.164\\u53F7\\u7801",jwt:"JWT",template_literal:"\\u8F93\\u5165"},o={nan:"NaN",number:"\\u6570\\u5B57",array:"\\u6570\\u7EC4",null:"\\u7A7A\\u503C(null)"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u65E0\\u6548\\u8F93\\u5165\\uFF1A\\u671F\\u671B instanceof ${t.expected}\\uFF0C\\u5B9E\\u9645\\u63A5\\u6536 ${p}`:`\\u65E0\\u6548\\u8F93\\u5165\\uFF1A\\u671F\\u671B ${i}\\uFF0C\\u5B9E\\u9645\\u63A5\\u6536 ${p}`}case"invalid_value":return t.values.length===1?`\\u65E0\\u6548\\u8F93\\u5165\\uFF1A\\u671F\\u671B ${$(t.values[0])}`:`\\u65E0\\u6548\\u9009\\u9879\\uFF1A\\u671F\\u671B\\u4EE5\\u4E0B\\u4E4B\\u4E00 ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u6570\\u503C\\u8FC7\\u5927\\uFF1A\\u671F\\u671B ${(m=t.origin)!=null?m:"\\u503C"} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u4E2A\\u5143\\u7D20"}`:`\\u6570\\u503C\\u8FC7\\u5927\\uFF1A\\u671F\\u671B ${(u=t.origin)!=null?u:"\\u503C"} ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u6570\\u503C\\u8FC7\\u5C0F\\uFF1A\\u671F\\u671B ${t.origin} ${i}${t.minimum.toString()} ${l.unit}`:`\\u6570\\u503C\\u8FC7\\u5C0F\\uFF1A\\u671F\\u671B ${t.origin} ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u65E0\\u6548\\u5B57\\u7B26\\u4E32\\uFF1A\\u5FC5\\u987B\\u4EE5 "${i.prefix}" \\u5F00\\u5934`:i.format==="ends_with"?`\\u65E0\\u6548\\u5B57\\u7B26\\u4E32\\uFF1A\\u5FC5\\u987B\\u4EE5 "${i.suffix}" \\u7ED3\\u5C3E`:i.format==="includes"?`\\u65E0\\u6548\\u5B57\\u7B26\\u4E32\\uFF1A\\u5FC5\\u987B\\u5305\\u542B "${i.includes}"`:i.format==="regex"?`\\u65E0\\u6548\\u5B57\\u7B26\\u4E32\\uFF1A\\u5FC5\\u987B\\u6EE1\\u8DB3\\u6B63\\u5219\\u8868\\u8FBE\\u5F0F ${i.pattern}`:`\\u65E0\\u6548${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u65E0\\u6548\\u6570\\u5B57\\uFF1A\\u5FC5\\u987B\\u662F ${t.divisor} \\u7684\\u500D\\u6570`;case"unrecognized_keys":return`\\u51FA\\u73B0\\u672A\\u77E5\\u7684\\u952E(key): ${h(t.keys,", ")}`;case"invalid_key":return`${t.origin} \\u4E2D\\u7684\\u952E(key)\\u65E0\\u6548`;case"invalid_union":return"\\u65E0\\u6548\\u8F93\\u5165";case"invalid_element":return`${t.origin} \\u4E2D\\u5305\\u542B\\u65E0\\u6548\\u503C(value)`;default:return"\\u65E0\\u6548\\u8F93\\u5165"}}};function Rl(){return{localeError:Kp()}}var Jp=()=>{let e={string:{unit:"\\u5B57\\u5143",verb:"\\u64C1\\u6709"},file:{unit:"\\u4F4D\\u5143\\u7D44",verb:"\\u64C1\\u6709"},array:{unit:"\\u9805\\u76EE",verb:"\\u64C1\\u6709"},set:{unit:"\\u9805\\u76EE",verb:"\\u64C1\\u6709"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u8F38\\u5165",email:"\\u90F5\\u4EF6\\u5730\\u5740",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO \\u65E5\\u671F\\u6642\\u9593",date:"ISO \\u65E5\\u671F",time:"ISO \\u6642\\u9593",duration:"ISO \\u671F\\u9593",ipv4:"IPv4 \\u4F4D\\u5740",ipv6:"IPv6 \\u4F4D\\u5740",cidrv4:"IPv4 \\u7BC4\\u570D",cidrv6:"IPv6 \\u7BC4\\u570D",base64:"base64 \\u7DE8\\u78BC\\u5B57\\u4E32",base64url:"base64url \\u7DE8\\u78BC\\u5B57\\u4E32",json_string:"JSON \\u5B57\\u4E32",e164:"E.164 \\u6578\\u503C",jwt:"JWT",template_literal:"\\u8F38\\u5165"},o={nan:"NaN"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=b(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u7121\\u6548\\u7684\\u8F38\\u5165\\u503C\\uFF1A\\u9810\\u671F\\u70BA instanceof ${t.expected}\\uFF0C\\u4F46\\u6536\\u5230 ${p}`:`\\u7121\\u6548\\u7684\\u8F38\\u5165\\u503C\\uFF1A\\u9810\\u671F\\u70BA ${i}\\uFF0C\\u4F46\\u6536\\u5230 ${p}`}case"invalid_value":return t.values.length===1?`\\u7121\\u6548\\u7684\\u8F38\\u5165\\u503C\\uFF1A\\u9810\\u671F\\u70BA ${$(t.values[0])}`:`\\u7121\\u6548\\u7684\\u9078\\u9805\\uFF1A\\u9810\\u671F\\u70BA\\u4EE5\\u4E0B\\u5176\\u4E2D\\u4E4B\\u4E00 ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u6578\\u503C\\u904E\\u5927\\uFF1A\\u9810\\u671F ${(m=t.origin)!=null?m:"\\u503C"} \\u61C9\\u70BA ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u500B\\u5143\\u7D20"}`:`\\u6578\\u503C\\u904E\\u5927\\uFF1A\\u9810\\u671F ${(u=t.origin)!=null?u:"\\u503C"} \\u61C9\\u70BA ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u6578\\u503C\\u904E\\u5C0F\\uFF1A\\u9810\\u671F ${t.origin} \\u61C9\\u70BA ${i}${t.minimum.toString()} ${l.unit}`:`\\u6578\\u503C\\u904E\\u5C0F\\uFF1A\\u9810\\u671F ${t.origin} \\u61C9\\u70BA ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u7121\\u6548\\u7684\\u5B57\\u4E32\\uFF1A\\u5FC5\\u9808\\u4EE5 "${i.prefix}" \\u958B\\u982D`:i.format==="ends_with"?`\\u7121\\u6548\\u7684\\u5B57\\u4E32\\uFF1A\\u5FC5\\u9808\\u4EE5 "${i.suffix}" \\u7D50\\u5C3E`:i.format==="includes"?`\\u7121\\u6548\\u7684\\u5B57\\u4E32\\uFF1A\\u5FC5\\u9808\\u5305\\u542B "${i.includes}"`:i.format==="regex"?`\\u7121\\u6548\\u7684\\u5B57\\u4E32\\uFF1A\\u5FC5\\u9808\\u7B26\\u5408\\u683C\\u5F0F ${i.pattern}`:`\\u7121\\u6548\\u7684 ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u7121\\u6548\\u7684\\u6578\\u5B57\\uFF1A\\u5FC5\\u9808\\u70BA ${t.divisor} \\u7684\\u500D\\u6578`;case"unrecognized_keys":return`\\u7121\\u6CD5\\u8B58\\u5225\\u7684\\u9375\\u503C${t.keys.length>1?"\\u5011":""}\\uFF1A${h(t.keys,"\\u3001")}`;case"invalid_key":return`${t.origin} \\u4E2D\\u6709\\u7121\\u6548\\u7684\\u9375\\u503C`;case"invalid_union":return"\\u7121\\u6548\\u7684\\u8F38\\u5165\\u503C";case"invalid_element":return`${t.origin} \\u4E2D\\u6709\\u7121\\u6548\\u7684\\u503C`;default:return"\\u7121\\u6548\\u7684\\u8F38\\u5165\\u503C"}}};function Al(){return{localeError:Jp()}}var Bp=()=>{let e={string:{unit:"\\xE0mi",verb:"n\\xED"},file:{unit:"bytes",verb:"n\\xED"},array:{unit:"nkan",verb:"n\\xED"},set:{unit:"nkan",verb:"n\\xED"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u1EB9\\u0300r\\u1ECD \\xECb\\xE1w\\u1ECDl\\xE9",email:"\\xE0d\\xEDr\\u1EB9\\u0301s\\xEC \\xECm\\u1EB9\\u0301l\\xEC",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"\\xE0k\\xF3k\\xF2 ISO",date:"\\u1ECDj\\u1ECD\\u0301 ISO",time:"\\xE0k\\xF3k\\xF2 ISO",duration:"\\xE0k\\xF3k\\xF2 t\\xF3 p\\xE9 ISO",ipv4:"\\xE0d\\xEDr\\u1EB9\\u0301s\\xEC IPv4",ipv6:"\\xE0d\\xEDr\\u1EB9\\u0301s\\xEC IPv6",cidrv4:"\\xE0gb\\xE8gb\\xE8 IPv4",cidrv6:"\\xE0gb\\xE8gb\\xE8 IPv6",base64:"\\u1ECD\\u0300r\\u1ECD\\u0300 t\\xED a k\\u1ECD\\u0301 n\\xED base64",base64url:"\\u1ECD\\u0300r\\u1ECD\\u0300 base64url",json_string:"\\u1ECD\\u0300r\\u1ECD\\u0300 JSON",e164:"n\\u1ECD\\u0301mb\\xE0 E.164",jwt:"JWT",template_literal:"\\u1EB9\\u0300r\\u1ECD \\xECb\\xE1w\\u1ECDl\\xE9"},o={nan:"NaN",number:"n\\u1ECD\\u0301mb\\xE0",array:"akop\\u1ECD"};return t=>{var a,c,m,s;switch(t.code){case"invalid_type":{let u=(a=o[t.expected])!=null?a:t.expected,d=b(t.input),i=(c=o[d])!=null?c:d;return/^[A-Z]/.test(t.expected)?`\\xCCb\\xE1w\\u1ECDl\\xE9 a\\u1E63\\xEC\\u1E63e: a n\\xED l\\xE1ti fi instanceof ${t.expected}, \\xE0m\\u1ECD\\u0300 a r\\xED ${i}`:`\\xCCb\\xE1w\\u1ECDl\\xE9 a\\u1E63\\xEC\\u1E63e: a n\\xED l\\xE1ti fi ${u}, \\xE0m\\u1ECD\\u0300 a r\\xED ${i}`}case"invalid_value":return t.values.length===1?`\\xCCb\\xE1w\\u1ECDl\\xE9 a\\u1E63\\xEC\\u1E63e: a n\\xED l\\xE1ti fi ${$(t.values[0])}`:`\\xC0\\u1E63\\xE0y\\xE0n a\\u1E63\\xEC\\u1E63e: yan \\u1ECD\\u0300kan l\\xE1ra ${h(t.values,"|")}`;case"too_big":{let u=t.inclusive?"<=":"<",d=r(t.origin);return d?`T\\xF3 p\\u1ECD\\u0300 j\\xF9: a n\\xED l\\xE1ti j\\u1EB9\\u0301 p\\xE9 ${(m=t.origin)!=null?m:"iye"} ${d.verb} ${u}${t.maximum} ${d.unit}`:`T\\xF3 p\\u1ECD\\u0300 j\\xF9: a n\\xED l\\xE1ti j\\u1EB9\\u0301 ${u}${t.maximum}`}case"too_small":{let u=t.inclusive?">=":">",d=r(t.origin);return d?`K\\xE9r\\xE9 ju: a n\\xED l\\xE1ti j\\u1EB9\\u0301 p\\xE9 ${t.origin} ${d.verb} ${u}${t.minimum} ${d.unit}`:`K\\xE9r\\xE9 ju: a n\\xED l\\xE1ti j\\u1EB9\\u0301 ${u}${t.minimum}`}case"invalid_format":{let u=t;return u.format==="starts_with"?`\\u1ECC\\u0300r\\u1ECD\\u0300 a\\u1E63\\xEC\\u1E63e: gb\\u1ECD\\u0301d\\u1ECD\\u0300 b\\u1EB9\\u0300r\\u1EB9\\u0300 p\\u1EB9\\u0300l\\xFA "${u.prefix}"`:u.format==="ends_with"?`\\u1ECC\\u0300r\\u1ECD\\u0300 a\\u1E63\\xEC\\u1E63e: gb\\u1ECD\\u0301d\\u1ECD\\u0300 par\\xED p\\u1EB9\\u0300l\\xFA "${u.suffix}"`:u.format==="includes"?`\\u1ECC\\u0300r\\u1ECD\\u0300 a\\u1E63\\xEC\\u1E63e: gb\\u1ECD\\u0301d\\u1ECD\\u0300 n\\xED "${u.includes}"`:u.format==="regex"?`\\u1ECC\\u0300r\\u1ECD\\u0300 a\\u1E63\\xEC\\u1E63e: gb\\u1ECD\\u0301d\\u1ECD\\u0300 b\\xE1 \\xE0p\\u1EB9\\u1EB9r\\u1EB9 mu ${u.pattern}`:`A\\u1E63\\xEC\\u1E63e: ${(s=n[u.format])!=null?s:t.format}`}case"not_multiple_of":return`N\\u1ECD\\u0301mb\\xE0 a\\u1E63\\xEC\\u1E63e: gb\\u1ECD\\u0301d\\u1ECD\\u0300 j\\u1EB9\\u0301 \\xE8y\\xE0 p\\xEDp\\xEDn ti ${t.divisor}`;case"unrecognized_keys":return`B\\u1ECDt\\xECn\\xEC \\xE0\\xECm\\u1ECD\\u0300: ${h(t.keys,", ")}`;case"invalid_key":return`B\\u1ECDt\\xECn\\xEC a\\u1E63\\xEC\\u1E63e n\\xEDn\\xFA ${t.origin}`;case"invalid_union":return"\\xCCb\\xE1w\\u1ECDl\\xE9 a\\u1E63\\xEC\\u1E63e";case"invalid_element":return`Iye a\\u1E63\\xEC\\u1E63e n\\xEDn\\xFA ${t.origin}`;default:return"\\xCCb\\xE1w\\u1ECDl\\xE9 a\\u1E63\\xEC\\u1E63e"}}};function Ml(){return{localeError:Bp()}}var Fl,Kl=Symbol("ZodOutput"),Jl=Symbol("ZodInput"),xr=class{constructor(){this._map=new WeakMap,this._idmap=new Map}add(r,...n){let o=n[0];return this._map.set(r,o),o&&typeof o=="object"&&"id"in o&&this._idmap.set(o.id,r),this}clear(){return this._map=new WeakMap,this._idmap=new Map,this}remove(r){let n=this._map.get(r);return n&&typeof n=="object"&&"id"in n&&this._idmap.delete(n.id),this._map.delete(r),this}get(r){var o;let n=r._zod.parent;if(n){let t=f({},(o=this.get(n))!=null?o:{});delete t.id;let a=f(f({},t),this._map.get(r));return Object.keys(a).length?a:void 0}return this._map.get(r)}has(r){return this._map.has(r)}};function Oi(){return new xr}var Vl;(Vl=(Fl=globalThis).__zod_globalRegistry)!=null||(Fl.__zod_globalRegistry=Oi());var F=globalThis.__zod_globalRegistry;function Ui(e,r){return new e(f({type:"string"},_(r)))}function Ni(e,r){return new e(f({type:"string",coerce:!0},_(r)))}function _r(e,r){return new e(f({type:"string",format:"email",check:"string_format",abort:!1},_(r)))}function gt(e,r){return new e(f({type:"string",format:"guid",check:"string_format",abort:!1},_(r)))}function Sr(e,r){return new e(f({type:"string",format:"uuid",check:"string_format",abort:!1},_(r)))}function kr(e,r){return new e(f({type:"string",format:"uuid",check:"string_format",abort:!1,version:"v4"},_(r)))}function Ir(e,r){return new e(f({type:"string",format:"uuid",check:"string_format",abort:!1,version:"v6"},_(r)))}function zr(e,r){return new e(f({type:"string",format:"uuid",check:"string_format",abort:!1,version:"v7"},_(r)))}function vt(e,r){return new e(f({type:"string",format:"url",check:"string_format",abort:!1},_(r)))}function Tr(e,r){return new e(f({type:"string",format:"emoji",check:"string_format",abort:!1},_(r)))}function wr(e,r){return new e(f({type:"string",format:"nanoid",check:"string_format",abort:!1},_(r)))}function Pr(e,r){return new e(f({type:"string",format:"cuid",check:"string_format",abort:!1},_(r)))}function Dr(e,r){return new e(f({type:"string",format:"cuid2",check:"string_format",abort:!1},_(r)))}function jr(e,r){return new e(f({type:"string",format:"ulid",check:"string_format",abort:!1},_(r)))}function Or(e,r){return new e(f({type:"string",format:"xid",check:"string_format",abort:!1},_(r)))}function Ur(e,r){return new e(f({type:"string",format:"ksuid",check:"string_format",abort:!1},_(r)))}function Nr(e,r){return new e(f({type:"string",format:"ipv4",check:"string_format",abort:!1},_(r)))}function Er(e,r){return new e(f({type:"string",format:"ipv6",check:"string_format",abort:!1},_(r)))}function Ei(e,r){return new e(f({type:"string",format:"mac",check:"string_format",abort:!1},_(r)))}function Zr(e,r){return new e(f({type:"string",format:"cidrv4",check:"string_format",abort:!1},_(r)))}function Lr(e,r){return new e(f({type:"string",format:"cidrv6",check:"string_format",abort:!1},_(r)))}function Cr(e,r){return new e(f({type:"string",format:"base64",check:"string_format",abort:!1},_(r)))}function Rr(e,r){return new e(f({type:"string",format:"base64url",check:"string_format",abort:!1},_(r)))}function Ar(e,r){return new e(f({type:"string",format:"e164",check:"string_format",abort:!1},_(r)))}function Mr(e,r){return new e(f({type:"string",format:"jwt",check:"string_format",abort:!1},_(r)))}var Bl={Any:null,Minute:-1,Second:0,Millisecond:3,Microsecond:6};function Zi(e,r){return new e(f({type:"string",format:"datetime",check:"string_format",offset:!1,local:!1,precision:null},_(r)))}function Li(e,r){return new e(f({type:"string",format:"date",check:"string_format"},_(r)))}function Ci(e,r){return new e(f({type:"string",format:"time",check:"string_format",precision:null},_(r)))}function Ri(e,r){return new e(f({type:"string",format:"duration",check:"string_format"},_(r)))}function Ai(e,r){return new e(f({type:"number",checks:[]},_(r)))}function Mi(e,r){return new e(f({type:"number",coerce:!0,checks:[]},_(r)))}function Fi(e,r){return new e(f({type:"number",check:"number_format",abort:!1,format:"safeint"},_(r)))}function Vi(e,r){return new e(f({type:"number",check:"number_format",abort:!1,format:"float32"},_(r)))}function Ki(e,r){return new e(f({type:"number",check:"number_format",abort:!1,format:"float64"},_(r)))}function Ji(e,r){return new e(f({type:"number",check:"number_format",abort:!1,format:"int32"},_(r)))}function Bi(e,r){return new e(f({type:"number",check:"number_format",abort:!1,format:"uint32"},_(r)))}function Gi(e,r){return new e(f({type:"boolean"},_(r)))}function Wi(e,r){return new e(f({type:"boolean",coerce:!0},_(r)))}function qi(e,r){return new e(f({type:"bigint"},_(r)))}function Xi(e,r){return new e(f({type:"bigint",coerce:!0},_(r)))}function Qi(e,r){return new e(f({type:"bigint",check:"bigint_format",abort:!1,format:"int64"},_(r)))}function Yi(e,r){return new e(f({type:"bigint",check:"bigint_format",abort:!1,format:"uint64"},_(r)))}function Hi(e,r){return new e(f({type:"symbol"},_(r)))}function ea(e,r){return new e(f({type:"undefined"},_(r)))}function ta(e,r){return new e(f({type:"null"},_(r)))}function ra(e){return new e({type:"any"})}function na(e){return new e({type:"unknown"})}function oa(e,r){return new e(f({type:"never"},_(r)))}function ia(e,r){return new e(f({type:"void"},_(r)))}function aa(e,r){return new e(f({type:"date"},_(r)))}function ca(e,r){return new e(f({type:"date",coerce:!0},_(r)))}function ua(e,r){return new e(f({type:"nan"},_(r)))}function se(e,r){return new cr(I(f({check:"less_than"},_(r)),{value:e,inclusive:!1}))}function te(e,r){return new cr(I(f({check:"less_than"},_(r)),{value:e,inclusive:!0}))}function de(e,r){return new ur(I(f({check:"greater_than"},_(r)),{value:e,inclusive:!1}))}function W(e,r){return new ur(I(f({check:"greater_than"},_(r)),{value:e,inclusive:!0}))}function la(e){return de(0,e)}function sa(e){return se(0,e)}function da(e){return te(0,e)}function ma(e){return W(0,e)}function je(e,r){return new ro(I(f({check:"multiple_of"},_(r)),{value:e}))}function Oe(e,r){return new io(I(f({check:"max_size"},_(r)),{maximum:e}))}function me(e,r){return new ao(I(f({check:"min_size"},_(r)),{minimum:e}))}function Ge(e,r){return new co(I(f({check:"size_equals"},_(r)),{size:e}))}function We(e,r){return new uo(I(f({check:"max_length"},_(r)),{maximum:e}))}function _e(e,r){return new lo(I(f({check:"min_length"},_(r)),{minimum:e}))}function qe(e,r){return new so(I(f({check:"length_equals"},_(r)),{length:e}))}function ht(e,r){return new mo(I(f({check:"string_format",format:"regex"},_(r)),{pattern:e}))}function yt(e){return new po(f({check:"string_format",format:"lowercase"},_(e)))}function $t(e){return new fo(f({check:"string_format",format:"uppercase"},_(e)))}function bt(e,r){return new go(I(f({check:"string_format",format:"includes"},_(r)),{includes:e}))}function xt(e,r){return new vo(I(f({check:"string_format",format:"starts_with"},_(r)),{prefix:e}))}function _t(e,r){return new ho(I(f({check:"string_format",format:"ends_with"},_(r)),{suffix:e}))}function pa(e,r,n){return new yo(f({check:"property",property:e,schema:r},_(n)))}function St(e,r){return new $o(f({check:"mime_type",mime:e},_(r)))}function ie(e){return new bo({check:"overwrite",tx:e})}function kt(e){return ie(r=>r.normalize(e))}function It(){return ie(e=>e.trim())}function zt(){return ie(e=>e.toLowerCase())}function Tt(){return ie(e=>e.toUpperCase())}function wt(){return ie(e=>$n(e))}function fa(e,r,n){return new e(f({type:"array",element:r},_(n)))}function Wp(e,r,n){return new e(f({type:"union",options:r},_(n)))}function qp(e,r,n){return new e(f({type:"union",options:r,inclusive:!1},_(n)))}function Xp(e,r,n,o){return new e(f({type:"union",options:n,discriminator:r},_(o)))}function Qp(e,r,n){return new e({type:"intersection",left:r,right:n})}function Yp(e,r,n,o){let t=n instanceof P,a=t?o:n,c=t?n:null;return new e(f({type:"tuple",items:r,rest:c},_(a)))}function Hp(e,r,n,o){return new e(f({type:"record",keyType:r,valueType:n},_(o)))}function ef(e,r,n,o){return new e(f({type:"map",keyType:r,valueType:n},_(o)))}function tf(e,r,n){return new e(f({type:"set",valueType:r},_(n)))}function rf(e,r,n){let o=Array.isArray(r)?Object.fromEntries(r.map(t=>[t,t])):r;return new e(f({type:"enum",entries:o},_(n)))}function nf(e,r,n){return new e(f({type:"enum",entries:r},_(n)))}function of(e,r,n){return new e(f({type:"literal",values:Array.isArray(r)?r:[r]},_(n)))}function ga(e,r){return new e(f({type:"file"},_(r)))}function af(e,r){return new e({type:"transform",transform:r})}function cf(e,r){return new e({type:"optional",innerType:r})}function uf(e,r){return new e({type:"nullable",innerType:r})}function lf(e,r,n){return new e({type:"default",innerType:r,get defaultValue(){return typeof n=="function"?n():xn(n)}})}function sf(e,r,n){return new e(f({type:"nonoptional",innerType:r},_(n)))}function df(e,r){return new e({type:"success",innerType:r})}function mf(e,r,n){return new e({type:"catch",innerType:r,catchValue:typeof n=="function"?n:()=>n})}function pf(e,r,n){return new e({type:"pipe",in:r,out:n})}function ff(e,r){return new e({type:"readonly",innerType:r})}function gf(e,r,n){return new e(f({type:"template_literal",parts:r},_(n)))}function vf(e,r){return new e({type:"lazy",getter:r})}function hf(e,r){return new e({type:"promise",innerType:r})}function va(e,r,n){var a;let o=_(n);return(a=o.abort)!=null||(o.abort=!0),new e(f({type:"custom",check:"custom",fn:r},o))}function ha(e,r,n){return new e(f({type:"custom",check:"custom",fn:r},_(n)))}function ya(e){let r=Gl(n=>(n.addIssue=o=>{var t,a,c,m;if(typeof o=="string")n.issues.push(Re(o,n.value,r._zod.def));else{let s=o;s.fatal&&(s.continue=!1),(t=s.code)!=null||(s.code="custom"),(a=s.input)!=null||(s.input=n.value),(c=s.inst)!=null||(s.inst=r),(m=s.continue)!=null||(s.continue=!r._zod.def.abort),n.issues.push(Re(s))}},e(n.value,n)));return r}function Gl(e,r){let n=new L(f({check:"custom"},_(r)));return n._zod.check=e,n}function $a(e){let r=new L({check:"describe"});return r._zod.onattach=[n=>{var t;let o=(t=F.get(n))!=null?t:{};F.add(n,I(f({},o),{description:e}))}],r._zod.check=()=>{},r}function ba(e){let r=new L({check:"meta"});return r._zod.onattach=[n=>{var t;let o=(t=F.get(n))!=null?t:{};F.add(n,f(f({},o),e))}],r._zod.check=()=>{},r}function xa(e,r){var p,v,y,S,w;let n=_(r),o=(p=n.truthy)!=null?p:["true","1","yes","on","y","enabled"],t=(v=n.falsy)!=null?v:["false","0","no","off","n","disabled"];n.case!=="sensitive"&&(o=o.map(D=>typeof D=="string"?D.toLowerCase():D),t=t.map(D=>typeof D=="string"?D.toLowerCase():D));let a=new Set(o),c=new Set(t),m=(y=e.Codec)!=null?y:pt,s=(S=e.Boolean)!=null?S:dt,u=(w=e.String)!=null?w:De,d=new u({type:"string",error:n.error}),i=new s({type:"boolean",error:n.error}),l=new m({type:"pipe",in:d,out:i,transform:((D,N)=>{let k=D;return n.case!=="sensitive"&&(k=k.toLowerCase()),a.has(k)?!0:c.has(k)?!1:(N.issues.push({code:"invalid_value",expected:"stringbool",values:[...a,...c],input:N.value,inst:l,continue:!1}),{})}),reverseTransform:((D,N)=>D===!0?o[0]||"true":t[0]||"false"),error:n.error});return l}function Xe(e,r,n,o={}){let t=_(o),a=f(I(f({},_(o)),{check:"string_format",type:"string",format:r,fn:typeof n=="function"?n:m=>n.test(m)}),t);return n instanceof RegExp&&(a.pattern=n),new e(a)}function Se(e){var n,o,t,a,c,m,s,u,d;let r=(n=e==null?void 0:e.target)!=null?n:"draft-2020-12";return r==="draft-4"&&(r="draft-04"),r==="draft-7"&&(r="draft-07"),{processors:(o=e.processors)!=null?o:{},metadataRegistry:(t=e==null?void 0:e.metadata)!=null?t:F,target:r,unrepresentable:(a=e==null?void 0:e.unrepresentable)!=null?a:"throw",override:(c=e==null?void 0:e.override)!=null?c:(()=>{}),io:(m=e==null?void 0:e.io)!=null?m:"output",counter:0,seen:new Map,cycles:(s=e==null?void 0:e.cycles)!=null?s:"ref",reused:(u=e==null?void 0:e.reused)!=null?u:"inline",external:(d=e==null?void 0:e.external)!=null?d:void 0}}function E(e,r,n={path:[],schemaPath:[]}){var d,i,l;var o;let t=e._zod.def,a=r.seen.get(e);if(a)return a.count++,n.schemaPath.includes(e)&&(a.cycle=n.path),a.schema;let c={schema:{},count:1,cycle:void 0,path:n.path};r.seen.set(e,c);let m=(i=(d=e._zod).toJSONSchema)==null?void 0:i.call(d);if(m)c.schema=m;else{let p=I(f({},n),{schemaPath:[...n.schemaPath,e],path:n.path});if(e._zod.processJSONSchema)e._zod.processJSONSchema(r,c.schema,p);else{let y=c.schema,S=r.processors[t.type];if(!S)throw new Error(`[toJSONSchema]: Non-representable type encountered: ${t.type}`);S(e,r,y,p)}let v=e._zod.parent;v&&(c.ref||(c.ref=v),E(v,r,p),r.seen.get(v).isParent=!0)}let s=r.metadataRegistry.get(e);return s&&Object.assign(c.schema,s),r.io==="input"&&V(e)&&(delete c.schema.examples,delete c.schema.default),r.io==="input"&&c.schema._prefault&&((l=(o=c.schema).default)!=null||(o.default=c.schema._prefault)),delete c.schema._prefault,r.seen.get(e).schema}function ke(e,r){var c,m,s,u;let n=e.seen.get(r);if(!n)throw new Error("Unprocessed schema. This is a bug in Zod.");let o=new Map;for(let d of e.seen.entries()){let i=(c=e.metadataRegistry.get(d[0]))==null?void 0:c.id;if(i){let l=o.get(i);if(l&&l!==d[0])throw new Error(`Duplicate schema id "${i}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);o.set(i,d[0])}}let t=d=>{var y,S,w,D,N;let i=e.target==="draft-2020-12"?"$defs":"definitions";if(e.external){let k=(y=e.external.registry.get(d[0]))==null?void 0:y.id,T=(S=e.external.uri)!=null?S:(R=>R);if(k)return{ref:T(k)};let U=(D=(w=d[1].defId)!=null?w:d[1].schema.id)!=null?D:`schema${e.counter++}`;return d[1].defId=U,{defId:U,ref:`${T("__shared")}#/${i}/${U}`}}if(d[1]===n)return{ref:"#"};let p=`#/${i}/`,v=(N=d[1].schema.id)!=null?N:`__schema${e.counter++}`;return{defId:v,ref:p+v}},a=d=>{if(d[1].schema.$ref)return;let i=d[1],{ref:l,defId:p}=t(d);i.def=f({},i.schema),p&&(i.defId=p);let v=i.schema;for(let y in v)delete v[y];v.$ref=l};if(e.cycles==="throw")for(let d of e.seen.entries()){let i=d[1];if(i.cycle)throw new Error(`Cycle detected: #/${(m=i.cycle)==null?void 0:m.join("/")}/<root>\n\nSet the \\`cycles\\` parameter to \\`"ref"\\` to resolve cyclical schemas with defs.`)}for(let d of e.seen.entries()){let i=d[1];if(r===d[0]){a(d);continue}if(e.external){let p=(s=e.external.registry.get(d[0]))==null?void 0:s.id;if(r!==d[0]&&p){a(d);continue}}if((u=e.metadataRegistry.get(d[0]))==null?void 0:u.id){a(d);continue}if(i.cycle){a(d);continue}if(i.count>1&&e.reused==="ref"){a(d);continue}}}function Ie(e,r){var c,m,s,u,d;let n=e.seen.get(r);if(!n)throw new Error("Unprocessed schema. This is a bug in Zod.");let o=i=>{var w,D,N;let l=e.seen.get(i);if(l.ref===null)return;let p=(w=l.def)!=null?w:l.schema,v=f({},p),y=l.ref;if(l.ref=null,y){o(y);let k=e.seen.get(y),T=k.schema;if(T.$ref&&(e.target==="draft-07"||e.target==="draft-04"||e.target==="openapi-3.0")?(p.allOf=(D=p.allOf)!=null?D:[],p.allOf.push(T)):Object.assign(p,T),Object.assign(p,v),i._zod.parent===y)for(let R in p)R==="$ref"||R==="allOf"||R in v||delete p[R];if(T.$ref&&k.def)for(let R in p)R==="$ref"||R==="allOf"||R in k.def&&JSON.stringify(p[R])===JSON.stringify(k.def[R])&&delete p[R]}let S=i._zod.parent;if(S&&S!==y){o(S);let k=e.seen.get(S);if(k!=null&&k.schema.$ref&&(p.$ref=k.schema.$ref,k.def))for(let T in p)T==="$ref"||T==="allOf"||T in k.def&&JSON.stringify(p[T])===JSON.stringify(k.def[T])&&delete p[T]}e.override({zodSchema:i,jsonSchema:p,path:(N=l.path)!=null?N:[]})};for(let i of[...e.seen.entries()].reverse())o(i[0]);let t={};if(e.target==="draft-2020-12"?t.$schema="https://json-schema.org/draft/2020-12/schema":e.target==="draft-07"?t.$schema="http://json-schema.org/draft-07/schema#":e.target==="draft-04"?t.$schema="http://json-schema.org/draft-04/schema#":e.target,(c=e.external)!=null&&c.uri){let i=(m=e.external.registry.get(r))==null?void 0:m.id;if(!i)throw new Error("Schema is missing an `id` property");t.$id=e.external.uri(i)}Object.assign(t,(s=n.def)!=null?s:n.schema);let a=(d=(u=e.external)==null?void 0:u.defs)!=null?d:{};for(let i of e.seen.entries()){let l=i[1];l.def&&l.defId&&(a[l.defId]=l.def)}e.external||Object.keys(a).length>0&&(e.target==="draft-2020-12"?t.$defs=a:t.definitions=a);try{let i=JSON.parse(JSON.stringify(t));return Object.defineProperty(i,"~standard",{value:I(f({},r["~standard"]),{jsonSchema:{input:Qe(r,"input",e.processors),output:Qe(r,"output",e.processors)}}),enumerable:!1,writable:!1}),i}catch(i){throw new Error("Error converting schema to JSON.")}}function V(e,r){let n=r!=null?r:{seen:new Set};if(n.seen.has(e))return!1;n.seen.add(e);let o=e._zod.def;if(o.type==="transform")return!0;if(o.type==="array")return V(o.element,n);if(o.type==="set")return V(o.valueType,n);if(o.type==="lazy")return V(o.getter(),n);if(o.type==="promise"||o.type==="optional"||o.type==="nonoptional"||o.type==="nullable"||o.type==="readonly"||o.type==="default"||o.type==="prefault")return V(o.innerType,n);if(o.type==="intersection")return V(o.left,n)||V(o.right,n);if(o.type==="record"||o.type==="map")return V(o.keyType,n)||V(o.valueType,n);if(o.type==="pipe")return V(o.in,n)||V(o.out,n);if(o.type==="object"){for(let t in o.shape)if(V(o.shape[t],n))return!0;return!1}if(o.type==="union"){for(let t of o.options)if(V(t,n))return!0;return!1}if(o.type==="tuple"){for(let t of o.items)if(V(t,n))return!0;return!!(o.rest&&V(o.rest,n))}return!1}var _a=(e,r={})=>n=>{let o=Se(I(f({},n),{processors:r}));return E(e,o),ke(o,e),Ie(o,e)},Qe=(e,r,n={})=>o=>{let{libraryOptions:t,target:a}=o!=null?o:{},c=Se(I(f({},t!=null?t:{}),{target:a,io:r,processors:n}));return E(e,c),ke(c,e),Ie(c,e)};var yf={guid:"uuid",url:"uri",datetime:"date-time",json_string:"json-string",regex:""},Sa=(e,r,n,o)=>{var d;let t=n;t.type="string";let{minimum:a,maximum:c,format:m,patterns:s,contentEncoding:u}=e._zod.bag;if(typeof a=="number"&&(t.minLength=a),typeof c=="number"&&(t.maxLength=c),m&&(t.format=(d=yf[m])!=null?d:m,t.format===""&&delete t.format,m==="time"&&delete t.format),u&&(t.contentEncoding=u),s&&s.size>0){let i=[...s];i.length===1?t.pattern=i[0].source:i.length>1&&(t.allOf=[...i.map(l=>I(f({},r.target==="draft-07"||r.target==="draft-04"||r.target==="openapi-3.0"?{type:"string"}:{}),{pattern:l.source}))])}},ka=(e,r,n,o)=>{let t=n,{minimum:a,maximum:c,format:m,multipleOf:s,exclusiveMaximum:u,exclusiveMinimum:d}=e._zod.bag;typeof m=="string"&&m.includes("int")?t.type="integer":t.type="number",typeof d=="number"&&(r.target==="draft-04"||r.target==="openapi-3.0"?(t.minimum=d,t.exclusiveMinimum=!0):t.exclusiveMinimum=d),typeof a=="number"&&(t.minimum=a,typeof d=="number"&&r.target!=="draft-04"&&(d>=a?delete t.minimum:delete t.exclusiveMinimum)),typeof u=="number"&&(r.target==="draft-04"||r.target==="openapi-3.0"?(t.maximum=u,t.exclusiveMaximum=!0):t.exclusiveMaximum=u),typeof c=="number"&&(t.maximum=c,typeof u=="number"&&r.target!=="draft-04"&&(u<=c?delete t.maximum:delete t.exclusiveMaximum)),typeof s=="number"&&(t.multipleOf=s)},Ia=(e,r,n,o)=>{n.type="boolean"},za=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("BigInt cannot be represented in JSON Schema")},Ta=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Symbols cannot be represented in JSON Schema")},wa=(e,r,n,o)=>{r.target==="openapi-3.0"?(n.type="string",n.nullable=!0,n.enum=[null]):n.type="null"},Pa=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Undefined cannot be represented in JSON Schema")},Da=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Void cannot be represented in JSON Schema")},ja=(e,r,n,o)=>{n.not={}},Oa=(e,r,n,o)=>{},Ua=(e,r,n,o)=>{},Na=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Date cannot be represented in JSON Schema")},Ea=(e,r,n,o)=>{let t=e._zod.def,a=rt(t.entries);a.every(c=>typeof c=="number")&&(n.type="number"),a.every(c=>typeof c=="string")&&(n.type="string"),n.enum=a},Za=(e,r,n,o)=>{let t=e._zod.def,a=[];for(let c of t.values)if(c===void 0){if(r.unrepresentable==="throw")throw new Error("Literal `undefined` cannot be represented in JSON Schema")}else if(typeof c=="bigint"){if(r.unrepresentable==="throw")throw new Error("BigInt literals cannot be represented in JSON Schema");a.push(Number(c))}else a.push(c);if(a.length!==0)if(a.length===1){let c=a[0];n.type=c===null?"null":typeof c,r.target==="draft-04"||r.target==="openapi-3.0"?n.enum=[c]:n.const=c}else a.every(c=>typeof c=="number")&&(n.type="number"),a.every(c=>typeof c=="string")&&(n.type="string"),a.every(c=>typeof c=="boolean")&&(n.type="boolean"),a.every(c=>c===null)&&(n.type="null"),n.enum=a},La=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("NaN cannot be represented in JSON Schema")},Ca=(e,r,n,o)=>{let t=n,a=e._zod.pattern;if(!a)throw new Error("Pattern not found in template literal");t.type="string",t.pattern=a.source},Ra=(e,r,n,o)=>{let t=n,a={type:"string",format:"binary",contentEncoding:"binary"},{minimum:c,maximum:m,mime:s}=e._zod.bag;c!==void 0&&(a.minLength=c),m!==void 0&&(a.maxLength=m),s?s.length===1?(a.contentMediaType=s[0],Object.assign(t,a)):(Object.assign(t,a),t.anyOf=s.map(u=>({contentMediaType:u}))):Object.assign(t,a)},Aa=(e,r,n,o)=>{n.type="boolean"},Ma=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Custom types cannot be represented in JSON Schema")},Fa=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Function types cannot be represented in JSON Schema")},Va=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Transforms cannot be represented in JSON Schema")},Ka=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Map cannot be represented in JSON Schema")},Ja=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Set cannot be represented in JSON Schema")},Ba=(e,r,n,o)=>{let t=n,a=e._zod.def,{minimum:c,maximum:m}=e._zod.bag;typeof c=="number"&&(t.minItems=c),typeof m=="number"&&(t.maxItems=m),t.type="array",t.items=E(a.element,r,I(f({},o),{path:[...o.path,"items"]}))},Ga=(e,r,n,o)=>{var u;let t=n,a=e._zod.def;t.type="object",t.properties={};let c=a.shape;for(let d in c)t.properties[d]=E(c[d],r,I(f({},o),{path:[...o.path,"properties",d]}));let m=new Set(Object.keys(c)),s=new Set([...m].filter(d=>{let i=a.shape[d]._zod;return r.io==="input"?i.optin===void 0:i.optout===void 0}));s.size>0&&(t.required=Array.from(s)),((u=a.catchall)==null?void 0:u._zod.def.type)==="never"?t.additionalProperties=!1:a.catchall?a.catchall&&(t.additionalProperties=E(a.catchall,r,I(f({},o),{path:[...o.path,"additionalProperties"]}))):r.io==="output"&&(t.additionalProperties=!1)},Vr=(e,r,n,o)=>{let t=e._zod.def,a=t.inclusive===!1,c=t.options.map((m,s)=>E(m,r,I(f({},o),{path:[...o.path,a?"oneOf":"anyOf",s]})));a?n.oneOf=c:n.anyOf=c},Wa=(e,r,n,o)=>{let t=e._zod.def,a=E(t.left,r,I(f({},o),{path:[...o.path,"allOf",0]})),c=E(t.right,r,I(f({},o),{path:[...o.path,"allOf",1]})),m=u=>"allOf"in u&&Object.keys(u).length===1,s=[...m(a)?a.allOf:[a],...m(c)?c.allOf:[c]];n.allOf=s},qa=(e,r,n,o)=>{let t=n,a=e._zod.def;t.type="array";let c=r.target==="draft-2020-12"?"prefixItems":"items",m=r.target==="draft-2020-12"||r.target==="openapi-3.0"?"items":"additionalItems",s=a.items.map((l,p)=>E(l,r,I(f({},o),{path:[...o.path,c,p]}))),u=a.rest?E(a.rest,r,I(f({},o),{path:[...o.path,m,...r.target==="openapi-3.0"?[a.items.length]:[]]})):null;r.target==="draft-2020-12"?(t.prefixItems=s,u&&(t.items=u)):r.target==="openapi-3.0"?(t.items={anyOf:s},u&&t.items.anyOf.push(u),t.minItems=s.length,u||(t.maxItems=s.length)):(t.items=s,u&&(t.additionalItems=u));let{minimum:d,maximum:i}=e._zod.bag;typeof d=="number"&&(t.minItems=d),typeof i=="number"&&(t.maxItems=i)},Xa=(e,r,n,o)=>{let t=n,a=e._zod.def;t.type="object";let c=a.keyType,m=c._zod.bag,s=m==null?void 0:m.patterns;if(a.mode==="loose"&&s&&s.size>0){let d=E(a.valueType,r,I(f({},o),{path:[...o.path,"patternProperties","*"]}));t.patternProperties={};for(let i of s)t.patternProperties[i.source]=d}else(r.target==="draft-07"||r.target==="draft-2020-12")&&(t.propertyNames=E(a.keyType,r,I(f({},o),{path:[...o.path,"propertyNames"]}))),t.additionalProperties=E(a.valueType,r,I(f({},o),{path:[...o.path,"additionalProperties"]}));let u=c._zod.values;if(u){let d=[...u].filter(i=>typeof i=="string"||typeof i=="number");d.length>0&&(t.required=d)}},Qa=(e,r,n,o)=>{let t=e._zod.def,a=E(t.innerType,r,o),c=r.seen.get(e);r.target==="openapi-3.0"?(c.ref=t.innerType,n.nullable=!0):n.anyOf=[a,{type:"null"}]},Ya=(e,r,n,o)=>{let t=e._zod.def;E(t.innerType,r,o);let a=r.seen.get(e);a.ref=t.innerType},Ha=(e,r,n,o)=>{let t=e._zod.def;E(t.innerType,r,o);let a=r.seen.get(e);a.ref=t.innerType,n.default=JSON.parse(JSON.stringify(t.defaultValue))},ec=(e,r,n,o)=>{let t=e._zod.def;E(t.innerType,r,o);let a=r.seen.get(e);a.ref=t.innerType,r.io==="input"&&(n._prefault=JSON.parse(JSON.stringify(t.defaultValue)))},tc=(e,r,n,o)=>{let t=e._zod.def;E(t.innerType,r,o);let a=r.seen.get(e);a.ref=t.innerType;let c;try{c=t.catchValue(void 0)}catch(m){throw new Error("Dynamic catch values are not supported in JSON Schema")}n.default=c},rc=(e,r,n,o)=>{let t=e._zod.def,a=r.io==="input"?t.in._zod.def.type==="transform"?t.out:t.in:t.out;E(a,r,o);let c=r.seen.get(e);c.ref=a},nc=(e,r,n,o)=>{let t=e._zod.def;E(t.innerType,r,o);let a=r.seen.get(e);a.ref=t.innerType,n.readOnly=!0},oc=(e,r,n,o)=>{let t=e._zod.def;E(t.innerType,r,o);let a=r.seen.get(e);a.ref=t.innerType},Kr=(e,r,n,o)=>{let t=e._zod.def;E(t.innerType,r,o);let a=r.seen.get(e);a.ref=t.innerType},ic=(e,r,n,o)=>{let t=e._zod.innerType;E(t,r,o);let a=r.seen.get(e);a.ref=t},Fr={string:Sa,number:ka,boolean:Ia,bigint:za,symbol:Ta,null:wa,undefined:Pa,void:Da,never:ja,any:Oa,unknown:Ua,date:Na,enum:Ea,literal:Za,nan:La,template_literal:Ca,file:Ra,success:Aa,custom:Ma,function:Fa,transform:Va,map:Ka,set:Ja,array:Ba,object:Ga,union:Vr,intersection:Wa,tuple:qa,record:Xa,nullable:Qa,nonoptional:Ya,default:Ha,prefault:ec,catch:tc,pipe:rc,readonly:nc,promise:oc,optional:Kr,lazy:ic};function ac(e,r){if("_idmap"in e){let o=e,t=Se(I(f({},r),{processors:Fr})),a={};for(let s of o._idmap.entries()){let[u,d]=s;E(d,t)}let c={},m={registry:o,uri:r==null?void 0:r.uri,defs:a};t.external=m;for(let s of o._idmap.entries()){let[u,d]=s;ke(t,d),c[u]=Ie(t,d)}if(Object.keys(a).length>0){let s=t.target==="draft-2020-12"?"$defs":"definitions";c.__shared={[s]:a}}return{schemas:c}}let n=Se(I(f({},r),{processors:Fr}));return E(e,n),ke(n,e),Ie(n,e)}var Jr=class{get metadataRegistry(){return this.ctx.metadataRegistry}get target(){return this.ctx.target}get unrepresentable(){return this.ctx.unrepresentable}get override(){return this.ctx.override}get io(){return this.ctx.io}get counter(){return this.ctx.counter}set counter(r){this.ctx.counter=r}get seen(){return this.ctx.seen}constructor(r){var o;let n=(o=r==null?void 0:r.target)!=null?o:"draft-2020-12";n==="draft-4"&&(n="draft-04"),n==="draft-7"&&(n="draft-07"),this.ctx=Se(f(f(f(f({processors:Fr,target:n},(r==null?void 0:r.metadata)&&{metadata:r.metadata}),(r==null?void 0:r.unrepresentable)&&{unrepresentable:r.unrepresentable}),(r==null?void 0:r.override)&&{override:r.override}),(r==null?void 0:r.io)&&{io:r.io}))}process(r,n={path:[],schemaPath:[]}){return E(r,this.ctx,n)}emit(r,n){n&&(n.cycles&&(this.ctx.cycles=n.cycles),n.reused&&(this.ctx.reused=n.reused),n.external&&(this.ctx.external=n.external)),ke(this.ctx,r);let c=Ie(this.ctx,r),{"~standard":t}=c;return au(c,["~standard"])}};var cc={};var Pt={};ve(Pt,{ZodAny:()=>ms,ZodArray:()=>vs,ZodBase64:()=>Dc,ZodBase64URL:()=>jc,ZodBigInt:()=>Et,ZodBigIntFormat:()=>Nc,ZodBoolean:()=>Nt,ZodCIDRv4:()=>wc,ZodCIDRv6:()=>Pc,ZodCUID:()=>xc,ZodCUID2:()=>_c,ZodCatch:()=>Cs,ZodCodec:()=>Mc,ZodCustom:()=>rn,ZodCustomStringFormat:()=>Ot,ZodDate:()=>Yr,ZodDefault:()=>Os,ZodDiscriminatedUnion:()=>ys,ZodE164:()=>Oc,ZodEmail:()=>yc,ZodEmoji:()=>$c,ZodEnum:()=>Dt,ZodExactOptional:()=>Ps,ZodFile:()=>Ts,ZodFunction:()=>Gs,ZodGUID:()=>Gr,ZodIPv4:()=>zc,ZodIPv6:()=>Tc,ZodIntersection:()=>$s,ZodJWT:()=>Uc,ZodKSUID:()=>Ic,ZodLazy:()=>Ks,ZodLiteral:()=>zs,ZodMAC:()=>cs,ZodMap:()=>ks,ZodNaN:()=>As,ZodNanoID:()=>bc,ZodNever:()=>fs,ZodNonOptional:()=>Rc,ZodNull:()=>ss,ZodNullable:()=>js,ZodNumber:()=>Ut,ZodNumberFormat:()=>He,ZodObject:()=>Hr,ZodOptional:()=>Cc,ZodPipe:()=>Ac,ZodPrefault:()=>Ns,ZodPromise:()=>Bs,ZodReadonly:()=>Ms,ZodRecord:()=>tn,ZodSet:()=>Is,ZodString:()=>jt,ZodStringFormat:()=>C,ZodSuccess:()=>Ls,ZodSymbol:()=>us,ZodTemplateLiteral:()=>Vs,ZodTransform:()=>ws,ZodTuple:()=>xs,ZodType:()=>j,ZodULID:()=>Sc,ZodURL:()=>Qr,ZodUUID:()=>fe,ZodUndefined:()=>ls,ZodUnion:()=>en,ZodUnknown:()=>ps,ZodVoid:()=>gs,ZodXID:()=>kc,ZodXor:()=>hs,_ZodString:()=>hc,_default:()=>Us,_function:()=>Ig,any:()=>og,array:()=>ce,base64:()=>Mf,base64url:()=>Ff,bigint:()=>Hf,boolean:()=>Ue,catch:()=>Rs,check:()=>zg,cidrv4:()=>Rf,cidrv6:()=>Af,codec:()=>_g,cuid:()=>jf,cuid2:()=>Of,custom:()=>Tg,date:()=>ag,describe:()=>wg,discriminatedUnion:()=>dg,e164:()=>Vf,email:()=>xf,emoji:()=>Pf,enum:()=>ze,exactOptional:()=>Ds,file:()=>yg,float32:()=>qf,float64:()=>Xf,function:()=>Ig,guid:()=>_f,hash:()=>Wf,hex:()=>Gf,hostname:()=>Bf,httpUrl:()=>wf,instanceof:()=>Dg,int:()=>vc,int32:()=>Qf,int64:()=>eg,intersection:()=>bs,ipv4:()=>Zf,ipv6:()=>Cf,json:()=>Og,jwt:()=>Kf,keyof:()=>cg,ksuid:()=>Ef,lazy:()=>Js,literal:()=>hg,looseObject:()=>lg,looseRecord:()=>pg,mac:()=>Lf,map:()=>fg,meta:()=>Pg,nan:()=>xg,nanoid:()=>Df,nativeEnum:()=>vg,never:()=>Ec,nonoptional:()=>Zs,null:()=>ds,nullable:()=>qr,nullish:()=>$g,number:()=>ae,object:()=>ge,optional:()=>Wr,partialRecord:()=>mg,pipe:()=>Xr,prefault:()=>Es,preprocess:()=>Ug,promise:()=>kg,readonly:()=>Fs,record:()=>Ss,refine:()=>Ws,set:()=>gg,strictObject:()=>ug,string:()=>K,stringFormat:()=>Jf,stringbool:()=>jg,success:()=>bg,superRefine:()=>qs,symbol:()=>rg,templateLiteral:()=>Sg,transform:()=>Lc,tuple:()=>_s,uint32:()=>Yf,uint64:()=>tg,ulid:()=>Uf,undefined:()=>ng,union:()=>Zc,unknown:()=>Q,url:()=>Tf,uuid:()=>Sf,uuidv4:()=>kf,uuidv6:()=>If,uuidv7:()=>zf,void:()=>ig,xid:()=>Nf,xor:()=>sg});var Br={};ve(Br,{endsWith:()=>_t,gt:()=>de,gte:()=>W,includes:()=>bt,length:()=>qe,lowercase:()=>yt,lt:()=>se,lte:()=>te,maxLength:()=>We,maxSize:()=>Oe,mime:()=>St,minLength:()=>_e,minSize:()=>me,multipleOf:()=>je,negative:()=>sa,nonnegative:()=>ma,nonpositive:()=>da,normalize:()=>kt,overwrite:()=>ie,positive:()=>la,property:()=>pa,regex:()=>ht,size:()=>Ge,slugify:()=>wt,startsWith:()=>xt,toLowerCase:()=>zt,toUpperCase:()=>Tt,trim:()=>It,uppercase:()=>$t});var Ye={};ve(Ye,{ZodISODate:()=>sc,ZodISODateTime:()=>uc,ZodISODuration:()=>fc,ZodISOTime:()=>mc,date:()=>dc,datetime:()=>lc,duration:()=>gc,time:()=>pc});var uc=g("ZodISODateTime",(e,r)=>{No.init(e,r),C.init(e,r)});function lc(e){return Zi(uc,e)}var sc=g("ZodISODate",(e,r)=>{Eo.init(e,r),C.init(e,r)});function dc(e){return Li(sc,e)}var mc=g("ZodISOTime",(e,r)=>{Zo.init(e,r),C.init(e,r)});function pc(e){return Ci(mc,e)}var fc=g("ZodISODuration",(e,r)=>{Lo.init(e,r),C.init(e,r)});function gc(e){return Ri(fc,e)}var Wl=(e,r)=>{ct.init(e,r),e.name="ZodError",Object.defineProperties(e,{format:{value:n=>Wt(e,n)},flatten:{value:n=>Gt(e,n)},addIssue:{value:n=>{e.issues.push(n),e.message=JSON.stringify(e.issues,Le,2)}},addIssues:{value:n=>{e.issues.push(...n),e.message=JSON.stringify(e.issues,Le,2)}},isEmpty:{get(){return e.issues.length===0}}})},n$=g("ZodError",Wl),X=g("ZodError",Wl,{Parent:Error});var ql=Ae(X),Xl=Me(X),Ql=Fe(X),Yl=Ve(X),Hl=Qt(X),es=Yt(X),ts=Ht(X),rs=er(X),ns=tr(X),os=rr(X),is=nr(X),as=or(X);var j=g("ZodType",(e,r)=>(P.init(e,r),Object.assign(e["~standard"],{jsonSchema:{input:Qe(e,"input"),output:Qe(e,"output")}}),e.toJSONSchema=_a(e,{}),e.def=r,e.type=r.type,Object.defineProperty(e,"_def",{value:r}),e.check=(...n)=>{var o;return e.clone(x.mergeDefs(r,{checks:[...(o=r.checks)!=null?o:[],...n.map(t=>typeof t=="function"?{_zod:{check:t,def:{check:"custom"},onattach:[]}}:t)]}),{parent:!0})},e.with=e.check,e.clone=(n,o)=>J(e,n,o),e.brand=()=>e,e.register=((n,o)=>(n.add(e,o),e)),e.parse=(n,o)=>ql(e,n,o,{callee:e.parse}),e.safeParse=(n,o)=>Ql(e,n,o),e.parseAsync=async(n,o)=>Xl(e,n,o,{callee:e.parseAsync}),e.safeParseAsync=async(n,o)=>Yl(e,n,o),e.spa=e.safeParseAsync,e.encode=(n,o)=>Hl(e,n,o),e.decode=(n,o)=>es(e,n,o),e.encodeAsync=async(n,o)=>ts(e,n,o),e.decodeAsync=async(n,o)=>rs(e,n,o),e.safeEncode=(n,o)=>ns(e,n,o),e.safeDecode=(n,o)=>os(e,n,o),e.safeEncodeAsync=async(n,o)=>is(e,n,o),e.safeDecodeAsync=async(n,o)=>as(e,n,o),e.refine=(n,o)=>e.check(Ws(n,o)),e.superRefine=n=>e.check(qs(n)),e.overwrite=n=>e.check(ie(n)),e.optional=()=>Wr(e),e.exactOptional=()=>Ds(e),e.nullable=()=>qr(e),e.nullish=()=>Wr(qr(e)),e.nonoptional=n=>Zs(e,n),e.array=()=>ce(e),e.or=n=>Zc([e,n]),e.and=n=>bs(e,n),e.transform=n=>Xr(e,Lc(n)),e.default=n=>Us(e,n),e.prefault=n=>Es(e,n),e.catch=n=>Rs(e,n),e.pipe=n=>Xr(e,n),e.readonly=()=>Fs(e),e.describe=n=>{let o=e.clone();return F.add(o,{description:n}),o},Object.defineProperty(e,"description",{get(){var n;return(n=F.get(e))==null?void 0:n.description},configurable:!0}),e.meta=(...n)=>{if(n.length===0)return F.get(e);let o=e.clone();return F.add(o,n[0]),o},e.isOptional=()=>e.safeParse(void 0).success,e.isNullable=()=>e.safeParse(null).success,e.apply=n=>n(e),e)),hc=g("_ZodString",(e,r)=>{var o,t,a;De.init(e,r),j.init(e,r),e._zod.processJSONSchema=(c,m,s)=>Sa(e,c,m,s);let n=e._zod.bag;e.format=(o=n.format)!=null?o:null,e.minLength=(t=n.minimum)!=null?t:null,e.maxLength=(a=n.maximum)!=null?a:null,e.regex=(...c)=>e.check(ht(...c)),e.includes=(...c)=>e.check(bt(...c)),e.startsWith=(...c)=>e.check(xt(...c)),e.endsWith=(...c)=>e.check(_t(...c)),e.min=(...c)=>e.check(_e(...c)),e.max=(...c)=>e.check(We(...c)),e.length=(...c)=>e.check(qe(...c)),e.nonempty=(...c)=>e.check(_e(1,...c)),e.lowercase=c=>e.check(yt(c)),e.uppercase=c=>e.check($t(c)),e.trim=()=>e.check(It()),e.normalize=(...c)=>e.check(kt(...c)),e.toLowerCase=()=>e.check(zt()),e.toUpperCase=()=>e.check(Tt()),e.slugify=()=>e.check(wt())}),jt=g("ZodString",(e,r)=>{De.init(e,r),hc.init(e,r),e.email=n=>e.check(_r(yc,n)),e.url=n=>e.check(vt(Qr,n)),e.jwt=n=>e.check(Mr(Uc,n)),e.emoji=n=>e.check(Tr($c,n)),e.guid=n=>e.check(gt(Gr,n)),e.uuid=n=>e.check(Sr(fe,n)),e.uuidv4=n=>e.check(kr(fe,n)),e.uuidv6=n=>e.check(Ir(fe,n)),e.uuidv7=n=>e.check(zr(fe,n)),e.nanoid=n=>e.check(wr(bc,n)),e.guid=n=>e.check(gt(Gr,n)),e.cuid=n=>e.check(Pr(xc,n)),e.cuid2=n=>e.check(Dr(_c,n)),e.ulid=n=>e.check(jr(Sc,n)),e.base64=n=>e.check(Cr(Dc,n)),e.base64url=n=>e.check(Rr(jc,n)),e.xid=n=>e.check(Or(kc,n)),e.ksuid=n=>e.check(Ur(Ic,n)),e.ipv4=n=>e.check(Nr(zc,n)),e.ipv6=n=>e.check(Er(Tc,n)),e.cidrv4=n=>e.check(Zr(wc,n)),e.cidrv6=n=>e.check(Lr(Pc,n)),e.e164=n=>e.check(Ar(Oc,n)),e.datetime=n=>e.check(lc(n)),e.date=n=>e.check(dc(n)),e.time=n=>e.check(pc(n)),e.duration=n=>e.check(gc(n))});function K(e){return Ui(jt,e)}var C=g("ZodStringFormat",(e,r)=>{Z.init(e,r),hc.init(e,r)}),yc=g("ZodEmail",(e,r)=>{Io.init(e,r),C.init(e,r)});function xf(e){return _r(yc,e)}var Gr=g("ZodGUID",(e,r)=>{So.init(e,r),C.init(e,r)});function _f(e){return gt(Gr,e)}var fe=g("ZodUUID",(e,r)=>{ko.init(e,r),C.init(e,r)});function Sf(e){return Sr(fe,e)}function kf(e){return kr(fe,e)}function If(e){return Ir(fe,e)}function zf(e){return zr(fe,e)}var Qr=g("ZodURL",(e,r)=>{zo.init(e,r),C.init(e,r)});function Tf(e){return vt(Qr,e)}function wf(e){return vt(Qr,f({protocol:/^https?$/,hostname:ee.domain},x.normalizeParams(e)))}var $c=g("ZodEmoji",(e,r)=>{To.init(e,r),C.init(e,r)});function Pf(e){return Tr($c,e)}var bc=g("ZodNanoID",(e,r)=>{wo.init(e,r),C.init(e,r)});function Df(e){return wr(bc,e)}var xc=g("ZodCUID",(e,r)=>{Po.init(e,r),C.init(e,r)});function jf(e){return Pr(xc,e)}var _c=g("ZodCUID2",(e,r)=>{Do.init(e,r),C.init(e,r)});function Of(e){return Dr(_c,e)}var Sc=g("ZodULID",(e,r)=>{jo.init(e,r),C.init(e,r)});function Uf(e){return jr(Sc,e)}var kc=g("ZodXID",(e,r)=>{Oo.init(e,r),C.init(e,r)});function Nf(e){return Or(kc,e)}var Ic=g("ZodKSUID",(e,r)=>{Uo.init(e,r),C.init(e,r)});function Ef(e){return Ur(Ic,e)}var zc=g("ZodIPv4",(e,r)=>{Co.init(e,r),C.init(e,r)});function Zf(e){return Nr(zc,e)}var cs=g("ZodMAC",(e,r)=>{Ao.init(e,r),C.init(e,r)});function Lf(e){return Ei(cs,e)}var Tc=g("ZodIPv6",(e,r)=>{Ro.init(e,r),C.init(e,r)});function Cf(e){return Er(Tc,e)}var wc=g("ZodCIDRv4",(e,r)=>{Mo.init(e,r),C.init(e,r)});function Rf(e){return Zr(wc,e)}var Pc=g("ZodCIDRv6",(e,r)=>{Fo.init(e,r),C.init(e,r)});function Af(e){return Lr(Pc,e)}var Dc=g("ZodBase64",(e,r)=>{Ko.init(e,r),C.init(e,r)});function Mf(e){return Cr(Dc,e)}var jc=g("ZodBase64URL",(e,r)=>{Jo.init(e,r),C.init(e,r)});function Ff(e){return Rr(jc,e)}var Oc=g("ZodE164",(e,r)=>{Bo.init(e,r),C.init(e,r)});function Vf(e){return Ar(Oc,e)}var Uc=g("ZodJWT",(e,r)=>{Go.init(e,r),C.init(e,r)});function Kf(e){return Mr(Uc,e)}var Ot=g("ZodCustomStringFormat",(e,r)=>{Wo.init(e,r),C.init(e,r)});function Jf(e,r,n={}){return Xe(Ot,e,r,n)}function Bf(e){return Xe(Ot,"hostname",ee.hostname,e)}function Gf(e){return Xe(Ot,"hex",ee.hex,e)}function Wf(e,r){var a;let n=(a=r==null?void 0:r.enc)!=null?a:"hex",o=`${e}_${n}`,t=ee[o];if(!t)throw new Error(`Unrecognized hash format: ${o}`);return Xe(Ot,o,t,r)}var Ut=g("ZodNumber",(e,r)=>{var o,t,a,c,m,s,u,d,i;fr.init(e,r),j.init(e,r),e._zod.processJSONSchema=(l,p,v)=>ka(e,l,p,v),e.gt=(l,p)=>e.check(de(l,p)),e.gte=(l,p)=>e.check(W(l,p)),e.min=(l,p)=>e.check(W(l,p)),e.lt=(l,p)=>e.check(se(l,p)),e.lte=(l,p)=>e.check(te(l,p)),e.max=(l,p)=>e.check(te(l,p)),e.int=l=>e.check(vc(l)),e.safe=l=>e.check(vc(l)),e.positive=l=>e.check(de(0,l)),e.nonnegative=l=>e.check(W(0,l)),e.negative=l=>e.check(se(0,l)),e.nonpositive=l=>e.check(te(0,l)),e.multipleOf=(l,p)=>e.check(je(l,p)),e.step=(l,p)=>e.check(je(l,p)),e.finite=()=>e;let n=e._zod.bag;e.minValue=(a=Math.max((o=n.minimum)!=null?o:Number.NEGATIVE_INFINITY,(t=n.exclusiveMinimum)!=null?t:Number.NEGATIVE_INFINITY))!=null?a:null,e.maxValue=(s=Math.min((c=n.maximum)!=null?c:Number.POSITIVE_INFINITY,(m=n.exclusiveMaximum)!=null?m:Number.POSITIVE_INFINITY))!=null?s:null,e.isInt=((u=n.format)!=null?u:"").includes("int")||Number.isSafeInteger((d=n.multipleOf)!=null?d:.5),e.isFinite=!0,e.format=(i=n.format)!=null?i:null});function ae(e){return Ai(Ut,e)}var He=g("ZodNumberFormat",(e,r)=>{qo.init(e,r),Ut.init(e,r)});function vc(e){return Fi(He,e)}function qf(e){return Vi(He,e)}function Xf(e){return Ki(He,e)}function Qf(e){return Ji(He,e)}function Yf(e){return Bi(He,e)}var Nt=g("ZodBoolean",(e,r)=>{dt.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ia(e,n,o,t)});function Ue(e){return Gi(Nt,e)}var Et=g("ZodBigInt",(e,r)=>{var o,t,a;gr.init(e,r),j.init(e,r),e._zod.processJSONSchema=(c,m,s)=>za(e,c,m,s),e.gte=(c,m)=>e.check(W(c,m)),e.min=(c,m)=>e.check(W(c,m)),e.gt=(c,m)=>e.check(de(c,m)),e.gte=(c,m)=>e.check(W(c,m)),e.min=(c,m)=>e.check(W(c,m)),e.lt=(c,m)=>e.check(se(c,m)),e.lte=(c,m)=>e.check(te(c,m)),e.max=(c,m)=>e.check(te(c,m)),e.positive=c=>e.check(de(BigInt(0),c)),e.negative=c=>e.check(se(BigInt(0),c)),e.nonpositive=c=>e.check(te(BigInt(0),c)),e.nonnegative=c=>e.check(W(BigInt(0),c)),e.multipleOf=(c,m)=>e.check(je(c,m));let n=e._zod.bag;e.minValue=(o=n.minimum)!=null?o:null,e.maxValue=(t=n.maximum)!=null?t:null,e.format=(a=n.format)!=null?a:null});function Hf(e){return qi(Et,e)}var Nc=g("ZodBigIntFormat",(e,r)=>{Xo.init(e,r),Et.init(e,r)});function eg(e){return Qi(Nc,e)}function tg(e){return Yi(Nc,e)}var us=g("ZodSymbol",(e,r)=>{Qo.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ta(e,n,o,t)});function rg(e){return Hi(us,e)}var ls=g("ZodUndefined",(e,r)=>{Yo.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Pa(e,n,o,t)});function ng(e){return ea(ls,e)}var ss=g("ZodNull",(e,r)=>{Ho.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>wa(e,n,o,t)});function ds(e){return ta(ss,e)}var ms=g("ZodAny",(e,r)=>{ei.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Oa(e,n,o,t)});function og(){return ra(ms)}var ps=g("ZodUnknown",(e,r)=>{ti.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ua(e,n,o,t)});function Q(){return na(ps)}var fs=g("ZodNever",(e,r)=>{ri.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>ja(e,n,o,t)});function Ec(e){return oa(fs,e)}var gs=g("ZodVoid",(e,r)=>{ni.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Da(e,n,o,t)});function ig(e){return ia(gs,e)}var Yr=g("ZodDate",(e,r)=>{oi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(o,t,a)=>Na(e,o,t,a),e.min=(o,t)=>e.check(W(o,t)),e.max=(o,t)=>e.check(te(o,t));let n=e._zod.bag;e.minDate=n.minimum?new Date(n.minimum):null,e.maxDate=n.maximum?new Date(n.maximum):null});function ag(e){return aa(Yr,e)}var vs=g("ZodArray",(e,r)=>{ii.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ba(e,n,o,t),e.element=r.element,e.min=(n,o)=>e.check(_e(n,o)),e.nonempty=n=>e.check(_e(1,n)),e.max=(n,o)=>e.check(We(n,o)),e.length=(n,o)=>e.check(qe(n,o)),e.unwrap=()=>e.element});function ce(e,r){return fa(vs,e,r)}function cg(e){let r=e._zod.def.shape;return ze(Object.keys(r))}var Hr=g("ZodObject",(e,r)=>{ai.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ga(e,n,o,t),x.defineLazy(e,"shape",()=>r.shape),e.keyof=()=>ze(Object.keys(e._zod.def.shape)),e.catchall=n=>e.clone(I(f({},e._zod.def),{catchall:n})),e.passthrough=()=>e.clone(I(f({},e._zod.def),{catchall:Q()})),e.loose=()=>e.clone(I(f({},e._zod.def),{catchall:Q()})),e.strict=()=>e.clone(I(f({},e._zod.def),{catchall:Ec()})),e.strip=()=>e.clone(I(f({},e._zod.def),{catchall:void 0})),e.extend=n=>x.extend(e,n),e.safeExtend=n=>x.safeExtend(e,n),e.merge=n=>x.merge(e,n),e.pick=n=>x.pick(e,n),e.omit=n=>x.omit(e,n),e.partial=(...n)=>x.partial(Cc,e,n[0]),e.required=(...n)=>x.required(Rc,e,n[0])});function ge(e,r){let n=f({type:"object",shape:e!=null?e:{}},x.normalizeParams(r));return new Hr(n)}function ug(e,r){return new Hr(f({type:"object",shape:e,catchall:Ec()},x.normalizeParams(r)))}function lg(e,r){return new Hr(f({type:"object",shape:e,catchall:Q()},x.normalizeParams(r)))}var en=g("ZodUnion",(e,r)=>{mt.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Vr(e,n,o,t),e.options=r.options});function Zc(e,r){return new en(f({type:"union",options:e},x.normalizeParams(r)))}var hs=g("ZodXor",(e,r)=>{en.init(e,r),ci.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Vr(e,n,o,t),e.options=r.options});function sg(e,r){return new hs(f({type:"union",options:e,inclusive:!1},x.normalizeParams(r)))}var ys=g("ZodDiscriminatedUnion",(e,r)=>{en.init(e,r),ui.init(e,r)});function dg(e,r,n){return new ys(f({type:"union",options:r,discriminator:e},x.normalizeParams(n)))}var $s=g("ZodIntersection",(e,r)=>{li.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Wa(e,n,o,t)});function bs(e,r){return new $s({type:"intersection",left:e,right:r})}var xs=g("ZodTuple",(e,r)=>{vr.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>qa(e,n,o,t),e.rest=n=>e.clone(I(f({},e._zod.def),{rest:n}))});function _s(e,r,n){let o=r instanceof P,t=o?n:r,a=o?r:null;return new xs(f({type:"tuple",items:e,rest:a},x.normalizeParams(t)))}var tn=g("ZodRecord",(e,r)=>{si.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Xa(e,n,o,t),e.keyType=r.keyType,e.valueType=r.valueType});function Ss(e,r,n){return new tn(f({type:"record",keyType:e,valueType:r},x.normalizeParams(n)))}function mg(e,r,n){let o=J(e);return o._zod.values=void 0,new tn(f({type:"record",keyType:o,valueType:r},x.normalizeParams(n)))}function pg(e,r,n){return new tn(f({type:"record",keyType:e,valueType:r,mode:"loose"},x.normalizeParams(n)))}var ks=g("ZodMap",(e,r)=>{di.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ka(e,n,o,t),e.keyType=r.keyType,e.valueType=r.valueType,e.min=(...n)=>e.check(me(...n)),e.nonempty=n=>e.check(me(1,n)),e.max=(...n)=>e.check(Oe(...n)),e.size=(...n)=>e.check(Ge(...n))});function fg(e,r,n){return new ks(f({type:"map",keyType:e,valueType:r},x.normalizeParams(n)))}var Is=g("ZodSet",(e,r)=>{mi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ja(e,n,o,t),e.min=(...n)=>e.check(me(...n)),e.nonempty=n=>e.check(me(1,n)),e.max=(...n)=>e.check(Oe(...n)),e.size=(...n)=>e.check(Ge(...n))});function gg(e,r){return new Is(f({type:"set",valueType:e},x.normalizeParams(r)))}var Dt=g("ZodEnum",(e,r)=>{pi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(o,t,a)=>Ea(e,o,t,a),e.enum=r.entries,e.options=Object.values(r.entries);let n=new Set(Object.keys(r.entries));e.extract=(o,t)=>{let a={};for(let c of o)if(n.has(c))a[c]=r.entries[c];else throw new Error(`Key ${c} not found in enum`);return new Dt(I(f(I(f({},r),{checks:[]}),x.normalizeParams(t)),{entries:a}))},e.exclude=(o,t)=>{let a=f({},r.entries);for(let c of o)if(n.has(c))delete a[c];else throw new Error(`Key ${c} not found in enum`);return new Dt(I(f(I(f({},r),{checks:[]}),x.normalizeParams(t)),{entries:a}))}});function ze(e,r){let n=Array.isArray(e)?Object.fromEntries(e.map(o=>[o,o])):e;return new Dt(f({type:"enum",entries:n},x.normalizeParams(r)))}function vg(e,r){return new Dt(f({type:"enum",entries:e},x.normalizeParams(r)))}var zs=g("ZodLiteral",(e,r)=>{fi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Za(e,n,o,t),e.values=new Set(r.values),Object.defineProperty(e,"value",{get(){if(r.values.length>1)throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");return r.values[0]}})});function hg(e,r){return new zs(f({type:"literal",values:Array.isArray(e)?e:[e]},x.normalizeParams(r)))}var Ts=g("ZodFile",(e,r)=>{gi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ra(e,n,o,t),e.min=(n,o)=>e.check(me(n,o)),e.max=(n,o)=>e.check(Oe(n,o)),e.mime=(n,o)=>e.check(St(Array.isArray(n)?n:[n],o))});function yg(e){return ga(Ts,e)}var ws=g("ZodTransform",(e,r)=>{vi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Va(e,n,o,t),e._zod.parse=(n,o)=>{if(o.direction==="backward")throw new he(e.constructor.name);n.addIssue=a=>{var c,m,s;if(typeof a=="string")n.issues.push(x.issue(a,n.value,r));else{let u=a;u.fatal&&(u.continue=!1),(c=u.code)!=null||(u.code="custom"),(m=u.input)!=null||(u.input=n.value),(s=u.inst)!=null||(u.inst=e),n.issues.push(x.issue(u))}};let t=r.transform(n.value,n);return t instanceof Promise?t.then(a=>(n.value=a,n)):(n.value=t,n)}});function Lc(e){return new ws({type:"transform",transform:e})}var Cc=g("ZodOptional",(e,r)=>{hr.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Kr(e,n,o,t),e.unwrap=()=>e._zod.def.innerType});function Wr(e){return new Cc({type:"optional",innerType:e})}var Ps=g("ZodExactOptional",(e,r)=>{hi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Kr(e,n,o,t),e.unwrap=()=>e._zod.def.innerType});function Ds(e){return new Ps({type:"optional",innerType:e})}var js=g("ZodNullable",(e,r)=>{yi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Qa(e,n,o,t),e.unwrap=()=>e._zod.def.innerType});function qr(e){return new js({type:"nullable",innerType:e})}function $g(e){return Wr(qr(e))}var Os=g("ZodDefault",(e,r)=>{$i.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ha(e,n,o,t),e.unwrap=()=>e._zod.def.innerType,e.removeDefault=e.unwrap});function Us(e,r){return new Os({type:"default",innerType:e,get defaultValue(){return typeof r=="function"?r():x.shallowClone(r)}})}var Ns=g("ZodPrefault",(e,r)=>{bi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>ec(e,n,o,t),e.unwrap=()=>e._zod.def.innerType});function Es(e,r){return new Ns({type:"prefault",innerType:e,get defaultValue(){return typeof r=="function"?r():x.shallowClone(r)}})}var Rc=g("ZodNonOptional",(e,r)=>{xi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ya(e,n,o,t),e.unwrap=()=>e._zod.def.innerType});function Zs(e,r){return new Rc(f({type:"nonoptional",innerType:e},x.normalizeParams(r)))}var Ls=g("ZodSuccess",(e,r)=>{_i.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Aa(e,n,o,t),e.unwrap=()=>e._zod.def.innerType});function bg(e){return new Ls({type:"success",innerType:e})}var Cs=g("ZodCatch",(e,r)=>{Si.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>tc(e,n,o,t),e.unwrap=()=>e._zod.def.innerType,e.removeCatch=e.unwrap});function Rs(e,r){return new Cs({type:"catch",innerType:e,catchValue:typeof r=="function"?r:()=>r})}var As=g("ZodNaN",(e,r)=>{ki.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>La(e,n,o,t)});function xg(e){return ua(As,e)}var Ac=g("ZodPipe",(e,r)=>{Ii.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>rc(e,n,o,t),e.in=r.in,e.out=r.out});function Xr(e,r){return new Ac({type:"pipe",in:e,out:r})}var Mc=g("ZodCodec",(e,r)=>{Ac.init(e,r),pt.init(e,r)});function _g(e,r,n){return new Mc({type:"pipe",in:e,out:r,transform:n.decode,reverseTransform:n.encode})}var Ms=g("ZodReadonly",(e,r)=>{zi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>nc(e,n,o,t),e.unwrap=()=>e._zod.def.innerType});function Fs(e){return new Ms({type:"readonly",innerType:e})}var Vs=g("ZodTemplateLiteral",(e,r)=>{Ti.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ca(e,n,o,t)});function Sg(e,r){return new Vs(f({type:"template_literal",parts:e},x.normalizeParams(r)))}var Ks=g("ZodLazy",(e,r)=>{Di.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>ic(e,n,o,t),e.unwrap=()=>e._zod.def.getter()});function Js(e){return new Ks({type:"lazy",getter:e})}var Bs=g("ZodPromise",(e,r)=>{Pi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>oc(e,n,o,t),e.unwrap=()=>e._zod.def.innerType});function kg(e){return new Bs({type:"promise",innerType:e})}var Gs=g("ZodFunction",(e,r)=>{wi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Fa(e,n,o,t)});function Ig(e){var r,n;return new Gs({type:"function",input:Array.isArray(e==null?void 0:e.input)?_s(e==null?void 0:e.input):(r=e==null?void 0:e.input)!=null?r:ce(Q()),output:(n=e==null?void 0:e.output)!=null?n:Q()})}var rn=g("ZodCustom",(e,r)=>{ji.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ma(e,n,o,t)});function zg(e){let r=new L({check:"custom"});return r._zod.check=e,r}function Tg(e,r){return va(rn,e!=null?e:(()=>!0),r)}function Ws(e,r={}){return ha(rn,e,r)}function qs(e){return ya(e)}var wg=$a,Pg=ba;function Dg(e,r={}){let n=new rn(f({type:"custom",check:"custom",fn:o=>o instanceof e,abort:!0},x.normalizeParams(r)));return n._zod.bag.Class=e,n._zod.check=o=>{var t;o.value instanceof e||o.issues.push({code:"invalid_type",expected:e.name,input:o.value,inst:n,path:[...(t=n._zod.def.path)!=null?t:[]]})},n}var jg=(...e)=>xa({Codec:Mc,Boolean:Nt,String:jt},...e);function Og(e){let r=Js(()=>Zc([K(e),ae(),Ue(),ds(),ce(r),Ss(K(),r)]));return r}function Ug(e,r){return Xr(Lc(e),r)}var Xs;Xs||(Xs={});var m$=I(f(f({},Pt),Br),{iso:Ye});var Fc={};ve(Fc,{bigint:()=>Lg,boolean:()=>Zg,date:()=>Cg,number:()=>Eg,string:()=>Ng});function Ng(e){return Ni(jt,e)}function Eg(e){return Mi(Ut,e)}function Zg(e){return Wi(Nt,e)}function Lg(e){return Xi(Et,e)}function Cg(e){return ca(Yr,e)}M(yr());var Rg=ze(["DETAILED"]),Ag=ze(["GYM","POKESTOP","POWERSPOT"]),Mg=ze(["HOLOHOLO"]),Fg=ze(["ACTIVE","INACTIVE"]),Qs=/^\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)\\s*\\)$/,Ys=K().transform((e,r)=>{let n=Qs.exec(e);return n?{lat:Number(n[1]),lng:Number(n[2])}:(r.addIssue({code:"invalid_format",message:"Invalid point format. Expected `(${number},${number})",format:"custom",pattern:Qs.source,input:e}),Kt)}),Hs=ge({ne:Ys,sw:Ys}),Vg=ge({s2CellLevel:ae(),s2CellId:K(),generatedTimestamp:K(),count:ae(),format:Rg}),Kg=ge({gameBrand:Mg,entity:Ag,status:Fg}),Jg=ge({poiId:K(),latE6:ae(),lngE6:ae(),title:K(),description:K(),address:K(),categoryTags:ce(Q()),mainImage:K(),hasAdditionalImages:Ue(),gmo:ce(Kg),isCommunityContributed:Ue()}),Bg=ge({metadata:Vg,pois:ce(Jg),clusters:ce(Q())}),Gg=ge({success:Ue(),data:ce(Bg),cellsQueried:ae(),cellsLoaded:ae(),snapshot:K(),cellLevel:ae()}),ed=ge({result:Gg,message:Q(),code:K(),errorsWithIcon:Q(),fieldErrors:Q(),errorDetails:Q(),version:K(),captcha:Ue()});function td(){return{sw:{lat:1/0,lng:1/0},ne:{lat:-1/0,lng:-1/0}}}function Wg(e,r,n,o){return{sw:{lat:e,lng:r},ne:{lat:n,lng:o}}}function rd(e,r){return Wg(e.lat,e.lng,r.lat,r.lng)}function nd(e){return{lat:(e.sw.lat+e.ne.lat)/2,lng:(e.sw.lng+e.ne.lng)/2}}function od(e,r){return{sw:{lat:Math.min(e.sw.lat,r.lat),lng:Math.min(e.sw.lng,r.lng)},ne:{lat:Math.max(e.ne.lat,r.lat),lng:Math.max(e.ne.lng,r.lng)}}}function id(e,r){return e.sw.lat<=r.ne.lat&&e.ne.lat>=r.sw.lat&&e.sw.lng<=r.ne.lng&&e.ne.lng>=r.sw.lng}function Ne(e){return e}function cd(...e){}var Vc=class extends Error{constructor(n){super(n);this.name="AbortError"}};function ud(e="The operation was aborted."){return typeof DOMException=="function"?new DOMException(e,"AbortError"):new Vc(e)}function Xg(e,r){for(let[n,o]of Object.entries(r)){let t=e.createObjectStore(n,{keyPath:o.key.slice()});for(let[a,c]of Object.entries(o.indexes))t.createIndex(a,c.key,c)}}function ld(e,r,n){return new Promise((o,t)=>{let a=indexedDB.open(e,r);a.addEventListener("upgradeneeded",()=>Xg(a.result,n)),a.addEventListener("blocked",()=>t(new Error("database blocked"))),a.addEventListener("error",()=>t(a.error)),a.addEventListener("success",()=>o(a.result))})}var Kc=class{constructor(r,n,o){this.source=r;this.query=n;this.action=o}};function sd(e,{mode:r,signal:n},o,...t){return new Promise((a,c)=>{if(n!=null&&n.aborted){c(ud());return}let m=!1,s,u=e.transaction(t,r),d=n?()=>{m||u.abort()}:cd;u.addEventListener("complete",()=>{n==null||n.removeEventListener("abort",d),m?a(s):c(new Error("internal error"))}),u.addEventListener("error",k=>{n==null||n.removeEventListener("abort",d),c(k.target.error)}),n==null||n.addEventListener("abort",d);let i={};for(let k of t)i[k]=u.objectStore(k);let l=o(i),p,v,y,S,w,D;function N(){let k;switch(p){case void 0:k=l.next();break;case"Request":{let U=v.result;p=void 0,v=void 0,k=l.next(U);break}case"WaitRequests":{let U=y,R=S,Ee=R[U.length].result;if(U.push(Ee),U.length!==R.length)return;p=void 0,S=void 0,y=void 0,k=l.next(U);break}case"OpenCursor":{let U=w.result;if(U===null||D(U.value)==="break")p=void 0,w=void 0,D=void 0,k=l.next(void 0);else{U.continue();return}break}default:{c(new Error(`Invalid resolving kind: ${p}`));return}}if(k.done){m=!0,s=k.value;return}let T=k.value;if(T instanceof IDBRequest){p="Request",v=T,T.onsuccess=N;return}if(T instanceof Kc){p="OpenCursor",w=T.source.openCursor(T.query),D=T.action,w.onsuccess=N;return}p="WaitRequests",S=T,y=[];for(let U of T)U.onsuccess=N}N()})}function nn(e,r){return e.index(r)}function Qg(e,r){let n=[];for(let o of r)n.push(e.get(o));return n}function*dd(e,r){let n=Qg(e,r);return n.length===0?[]:yield n}function*md(e,r,n){return yield e.getAll(r,n)}function*Jc(e,r){let n;for(let o of r)n=e.put(o);n!=null&&(yield n)}function*pd(e,r){let n;for(let o of r)n=e.delete(o);n!=null&&(yield n)}function Hg(e){"use strict";var r=e.S2={L:{}};r.L.LatLng=function(s,u,d){var i=parseFloat(s,10),l=parseFloat(u,10);if(isNaN(i)||isNaN(l))throw new Error("Invalid LatLng object: ("+s+", "+u+")");return d!==!0&&(i=Math.max(Math.min(i,90),-90),l=(l+180)%360+(l<-180||l===180?180:-180)),{lat:i,lng:l}},r.L.LatLng.DEG_TO_RAD=Math.PI/180,r.L.LatLng.RAD_TO_DEG=180/Math.PI,r.LatLngToXYZ=function(s){var u=r.L.LatLng.DEG_TO_RAD,d=s.lat*u,i=s.lng*u,l=Math.cos(d);return[Math.cos(i)*l,Math.sin(i)*l,Math.sin(d)]},r.XYZToLatLng=function(s){var u=r.L.LatLng.RAD_TO_DEG,d=Math.atan2(s[2],Math.sqrt(s[0]*s[0]+s[1]*s[1])),i=Math.atan2(s[1],s[0]);return r.L.LatLng(d*u,i*u)};var n=function(s){var u=[Math.abs(s[0]),Math.abs(s[1]),Math.abs(s[2])];return u[0]>u[1]?u[0]>u[2]?0:2:u[1]>u[2]?1:2},o=function(s,u){var d,i;switch(s){case 0:d=u[1]/u[0],i=u[2]/u[0];break;case 1:d=-u[0]/u[1],i=u[2]/u[1];break;case 2:d=-u[0]/u[2],i=-u[1]/u[2];break;case 3:d=u[2]/u[0],i=u[1]/u[0];break;case 4:d=u[2]/u[1],i=-u[0]/u[1];break;case 5:d=-u[1]/u[2],i=-u[0]/u[2];break;default:throw{error:"Invalid face"}}return[d,i]};r.XYZToFaceUV=function(s){var u=n(s);s[u]<0&&(u+=3);var d=o(u,s);return[u,d]},r.FaceUVToXYZ=function(s,u){var d=u[0],i=u[1];switch(s){case 0:return[1,d,i];case 1:return[-d,1,i];case 2:return[-d,-i,1];case 3:return[-1,-i,-d];case 4:return[i,-1,-d];case 5:return[i,d,-1];default:throw{error:"Invalid face"}}};var t=function(s){return s>=.5?1/3*(4*s*s-1):1/3*(1-4*(1-s)*(1-s))};r.STToUV=function(s){return[t(s[0]),t(s[1])]};var a=function(s){return s>=0?.5*Math.sqrt(1+3*s):1-.5*Math.sqrt(1-3*s)};r.UVToST=function(s){return[a(s[0]),a(s[1])]},r.STToIJ=function(s,u){var d=1<<u,i=function(l){var p=Math.floor(l*d);return Math.max(0,Math.min(d-1,p))};return[i(s[0]),i(s[1])]},r.IJToST=function(s,u,d){var i=1<<u;return[(s[0]+d[0])/i,(s[1]+d[1])/i]};var c=function(s,u,d,i){var l,p;if(i==0){d==1&&(u.x=s-1-u.x,u.y=s-1-u.y);var v=u.x;u.x=u.y,u.y=v}},m=function(s,u,d,i){var l={a:[[0,"d"],[1,"a"],[3,"b"],[2,"a"]],b:[[2,"b"],[1,"b"],[3,"a"],[0,"c"]],c:[[2,"c"],[3,"d"],[1,"c"],[0,"b"]],d:[[0,"a"],[3,"c"],[1,"d"],[2,"d"]]};typeof i!="number"&&console.warn(new Error("called pointToHilbertQuadList without face value, defaulting to \'0\'").stack);for(var p=i%2?"d":"a",v=[],y=d-1;y>=0;y--){var S=1<<y,w=s&S?1:0,D=u&S?1:0,N=l[p][w*2+D];v.push(N[0]),p=N[1]}return v};return r.S2Cell=function(){},r.S2Cell.FromHilbertQuadKey=function(s){var u=s.split("/"),d=parseInt(u[0]),i=u[1],l=i.length,p={x:0,y:0},v,y,S,w,D,N;for(v=l-1;v>=0;v--)y=l-v,S=i[v],w=0,D=0,S==="1"?D=1:S==="2"?(w=1,D=1):S==="3"&&(w=1),N=Math.pow(2,y-1),c(N,p,w,D),p.x+=N*w,p.y+=N*D;if(d%2===1){var k=p.x;p.x=p.y,p.y=k}return r.S2Cell.FromFaceIJ(parseInt(d),[p.x,p.y],y)},r.S2Cell.FromLatLng=function(s,u){if(!s.lat&&s.lat!==0||!s.lng&&s.lng!==0)throw new Error("Pass { lat: lat, lng: lng } to S2.S2Cell.FromLatLng");var d=r.LatLngToXYZ(s),i=r.XYZToFaceUV(d),l=r.UVToST(i[1]),p=r.STToIJ(l,u);return r.S2Cell.FromFaceIJ(i[0],p,u)},r.S2Cell.FromFaceIJ=function(s,u,d){var i=new r.S2Cell;return i.face=s,i.ij=u,i.level=d,i},r.S2Cell.prototype.toString=function(){return"F"+this.face+"ij["+this.ij[0]+","+this.ij[1]+"]@"+this.level},r.S2Cell.prototype.getLatLng=function(){var s=r.IJToST(this.ij,this.level,[.5,.5]),u=r.STToUV(s),d=r.FaceUVToXYZ(this.face,u);return r.XYZToLatLng(d)},r.S2Cell.prototype.getCornerLatLngs=function(){for(var s=[],u=[[0,0],[0,1],[1,1],[1,0]],d=0;d<4;d++){var i=r.IJToST(this.ij,this.level,u[d]),l=r.STToUV(i),p=r.FaceUVToXYZ(this.face,l);s.push(r.XYZToLatLng(p))}return s},r.S2Cell.prototype.getFaceAndQuads=function(){var s=m(this.ij[0],this.ij[1],this.level,this.face);return[this.face,s]},r.S2Cell.prototype.toHilbertQuadkey=function(){var s=m(this.ij[0],this.ij[1],this.level,this.face);return this.face.toString(10)+"/"+s.join("")},r.latLngToNeighborKeys=r.S2Cell.latLngToNeighborKeys=function(s,u,d){return r.S2Cell.FromLatLng({lat:s,lng:u},d).getNeighbors().map(function(i){return i.toHilbertQuadkey()})},r.S2Cell.prototype.getNeighbors=function(){var s=function(p,v,y){var S=1<<y;if(v[0]>=0&&v[1]>=0&&v[0]<S&&v[1]<S)return r.S2Cell.FromFaceIJ(p,v,y);var w=r.IJToST(v,y,[.5,.5]),D=r.STToUV(w),N=r.FaceUVToXYZ(p,D),k=r.XYZToFaceUV(N);return p=k[0],D=k[1],w=r.UVToST(D),v=r.STToIJ(w,y),r.S2Cell.FromFaceIJ(p,v,y)},u=this.face,d=this.ij[0],i=this.ij[1],l=this.level;return[s(u,[d-1,i],l),s(u,[d,i-1],l),s(u,[d+1,i],l),s(u,[d,i+1],l)]},r.FACE_BITS=3,r.MAX_LEVEL=30,r.POS_BITS=2*r.MAX_LEVEL+1,r.facePosLevelToId=r.S2Cell.facePosLevelToId=r.fromFacePosLevel=function(s,u,d){var i=e.dcodeIO&&e.dcodeIO.Long,l,p,v;for(d||(d=u.length),u.length>d&&(u=u.substr(0,d)),l=i.fromString(s.toString(10),!0,10).toString(2);l.length<r.FACE_BITS;)l="0"+l;for(p=i.fromString(u,!0,4).toString(2);p.length<2*d;)p="0"+p;for(v=l+p,v+="1";v.length<r.FACE_BITS+r.POS_BITS;)v+="0";return i.fromString(v,!0,2).toString(10)},r.keyToId=r.S2Cell.keyToId=r.toId=r.toCellId=r.fromKey=function(s){var u=s.split("/");return r.fromFacePosLevel(u[0],u[1],u[1].length)},r.idToKey=r.S2Cell.idToKey=r.S2Cell.toKey=r.toKey=r.fromId=r.fromCellId=r.S2Cell.toHilbertQuadkey=r.toHilbertQuadkey=function(s){for(var u=e.dcodeIO&&e.dcodeIO.Long,d=u.fromString(s,!0,10).toString(2);d.length<r.FACE_BITS+r.POS_BITS;)d="0"+d;for(var i=d.lastIndexOf("1"),l=d.substring(0,3),p=d.substring(3,i),v=p.length/2,y=u.fromString(l,!0,2).toString(10),S=u.fromString(p,!0,2).toString(4);S.length<v;)S="0"+S;return y+"/"+S},r.keyToLatLng=r.S2Cell.keyToLatLng=function(s){var u=r.S2Cell.FromHilbertQuadKey(s);return u.getLatLng()},r.idToLatLng=r.S2Cell.idToLatLng=function(s){var u=r.idToKey(s);return r.keyToLatLng(u)},r.S2Cell.latLngToKey=r.latLngToKey=r.latLngToQuadkey=function(s,u,d){if(isNaN(d)||d<1||d>30)throw new Error("\'level\' is not a number between 1 and 30 (but it should be)");return r.S2Cell.FromLatLng({lat:s,lng:u},d).toHilbertQuadkey()},r.stepKey=function(s,u){var d=e.dcodeIO&&e.dcodeIO.Long,i=s.split("/"),l=i[0],p=i[1],v=i[1].length,y=d.fromString(p,!0,4),S;u>0?S=y.add(Math.abs(u)):u<0&&(S=y.subtract(Math.abs(u)));var w=S.toString(4);for(w==="0"&&console.warning(new Error("face/position wrapping is not yet supported"));w.length<v;)w="0"+w;return l+"/"+w},r.S2Cell.prevKey=r.prevKey=function(s){return r.stepKey(s,-1)},r.S2Cell.nextKey=r.nextKey=function(s){return r.stepKey(s,1)},r}var Zt=Hg(typeof module!="undefined"&&module.exports?module.exports:typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:typeof window!="undefined"?window:void 0);function Bc(e,r){return Zt.S2Cell.FromLatLng(e,r)}function ev(e){return Zt.S2Cell.FromHilbertQuadKey(e)}function cn(e,r){return Bc(e,r).toString()}var tv=Object.freeze(["0","1","2","3"]);function un(e){let r=e.level;if(Zt.MAX_LEVEL<=r)throw new Error("Cannot get children for a cell at MAX_LEVEL (30).");let n=e.toHilbertQuadkey(),o=[];for(let t of tv){let a=n+t;o.push(ev(a))}return o}function fd(e){let r=e.padEnd(16,"0"),n=BigInt(`0x${r}`),o=nv(n);return Zt.S2Cell.FromHilbertQuadKey(o)}var Gc=new BigUint64Array(1),an=new Uint32Array(Gc.buffer);function rv(e){Gc[0]=e;let r=an[0],n=an[1];return r!==0?31-Math.clz32(r&-r):n!==0?32+(31-Math.clz32(n&-n)):64}var on=[];function nv(e){Gc[0]=e;let r=an[0],n=an[1],o=n>>>29,t=ov(e);on.length=0,on.push(o,"/");for(let a=1;a<=t;a++){let c=61-2*a,m;c>=32?m=n>>>c-32&3:c===31?m=(n&1)<<1|r>>>31:m=r>>>c&3,on.push(m)}return on.join("")}function ov(e){let r=rv(e);if(r>60||(r&1)!==0)throw new Error("Invalid S2CellID");return 60-r>>1}function gd(e=1024){let r=new Array(e),n=e-1,o=0,t=0;return{enqueue(a){r[t&n]=a,t++},dequeue(){if(o===t)return;let a=r[o&n];return o++,a}}}var iv={pois:{recordType:Ne,key:"guid",indexes:{coordinates:{key:["lat","lng"]},cellIds:{key:"cellIds",multiEntry:!0}}},cells:{recordType:Ne,key:"cellId",indexes:{ancestorIds:{key:"ancestorIds",multiEntry:!0}}}},ln=Symbol("_pois"),vd=Symbol("_cells"),av=Symbol("_coordinatesIndex"),hd=Symbol("_cellIdsIndex"),cv=Symbol("_ancestorIdsIndexSymbol");var uv="poi-records-e232930d-7282-4c02-aeef-bb9508576d2e",lv=1,yd=Symbol("_database");async function $d(){return{[yd]:await ld(uv,lv,iv)}}function sv(e,r,n,o){return sd(e[yd],{mode:r,signal:n==null?void 0:n.signal},({pois:t,cells:a})=>{let c={[ln]:t,[vd]:a,[av]:nn(t,"coordinates"),[hd]:nn(t,"cellIds"),[cv]:nn(a,"ancestorIds")};return o(c)},"pois","cells")}function dv(e,r){let n=[],o=new Set,t=gd();t.enqueue(Bc(nd(e),r));for(let a;a=t.dequeue();){let c=a.toString();if(o.has(c))continue;o.add(c);let m=td();for(let s of a.getCornerLatLngs())m=od(m,s);if(id(e,m)){n.push(a);for(let s of a.getNeighbors())t.enqueue(s)}}return n}function mv(e,r,n,o){let t=n.latE6/1e6,a=n.lngE6/1e6,c=n.title,m={lat:t,lng:a},s=[cn(m,14),cn(m,15)],u=e!=null?e:{guid:r,lat:t,lng:a,name:c,data:n,cellIds:s,firstFetchDate:o,lastFetchDate:o};return I(f({},u),{name:c!==""?c:u.name,lat:t,lng:a,data:n,cellIds:s,lastFetchDate:o})}async function bd(e,r,n,o,t){let a=new Map;for(let c of n)for(let m of dv(c,Wc)){let s=m.toString();r.has(s)||a.set(s,{cell:m})}await sv(e,"readwrite",{signal:t},function*(c){yield*ue(pv(c,r)),yield*ue(fv(r,c,o)),yield*ue(gv(c,r,a,o))})}function*pv(e,r){let n=[];for(let[o,{pois:t}]of r){let a=new Set;for(let m of t)a.add(m.poiId);let c=yield*ue(md(e[hd],o));for(let{guid:m}of c)a.has(m)||n.push(m)}yield*ue(pd(e[ln],n))}function*fv(e,r,n){let o=[],t=[];for(let{pois:m}of e.values())for(let s of m)o.push(s.poiId),t.push(s);let c=(yield*ue(dd(r[ln],o))).map((m,s)=>{let u=t[s];return mv(m,u.poiId,u,n)});yield*ue(Jc(r[ln],c))}function*gv(e,r,n,o){let t=[];for(let{cell:a}of[...r.values(),...n.values()])for(let c of un(a))for(let m of un(c))for(let s of un(m)){let u=s.getLatLng();t.push({cellId:s.toString(),centerLat:u.lat,centerLng:u.lng,level:s.level,ancestorIds:[cn(u,14)],firstFetchDate:o,lastFetchDate:o})}yield*ue(Jc(e[vd],t))}function xd(){return new EventTarget}function _d(e,r){return new CustomEvent(e,{detail:r})}function vv(e){let r={};return e.searchParams.forEach((n,o)=>{r[o]=n}),r}async function hv(e,r,{cells:n,bounds:o},t){await bd(e,n,o,Date.now(),t),r.dispatchEvent(_d("gcs-saved",void 0))}var Wc=14;async function yv(e,r){let n=new Map,o=[];for(let{queries:t,responseText:a}of e){await r.yield();let c=ed.parse(JSON.parse(a));if(c.captcha||!c.result.success)continue;let m=Hs.parse(t);o.push(rd(m.sw,m.ne));for(let{metadata:s,pois:u}of c.result.data){if(s.s2CellLevel!==Wc)continue;let d=fd(s.s2CellId),i=d.toString();n.set(i,{pois:u,cell:d})}}return{cells:n,bounds:o}}async function Sd(e,r){let n=await $d(),o=fu(async t=>{let{signal:a}=new AbortController,c=vu(a),m=await yv(t,c);await hv(n,e,m,a)},r);return(t,a)=>{o.push({queries:vv(t),responseText:a})}}function qc(e,r){return e}var $v=[qc("config-changed",Ne),qc("gcs-received",Ne),qc("gcs-saved",Ne)],kd=$v;function Id(e){console.error("An error occurred during asynchronous processing:",e)}async function bv(){let e=fn(self),r=xd(),n=a=>e.dispatchEvent(a.type,a.detail);kd.forEach(a=>r.addEventListener(a,n));let o=await Sd(r,Id);Vt({hello(a){return`Worker received: ${a}`},onGcsReceived(a,c){o(new URL(a),c)}})}bv().catch(Id);\n/*! Bundled license information:\n\ncomlink/dist/esm/comlink.mjs:\n  (**\n   * @license\n   * Copyright 2019 Google LLC\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n*/\n');
  }

  // node_modules/comlink/dist/esm/comlink.mjs
  var proxyMarker = /* @__PURE__ */ Symbol("Comlink.proxy");
  var createEndpoint = /* @__PURE__ */ Symbol("Comlink.endpoint");
  var releaseProxy = /* @__PURE__ */ Symbol("Comlink.releaseProxy");
  var finalizer = /* @__PURE__ */ Symbol("Comlink.finalizer");
  var throwMarker = /* @__PURE__ */ Symbol("Comlink.thrown");
  var isObject2 = (val) => typeof val === "object" && val !== null || typeof val === "function";
  var proxyTransferHandler = {
    canHandle: (val) => isObject2(val) && val[proxyMarker],
    serialize(obj) {
      const { port1, port2 } = new MessageChannel();
      expose(obj, port1);
      return [port2, [port2]];
    },
    deserialize(port) {
      port.start();
      return wrap2(port);
    }
  };
  var throwTransferHandler = {
    canHandle: (value) => isObject2(value) && throwMarker in value,
    serialize({ value }) {
      let serialized;
      if (value instanceof Error) {
        serialized = {
          isError: true,
          value: {
            message: value.message,
            name: value.name,
            stack: value.stack
          }
        };
      } else {
        serialized = { isError: false, value };
      }
      return [serialized, []];
    },
    deserialize(serialized) {
      if (serialized.isError) {
        throw Object.assign(new Error(serialized.value.message), serialized.value);
      }
      throw serialized.value;
    }
  };
  var transferHandlers = /* @__PURE__ */ new Map([
    ["proxy", proxyTransferHandler],
    ["throw", throwTransferHandler]
  ]);
  function isAllowedOrigin(allowedOrigins, origin) {
    for (const allowedOrigin of allowedOrigins) {
      if (origin === allowedOrigin || allowedOrigin === "*") {
        return true;
      }
      if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
        return true;
      }
    }
    return false;
  }
  function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
    ep.addEventListener("message", function callback(ev) {
      if (!ev || !ev.data) {
        return;
      }
      if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
        console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
        return;
      }
      const { id: id2, type, path } = Object.assign({ path: [] }, ev.data);
      const argumentList = (ev.data.argumentList || []).map(fromWireValue);
      let returnValue;
      try {
        const parent = path.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
        const rawValue = path.reduce((obj2, prop) => obj2[prop], obj);
        switch (type) {
          case "GET":
            {
              returnValue = rawValue;
            }
            break;
          case "SET":
            {
              parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
              returnValue = true;
            }
            break;
          case "APPLY":
            {
              returnValue = rawValue.apply(parent, argumentList);
            }
            break;
          case "CONSTRUCT":
            {
              const value = new rawValue(...argumentList);
              returnValue = proxy(value);
            }
            break;
          case "ENDPOINT":
            {
              const { port1, port2 } = new MessageChannel();
              expose(obj, port2);
              returnValue = transfer(port1, [port1]);
            }
            break;
          case "RELEASE":
            {
              returnValue = void 0;
            }
            break;
          default:
            return;
        }
      } catch (value) {
        returnValue = { value, [throwMarker]: 0 };
      }
      Promise.resolve(returnValue).catch((value) => {
        return { value, [throwMarker]: 0 };
      }).then((returnValue2) => {
        const [wireValue, transferables] = toWireValue(returnValue2);
        ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
        if (type === "RELEASE") {
          ep.removeEventListener("message", callback);
          closeEndPoint(ep);
          if (finalizer in obj && typeof obj[finalizer] === "function") {
            obj[finalizer]();
          }
        }
      }).catch((error48) => {
        const [wireValue, transferables] = toWireValue({
          value: new TypeError("Unserializable return value"),
          [throwMarker]: 0
        });
        ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
      });
    });
    if (ep.start) {
      ep.start();
    }
  }
  function isMessagePort(endpoint) {
    return endpoint.constructor.name === "MessagePort";
  }
  function closeEndPoint(endpoint) {
    if (isMessagePort(endpoint))
      endpoint.close();
  }
  function wrap2(ep, target) {
    const pendingListeners = /* @__PURE__ */ new Map();
    ep.addEventListener("message", function handleMessage(ev) {
      const { data } = ev;
      if (!data || !data.id) {
        return;
      }
      const resolver = pendingListeners.get(data.id);
      if (!resolver) {
        return;
      }
      try {
        resolver(data);
      } finally {
        pendingListeners.delete(data.id);
      }
    });
    return createProxy(ep, pendingListeners, [], target);
  }
  function throwIfProxyReleased(isReleased) {
    if (isReleased) {
      throw new Error("Proxy has been released and is not useable");
    }
  }
  function releaseEndpoint(ep) {
    return requestResponseMessage(ep, /* @__PURE__ */ new Map(), {
      type: "RELEASE"
    }).then(() => {
      closeEndPoint(ep);
    });
  }
  var proxyCounter = /* @__PURE__ */ new WeakMap();
  var proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
    const newCount = (proxyCounter.get(ep) || 0) - 1;
    proxyCounter.set(ep, newCount);
    if (newCount === 0) {
      releaseEndpoint(ep);
    }
  });
  function registerProxy(proxy2, ep) {
    const newCount = (proxyCounter.get(ep) || 0) + 1;
    proxyCounter.set(ep, newCount);
    if (proxyFinalizers) {
      proxyFinalizers.register(proxy2, ep, proxy2);
    }
  }
  function unregisterProxy(proxy2) {
    if (proxyFinalizers) {
      proxyFinalizers.unregister(proxy2);
    }
  }
  function createProxy(ep, pendingListeners, path = [], target = function() {
  }) {
    let isProxyReleased = false;
    const proxy2 = new Proxy(target, {
      get(_target, prop) {
        throwIfProxyReleased(isProxyReleased);
        if (prop === releaseProxy) {
          return () => {
            unregisterProxy(proxy2);
            releaseEndpoint(ep);
            pendingListeners.clear();
            isProxyReleased = true;
          };
        }
        if (prop === "then") {
          if (path.length === 0) {
            return { then: () => proxy2 };
          }
          const r = requestResponseMessage(ep, pendingListeners, {
            type: "GET",
            path: path.map((p) => p.toString())
          }).then(fromWireValue);
          return r.then.bind(r);
        }
        return createProxy(ep, pendingListeners, [...path, prop]);
      },
      set(_target, prop, rawValue) {
        throwIfProxyReleased(isProxyReleased);
        const [value, transferables] = toWireValue(rawValue);
        return requestResponseMessage(ep, pendingListeners, {
          type: "SET",
          path: [...path, prop].map((p) => p.toString()),
          value
        }, transferables).then(fromWireValue);
      },
      apply(_target, _thisArg, rawArgumentList) {
        throwIfProxyReleased(isProxyReleased);
        const last = path[path.length - 1];
        if (last === createEndpoint) {
          return requestResponseMessage(ep, pendingListeners, {
            type: "ENDPOINT"
          }).then(fromWireValue);
        }
        if (last === "bind") {
          return createProxy(ep, pendingListeners, path.slice(0, -1));
        }
        const [argumentList, transferables] = processArguments(rawArgumentList);
        return requestResponseMessage(ep, pendingListeners, {
          type: "APPLY",
          path: path.map((p) => p.toString()),
          argumentList
        }, transferables).then(fromWireValue);
      },
      construct(_target, rawArgumentList) {
        throwIfProxyReleased(isProxyReleased);
        const [argumentList, transferables] = processArguments(rawArgumentList);
        return requestResponseMessage(ep, pendingListeners, {
          type: "CONSTRUCT",
          path: path.map((p) => p.toString()),
          argumentList
        }, transferables).then(fromWireValue);
      }
    });
    registerProxy(proxy2, ep);
    return proxy2;
  }
  function myFlat(arr) {
    return Array.prototype.concat.apply([], arr);
  }
  function processArguments(argumentList) {
    const processed = argumentList.map(toWireValue);
    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
  }
  var transferCache = /* @__PURE__ */ new WeakMap();
  function transfer(obj, transfers) {
    transferCache.set(obj, transfers);
    return obj;
  }
  function proxy(obj) {
    return Object.assign(obj, { [proxyMarker]: true });
  }
  function toWireValue(value) {
    for (const [name, handler] of transferHandlers) {
      if (handler.canHandle(value)) {
        const [serializedValue, transferables] = handler.serialize(value);
        return [
          {
            type: "HANDLER",
            name,
            value: serializedValue
          },
          transferables
        ];
      }
    }
    return [
      {
        type: "RAW",
        value
      },
      transferCache.get(value) || []
    ];
  }
  function fromWireValue(value) {
    switch (value.type) {
      case "HANDLER":
        return transferHandlers.get(value.name).deserialize(value.value);
      case "RAW":
        return value.value;
    }
  }
  function requestResponseMessage(ep, pendingListeners, msg, transfers) {
    return new Promise((resolve) => {
      const id2 = generateUUID();
      pendingListeners.set(id2, resolve);
      if (ep.start) {
        ep.start();
      }
      ep.postMessage(Object.assign({ id: id2 }, msg), transfers);
    });
  }
  function generateUUID() {
    return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
  }

  // source/drafts-view/dialog.module.css
  var cssText3 = '.dialog-59a53fe03e3575e542ce8529fd0df0730794d761 {\n    --initial-height-495e116479cd0a7f6c7e692d6f9bdccbce49be36: min(300px, 50%);\n    --initial-width-34ea83cc4f4c691432fc64a891f4be0f53ecd5fa: min(400px, 80%);\n    --border-radius-e5129cde634ebedc5b44d3c50a36d58b65129a1e: 6px;\n\n    position: fixed;\n    top: var(--drag-top-737ad0c0838ca0307f6d25b24cebb7846196db72, calc(100% - var(--initial-height-495e116479cd0a7f6c7e692d6f9bdccbce49be36)));\n    left: var(--drag-left-0481d18ee27dc8bdf676134913f1eab609bbb7f7, calc(100% - var(--initial-width-34ea83cc4f4c691432fc64a891f4be0f53ecd5fa)));\n    height: var(--initial-height-495e116479cd0a7f6c7e692d6f9bdccbce49be36);\n    width: var(--initial-width-34ea83cc4f4c691432fc64a891f4be0f53ecd5fa);\n\n    --foreground-color-58da031e86887b92a1feaf5e8052dd5c83e23b4d: var(--external-foreground-color-5de188c61cf6701393a6300181cad2c723ea246c, #717171);\n    --background-color-b3200fc721c2f9f2b2d7b295b0ef23343df6f092: var(\n        --external-background-color-bb20739c0fcb55a95dfe902adb5bd01a0380425f,\n        rgba(247, 251, 255, 0.8)\n    );\n\n    color: var(--foreground-color-58da031e86887b92a1feaf5e8052dd5c83e23b4d);\n    background: var(--background-color-b3200fc721c2f9f2b2d7b295b0ef23343df6f092);\n    backdrop-filter: blur(6px);\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);\n    z-index: 10000;\n    border-radius: var(--border-radius-e5129cde634ebedc5b44d3c50a36d58b65129a1e);\n\n    overflow: auto;\n    resize: both;\n    display: flex;\n    flex-direction: column;\n}\n\n.dialog-59a53fe03e3575e542ce8529fd0df0730794d761.maximized-153d4ccb93d0dc13d48f201dd533f39d0bbc8ced {\n    /* resize: both \u306B\u3088\u3063\u3066\u30D6\u30E9\u30A6\u30B6\u306B\u3088\u3063\u3066\u8A2D\u5B9A\u3055\u308C\u305F\u30A4\u30F3\u30E9\u30A4\u30F3\u30B9\u30BF\u30A4\u30EB\u3092\u4E0A\u66F8\u304D\u3059\u308B\u305F\u3081 */\n    width: 100% !important;\n    height: 100% !important;\n    left: 0;\n    top: 0;\n    resize: none;\n}\n\n.dialog-59a53fe03e3575e542ce8529fd0df0730794d761.minimized-b1fe5ca90f7af0d447dd92c120b85309a6bffdfe {\n    resize: none;\n\n    /* resize: both \u306B\u3088\u3063\u3066\u30D6\u30E9\u30A6\u30B6\u306B\u3088\u3063\u3066\u8A2D\u5B9A\u3055\u308C\u305F\u30A4\u30F3\u30E9\u30A4\u30F3\u30B9\u30BF\u30A4\u30EB\u3092\u4E0A\u66F8\u304D\u3059\u308B\u305F\u3081 */\n    width: auto !important;\n    height: auto !important;\n}\n\n.titlebar-77f4f2a0b714f05efd6878ddb3f8362533a260f1 {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    align-content: center;\n    user-select: none;\n    touch-action: none;\n\n    padding: 2px 4px;\n\n    background-color: #e5e7eb;\n    border-radius: var(--border-radius-e5129cde634ebedc5b44d3c50a36d58b65129a1e) var(--border-radius-e5129cde634ebedc5b44d3c50a36d58b65129a1e) 0 0;\n}\n\n.titlebar-icon-412b1d35c34f2f49f26bd6a3dc81001c27e0fe4b {\n    width: 16px;\n    height: 16px;\n    margin-right: 8px;\n}\n\n.titlebar-title-140e5b86835d843d6f9a7c022dae1a3bf76fd116 {\n    display: flex;\n    justify-content: center;\n    flex-grow: 1;\n\n    cursor: move;\n}\n\n.titlebar-right-controls-b99876a673652ed87e84d15f17ba6f9b394c2846 {\n    display: flex;\n    align-items: center;\n}\n\n.titlebar-button-2acc5baf768eb39ffacca5d5359121c9ce7ee90f {\n    color: var(--foreground-color-58da031e86887b92a1feaf5e8052dd5c83e23b4d);\n    background: none;\n    border: none;\n    cursor: pointer;\n    padding: 0 12px;\n}\n\n.titlebar-button-2acc5baf768eb39ffacca5d5359121c9ce7ee90f::before {\n    color: var(--foreground-color-58da031e86887b92a1feaf5e8052dd5c83e23b4d);\n}\n\n.maximize-toggle-button-7fa903373c55bc3db348e90f211001c4f117f7d1::before {\n    content: "\u25A1";\n}\n\n.maximized-153d4ccb93d0dc13d48f201dd533f39d0bbc8ced .maximize-toggle-button-7fa903373c55bc3db348e90f211001c4f117f7d1::before {\n    content: "\u2750";\n}\n\n.minimize-toggle-button-bca3fbdc7dd23b6c26035e7111aeb869dd28182e::before {\n    content: "\uFF3F";\n}\n\n.minimized-b1fe5ca90f7af0d447dd92c120b85309a6bffdfe .minimize-toggle-button-bca3fbdc7dd23b6c26035e7111aeb869dd28182e::before {\n    content: "\u2750";\n}\n\n.minimized-b1fe5ca90f7af0d447dd92c120b85309a6bffdfe .titlebar-button-2acc5baf768eb39ffacca5d5359121c9ce7ee90f:not(.minimize-toggle-button-bca3fbdc7dd23b6c26035e7111aeb869dd28182e) {\n    display: none;\n}\n\n.inner-container-606dc1192fb95b445129198ee621c32f887ea204 {\n    flex-grow: 1;\n    overflow: auto;\n}\n\n.minimized-b1fe5ca90f7af0d447dd92c120b85309a6bffdfe .inner-container-606dc1192fb95b445129198ee621c32f887ea204 {\n    display: none;\n}\n';
  var variables = {
    "--initial-height": "--initial-height-495e116479cd0a7f6c7e692d6f9bdccbce49be36",
    "--initial-width": "--initial-width-34ea83cc4f4c691432fc64a891f4be0f53ecd5fa",
    "--border-radius": "--border-radius-e5129cde634ebedc5b44d3c50a36d58b65129a1e",
    "--drag-top": "--drag-top-737ad0c0838ca0307f6d25b24cebb7846196db72",
    "--drag-left": "--drag-left-0481d18ee27dc8bdf676134913f1eab609bbb7f7",
    "--foreground-color": "--foreground-color-58da031e86887b92a1feaf5e8052dd5c83e23b4d",
    "--external-foreground-color": "--external-foreground-color-5de188c61cf6701393a6300181cad2c723ea246c",
    "--background-color": "--background-color-b3200fc721c2f9f2b2d7b295b0ef23343df6f092",
    "--external-background-color": "--external-background-color-bb20739c0fcb55a95dfe902adb5bd01a0380425f"
  };
  var dialog_default = {
    dialog: "dialog-59a53fe03e3575e542ce8529fd0df0730794d761",
    maximized: "maximized-153d4ccb93d0dc13d48f201dd533f39d0bbc8ced",
    minimized: "minimized-b1fe5ca90f7af0d447dd92c120b85309a6bffdfe",
    titlebar: "titlebar-77f4f2a0b714f05efd6878ddb3f8362533a260f1",
    "titlebar-icon": "titlebar-icon-412b1d35c34f2f49f26bd6a3dc81001c27e0fe4b",
    "titlebar-title": "titlebar-title-140e5b86835d843d6f9a7c022dae1a3bf76fd116",
    "titlebar-right-controls": "titlebar-right-controls-b99876a673652ed87e84d15f17ba6f9b394c2846",
    "titlebar-button": "titlebar-button-2acc5baf768eb39ffacca5d5359121c9ce7ee90f",
    "maximize-toggle-button": "maximize-toggle-button-7fa903373c55bc3db348e90f211001c4f117f7d1",
    "minimize-toggle-button": "minimize-toggle-button-bca3fbdc7dd23b6c26035e7111aeb869dd28182e",
    "inner-container": "inner-container-606dc1192fb95b445129198ee621c32f887ea204"
  };

  // source/document-jsx/jsx-runtime.ts
  function jsxs(name, properties, _option) {
    if (name === Fragment) {
      return createFragment(
        properties.children
      );
    }
    const element = document.createElement(name);
    for (const [key, value] of Object.entries(properties ?? {})) {
      if (key === "children") continue;
      if (key.startsWith("on") && typeof value === "function") {
        const eventName = key.substring(2).toLowerCase();
        element.addEventListener(eventName, value);
        continue;
      }
      if (key === "style" && typeof value === "function") {
        value(element.style);
        continue;
      }
      if (key === "classList" && value) {
        const classes = Array.isArray(value) ? value : [value];
        for (const c of classes) {
          if (typeof c === "string" && c) {
            element.classList.add(c);
          }
        }
        continue;
      }
      if (value !== void 0 && value !== null) {
        element.setAttribute(key, String(value));
      }
    }
    const children = properties?.children;
    if (children) {
      if (Array.isArray(children)) {
        for (const child of children) {
          if (!child) continue;
          element.append(child);
        }
      } else {
        element.append(children);
      }
    }
    return element;
  }
  var jsx = jsxs;
  var Fragment = /* @__PURE__ */ Symbol("Fragment");
  function createFragment(children) {
    const fragment = document.createDocumentFragment();
    if (children != null) {
      if (Array.isArray(children)) {
        for (const child of children) {
          fragment.appendChild(child);
        }
      } else {
        fragment.appendChild(children);
      }
    }
    return fragment;
  }

  // source/drafts-view/dialog.tsx
  function makeDraggable(element, handleElement = element, options) {
    let offsetX = 0, offsetY = 0;
    function setPosition(left, top) {
      const rect = element.getBoundingClientRect();
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      left = Math.max(0, Math.min(left, windowWidth - rect.width));
      top = Math.max(0, Math.min(top, windowHeight - rect.height));
      if (options?.propertyNames) {
        const { left: leftName, top: topName } = options.propertyNames;
        element.style.setProperty(leftName, `${left}px`);
        element.style.setProperty(topName, `${top}px`);
      } else {
        element.style.left = `${left}px`;
        element.style.top = `${top}px`;
      }
    }
    const onPointerMove = (e) => {
      setPosition(e.clientX - offsetX, e.clientY - offsetY);
    };
    handleElement.addEventListener("pointerdown", (e) => {
      handleElement.addEventListener("pointermove", onPointerMove);
      handleElement.setPointerCapture(e.pointerId);
      offsetX = e.clientX - element.offsetLeft;
      offsetY = e.clientY - element.offsetTop;
    });
    handleElement.addEventListener("pointerup", (e) => {
      handleElement.removeEventListener("pointermove", onPointerMove);
      handleElement.releasePointerCapture(e.pointerId);
    });
    function adjustSize() {
      const rect = element.getBoundingClientRect();
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      if (rect.width > windowWidth) {
        element.style.width = `${windowWidth}px`;
      }
      if (rect.height > windowHeight) {
        element.style.height = `${windowHeight}px`;
      }
      setPosition(rect.left, rect.top);
    }
    window.addEventListener("resize", adjustSize);
    adjustSize();
  }
  function createDialog(innerElement, options) {
    const minimizeToggleButton = /* @__PURE__ */ jsx(
      "button",
      {
        class: dialog_default["titlebar-button"] + " " + dialog_default["minimize-toggle-button"],
        title: "minimize"
      }
    );
    const maximizeToggleButton = /* @__PURE__ */ jsx(
      "button",
      {
        class: dialog_default["titlebar-button"] + " " + dialog_default["maximize-toggle-button"],
        title: "maximize"
      }
    );
    const closeButton = /* @__PURE__ */ jsx("button", { class: dialog_default["titlebar-button"], title: "close", children: "\xD7" });
    const titleSpan = /* @__PURE__ */ jsx("div", { class: dialog_default["titlebar-title"], children: options?.title ?? "" });
    const titleBar = /* @__PURE__ */ jsxs("div", { class: dialog_default["titlebar"], children: [
      titleSpan,
      /* @__PURE__ */ jsxs("div", { class: dialog_default["titlebar-right-controls"], children: [
        minimizeToggleButton,
        maximizeToggleButton,
        closeButton
      ] })
    ] });
    const dialogElement = /* @__PURE__ */ jsxs("div", { class: dialog_default["dialog"], children: [
      titleBar,
      /* @__PURE__ */ jsx("div", { class: dialog_default["inner-container"], children: innerElement })
    ] });
    titleBar.addEventListener("dblclick", toggleMaximizedState);
    minimizeToggleButton.addEventListener("click", toggleMinimizedState);
    maximizeToggleButton.addEventListener("click", toggleMaximizedState);
    closeButton.addEventListener("click", hide);
    makeDraggable(dialogElement, titleSpan, {
      propertyNames: {
        left: variables["--drag-left"],
        top: variables["--drag-top"]
      }
    });
    function show() {
      document.body.appendChild(dialogElement);
    }
    function hide() {
      document.body.removeChild(dialogElement);
    }
    function toggleMaximizedState() {
      dialogElement.classList.remove(dialog_default["minimized"]);
      dialogElement.classList.toggle(dialog_default["maximized"]);
    }
    function toggleMinimizedState() {
      dialogElement.classList.remove(dialog_default["maximized"]);
      dialogElement.classList.toggle(dialog_default["minimized"]);
    }
    return {
      show,
      hide,
      cssText: cssText3,
      element: dialogElement,
      setTitle(title) {
        titleSpan.innerHTML = "";
        titleSpan.append(title);
      },
      setForegroundColor(cssColorText) {
        dialogElement.style.setProperty(
          variables["--external-foreground-color"],
          cssColorText
        );
      },
      setBackgroundColor(cssColorText) {
        dialogElement.style.setProperty(
          variables["--external-background-color"],
          cssColorText
        );
      }
    };
  }

  // source/drafts-view/draft-list.module.css
  var cssText4 = ':root {\n    --border-color-c0890b11309ce8d35dc919f9d74de8e2362a56d1: #ccc;\n    --selected-background-color-d7f64ef7b890bbee7594cf5bc100828d41a3dd1f: #2563eb;\n    --selected-text-color-5a2b8755b80ad982504d46984d53151452db01b4: #fff;\n    --text-muted-bf5a19b1afbc0854f0a50ce10012b81f9883028b: #666;\n    --background-color-light-312fa40164e25efde6a346554297557cd49e68a2: #f8f9fa;\n    --primary-color-0ecf8e681c0883ab213d2c7c6a40d94bda12b44a: #2563eb;\n    --primary-color-dark-7390d1dc3790bb3c7a619222dfda25647e8f625a: #0056b3;\n}\n\n.container-a8e27d697d0bc425baf3dc2c5242337e753177a8 {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n}\n\n.input-field-947438d7c2c2b36f5b2c83ef0155735354bfa216 {\n    border: 1px solid;\n    border-color: rgba(255, 255, 255, 0.514) rgba(255, 255, 255, 0.726) white;\n    background-color: rgba(255, 255, 255, 0.25);\n    outline: none;\n}\n\n.input-field-947438d7c2c2b36f5b2c83ef0155735354bfa216:focus {\n    background-color: #ffffff;\n    border-color: #cbd5e1;\n    box-shadow: 0 0 0 3px rgba(203, 213, 225, 0.35);\n}\n\n.input-error-a3d58ba035f3034ca9a070c9fc80243539479b90 {\n    border: 1px solid red;\n}\n\n.search-input-8382bbc6e67a7ef46f07fa2f9de75722fbfdc642 {\n    padding: 8px;\n    margin-bottom: 8px;\n    border-radius: 4px;\n}\n\n.list-container-ce7be2434a7bb81b1d987632aa71b41a61e94948 {\n    flex-grow: 1;\n    overflow-y: auto;\n    border: 1px solid var(--border-color-c0890b11309ce8d35dc919f9d74de8e2362a56d1);\n    border-radius: 4px;\n}\n\n.item-dbe64dceaaaccd57dbe04af327db992280635bcf {\n    height: 100%;\n    display: flex;\n    align-items: center;\n    flex-grow: 1;\n    min-width: 0;\n    padding: 4px;\n    border-bottom: 1px solid var(--border-color-c0890b11309ce8d35dc919f9d74de8e2362a56d1);\n    cursor: pointer;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n\n.item-dbe64dceaaaccd57dbe04af327db992280635bcf:last-child {\n    border-bottom: none;\n}\n\n.item-dbe64dceaaaccd57dbe04af327db992280635bcf.selected-bc18875271f8766e50b7f8a87e3580ff887f8f69 {\n    background-color: var(--selected-background-color-d7f64ef7b890bbee7594cf5bc100828d41a3dd1f);\n    color: var(--selected-text-color-5a2b8755b80ad982504d46984d53151452db01b4);\n}\n\n.item-dbe64dceaaaccd57dbe04af327db992280635bcf.selected-bc18875271f8766e50b7f8a87e3580ff887f8f69 .item-note-7b19d49cc782813c2c4430282830d4592546b811 {\n    color: var(--selected-text-color-5a2b8755b80ad982504d46984d53151452db01b4);\n}\n\n.item-name-8b4812ea97d1ea2711e4a9ccf6d6ed4ec6fa9d87 {\n    font-weight: bold;\n    flex-shrink: 0;\n    margin-right: 4px;\n}\n\n.item-note-7b19d49cc782813c2c4430282830d4592546b811 {\n    font-size: 0.8em;\n    color: var(--text-muted-bf5a19b1afbc0854f0a50ce10012b81f9883028b);\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.detail-pane-af0595b4c6c4cc9d12999d1e98557852b8887ad9 {\n    box-shadow: 0px 0px 4px 0px rgba(0, 0, 0, 0.5);\n    border: 1px solid var(--border-color-c0890b11309ce8d35dc919f9d74de8e2362a56d1);\n    border-radius: 4px;\n    flex-shrink: 0;\n    padding: 0;\n}\n\n.detail-summary-40e2841fe4051eee9c401d3e29aaedc07fb3b38b {\n    list-style: none;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    cursor: pointer;\n    padding: 16px;\n}\n\n/* Webkit\u30D6\u30E9\u30A6\u30B6\u306E\u30C7\u30D5\u30A9\u30EB\u30C8\u30DE\u30FC\u30AB\u30FC\u3092\u975E\u8868\u793A\u306B\u3059\u308B */\n.detail-summary-40e2841fe4051eee9c401d3e29aaedc07fb3b38b::-webkit-details-marker {\n    display: none;\n}\n\n/* \u9589\u3058\u305F\u3068\u304D\u306E\u30A2\u30A4\u30B3\u30F3 */\n.detail-summary-40e2841fe4051eee9c401d3e29aaedc07fb3b38b::after {\n    content: "+";\n    font-size: 1.5em;\n    line-height: 1;\n    margin-left: 10px;\n}\n\n/* \u958B\u3044\u305F\u3068\u304D\u306E\u30A2\u30A4\u30B3\u30F3 */\n.detail-pane-af0595b4c6c4cc9d12999d1e98557852b8887ad9[open] > .detail-summary-40e2841fe4051eee9c401d3e29aaedc07fb3b38b::after {\n    content: "\u2212";\n}\n\n.detail-name-ba6028060f6ac583f1a090d3d621f7e2838c59b7 {\n    flex-grow: 1;\n    font-size: 1.2em;\n    font-weight: bold;\n    margin-bottom: 0;\n}\n\n.detail-description-4cc3c15a0fd85d0cbdc664b3d9ba1aeb48e207fc,\n.detail-note-bebf9fd1e3f2d012bad93b70c10582b9bc286ccc,\n.detail-coordinates-6bdc32729f5f8243f746b936016d369867ca41d5 {\n    margin-bottom: 4px;\n    padding: 0;\n    width: 100%;\n    box-sizing: border-box;\n}\n\n.detail-content-wrapper-9cdfbd2c49202411e49954e145abab5307d92d79 {\n    padding: 0 16px 16px 16px;\n    display: flex;\n    flex-wrap: wrap;\n    gap: 8px;\n}\n\n.map-button-1aaab2651dc3a0efbec0c08bb4eeebb22fd5feb7,\n.create-button-3b2f85fe1bfd1b845e8234db1ab125c6832394a3,\n.delete-button-27f9ef387904083464a03e980a246c11a491a4f1,\n.template-button-80a3eb211221ef1108e4bda1a5194790c46cf234,\n.config-button-1307b5b58b3594065b5da7f8f52057969ff228bc {\n    margin-top: 8px;\n    padding: 8px 12px;\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n}\n\n.map-button-1aaab2651dc3a0efbec0c08bb4eeebb22fd5feb7,\n.create-button-3b2f85fe1bfd1b845e8234db1ab125c6832394a3,\n.template-button-80a3eb211221ef1108e4bda1a5194790c46cf234,\n.config-button-1307b5b58b3594065b5da7f8f52057969ff228bc {\n    background-color: var(--primary-color-0ecf8e681c0883ab213d2c7c6a40d94bda12b44a);\n}\n\n.map-button-1aaab2651dc3a0efbec0c08bb4eeebb22fd5feb7:hover,\n.create-button-3b2f85fe1bfd1b845e8234db1ab125c6832394a3:hover,\n.template-button-80a3eb211221ef1108e4bda1a5194790c46cf234:hover,\n.config-button-1307b5b58b3594065b5da7f8f52057969ff228bc:hover {\n    background-color: var(--primary-color-dark-7390d1dc3790bb3c7a619222dfda25647e8f625a);\n}\n\n.delete-button-27f9ef387904083464a03e980a246c11a491a4f1 {\n    background-color: #dc3545;\n}\n\n.delete-button-27f9ef387904083464a03e980a246c11a491a4f1:hover {\n    background-color: #c82333;\n}\n\n.template-button-80a3eb211221ef1108e4bda1a5194790c46cf234.is-template-c7ffcfb1efec5490c003e4d9ca280d39af93abd9 {\n    background-color: #28a745;\n}\n\n.template-button-80a3eb211221ef1108e4bda1a5194790c46cf234.is-template-c7ffcfb1efec5490c003e4d9ca280d39af93abd9:hover {\n    background-color: #218838;\n}\n\n.input-error-a3d58ba035f3034ca9a070c9fc80243539479b90 {\n    border: 1px solid red;\n    background-color: #c82333;\n}\n';
  var draft_list_default = {
    container: "container-a8e27d697d0bc425baf3dc2c5242337e753177a8",
    "input-field": "input-field-947438d7c2c2b36f5b2c83ef0155735354bfa216",
    "input-error": "input-error-a3d58ba035f3034ca9a070c9fc80243539479b90",
    "search-input": "search-input-8382bbc6e67a7ef46f07fa2f9de75722fbfdc642",
    "list-container": "list-container-ce7be2434a7bb81b1d987632aa71b41a61e94948",
    item: "item-dbe64dceaaaccd57dbe04af327db992280635bcf",
    selected: "selected-bc18875271f8766e50b7f8a87e3580ff887f8f69",
    "item-note": "item-note-7b19d49cc782813c2c4430282830d4592546b811",
    "item-name": "item-name-8b4812ea97d1ea2711e4a9ccf6d6ed4ec6fa9d87",
    "detail-pane": "detail-pane-af0595b4c6c4cc9d12999d1e98557852b8887ad9",
    "detail-summary": "detail-summary-40e2841fe4051eee9c401d3e29aaedc07fb3b38b",
    "detail-name": "detail-name-ba6028060f6ac583f1a090d3d621f7e2838c59b7",
    "detail-description": "detail-description-4cc3c15a0fd85d0cbdc664b3d9ba1aeb48e207fc",
    "detail-note": "detail-note-bebf9fd1e3f2d012bad93b70c10582b9bc286ccc",
    "detail-coordinates": "detail-coordinates-6bdc32729f5f8243f746b936016d369867ca41d5",
    "detail-content-wrapper": "detail-content-wrapper-9cdfbd2c49202411e49954e145abab5307d92d79",
    "map-button": "map-button-1aaab2651dc3a0efbec0c08bb4eeebb22fd5feb7",
    "create-button": "create-button-3b2f85fe1bfd1b845e8234db1ab125c6832394a3",
    "delete-button": "delete-button-27f9ef387904083464a03e980a246c11a491a4f1",
    "template-button": "template-button-80a3eb211221ef1108e4bda1a5194790c46cf234",
    "config-button": "config-button-1307b5b58b3594065b5da7f8f52057969ff228bc",
    "is-template": "is-template-c7ffcfb1efec5490c003e4d9ca280d39af93abd9"
  };

  // source/drafts-view/virtual-list.module.css
  var cssText5 = ".list-window-bcd08fce6b1a595356880a5a598137912e379aee {\n    height: 100%;\n    overflow: auto;\n}\n\n.list-spacer-32059099ba781e882b7ae69bcd971a9b66d151a8 {\n    box-sizing: border-box;\n    height: var(--list-height-601758becf7d7867f70930534784cc2ddcc8fb22);\n    padding-top: var(--list-offset-top-fcb56bf845280fbeb22cda5501878b68a331e405);\n}\n\n.list-fffb82a022c6017f97dfdac45113ef61fa81fe9c {\n    list-style-type: none;\n    margin: 0;\n    padding: 0;\n}\n\n.item-519dd442a3657bdc57c1e482401f339cee8003a2 {\n    height: var(--item-height-c5da2f0d91ae8c90a7f14e92fce1ba40bfd0b3ec);\n}\n";
  var variables2 = {
    "--list-height": "--list-height-601758becf7d7867f70930534784cc2ddcc8fb22",
    "--list-offset-top": "--list-offset-top-fcb56bf845280fbeb22cda5501878b68a331e405",
    "--item-height": "--item-height-c5da2f0d91ae8c90a7f14e92fce1ba40bfd0b3ec"
  };
  var virtual_list_default = {
    "list-window": "list-window-bcd08fce6b1a595356880a5a598137912e379aee",
    "list-spacer": "list-spacer-32059099ba781e882b7ae69bcd971a9b66d151a8",
    list: "list-fffb82a022c6017f97dfdac45113ef61fa81fe9c",
    item: "item-519dd442a3657bdc57c1e482401f339cee8003a2"
  };

  // source/drafts-view/virtual-list.tsx
  function createEmptyElements() {
    return {
      itemHeight: 0,
      count: 0,
      get() {
        return void 0;
      }
    };
  }
  function createVirtualList() {
    const list = /* @__PURE__ */ jsx("ul", { class: virtual_list_default["list"] });
    const listSpacer = /* @__PURE__ */ jsx("div", { class: virtual_list_default["list-spacer"], children: list });
    const listWindow = /* @__PURE__ */ jsx("div", { class: virtual_list_default["list-window"], children: listSpacer });
    let items = createEmptyElements();
    let redrawRequested = true;
    let lastStart = null;
    let lastCount = null;
    function update() {
      const { scrollTop, offsetHeight: windowHeight } = listWindow;
      const { itemHeight, count: itemCount } = items;
      const start = Math.floor(scrollTop / itemHeight);
      const count = Math.min(
        itemCount,
        Math.ceil((scrollTop + windowHeight) / itemHeight)
      ) - start;
      redrawRequested = redrawRequested || lastStart !== start || lastCount !== count;
      lastStart = start;
      lastCount = count;
      if (!redrawRequested) return;
      redrawRequested = false;
      list.innerHTML = "";
      for (let i = 0; i < count; i++) {
        list.append(
          /* @__PURE__ */ jsx("li", { class: virtual_list_default.item, children: items.get(start + i) })
        );
      }
      listWindow.style.setProperty(
        variables2["--item-height"],
        itemHeight + "px"
      );
      listWindow.style.setProperty(
        variables2["--list-height"],
        itemHeight * itemCount + "px"
      );
      listWindow.style.setProperty(
        variables2["--list-offset-top"],
        start * itemHeight + "px"
      );
    }
    function setItems(newItems) {
      items = newItems;
      redrawRequested = true;
      return update();
    }
    listWindow.addEventListener("scroll", update);
    new ResizeObserver((entries) => {
      for (const _ of entries) void update();
    }).observe(listWindow);
    return {
      element: listWindow,
      cssText: cssText5,
      setItems
    };
  }

  // source/draft.ts
  function setDraftIsTemplate(draft, isTemplate) {
    draft.data["isTemplate"] = isTemplate || void 0;
  }
  function getDraftIsTemplate(draft) {
    return draft.data["isTemplate"] === true;
  }
  function pad2(value) {
    return ("00" + value).slice(-2);
  }
  function getIsoTodayString(date5) {
    const yyyy = date5.getFullYear();
    const mm = pad2(date5.getMonth() + 1);
    const dd = pad2(date5.getDate());
    return `${yyyy}-${mm}-${dd}`;
  }
  function getIsoTimeString(date5) {
    const hours = pad2(date5.getHours());
    const minutes = pad2(date5.getMinutes());
    const seconds = pad2(date5.getSeconds());
    return `${hours}:${minutes}:${seconds}`;
  }
  function getIsoTimeZoneString(date5) {
    const offset = -date5.getTimezoneOffset();
    const sign = offset >= 0 ? "+" : "-";
    const hours = pad2(offset / 60);
    const minutes = pad2(offset % 60);
    return `${sign}${hours}:${minutes}`;
  }
  function getIsoDateTimeString(date5, withTimeZone = false) {
    return `${getIsoTodayString(date5)}T${getIsoTimeString(date5)}${withTimeZone ? getIsoTimeZoneString(date5) : ""}`;
  }
  function resolveStandardVariable(name) {
    switch (name) {
      case "today":
        return getIsoTodayString(/* @__PURE__ */ new Date());
      case "now":
        return getIsoDateTimeString(/* @__PURE__ */ new Date());
      case "nowWithTimeZone":
        return getIsoDateTimeString(/* @__PURE__ */ new Date(), true);
    }
  }
  var interpolationPattern = /\\\(\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)/g;
  function applyTemplate(template, resolve) {
    return template.replace(
      interpolationPattern,
      (interpolation, variableName) => resolve?.(variableName) ?? resolveStandardVariable(variableName) ?? interpolation
    );
  }

  // source/local-config-view/local-config-view.module.css
  var cssText6 = ".container-f1dab241a09bb3df58f56a71a1860677b51f2515 {\n    box-sizing: border-box;\n}\n\n.container-f1dab241a09bb3df58f56a71a1860677b51f2515 {\n    width: 100%;\n    height: 100%;\n    padding: 24px;\n    color: #1f2937;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.form-scroll-2e3ac2fd8bc51e6f171db04ef7d943ff85b90020 {\n    overflow-y: auto;\n    padding-right: 4px;\n    margin-right: -4px;\n    flex: 1 1 auto;\n}\n\n.status-message-c256dff5faa609e9d6ec55dc16d17267529c8bdc {\n    margin-top: auto;\n    font-size: 13px;\n    color: #6b7280;\n    padding-top: 10px;\n    border-radius: 8px;\n    transition:\n        background-color 0.2s ease,\n        color 0.2s ease,\n        border-color 0.2s ease;\n}\n\n.status-message-c256dff5faa609e9d6ec55dc16d17267529c8bdc.success-2e73314ef49e2ec643b73bff4583ac0097498f92 {\n    color: #065f46;\n    background-color: #ecfdf5;\n    border: 1px solid #a7f3d0;\n    padding: 10px 12px;\n}\n\n.status-message-c256dff5faa609e9d6ec55dc16d17267529c8bdc.error-683e02068e71c66e6211aa9a1b8738688ff5ad26 {\n    color: #7f1d1d;\n    background-color: #fef2f2;\n    border: 1px solid #fecaca;\n    padding: 10px 12px;\n}\n";
  var local_config_view_default = {
    container: "container-f1dab241a09bb3df58f56a71a1860677b51f2515",
    "form-scroll": "form-scroll-2e3ac2fd8bc51e6f171db04ef7d943ff85b90020",
    "status-message": "status-message-c256dff5faa609e9d6ec55dc16d17267529c8bdc",
    success: "success-2e73314ef49e2ec643b73bff4583ac0097498f92",
    error: "error-683e02068e71c66e6211aa9a1b8738688ff5ad26"
  };

  // source/local-config-view/item-input.module.css
  var cssText7 = ".form-group-e5a3430126ab0369fd7ee8a6a30580ffad360df7 {\n    width: 100%;\n    margin-bottom: 18px;\n    display: flex;\n    flex-direction: column;\n    flex-shrink: 0;\n}\n\n.form-group-e5a3430126ab0369fd7ee8a6a30580ffad360df7 {\n    width: 100%;\n    margin-bottom: 18px;\n    display: flex;\n    flex-direction: column;\n    flex-shrink: 0;\n}\n\n.label-5d97d2385d3fe4f8201f867470d9a372143c929f {\n    font-size: 13px;\n    font-weight: 500;\n    margin-bottom: 6px;\n    color: #374151;\n}\n\n.input-d67df4267ce56bfa6a39eaade32c4f8c68e12ce0,\n.textarea-f6272e46e885340c7cfafd8e922bfd093e4269d4 {\n    width: 100%;\n    border: 1px solid #e5e7eb;\n    background-color: #ffffff;\n    border-radius: 8px;\n    padding: 10px 12px;\n    font-size: 14px;\n    color: #111827;\n    outline: none;\n    transition:\n        border-color 0.2s ease,\n        box-shadow 0.2s ease;\n}\n\n.input-d67df4267ce56bfa6a39eaade32c4f8c68e12ce0:focus,\n.textarea-f6272e46e885340c7cfafd8e922bfd093e4269d4:focus {\n    border-color: #cbd5e1;\n    box-shadow: 0 0 0 3px rgba(203, 213, 225, 0.35);\n}\n\n.checkbox-40de0e9fd90c64b05aa39b0981eff0ac2c2c3b16 {\n    width: 16px;\n    height: 16px;\n    margin-right: 8px;\n    vertical-align: middle;\n}\n\n.textarea-f6272e46e885340c7cfafd8e922bfd093e4269d4 {\n    min-height: 120px;\n    resize: vertical;\n    line-height: 1.5;\n}\n";
  var item_input_default = {
    "form-group": "form-group-e5a3430126ab0369fd7ee8a6a30580ffad360df7",
    label: "label-5d97d2385d3fe4f8201f867470d9a372143c929f",
    input: "input-d67df4267ce56bfa6a39eaade32c4f8c68e12ce0",
    textarea: "textarea-f6272e46e885340c7cfafd8e922bfd093e4269d4",
    checkbox: "checkbox-40de0e9fd90c64b05aa39b0981eff0ac2c2c3b16"
  };

  // source/local-config-view/item-input-string.tsx
  function createStringItemInput(label) {
    const events = createTypedEventTarget();
    const input = /* @__PURE__ */ jsx("input", { type: "text", class: item_input_default["input"] });
    const enabledCheckbox = /* @__PURE__ */ jsx("input", { type: "checkbox", class: item_input_default["checkbox"] });
    const inputContainer = /* @__PURE__ */ jsx("div", { class: item_input_default["form-group"], children: /* @__PURE__ */ jsx("label", { class: item_input_default["label"], children: input }) });
    const element = /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx("div", { class: item_input_default["form-group"], children: /* @__PURE__ */ jsxs("label", { class: item_input_default["label"], children: [
        enabledCheckbox,
        /* @__PURE__ */ jsx("span", { children: label })
      ] }) }),
      inputContainer
    ] });
    const onChanged = () => events.dispatchEvent(createTypedCustomEvent("changed", void 0));
    enabledCheckbox.addEventListener("change", () => {
      const isChecked = enabledCheckbox.checked;
      input.disabled = !isChecked;
      inputContainer.style.display = isChecked ? "" : "none";
      onChanged();
    });
    input.addEventListener("input", onChanged);
    function setValue(value) {
      const hasUserId = value !== void 0;
      enabledCheckbox.checked = hasUserId;
      input.disabled = !hasUserId;
      inputContainer.style.display = hasUserId ? "" : "none";
      input.value = hasUserId ? value ?? "" : "";
    }
    function getValue2() {
      if (enabledCheckbox.checked) {
        return input.value;
      }
    }
    return {
      element,
      cssText: cssText7,
      events,
      setValue,
      getValue: getValue2
    };
  }

  // source/local-config-view/item-input-json.tsx
  function createJsonItemInput(label) {
    const events = createTypedEventTarget();
    const textarea = /* @__PURE__ */ jsx("textarea", { class: item_input_default["textarea"] });
    const enabledCheckbox = /* @__PURE__ */ jsx("input", { type: "checkbox", class: item_input_default["checkbox"] });
    const inputContainer = /* @__PURE__ */ jsx("div", { class: item_input_default["form-group"], children: /* @__PURE__ */ jsx("label", { class: item_input_default["label"], children: textarea }) });
    const element = /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx("div", { class: item_input_default["form-group"], children: /* @__PURE__ */ jsxs("label", { class: item_input_default["label"], children: [
        enabledCheckbox,
        /* @__PURE__ */ jsx("span", { children: label })
      ] }) }),
      inputContainer
    ] });
    function setValue(value) {
      const hasValue = value !== void 0;
      enabledCheckbox.checked = hasValue;
      textarea.disabled = !hasValue;
      inputContainer.style.display = hasValue ? "" : "none";
      textarea.value = hasValue ? JSON.stringify(value, null, 2) : "";
    }
    function getValue2() {
      if (enabledCheckbox.checked) {
        try {
          const parsedJson = JSON.parse(textarea.value);
          return parsedJson;
        } catch {
          throw new Error("Invalid JSON. Please check the syntax.");
        }
      }
    }
    const onChange = () => events.dispatchEvent(createTypedCustomEvent("changed", void 0));
    enabledCheckbox.addEventListener("change", () => {
      const isChecked = enabledCheckbox.checked;
      textarea.disabled = !isChecked;
      inputContainer.style.display = isChecked ? "" : "none";
      onChange();
    });
    textarea.addEventListener("input", onChange);
    return {
      element,
      cssText: cssText7,
      events,
      setValue,
      getValue: getValue2
    };
  }

  // source/local-config-view/local-config-view.tsx
  function debounce(f, ms) {
    let timeout;
    const debounced = (...args) => {
      if (timeout !== void 0) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(() => {
        timeout = void 0;
        f(...args);
      }, ms);
    };
    const cancel = () => {
      if (timeout !== void 0) {
        clearTimeout(timeout);
        timeout = void 0;
      }
    };
    return {
      debounced,
      cancel
    };
  }
  function createLocalConfigView(configAccessor) {
    const userIdInput = createStringItemInput("User ID");
    const apiRootInput = createStringItemInput("API Root");
    const dictionariesInput = createJsonItemInput("Dictionaries(JSON)");
    const statusMessageElement = /* @__PURE__ */ jsx("div", { class: local_config_view_default["status-message"], children: "Loading configuration..." });
    const element = /* @__PURE__ */ jsxs("div", { class: local_config_view_default["container"], children: [
      /* @__PURE__ */ jsxs("div", { class: local_config_view_default["form-scroll"], children: [
        userIdInput.element,
        apiRootInput.element,
        dictionariesInput.element
      ] }),
      statusMessageElement
    ] });
    const loadConfig = () => {
      const currentConfig = configAccessor.getConfig();
      userIdInput.setValue(currentConfig.userId);
      apiRootInput.setValue(currentConfig.apiRoot);
      dictionariesInput.setValue(currentConfig.dictionaries);
    };
    const { debounced: saveConfig } = debounce(() => {
      statusMessageElement.textContent = "Changes pending...";
      statusMessageElement.className = local_config_view_default["status-message"];
      try {
        let newConfig = {
          version: "1"
        };
        newConfig = { ...newConfig, userId: userIdInput.getValue() };
        newConfig = { ...newConfig, apiRoot: apiRootInput.getValue() };
        newConfig = {
          ...newConfig,
          dictionaries: dictionariesInput.getValue()
        };
        ConfigSchema.parse(newConfig);
        configAccessor.setConfig(newConfig);
        statusMessageElement.textContent = "Saved successfully!";
        statusMessageElement.classList.add(local_config_view_default.success);
      } catch (error48) {
        let errorMessage = "Unknown error";
        if (error48 instanceof Error) {
          errorMessage = error48.message;
        }
        statusMessageElement.textContent = `Error saving configuration: ${errorMessage}`;
        statusMessageElement.classList.add(local_config_view_default.error);
      }
    }, 500);
    userIdInput.events.addEventListener("changed", saveConfig);
    apiRootInput.events.addEventListener("changed", saveConfig);
    dictionariesInput.events.addEventListener("changed", saveConfig);
    loadConfig();
    return {
      element,
      cssText: cssText6 + "\n" + userIdInput.cssText
    };
  }

  // source/drafts-view/draft-list.tsx
  function hasTermInString(text, term) {
    return text.toLowerCase().includes(term);
  }
  function hasTermInDraft({ name, description, note }, term) {
    return hasTermInString(name, term) || hasTermInString(description, term) || hasTermInString(note, term);
  }
  function createDraftList({ overlay, remote, local }) {
    const events = createTypedEventTarget();
    let allDrafts = Array.from(overlay.drafts.values()).map(
      (view) => view.draft
    );
    let filteredDrafts = [...allDrafts];
    let searchTerm = "";
    let selectedDraft = null;
    overlay.events.addEventListener("selection-changed", ({ detail: id2 }) => {
      if (id2 == null) {
        selectedDraft = null;
      } else {
        const draft = allDrafts.find((x) => x.id === id2);
        if (draft == null) return;
        selectedDraft = draft;
      }
      updateDetailPane();
      updateVirtualList();
    });
    overlay.events.addEventListener("draft-updated", ({ detail: id2 }) => {
      const draft = allDrafts.find((x) => x.id === id2);
      if (draft == null) return;
      updateDetailPane();
      updateVirtualList();
      saveDraftChanges(draft);
    });
    const dispatchCountUpdatedEvent = () => {
      events.dispatchEvent(
        createTypedCustomEvent("count-changed", {
          totalCount: allDrafts.length,
          filteredCount: filteredDrafts.length
        })
      );
    };
    dispatchCountUpdatedEvent();
    const saveDraftChanges = (draft) => {
      const { apiRoot, userId } = local.getConfig();
      if (!apiRoot || !userId) return;
      remote.set(
        {
          type: "route",
          "user-id": userId,
          "route-id": draft.id,
          "route-name": draft.name,
          coordinates: coordinatesToString(draft.coordinates),
          description: draft.description,
          note: draft.note,
          data: JSON.stringify(draft.data)
        },
        apiRoot
      );
    };
    const listContainer = /* @__PURE__ */ jsx("div", { class: draft_list_default["list-container"] });
    const {
      element: virtualListElement,
      setItems: setVirtualListItems,
      cssText: virtualListCssText
    } = createVirtualList();
    listContainer.append(virtualListElement);
    const searchInput = /* @__PURE__ */ jsx("input", { type: "search", placeholder: "Search drafts..." });
    searchInput.classList.add(
      draft_list_default["search-input"],
      draft_list_default["input-field"]
    );
    const detailName = /* @__PURE__ */ jsx("input", { type: "text", value: "" });
    detailName.classList.add(
      draft_list_default["detail-name"],
      draft_list_default["input-field"]
    );
    detailName.addEventListener("input", (event) => {
      if (!selectedDraft) return;
      selectedDraft.name = event.target.value;
      overlay.updateDraftTitle(selectedDraft);
      saveDraftChanges(selectedDraft);
    });
    const detailDescription = /* @__PURE__ */ jsx("textarea", { value: "" });
    detailDescription.classList.add(
      draft_list_default["detail-description"],
      draft_list_default["input-field"]
    );
    detailDescription.addEventListener("input", (event) => {
      if (!selectedDraft) return;
      selectedDraft.description = event.target.value;
      saveDraftChanges(selectedDraft);
    });
    const detailNote = /* @__PURE__ */ jsx("textarea", { class: draft_list_default["detail-note"], value: "" });
    detailNote.classList.add(
      draft_list_default["detail-note"],
      draft_list_default["input-field"]
    );
    detailNote.addEventListener("input", (event) => {
      if (!selectedDraft) return;
      selectedDraft.note = event.target.value;
      saveDraftChanges(selectedDraft);
    });
    const detailCoordinates = /* @__PURE__ */ jsx("input", { type: "text", value: "" });
    detailCoordinates.classList.add(
      draft_list_default["detail-coordinates"],
      draft_list_default["input-field"]
    );
    detailCoordinates.addEventListener("input", (event) => {
      if (!selectedDraft) return;
      const textarea = event.target;
      try {
        const newCoordinates = parseCoordinates(textarea.value);
        if (newCoordinates.length > 0) {
          selectedDraft.coordinates = newCoordinates;
          textarea.classList.remove(draft_list_default["input-error"]);
        } else {
          textarea.classList.add(draft_list_default["input-error"]);
          return;
        }
      } catch (e) {
        console.error("Failed to parse coordinates:", e);
        textarea.classList.add(draft_list_default["input-error"]);
        return;
      }
      overlay.updateDraftCoordinates(selectedDraft);
      saveDraftChanges(selectedDraft);
    });
    const createButton = /* @__PURE__ */ jsx("button", { class: draft_list_default["create-button"], children: "\u{1F4CD}\u65B0\u898F\u4F5C\u6210" });
    createButton.addEventListener("click", () => {
      addNewDraft();
    });
    const deleteButton = /* @__PURE__ */ jsx("button", { class: draft_list_default["delete-button"], children: "\u{1F5D1}\uFE0F\u524A\u9664" });
    deleteButton.addEventListener("click", () => {
      if (!selectedDraft) {
        alert("\u524A\u9664\u3059\u308B\u5019\u88DC\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002");
        return;
      }
      if (confirm(`\u672C\u5F53\u306B\u300C${selectedDraft.name}\u300D\u3092\u524A\u9664\u3057\u307E\u3059\u304B\uFF1F`)) {
        deleteSelectedDraft(selectedDraft.id);
      }
    });
    const mapButton = /* @__PURE__ */ jsx("button", { class: draft_list_default["map-button"], children: "\u{1F3AF}\u5730\u56F3\u3067\u8868\u793A" });
    const templateToggleButton = /* @__PURE__ */ jsx("button", { class: draft_list_default["template-button"], children: "\u{1F4C4}\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8" });
    templateToggleButton.addEventListener("click", () => {
      if (!selectedDraft) return;
      if (getDraftIsTemplate(selectedDraft)) {
        setDraftIsTemplate(selectedDraft, false);
        saveDraftChanges(selectedDraft);
      } else {
        const currentTemplate = allDrafts.find(
          (d) => getDraftIsTemplate(d)
        );
        if (currentTemplate) {
          setDraftIsTemplate(currentTemplate, false);
          saveDraftChanges(currentTemplate);
        }
        setDraftIsTemplate(selectedDraft, true);
        saveDraftChanges(selectedDraft);
      }
      updateVirtualList();
      updateDetailPane();
    });
    const configView = createLocalConfigView(local);
    const configDialog = createDialog(configView.element, { title: "\u8A2D\u5B9A" });
    const configButton = /* @__PURE__ */ jsx("button", { class: draft_list_default["config-button"], children: "\u2699\uFE0F\u8A2D\u5B9A" });
    configButton.addEventListener("click", () => {
      configDialog.show();
    });
    const deleteSelectedDraft = (draftId) => {
      const { apiRoot, userId } = local.getConfig();
      if (!userId || !apiRoot) {
        console.error(
          "User ID or API Root not available. Cannot delete draft."
        );
        return;
      }
      overlay.deleteDraft(draftId);
      allDrafts = allDrafts.filter((d) => d.id !== draftId);
      filteredDrafts = filteredDrafts.filter((d) => d.id !== draftId);
      if (selectedDraft?.id === draftId) {
        selectedDraft = null;
        updateDetailPane();
      }
      updateVirtualList();
      remote.delete(
        {
          "route-id": draftId
        },
        apiRoot
      );
    };
    const detailPane = /* @__PURE__ */ jsxs("details", { class: draft_list_default["detail-pane"], open: true, children: [
      /* @__PURE__ */ jsx("summary", { class: draft_list_default["detail-summary"], children: detailName }),
      /* @__PURE__ */ jsxs("div", { class: draft_list_default["detail-content-wrapper"], children: [
        detailDescription,
        detailNote,
        detailCoordinates,
        createButton,
        deleteButton,
        mapButton,
        templateToggleButton,
        configButton
      ] })
    ] });
    const container = /* @__PURE__ */ jsxs("div", { class: draft_list_default["container"], children: [
      searchInput,
      listContainer,
      detailPane
    ] });
    const addNewDraft = () => {
      const { userId } = local.getConfig();
      if (!userId) {
        console.error("User ID not available. Cannot create draft.");
        return;
      }
      const center = overlay.map.getCenter();
      if (!center) return;
      const newDraftId = `draft-${Date.now()}-${Math.floor(
        Math.random() * 1e6
      )}`;
      const newDraft = {
        id: newDraftId,
        type: "route",
        userId,
        name: "\u65B0\u3057\u3044\u5019\u88DC",
        coordinates: [{ lat: center.lat(), lng: center.lng() }],
        description: "",
        note: "",
        data: {}
      };
      const templateDraft = allDrafts.find((d) => getDraftIsTemplate(d));
      if (templateDraft) {
        newDraft.name = applyTemplate(templateDraft.name);
        newDraft.description = applyTemplate(templateDraft.description);
        newDraft.note = applyTemplate(templateDraft.note);
        newDraft.data = structuredClone(templateDraft.data);
        setDraftIsTemplate(newDraft, false);
      }
      overlay.addDraft(newDraft);
      overlay.select(newDraft.id);
      selectedDraft = newDraft;
      updateDetailPane();
      updateVirtualList();
      dispatchCountUpdatedEvent();
      saveDraftChanges(newDraft);
    };
    const updateDetailPane = () => {
      if (selectedDraft) {
        detailName.value = selectedDraft.name;
        detailDescription.value = selectedDraft.description;
        detailNote.value = selectedDraft.note;
        detailCoordinates.value = coordinatesToString(
          selectedDraft.coordinates
        );
        detailCoordinates.classList.remove(draft_list_default["input-error"]);
        mapButton.style.display = "";
        deleteButton.style.display = "";
        templateToggleButton.style.display = "";
        if (getDraftIsTemplate(selectedDraft)) {
          templateToggleButton.textContent = "\u{1F4C4}\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8 (\u8A2D\u5B9A\u6E08\u307F)";
          templateToggleButton.classList.add(draft_list_default["is-template"]);
        } else {
          templateToggleButton.textContent = "\u{1F4C4}\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8\u306B\u8A2D\u5B9A";
          templateToggleButton.classList.remove(
            draft_list_default["is-template"]
          );
        }
      } else {
        detailName.value = "";
        detailDescription.value = "";
        detailNote.value = "";
        detailCoordinates.value = "";
        detailCoordinates.classList.remove(draft_list_default["input-error"]);
        mapButton.style.display = "none";
        deleteButton.style.display = "none";
        templateToggleButton.style.display = "none";
      }
    };
    updateDetailPane();
    const applyFilter = () => {
      const searchAndTerms = searchTerm.toLowerCase().match(/[^ ]+/g) ?? [""];
      filteredDrafts = allDrafts.filter((draft) => {
        for (const term of searchAndTerms) {
          if (!hasTermInDraft(draft, term)) return false;
        }
        return true;
      });
      dispatchCountUpdatedEvent();
      updateVirtualList();
    };
    const updateVirtualList = () => {
      const virtualElements = {
        itemHeight: 40,
        count: filteredDrafts.length,
        get: (index) => {
          const draft = filteredDrafts[index];
          if (!draft) return void 0;
          const item = document.createElement("div");
          item.className = draft_list_default["item"];
          if (selectedDraft && selectedDraft.id === draft.id) {
            item.classList.add(draft_list_default["selected"]);
          }
          const nameDiv = document.createElement("div");
          nameDiv.className = draft_list_default["item-name"];
          nameDiv.textContent = draft.name;
          const noteDiv = document.createElement("div");
          noteDiv.className = draft_list_default["item-note"];
          noteDiv.textContent = draft.note;
          item.append(nameDiv, noteDiv);
          const onClick = () => {
            overlay.select(draft.id);
            updateDetailPane();
            updateVirtualList();
          };
          const onDblclick = () => {
            if (draft) {
              overlay.map.setCenter(draft.coordinates[0]);
            }
          };
          let clickTimer = null;
          item.addEventListener("click", () => {
            clickTimer = setTimeout(() => {
              selectedDraft = draft;
              onClick();
              clickTimer = null;
            }, 0);
          });
          item.addEventListener("dblclick", () => {
            if (clickTimer !== null) clearTimeout(clickTimer);
            clickTimer = null;
            onDblclick();
          });
          return item;
        }
      };
      setVirtualListItems(virtualElements);
    };
    updateVirtualList();
    searchInput.addEventListener("input", () => {
      searchTerm = searchInput.value;
      applyFilter();
    });
    mapButton.addEventListener("click", () => {
      if (selectedDraft) {
        overlay.map.setCenter(selectedDraft.coordinates[0]);
      }
    });
    return {
      events,
      element: container,
      cssText: cssText4 + "\n" + virtualListCssText + "\n" + configView.cssText,
      setDrafts(newDrafts) {
        allDrafts.splice(0, allDrafts.length, ...newDrafts);
        applyFilter();
        if (selectedDraft && !newDrafts.some((d) => d.id === selectedDraft?.id)) {
          selectedDraft = null;
          updateDetailPane();
        }
      }
    };
  }

  // source/locales/ja.json
  var ja_default2 = {
    draftsTitle: "\u5019\u88DC"
  };

  // source/drafts-view/drafts-dialog-title.module.css
  var cssText8 = ":root {\n    --text-color-b5fcef7c2e75eaff3726c619b44d741fa4d5c907: #333;\n    --secondary-text-color-688b6add60d632c00d21958cec42f53996ebfce5: #666;\n    --primary-color-85c1441dbfb39319542140435119ee442e85721a: #007bff;\n    --background-color-light-d3c1d427ed49fb706d5d27ecc2e2bf2144145b42: #f8f9fa;\n    --border-color-0c4d1205af0f0747deb181610984f634e079550a: #dee2e6;\n}\n\n.container-3a7a3702be125e4c680a49a5f6b48a0685a89213 {\n    display: flex;\n    align-items: center;\n    border-bottom: 1px solid var(--border-color-0c4d1205af0f0747deb181610984f634e079550a);\n    color: var(--text-color-b5fcef7c2e75eaff3726c619b44d741fa4d5c907);\n    gap: 10px;\n}\n\n.main-title-af45008e5a094765ba2506a66e549cf852ebcfe3 {\n    font-size: 1.2em;\n    font-weight: bold;\n    color: var(--text-color-b5fcef7c2e75eaff3726c619b44d741fa4d5c907);\n    flex-grow: 1;\n}\n\n.counts-element-a73b5f2718d6c70b187f8e1f493bdd0805dd7a96 {\n    font-size: 0.9em;\n    color: var(--secondary-text-color-688b6add60d632c00d21958cec42f53996ebfce5);\n    white-space: nowrap;\n}\n\n.saving-indicator-ff5b78079ff0b8a9d57fab5841cd61fa1bbc9865 {\n    display: none;\n    font-size: 0.85em;\n    color: var(--primary-color-85c1441dbfb39319542140435119ee442e85721a);\n    margin-left: auto;\n    white-space: nowrap;\n}\n\n.saving-63a9f84c54405daf885a836d67ad7091a22f7475 {\n    display: unset;\n    animation: blink 0.7s infinite steps(1);\n}\n\n@keyframes blink {\n    0% {\n        opacity: 0;\n    }\n\n    50% {\n        opacity: 1;\n    }\n\n    100% {\n        opacity: 0;\n    }\n}\n";
  var drafts_dialog_title_default = {
    container: "container-3a7a3702be125e4c680a49a5f6b48a0685a89213",
    "main-title": "main-title-af45008e5a094765ba2506a66e549cf852ebcfe3",
    "counts-element": "counts-element-a73b5f2718d6c70b187f8e1f493bdd0805dd7a96",
    "saving-indicator": "saving-indicator-ff5b78079ff0b8a9d57fab5841cd61fa1bbc9865",
    saving: "saving-63a9f84c54405daf885a836d67ad7091a22f7475"
  };

  // source/drafts-view/indicator.module.css
  var cssText9 = ".loader-62b568c1cf31831c16b87cb441cc3a63b60f4dbd {\n    position: relative;\n    width: 1rem;\n    height: 1rem;\n}\n\n.orb-86b430db43d2410a62a17c1ee0232463705b2aa5 {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    background: radial-gradient(\n        circle,\n        rgba(59, 130, 246, 0.95) 0%,\n        rgba(96, 165, 250, 0.6) 45%,\n        rgba(147, 197, 253, 0.25) 75%,\n        transparent 100%\n    );\n    box-shadow:\n        0 0 4px rgba(96, 165, 250, 0.8),\n        0 0 8px rgba(147, 197, 253, 0.5);\n    transform: translate(-50%, -50%);\n    opacity: 0;\n    animation: pulse var(--pulseDur-cefcb0590d6e63a0997f5b774909fa76285c1337, 2.6s) ease-in-out infinite;\n}\n\n@keyframes pulse {\n    0%,\n    100% {\n        opacity: 0.35;\n        filter: blur(0.6px);\n    }\n\n    50% {\n        opacity: 1;\n        filter: blur(0);\n    }\n}\n\n@keyframes softAppear {\n    from {\n        opacity: 0;\n        filter: blur(2px);\n    }\n\n    to {\n        opacity: 0.9;\n        filter: blur(0.6px);\n    }\n}\n\n@keyframes endFade {\n    to {\n        opacity: 0;\n        filter: blur(2px);\n    }\n}\n\n.starting-02933a59452e89089c97a52e6fe88a96cf4766d4 .orb-86b430db43d2410a62a17c1ee0232463705b2aa5 {\n    animation: softAppear 0.35s ease-out forwards;\n}\n\n.ending-701c23d5aacc00f9e4c0bb8ae539ee979c42e024 .orb-86b430db43d2410a62a17c1ee0232463705b2aa5 {\n    animation: endFade 0.4s ease-in forwards;\n}\n";
  var variables3 = {
    "--pulseDur": "--pulseDur-cefcb0590d6e63a0997f5b774909fa76285c1337"
  };
  var indicator_default = {
    loader: "loader-62b568c1cf31831c16b87cb441cc3a63b60f4dbd",
    orb: "orb-86b430db43d2410a62a17c1ee0232463705b2aa5",
    starting: "starting-02933a59452e89089c97a52e6fe88a96cf4766d4",
    ending: "ending-701c23d5aacc00f9e4c0bb8ae539ee979c42e024"
  };

  // source/drafts-view/indicator.tsx
  function createIndicator() {
    const loader = /* @__PURE__ */ jsxs("div", { class: indicator_default.loader, "aria-label": "Communicating", children: [
      /* @__PURE__ */ jsx("div", { class: indicator_default.orb }),
      /* @__PURE__ */ jsx("div", { class: indicator_default.orb }),
      /* @__PURE__ */ jsx("div", { class: indicator_default.orb }),
      /* @__PURE__ */ jsx("div", { class: indicator_default.orb })
    ] });
    const orbs = [
      ...loader.getElementsByClassName(indicator_default.orb)
    ];
    const intervals = [];
    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }
    function setOrbPosition(orb, x, y) {
      orb.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
      orb._x = x;
      orb._y = y;
    }
    function animateOrbit(orb) {
      const radius = rand(5, 12);
      const duration3 = rand(2.5, 5);
      const drift = rand(-0.6, 0.6);
      const startAngle = Math.atan2(orb._y || 0, orb._x || 0);
      let start = null;
      function frame(ts) {
        if (!start) start = ts;
        const t = (ts - start) / 1e3;
        const angle = startAngle + t * (Math.PI * 2 / duration3) + Math.sin(t) * drift;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        setOrbPosition(orb, x, y);
        orb._anim = requestAnimationFrame(frame);
      }
      orb._anim = requestAnimationFrame(frame);
    }
    function randomizePulse(orb) {
      orb.style.setProperty(variables3["--pulseDur"], rand(2, 4) + "s");
    }
    function startCommunication() {
      loader.classList.remove(indicator_default.ending);
      loader.classList.add(indicator_default.starting);
      loader.classList.remove(indicator_default.starting);
      orbs.forEach((orb) => {
        orb.style.opacity = String(0.9);
        randomizePulse(orb);
        animateOrbit(orb);
        const id2 = setInterval(() => randomizePulse(orb), rand(3e3, 5e3));
        intervals.push(id2);
      });
    }
    function stopCommunication() {
      loader.classList.add(indicator_default.ending);
      setTimeout(() => {
        intervals.forEach(clearInterval);
        intervals.length = 0;
        orbs.forEach((o) => cancelAnimationFrame(o._anim));
      }, 400);
    }
    stopCommunication();
    return {
      element: loader,
      cssText: cssText9,
      start: startCommunication,
      stop: stopCommunication
    };
  }

  // source/drafts-view/drafts-dialog-title.tsx
  function createDraftsDialogTitle({ title }) {
    const mainTitleElement = /* @__PURE__ */ jsx("div", { class: drafts_dialog_title_default["main-title"], children: title });
    const countsElement = /* @__PURE__ */ jsx("div", { class: drafts_dialog_title_default["counts-element"] });
    const indicator = createIndicator();
    const element = /* @__PURE__ */ jsxs("div", { class: drafts_dialog_title_default.container, children: [
      mainTitleElement,
      countsElement,
      indicator.element
    ] });
    let currentSaving;
    return {
      element,
      cssText: cssText8 + "\n" + indicator.cssText,
      setCounts({
        totalCount,
        filteredCount
      }) {
        if (filteredCount !== totalCount) {
          countsElement.innerText = `${filteredCount}/${totalCount}\u4EF6`;
        } else {
          countsElement.innerText = `${totalCount}\u4EF6`;
        }
      },
      setIsSaving(isSaving) {
        if (currentSaving !== isSaving) {
          if (isSaving) {
            indicator.start();
          } else {
            indicator.stop();
          }
          currentSaving = isSaving;
        }
      }
    };
  }

  // source/setup.ts
  var localConfigKey = "wayfarer-map-extension-f079bd37-f7cd-4d65-9def-f0888b70b231";
  function handleAsyncError(reason) {
    console.error("An error occurred during asynchronous processing:", reason);
  }
  async function getGMapObject(options) {
    return await awaitElement(() => {
      try {
        const e = document.querySelector("app-wf-base-map");
        return e.__ngContext__[27];
      } catch {
        return null;
      }
    }, options);
  }
  var defaultDictionary = ja_default2;
  function setupWorkerRecorder(events) {
    const mainApi = {
      dispatchEvent(type, data) {
        events.dispatchEvent(createTypedCustomEvent(type, data));
      }
    };
    const recordsWorker = new Worker2();
    expose(mainApi, recordsWorker);
    const workerApi = wrap2(recordsWorker);
    injectGcsListener((url2, responseText) => {
      events.dispatchEvent(createTypedCustomEvent("gcs-received", void 0));
      workerApi.onGcsReceived(url2.toString(), responseText).catch(handleAsyncError);
    });
  }
  function setStyle(page, cssText10) {
    page.styleElement.textContent += cssText10 + "\n";
  }
  function getDictionaryEntry(page, key) {
    const lang = navigator.language;
    return page.local.getConfig()?.dictionaries?.[lang]?.[key] ?? page.defaultDictionary[key];
  }
  function setupDraftManagerDialog(page) {
    const draftList = createDraftList({
      overlay: page.drafts,
      remote: page.remote,
      local: page.local
    });
    const title = createDraftsDialogTitle({
      title: getDictionaryEntry(page, "draftsTitle")
    });
    const drafts = createDialog(draftList.element, {
      title: title.element
    });
    drafts.show();
    setStyle(page, title.cssText);
    setStyle(page, drafts.cssText);
    setStyle(page, draftList.cssText);
    document.body.append(drafts.element);
    draftList.events.addEventListener("count-changed", (e) => {
      title.setCounts(e.detail);
    });
    let fetchCount = 0;
    page.remote.events.addEventListener("fetch-start", () => {
      fetchCount++;
      title.setIsSaving(true);
    });
    page.remote.events.addEventListener("fetch-end", () => {
      fetchCount--;
      if (fetchCount <= 0) {
        title.setIsSaving(false);
      }
    });
    page.drafts.events.addEventListener(
      "drafts-updated",
      (e) => draftList.setDrafts(e.detail)
    );
  }
  async function asyncSetup(signal) {
    await awaitElement(() => document.querySelector("#wfmapmods-side-panel"), {
      signal
    });
    const map2 = await getGMapObject({ signal });
    const events = createTypedEventTarget();
    const local = createConfigAccessor(localConfigKey);
    local.events.addEventListener(
      "config-changed",
      () => events.dispatchEvent(
        createTypedCustomEvent("config-changed", void 0)
      )
    );
    const scheduler = createScheduler(signal);
    const page = {
      records: await openRecords(),
      remote: createRemote(handleAsyncError, 2e3),
      styleElement: document.createElement("style"),
      map: map2,
      defaultAsyncErrorHandler: handleAsyncError,
      overlay: createPoisOverlay(map2),
      events,
      local,
      drafts: createDraftsOverlay(map2, handleAsyncError),
      defaultDictionary
    };
    document.head.appendChild(page.styleElement);
    setupWorkerRecorder(events);
    setupPoiRecordOverlay(page);
    setupDraftManagerDialog(page);
    await setupDraftsOverlay(page.drafts, local, scheduler);
  }
  function setup() {
    const cancel = new AbortController();
    asyncSetup(cancel.signal).catch(handleAsyncError);
  }

  // wayfarer-map-extension.user.ts
  setup();
})();
/*! Bundled license information:

comlink/dist/esm/comlink.mjs:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
