// ==UserScript==
// @name         wayfarer-map-extension
// @namespace    http://tampermonkey.net/
// @version      0.4.16
// @description  A user script that extends the official Niantic Wayfarer map.
// @author       Wiinuk
// @match        https://wayfarer.nianticlabs.com/new/mapview
// @grant        none
// ==/UserScript==
"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/antlr4ts/ANTLRErrorListener.js
  var require_ANTLRErrorListener = __commonJS({
    "node_modules/antlr4ts/ANTLRErrorListener.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/antlr4ts/ANTLRErrorStrategy.js
  var require_ANTLRErrorStrategy = __commonJS({
    "node_modules/antlr4ts/ANTLRErrorStrategy.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // shims/assert.js
  var require_assert = __commonJS({
    "shims/assert.js"(exports, module2) {
      "use strict";
      function assert(condition, message) {
        if (!condition) {
          throw new Error(message || "Assertion failed");
        }
      }
      module2.exports = assert;
    }
  });

  // node_modules/antlr4ts/Decorators.js
  var require_Decorators = __commonJS({
    "node_modules/antlr4ts/Decorators.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SuppressWarnings = exports.Override = exports.Nullable = exports.NotNull = void 0;
      function NotNull(target, propertyKey, propertyDescriptor) {
      }
      exports.NotNull = NotNull;
      function Nullable(target, propertyKey, propertyDescriptor) {
      }
      exports.Nullable = Nullable;
      function Override(target, propertyKey, propertyDescriptor) {
      }
      exports.Override = Override;
      function SuppressWarnings(options) {
        return (target, propertyKey, descriptor) => {
        };
      }
      exports.SuppressWarnings = SuppressWarnings;
    }
  });

  // node_modules/antlr4ts/IntStream.js
  var require_IntStream = __commonJS({
    "node_modules/antlr4ts/IntStream.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IntStream = void 0;
      var IntStream;
      (function(IntStream2) {
        IntStream2.EOF = -1;
        IntStream2.UNKNOWN_SOURCE_NAME = "<unknown>";
      })(IntStream = exports.IntStream || (exports.IntStream = {}));
    }
  });

  // node_modules/antlr4ts/ANTLRInputStream.js
  var require_ANTLRInputStream = __commonJS({
    "node_modules/antlr4ts/ANTLRInputStream.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ANTLRInputStream = void 0;
      var assert = require_assert();
      var Decorators_1 = require_Decorators();
      var IntStream_1 = require_IntStream();
      var ANTLRInputStream = class {
        /** Copy data in string to a local char array */
        constructor(input) {
          this.p = 0;
          this.data = input;
          this.n = input.length;
        }
        /** Reset the stream so that it's in the same state it was
         *  when the object was created *except* the data array is not
         *  touched.
         */
        reset() {
          this.p = 0;
        }
        consume() {
          if (this.p >= this.n) {
            assert(this.LA(1) === IntStream_1.IntStream.EOF);
            throw new Error("cannot consume EOF");
          }
          if (this.p < this.n) {
            this.p++;
          }
        }
        LA(i) {
          if (i === 0) {
            return 0;
          }
          if (i < 0) {
            i++;
            if (this.p + i - 1 < 0) {
              return IntStream_1.IntStream.EOF;
            }
          }
          if (this.p + i - 1 >= this.n) {
            return IntStream_1.IntStream.EOF;
          }
          return this.data.charCodeAt(this.p + i - 1);
        }
        LT(i) {
          return this.LA(i);
        }
        /** Return the current input symbol index 0..n where n indicates the
         *  last symbol has been read.  The index is the index of char to
         *  be returned from LA(1).
         */
        get index() {
          return this.p;
        }
        get size() {
          return this.n;
        }
        /** mark/release do nothing; we have entire buffer */
        mark() {
          return -1;
        }
        release(marker) {
        }
        /** consume() ahead until p==index; can't just set p=index as we must
         *  update line and charPositionInLine. If we seek backwards, just set p
         */
        seek(index) {
          if (index <= this.p) {
            this.p = index;
            return;
          }
          index = Math.min(index, this.n);
          while (this.p < index) {
            this.consume();
          }
        }
        getText(interval) {
          let start = interval.a;
          let stop = interval.b;
          if (stop >= this.n) {
            stop = this.n - 1;
          }
          let count = stop - start + 1;
          if (start >= this.n) {
            return "";
          }
          return this.data.substr(start, count);
        }
        get sourceName() {
          if (!this.name) {
            return IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
          }
          return this.name;
        }
        toString() {
          return this.data;
        }
      };
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "consume", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "LA", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "index", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "mark", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "release", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "seek", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "getText", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "sourceName", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "toString", null);
      exports.ANTLRInputStream = ANTLRInputStream;
    }
  });

  // node_modules/antlr4ts/atn/ATNState.js
  var require_ATNState = __commonJS({
    "node_modules/antlr4ts/atn/ATNState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATNState = void 0;
      var Decorators_1 = require_Decorators();
      var ATNState = class _ATNState {
        constructor() {
          this.stateNumber = _ATNState.INVALID_STATE_NUMBER;
          this.ruleIndex = 0;
          this.epsilonOnlyTransitions = false;
          this.transitions = [];
          this.optimizedTransitions = this.transitions;
        }
        /**
         * Gets the state number.
         *
         * @returns the state number
         */
        getStateNumber() {
          return this.stateNumber;
        }
        /**
         * For all states except {@link RuleStopState}, this returns the state
         * number. Returns -1 for stop states.
         *
         * @returns -1 for {@link RuleStopState}, otherwise the state number
         */
        get nonStopStateNumber() {
          return this.getStateNumber();
        }
        hashCode() {
          return this.stateNumber;
        }
        equals(o) {
          if (o instanceof _ATNState) {
            return this.stateNumber === o.stateNumber;
          }
          return false;
        }
        get isNonGreedyExitState() {
          return false;
        }
        toString() {
          return String(this.stateNumber);
        }
        getTransitions() {
          return this.transitions.slice(0);
        }
        get numberOfTransitions() {
          return this.transitions.length;
        }
        addTransition(e, index) {
          if (this.transitions.length === 0) {
            this.epsilonOnlyTransitions = e.isEpsilon;
          } else if (this.epsilonOnlyTransitions !== e.isEpsilon) {
            this.epsilonOnlyTransitions = false;
            throw new Error("ATN state " + this.stateNumber + " has both epsilon and non-epsilon transitions.");
          }
          this.transitions.splice(index !== void 0 ? index : this.transitions.length, 0, e);
        }
        transition(i) {
          return this.transitions[i];
        }
        setTransition(i, e) {
          this.transitions[i] = e;
        }
        removeTransition(index) {
          return this.transitions.splice(index, 1)[0];
        }
        get onlyHasEpsilonTransitions() {
          return this.epsilonOnlyTransitions;
        }
        setRuleIndex(ruleIndex) {
          this.ruleIndex = ruleIndex;
        }
        get isOptimized() {
          return this.optimizedTransitions !== this.transitions;
        }
        get numberOfOptimizedTransitions() {
          return this.optimizedTransitions.length;
        }
        getOptimizedTransition(i) {
          return this.optimizedTransitions[i];
        }
        addOptimizedTransition(e) {
          if (!this.isOptimized) {
            this.optimizedTransitions = new Array();
          }
          this.optimizedTransitions.push(e);
        }
        setOptimizedTransition(i, e) {
          if (!this.isOptimized) {
            throw new Error("This ATNState is not optimized.");
          }
          this.optimizedTransitions[i] = e;
        }
        removeOptimizedTransition(i) {
          if (!this.isOptimized) {
            throw new Error("This ATNState is not optimized.");
          }
          this.optimizedTransitions.splice(i, 1);
        }
      };
      __decorate([
        Decorators_1.Override
      ], ATNState.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], ATNState.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], ATNState.prototype, "toString", null);
      exports.ATNState = ATNState;
      (function(ATNState2) {
        ATNState2.INVALID_STATE_NUMBER = -1;
      })(ATNState = exports.ATNState || (exports.ATNState = {}));
    }
  });

  // node_modules/antlr4ts/atn/ATNStateType.js
  var require_ATNStateType = __commonJS({
    "node_modules/antlr4ts/atn/ATNStateType.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATNStateType = void 0;
      var ATNStateType;
      (function(ATNStateType2) {
        ATNStateType2[ATNStateType2["INVALID_TYPE"] = 0] = "INVALID_TYPE";
        ATNStateType2[ATNStateType2["BASIC"] = 1] = "BASIC";
        ATNStateType2[ATNStateType2["RULE_START"] = 2] = "RULE_START";
        ATNStateType2[ATNStateType2["BLOCK_START"] = 3] = "BLOCK_START";
        ATNStateType2[ATNStateType2["PLUS_BLOCK_START"] = 4] = "PLUS_BLOCK_START";
        ATNStateType2[ATNStateType2["STAR_BLOCK_START"] = 5] = "STAR_BLOCK_START";
        ATNStateType2[ATNStateType2["TOKEN_START"] = 6] = "TOKEN_START";
        ATNStateType2[ATNStateType2["RULE_STOP"] = 7] = "RULE_STOP";
        ATNStateType2[ATNStateType2["BLOCK_END"] = 8] = "BLOCK_END";
        ATNStateType2[ATNStateType2["STAR_LOOP_BACK"] = 9] = "STAR_LOOP_BACK";
        ATNStateType2[ATNStateType2["STAR_LOOP_ENTRY"] = 10] = "STAR_LOOP_ENTRY";
        ATNStateType2[ATNStateType2["PLUS_LOOP_BACK"] = 11] = "PLUS_LOOP_BACK";
        ATNStateType2[ATNStateType2["LOOP_END"] = 12] = "LOOP_END";
      })(ATNStateType = exports.ATNStateType || (exports.ATNStateType = {}));
    }
  });

  // node_modules/antlr4ts/RecognitionException.js
  var require_RecognitionException = __commonJS({
    "node_modules/antlr4ts/RecognitionException.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RecognitionException = void 0;
      var RecognitionException2 = class extends Error {
        constructor(recognizer, input, ctx, message) {
          super(message);
          this._offendingState = -1;
          this._recognizer = recognizer;
          this.input = input;
          this.ctx = ctx;
          if (recognizer) {
            this._offendingState = recognizer.state;
          }
        }
        /**
         * Get the ATN state number the parser was in at the time the error
         * occurred. For {@link NoViableAltException} and
         * {@link LexerNoViableAltException} exceptions, this is the
         * {@link DecisionState} number. For others, it is the state whose outgoing
         * edge we couldn't match.
         *
         * If the state number is not known, this method returns -1.
         */
        get offendingState() {
          return this._offendingState;
        }
        setOffendingState(offendingState) {
          this._offendingState = offendingState;
        }
        /**
         * Gets the set of input symbols which could potentially follow the
         * previously matched symbol at the time this exception was thrown.
         *
         * If the set of expected tokens is not known and could not be computed,
         * this method returns `undefined`.
         *
         * @returns The set of token types that could potentially follow the current
         * state in the ATN, or `undefined` if the information is not available.
         */
        get expectedTokens() {
          if (this._recognizer) {
            return this._recognizer.atn.getExpectedTokens(this._offendingState, this.ctx);
          }
          return void 0;
        }
        /**
         * Gets the {@link RuleContext} at the time this exception was thrown.
         *
         * If the context is not available, this method returns `undefined`.
         *
         * @returns The {@link RuleContext} at the time this exception was thrown.
         * If the context is not available, this method returns `undefined`.
         */
        get context() {
          return this.ctx;
        }
        /**
         * Gets the input stream which is the symbol source for the recognizer where
         * this exception was thrown.
         *
         * If the input stream is not available, this method returns `undefined`.
         *
         * @returns The input stream which is the symbol source for the recognizer
         * where this exception was thrown, or `undefined` if the stream is not
         * available.
         */
        get inputStream() {
          return this.input;
        }
        getOffendingToken(recognizer) {
          if (recognizer && recognizer !== this._recognizer) {
            return void 0;
          }
          return this.offendingToken;
        }
        setOffendingToken(recognizer, offendingToken) {
          if (recognizer === this._recognizer) {
            this.offendingToken = offendingToken;
          }
        }
        /**
         * Gets the {@link Recognizer} where this exception occurred.
         *
         * If the recognizer is not available, this method returns `undefined`.
         *
         * @returns The recognizer where this exception occurred, or `undefined` if
         * the recognizer is not available.
         */
        get recognizer() {
          return this._recognizer;
        }
      };
      exports.RecognitionException = RecognitionException2;
    }
  });

  // node_modules/antlr4ts/atn/Transition.js
  var require_Transition = __commonJS({
    "node_modules/antlr4ts/atn/Transition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Transition = void 0;
      var Decorators_1 = require_Decorators();
      var Transition = class Transition {
        constructor(target) {
          if (target == null) {
            throw new Error("target cannot be null.");
          }
          this.target = target;
        }
        /**
         * Determines if the transition is an "epsilon" transition.
         *
         * The default implementation returns `false`.
         *
         * @returns `true` if traversing this transition in the ATN does not
         * consume an input symbol; otherwise, `false` if traversing this
         * transition consumes (matches) an input symbol.
         */
        get isEpsilon() {
          return false;
        }
        get label() {
          return void 0;
        }
      };
      Transition.serializationNames = [
        "INVALID",
        "EPSILON",
        "RANGE",
        "RULE",
        "PREDICATE",
        "ATOM",
        "ACTION",
        "SET",
        "NOT_SET",
        "WILDCARD",
        "PRECEDENCE"
      ];
      __decorate([
        Decorators_1.NotNull
      ], Transition.prototype, "target", void 0);
      Transition = __decorate([
        __param(0, Decorators_1.NotNull)
      ], Transition);
      exports.Transition = Transition;
    }
  });

  // node_modules/antlr4ts/atn/AbstractPredicateTransition.js
  var require_AbstractPredicateTransition = __commonJS({
    "node_modules/antlr4ts/atn/AbstractPredicateTransition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractPredicateTransition = void 0;
      var Transition_1 = require_Transition();
      var AbstractPredicateTransition = class extends Transition_1.Transition {
        constructor(target) {
          super(target);
        }
      };
      exports.AbstractPredicateTransition = AbstractPredicateTransition;
    }
  });

  // node_modules/antlr4ts/misc/MurmurHash.js
  var require_MurmurHash = __commonJS({
    "node_modules/antlr4ts/misc/MurmurHash.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MurmurHash = void 0;
      var MurmurHash;
      (function(MurmurHash2) {
        const DEFAULT_SEED = 0;
        function initialize(seed = DEFAULT_SEED) {
          return seed;
        }
        MurmurHash2.initialize = initialize;
        function update(hash, value) {
          const c1 = 3432918353;
          const c2 = 461845907;
          const r1 = 15;
          const r2 = 13;
          const m = 5;
          const n = 3864292196;
          if (value == null) {
            value = 0;
          } else if (typeof value === "string") {
            value = hashString(value);
          } else if (typeof value === "object") {
            value = value.hashCode();
          }
          let k = value;
          k = Math.imul(k, c1);
          k = k << r1 | k >>> 32 - r1;
          k = Math.imul(k, c2);
          hash = hash ^ k;
          hash = hash << r2 | hash >>> 32 - r2;
          hash = Math.imul(hash, m) + n;
          return hash & 4294967295;
        }
        MurmurHash2.update = update;
        function finish(hash, numberOfWords) {
          hash = hash ^ numberOfWords * 4;
          hash = hash ^ hash >>> 16;
          hash = Math.imul(hash, 2246822507);
          hash = hash ^ hash >>> 13;
          hash = Math.imul(hash, 3266489909);
          hash = hash ^ hash >>> 16;
          return hash;
        }
        MurmurHash2.finish = finish;
        function hashCode(data, seed = DEFAULT_SEED) {
          let hash = initialize(seed);
          let length = 0;
          for (let value of data) {
            hash = update(hash, value);
            length++;
          }
          hash = finish(hash, length);
          return hash;
        }
        MurmurHash2.hashCode = hashCode;
        function hashString(str) {
          let len = str.length;
          if (len === 0) {
            return 0;
          }
          let hash = 0;
          for (let i = 0; i < len; i++) {
            let c = str.charCodeAt(i);
            hash = (hash << 5 >>> 0) - hash + c;
            hash |= 0;
          }
          return hash;
        }
      })(MurmurHash = exports.MurmurHash || (exports.MurmurHash = {}));
    }
  });

  // node_modules/antlr4ts/misc/ObjectEqualityComparator.js
  var require_ObjectEqualityComparator = __commonJS({
    "node_modules/antlr4ts/misc/ObjectEqualityComparator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ObjectEqualityComparator = void 0;
      var Decorators_1 = require_Decorators();
      var ObjectEqualityComparator = class {
        /**
         * {@inheritDoc}
         *
         * This implementation returns
         * `obj.`{@link Object#hashCode hashCode()}.
         */
        hashCode(obj) {
          if (obj == null) {
            return 0;
          }
          return obj.hashCode();
        }
        /**
         * {@inheritDoc}
         *
         * This implementation relies on object equality. If both objects are
         * `undefined` or `null`, this method returns `true`. Otherwise if only
         * `a` is `undefined` or `null`, this method returns `false`. Otherwise,
         * this method returns the result of
         * `a.`{@link Object#equals equals}`(b)`.
         */
        equals(a, b) {
          if (a == null) {
            return b == null;
          }
          return a.equals(b);
        }
      };
      ObjectEqualityComparator.INSTANCE = new ObjectEqualityComparator();
      __decorate([
        Decorators_1.Override
      ], ObjectEqualityComparator.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], ObjectEqualityComparator.prototype, "equals", null);
      exports.ObjectEqualityComparator = ObjectEqualityComparator;
    }
  });

  // node_modules/antlr4ts/misc/DefaultEqualityComparator.js
  var require_DefaultEqualityComparator = __commonJS({
    "node_modules/antlr4ts/misc/DefaultEqualityComparator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultEqualityComparator = void 0;
      var Decorators_1 = require_Decorators();
      var MurmurHash_1 = require_MurmurHash();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var DefaultEqualityComparator = class {
        /**
         * {@inheritDoc}
         *
         * This implementation returns
         * `obj.`{@link Object#hashCode hashCode()}.
         */
        hashCode(obj) {
          if (obj == null) {
            return 0;
          } else if (typeof obj === "string" || typeof obj === "number") {
            return MurmurHash_1.MurmurHash.hashCode([obj]);
          } else {
            return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.hashCode(obj);
          }
        }
        /**
         * {@inheritDoc}
         *
         * This implementation relies on object equality. If both objects are
         * `undefined` or `null`, this method returns `true`. Otherwise if only
         * `a` is `undefined` or `null`, this method returns `false`. Otherwise,
         * this method returns the result of
         * `a.`{@link Object#equals equals}`(b)`.
         */
        equals(a, b) {
          if (a == null) {
            return b == null;
          } else if (typeof a === "string" || typeof a === "number") {
            return a === b;
          } else {
            return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a, b);
          }
        }
      };
      DefaultEqualityComparator.INSTANCE = new DefaultEqualityComparator();
      __decorate([
        Decorators_1.Override
      ], DefaultEqualityComparator.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], DefaultEqualityComparator.prototype, "equals", null);
      exports.DefaultEqualityComparator = DefaultEqualityComparator;
    }
  });

  // node_modules/antlr4ts/misc/Array2DHashSet.js
  var require_Array2DHashSet = __commonJS({
    "node_modules/antlr4ts/misc/Array2DHashSet.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Array2DHashSet = void 0;
      var assert = require_assert();
      var DefaultEqualityComparator_1 = require_DefaultEqualityComparator();
      var Decorators_1 = require_Decorators();
      var MurmurHash_1 = require_MurmurHash();
      var INITAL_CAPACITY = 16;
      var LOAD_FACTOR = 0.75;
      var Array2DHashSet = class _Array2DHashSet {
        constructor(comparatorOrSet, initialCapacity = INITAL_CAPACITY) {
          this.n = 0;
          this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
          if (comparatorOrSet instanceof _Array2DHashSet) {
            this.comparator = comparatorOrSet.comparator;
            this.buckets = comparatorOrSet.buckets.slice(0);
            for (let i = 0; i < this.buckets.length; i++) {
              let bucket = this.buckets[i];
              if (bucket) {
                this.buckets[i] = bucket.slice(0);
              }
            }
            this.n = comparatorOrSet.n;
            this.threshold = comparatorOrSet.threshold;
          } else {
            this.comparator = comparatorOrSet || DefaultEqualityComparator_1.DefaultEqualityComparator.INSTANCE;
            this.buckets = this.createBuckets(initialCapacity);
          }
        }
        /**
         * Add `o` to set if not there; return existing value if already
         * there. This method performs the same operation as {@link #add} aside from
         * the return value.
         */
        getOrAdd(o) {
          if (this.n > this.threshold) {
            this.expand();
          }
          return this.getOrAddImpl(o);
        }
        getOrAddImpl(o) {
          let b = this.getBucket(o);
          let bucket = this.buckets[b];
          if (!bucket) {
            bucket = [o];
            this.buckets[b] = bucket;
            this.n++;
            return o;
          }
          for (let existing of bucket) {
            if (this.comparator.equals(existing, o)) {
              return existing;
            }
          }
          bucket.push(o);
          this.n++;
          return o;
        }
        get(o) {
          if (o == null) {
            return o;
          }
          let b = this.getBucket(o);
          let bucket = this.buckets[b];
          if (!bucket) {
            return void 0;
          }
          for (let e of bucket) {
            if (this.comparator.equals(e, o)) {
              return e;
            }
          }
          return void 0;
        }
        getBucket(o) {
          let hash = this.comparator.hashCode(o);
          let b = hash & this.buckets.length - 1;
          return b;
        }
        hashCode() {
          let hash = MurmurHash_1.MurmurHash.initialize();
          for (let bucket of this.buckets) {
            if (bucket == null) {
              continue;
            }
            for (let o of bucket) {
              if (o == null) {
                break;
              }
              hash = MurmurHash_1.MurmurHash.update(hash, this.comparator.hashCode(o));
            }
          }
          hash = MurmurHash_1.MurmurHash.finish(hash, this.size);
          return hash;
        }
        equals(o) {
          if (o === this) {
            return true;
          }
          if (!(o instanceof _Array2DHashSet)) {
            return false;
          }
          if (o.size !== this.size) {
            return false;
          }
          let same = this.containsAll(o);
          return same;
        }
        expand() {
          let old = this.buckets;
          let newCapacity = this.buckets.length * 2;
          let newTable = this.createBuckets(newCapacity);
          this.buckets = newTable;
          this.threshold = Math.floor(newCapacity * LOAD_FACTOR);
          let oldSize = this.size;
          for (let bucket of old) {
            if (!bucket) {
              continue;
            }
            for (let o of bucket) {
              let b = this.getBucket(o);
              let newBucket = this.buckets[b];
              if (!newBucket) {
                newBucket = [];
                this.buckets[b] = newBucket;
              }
              newBucket.push(o);
            }
          }
          assert(this.n === oldSize);
        }
        add(t) {
          let existing = this.getOrAdd(t);
          return existing === t;
        }
        get size() {
          return this.n;
        }
        get isEmpty() {
          return this.n === 0;
        }
        contains(o) {
          return this.containsFast(this.asElementType(o));
        }
        containsFast(obj) {
          if (obj == null) {
            return false;
          }
          return this.get(obj) != null;
        }
        *[Symbol.iterator]() {
          yield* this.toArray();
        }
        toArray() {
          const a = new Array(this.size);
          let i = 0;
          for (let bucket of this.buckets) {
            if (bucket == null) {
              continue;
            }
            for (let o of bucket) {
              if (o == null) {
                break;
              }
              a[i++] = o;
            }
          }
          return a;
        }
        containsAll(collection) {
          if (collection instanceof _Array2DHashSet) {
            let s = collection;
            for (let bucket of s.buckets) {
              if (bucket == null) {
                continue;
              }
              for (let o of bucket) {
                if (o == null) {
                  break;
                }
                if (!this.containsFast(this.asElementType(o))) {
                  return false;
                }
              }
            }
          } else {
            for (let o of collection) {
              if (!this.containsFast(this.asElementType(o))) {
                return false;
              }
            }
          }
          return true;
        }
        addAll(c) {
          let changed = false;
          for (let o of c) {
            let existing = this.getOrAdd(o);
            if (existing !== o) {
              changed = true;
            }
          }
          return changed;
        }
        clear() {
          this.buckets = this.createBuckets(INITAL_CAPACITY);
          this.n = 0;
          this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
        }
        toString() {
          if (this.size === 0) {
            return "{}";
          }
          let buf = "{";
          let first = true;
          for (let bucket of this.buckets) {
            if (bucket == null) {
              continue;
            }
            for (let o of bucket) {
              if (o == null) {
                break;
              }
              if (first) {
                first = false;
              } else {
                buf += ", ";
              }
              buf += o.toString();
            }
          }
          buf += "}";
          return buf;
        }
        toTableString() {
          let buf = "";
          for (let bucket of this.buckets) {
            if (bucket == null) {
              buf += "null\n";
              continue;
            }
            buf += "[";
            let first = true;
            for (let o of bucket) {
              if (first) {
                first = false;
              } else {
                buf += " ";
              }
              if (o == null) {
                buf += "_";
              } else {
                buf += o.toString();
              }
            }
            buf += "]\n";
          }
          return buf;
        }
        /**
         * Return `o` as an instance of the element type `T`. If
         * `o` is non-undefined but known to not be an instance of `T`, this
         * method returns `undefined`. The base implementation does not perform any
         * type checks; override this method to provide strong type checks for the
         * {@link #contains} and {@link #remove} methods to ensure the arguments to
         * the {@link EqualityComparator} for the set always have the expected
         * types.
         *
         * @param o the object to try and cast to the element type of the set
         * @returns `o` if it could be an instance of `T`, otherwise
         * `undefined`.
         */
        asElementType(o) {
          return o;
        }
        /**
         * Return an array of `T[]` with length `capacity`.
         *
         * @param capacity the length of the array to return
         * @returns the newly constructed array
         */
        createBuckets(capacity) {
          return new Array(capacity);
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], Array2DHashSet.prototype, "comparator", void 0);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "add", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "isEmpty", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "contains", null);
      __decorate([
        __param(0, Decorators_1.Nullable)
      ], Array2DHashSet.prototype, "containsFast", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, Symbol.iterator, null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "toArray", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "containsAll", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "addAll", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "clear", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "toString", null);
      __decorate([
        Decorators_1.SuppressWarnings("unchecked")
      ], Array2DHashSet.prototype, "asElementType", null);
      __decorate([
        Decorators_1.SuppressWarnings("unchecked")
      ], Array2DHashSet.prototype, "createBuckets", null);
      exports.Array2DHashSet = Array2DHashSet;
    }
  });

  // node_modules/antlr4ts/misc/ArrayEqualityComparator.js
  var require_ArrayEqualityComparator = __commonJS({
    "node_modules/antlr4ts/misc/ArrayEqualityComparator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ArrayEqualityComparator = void 0;
      var Decorators_1 = require_Decorators();
      var MurmurHash_1 = require_MurmurHash();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var ArrayEqualityComparator = class {
        /**
         * {@inheritDoc}
         *
         * This implementation returns
         * `obj.`{@link Object#hashCode hashCode()}.
         */
        hashCode(obj) {
          if (obj == null) {
            return 0;
          }
          return MurmurHash_1.MurmurHash.hashCode(obj, 0);
        }
        /**
         * {@inheritDoc}
         *
         * This implementation relies on object equality. If both objects are
         * `undefined`, this method returns `true`. Otherwise if only
         * `a` is `undefined`, this method returns `false`. Otherwise,
         * this method returns the result of
         * `a.`{@link Object#equals equals}`(b)`.
         */
        equals(a, b) {
          if (a == null) {
            return b == null;
          } else if (b == null) {
            return false;
          }
          if (a.length !== b.length) {
            return false;
          }
          for (let i = 0; i < a.length; i++) {
            if (!ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a[i], b[i])) {
              return false;
            }
          }
          return true;
        }
      };
      ArrayEqualityComparator.INSTANCE = new ArrayEqualityComparator();
      __decorate([
        Decorators_1.Override
      ], ArrayEqualityComparator.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], ArrayEqualityComparator.prototype, "equals", null);
      exports.ArrayEqualityComparator = ArrayEqualityComparator;
    }
  });

  // node_modules/antlr4ts/misc/Utils.js
  var require_Utils = __commonJS({
    "node_modules/antlr4ts/misc/Utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toCharArray = exports.toMap = exports.equals = exports.join = exports.escapeWhitespace = void 0;
      function escapeWhitespace(s, escapeSpaces) {
        return escapeSpaces ? s.replace(/ /, "\xB7") : s.replace(/\t/, "\\t").replace(/\n/, "\\n").replace(/\r/, "\\r");
      }
      exports.escapeWhitespace = escapeWhitespace;
      function join2(collection, separator) {
        let buf = "";
        let first = true;
        for (let current of collection) {
          if (first) {
            first = false;
          } else {
            buf += separator;
          }
          buf += current;
        }
        return buf;
      }
      exports.join = join2;
      function equals(x, y) {
        if (x === y) {
          return true;
        }
        if (x === void 0 || y === void 0) {
          return false;
        }
        return x.equals(y);
      }
      exports.equals = equals;
      function toMap(keys) {
        let m = /* @__PURE__ */ new Map();
        for (let i = 0; i < keys.length; i++) {
          m.set(keys[i], i);
        }
        return m;
      }
      exports.toMap = toMap;
      function toCharArray3(str) {
        if (typeof str === "string") {
          let result = new Uint16Array(str.length);
          for (let i = 0; i < str.length; i++) {
            result[i] = str.charCodeAt(i);
          }
          return result;
        } else {
          return str.toCharArray();
        }
      }
      exports.toCharArray = toCharArray3;
    }
  });

  // node_modules/antlr4ts/atn/SemanticContext.js
  var require_SemanticContext = __commonJS({
    "node_modules/antlr4ts/atn/SemanticContext.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SemanticContext = void 0;
      var Array2DHashSet_1 = require_Array2DHashSet();
      var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var Utils3 = require_Utils();
      function max(items) {
        let result;
        for (let current of items) {
          if (result === void 0) {
            result = current;
            continue;
          }
          let comparison = result.compareTo(current);
          if (comparison < 0) {
            result = current;
          }
        }
        return result;
      }
      function min(items) {
        let result;
        for (let current of items) {
          if (result === void 0) {
            result = current;
            continue;
          }
          let comparison = result.compareTo(current);
          if (comparison > 0) {
            result = current;
          }
        }
        return result;
      }
      var SemanticContext = class _SemanticContext {
        /**
         * The default {@link SemanticContext}, which is semantically equivalent to
         * a predicate of the form `{true}?`.
         */
        static get NONE() {
          if (_SemanticContext._NONE === void 0) {
            _SemanticContext._NONE = new _SemanticContext.Predicate();
          }
          return _SemanticContext._NONE;
        }
        /**
         * Evaluate the precedence predicates for the context and reduce the result.
         *
         * @param parser The parser instance.
         * @param parserCallStack
         * @returns The simplified semantic context after precedence predicates are
         * evaluated, which will be one of the following values.
         *
         * * {@link #NONE}: if the predicate simplifies to `true` after
         *   precedence predicates are evaluated.
         * * `undefined`: if the predicate simplifies to `false` after
         *   precedence predicates are evaluated.
         * * `this`: if the semantic context is not changed as a result of
         *   precedence predicate evaluation.
         * * A non-`undefined` {@link SemanticContext}: the new simplified
         *   semantic context after precedence predicates are evaluated.
         */
        evalPrecedence(parser, parserCallStack) {
          return this;
        }
        static and(a, b) {
          if (!a || a === _SemanticContext.NONE) {
            return b;
          }
          if (b === _SemanticContext.NONE) {
            return a;
          }
          let result = new _SemanticContext.AND(a, b);
          if (result.opnds.length === 1) {
            return result.opnds[0];
          }
          return result;
        }
        /**
         *
         *  @see ParserATNSimulator#getPredsForAmbigAlts
         */
        static or(a, b) {
          if (!a) {
            return b;
          }
          if (a === _SemanticContext.NONE || b === _SemanticContext.NONE) {
            return _SemanticContext.NONE;
          }
          let result = new _SemanticContext.OR(a, b);
          if (result.opnds.length === 1) {
            return result.opnds[0];
          }
          return result;
        }
      };
      exports.SemanticContext = SemanticContext;
      (function(SemanticContext2) {
        const AND_HASHCODE = 40363613;
        const OR_HASHCODE = 486279973;
        function filterPrecedencePredicates(collection) {
          let result = [];
          for (let i = 0; i < collection.length; i++) {
            let context = collection[i];
            if (context instanceof SemanticContext2.PrecedencePredicate) {
              result.push(context);
              collection.splice(i, 1);
              i--;
            }
          }
          return result;
        }
        class Predicate extends SemanticContext2 {
          constructor(ruleIndex = -1, predIndex = -1, isCtxDependent = false) {
            super();
            this.ruleIndex = ruleIndex;
            this.predIndex = predIndex;
            this.isCtxDependent = isCtxDependent;
          }
          eval(parser, parserCallStack) {
            let localctx = this.isCtxDependent ? parserCallStack : void 0;
            return parser.sempred(localctx, this.ruleIndex, this.predIndex);
          }
          hashCode() {
            let hashCode = MurmurHash_1.MurmurHash.initialize();
            hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.ruleIndex);
            hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.predIndex);
            hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);
            hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 3);
            return hashCode;
          }
          equals(obj) {
            if (!(obj instanceof Predicate)) {
              return false;
            }
            if (this === obj) {
              return true;
            }
            return this.ruleIndex === obj.ruleIndex && this.predIndex === obj.predIndex && this.isCtxDependent === obj.isCtxDependent;
          }
          toString() {
            return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
          }
        }
        __decorate([
          Decorators_1.Override
        ], Predicate.prototype, "eval", null);
        __decorate([
          Decorators_1.Override
        ], Predicate.prototype, "hashCode", null);
        __decorate([
          Decorators_1.Override
        ], Predicate.prototype, "equals", null);
        __decorate([
          Decorators_1.Override
        ], Predicate.prototype, "toString", null);
        SemanticContext2.Predicate = Predicate;
        class PrecedencePredicate extends SemanticContext2 {
          constructor(precedence) {
            super();
            this.precedence = precedence;
          }
          eval(parser, parserCallStack) {
            return parser.precpred(parserCallStack, this.precedence);
          }
          evalPrecedence(parser, parserCallStack) {
            if (parser.precpred(parserCallStack, this.precedence)) {
              return SemanticContext2.NONE;
            } else {
              return void 0;
            }
          }
          compareTo(o) {
            return this.precedence - o.precedence;
          }
          hashCode() {
            let hashCode = 1;
            hashCode = 31 * hashCode + this.precedence;
            return hashCode;
          }
          equals(obj) {
            if (!(obj instanceof PrecedencePredicate)) {
              return false;
            }
            if (this === obj) {
              return true;
            }
            return this.precedence === obj.precedence;
          }
          toString() {
            return "{" + this.precedence + ">=prec}?";
          }
        }
        __decorate([
          Decorators_1.Override
        ], PrecedencePredicate.prototype, "eval", null);
        __decorate([
          Decorators_1.Override
        ], PrecedencePredicate.prototype, "evalPrecedence", null);
        __decorate([
          Decorators_1.Override
        ], PrecedencePredicate.prototype, "compareTo", null);
        __decorate([
          Decorators_1.Override
        ], PrecedencePredicate.prototype, "hashCode", null);
        __decorate([
          Decorators_1.Override
        ], PrecedencePredicate.prototype, "equals", null);
        __decorate([
          Decorators_1.Override
        ], PrecedencePredicate.prototype, "toString", null);
        SemanticContext2.PrecedencePredicate = PrecedencePredicate;
        class Operator extends SemanticContext2 {
        }
        SemanticContext2.Operator = Operator;
        let AND = class AND2 extends Operator {
          constructor(a, b) {
            super();
            let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
            if (a instanceof AND2) {
              operands.addAll(a.opnds);
            } else {
              operands.add(a);
            }
            if (b instanceof AND2) {
              operands.addAll(b.opnds);
            } else {
              operands.add(b);
            }
            this.opnds = operands.toArray();
            let precedencePredicates = filterPrecedencePredicates(this.opnds);
            let reduced = min(precedencePredicates);
            if (reduced) {
              this.opnds.push(reduced);
            }
          }
          get operands() {
            return this.opnds;
          }
          equals(obj) {
            if (this === obj) {
              return true;
            }
            if (!(obj instanceof AND2)) {
              return false;
            }
            return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
          }
          hashCode() {
            return MurmurHash_1.MurmurHash.hashCode(this.opnds, AND_HASHCODE);
          }
          /**
           * {@inheritDoc}
           *
           * The evaluation of predicates by this context is short-circuiting, but
           * unordered.
           */
          eval(parser, parserCallStack) {
            for (let opnd of this.opnds) {
              if (!opnd.eval(parser, parserCallStack)) {
                return false;
              }
            }
            return true;
          }
          evalPrecedence(parser, parserCallStack) {
            let differs = false;
            let operands = [];
            for (let context of this.opnds) {
              let evaluated = context.evalPrecedence(parser, parserCallStack);
              differs = differs || evaluated !== context;
              if (evaluated == null) {
                return void 0;
              } else if (evaluated !== SemanticContext2.NONE) {
                operands.push(evaluated);
              }
            }
            if (!differs) {
              return this;
            }
            if (operands.length === 0) {
              return SemanticContext2.NONE;
            }
            let result = operands[0];
            for (let i = 1; i < operands.length; i++) {
              result = SemanticContext2.and(result, operands[i]);
            }
            return result;
          }
          toString() {
            return Utils3.join(this.opnds, "&&");
          }
        };
        __decorate([
          Decorators_1.Override
        ], AND.prototype, "operands", null);
        __decorate([
          Decorators_1.Override
        ], AND.prototype, "equals", null);
        __decorate([
          Decorators_1.Override
        ], AND.prototype, "hashCode", null);
        __decorate([
          Decorators_1.Override
        ], AND.prototype, "eval", null);
        __decorate([
          Decorators_1.Override
        ], AND.prototype, "evalPrecedence", null);
        __decorate([
          Decorators_1.Override
        ], AND.prototype, "toString", null);
        AND = __decorate([
          __param(0, Decorators_1.NotNull),
          __param(1, Decorators_1.NotNull)
        ], AND);
        SemanticContext2.AND = AND;
        let OR = class OR2 extends Operator {
          constructor(a, b) {
            super();
            let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
            if (a instanceof OR2) {
              operands.addAll(a.opnds);
            } else {
              operands.add(a);
            }
            if (b instanceof OR2) {
              operands.addAll(b.opnds);
            } else {
              operands.add(b);
            }
            this.opnds = operands.toArray();
            let precedencePredicates = filterPrecedencePredicates(this.opnds);
            let reduced = max(precedencePredicates);
            if (reduced) {
              this.opnds.push(reduced);
            }
          }
          get operands() {
            return this.opnds;
          }
          equals(obj) {
            if (this === obj) {
              return true;
            }
            if (!(obj instanceof OR2)) {
              return false;
            }
            return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
          }
          hashCode() {
            return MurmurHash_1.MurmurHash.hashCode(this.opnds, OR_HASHCODE);
          }
          /**
           * {@inheritDoc}
           *
           * The evaluation of predicates by this context is short-circuiting, but
           * unordered.
           */
          eval(parser, parserCallStack) {
            for (let opnd of this.opnds) {
              if (opnd.eval(parser, parserCallStack)) {
                return true;
              }
            }
            return false;
          }
          evalPrecedence(parser, parserCallStack) {
            let differs = false;
            let operands = [];
            for (let context of this.opnds) {
              let evaluated = context.evalPrecedence(parser, parserCallStack);
              differs = differs || evaluated !== context;
              if (evaluated === SemanticContext2.NONE) {
                return SemanticContext2.NONE;
              } else if (evaluated) {
                operands.push(evaluated);
              }
            }
            if (!differs) {
              return this;
            }
            if (operands.length === 0) {
              return void 0;
            }
            let result = operands[0];
            for (let i = 1; i < operands.length; i++) {
              result = SemanticContext2.or(result, operands[i]);
            }
            return result;
          }
          toString() {
            return Utils3.join(this.opnds, "||");
          }
        };
        __decorate([
          Decorators_1.Override
        ], OR.prototype, "operands", null);
        __decorate([
          Decorators_1.Override
        ], OR.prototype, "equals", null);
        __decorate([
          Decorators_1.Override
        ], OR.prototype, "hashCode", null);
        __decorate([
          Decorators_1.Override
        ], OR.prototype, "eval", null);
        __decorate([
          Decorators_1.Override
        ], OR.prototype, "evalPrecedence", null);
        __decorate([
          Decorators_1.Override
        ], OR.prototype, "toString", null);
        OR = __decorate([
          __param(0, Decorators_1.NotNull),
          __param(1, Decorators_1.NotNull)
        ], OR);
        SemanticContext2.OR = OR;
      })(SemanticContext = exports.SemanticContext || (exports.SemanticContext = {}));
    }
  });

  // node_modules/antlr4ts/atn/PredicateTransition.js
  var require_PredicateTransition = __commonJS({
    "node_modules/antlr4ts/atn/PredicateTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PredicateTransition = void 0;
      var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
      var Decorators_1 = require_Decorators();
      var SemanticContext_1 = require_SemanticContext();
      var PredicateTransition = class PredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {
        constructor(target, ruleIndex, predIndex, isCtxDependent) {
          super(target);
          this.ruleIndex = ruleIndex;
          this.predIndex = predIndex;
          this.isCtxDependent = isCtxDependent;
        }
        get serializationType() {
          return 4;
        }
        get isEpsilon() {
          return true;
        }
        matches(symbol, minVocabSymbol, maxVocabSymbol) {
          return false;
        }
        get predicate() {
          return new SemanticContext_1.SemanticContext.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
        }
        toString() {
          return "pred_" + this.ruleIndex + ":" + this.predIndex;
        }
      };
      __decorate([
        Decorators_1.Override
      ], PredicateTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override
      ], PredicateTransition.prototype, "isEpsilon", null);
      __decorate([
        Decorators_1.Override
      ], PredicateTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], PredicateTransition.prototype, "toString", null);
      PredicateTransition = __decorate([
        __param(0, Decorators_1.NotNull)
      ], PredicateTransition);
      exports.PredicateTransition = PredicateTransition;
    }
  });

  // node_modules/antlr4ts/FailedPredicateException.js
  var require_FailedPredicateException = __commonJS({
    "node_modules/antlr4ts/FailedPredicateException.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FailedPredicateException = void 0;
      var RecognitionException_1 = require_RecognitionException();
      var Decorators_1 = require_Decorators();
      var PredicateTransition_1 = require_PredicateTransition();
      var FailedPredicateException2 = class FailedPredicateException3 extends RecognitionException_1.RecognitionException {
        constructor(recognizer, predicate, message) {
          super(recognizer, recognizer.inputStream, recognizer.context, FailedPredicateException3.formatMessage(predicate, message));
          let s = recognizer.interpreter.atn.states[recognizer.state];
          let trans = s.transition(0);
          if (trans instanceof PredicateTransition_1.PredicateTransition) {
            this._ruleIndex = trans.ruleIndex;
            this._predicateIndex = trans.predIndex;
          } else {
            this._ruleIndex = 0;
            this._predicateIndex = 0;
          }
          this._predicate = predicate;
          super.setOffendingToken(recognizer, recognizer.currentToken);
        }
        get ruleIndex() {
          return this._ruleIndex;
        }
        get predicateIndex() {
          return this._predicateIndex;
        }
        get predicate() {
          return this._predicate;
        }
        static formatMessage(predicate, message) {
          if (message) {
            return message;
          }
          return `failed predicate: {${predicate}}?`;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], FailedPredicateException2, "formatMessage", null);
      FailedPredicateException2 = __decorate([
        __param(0, Decorators_1.NotNull)
      ], FailedPredicateException2);
      exports.FailedPredicateException = FailedPredicateException2;
    }
  });

  // node_modules/antlr4ts/InputMismatchException.js
  var require_InputMismatchException = __commonJS({
    "node_modules/antlr4ts/InputMismatchException.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InputMismatchException = void 0;
      var RecognitionException_1 = require_RecognitionException();
      var Decorators_1 = require_Decorators();
      var InputMismatchException = class InputMismatchException extends RecognitionException_1.RecognitionException {
        constructor(recognizer, state, context) {
          if (context === void 0) {
            context = recognizer.context;
          }
          super(recognizer, recognizer.inputStream, context);
          if (state !== void 0) {
            this.setOffendingState(state);
          }
          this.setOffendingToken(recognizer, recognizer.currentToken);
        }
      };
      InputMismatchException = __decorate([
        __param(0, Decorators_1.NotNull)
      ], InputMismatchException);
      exports.InputMismatchException = InputMismatchException;
    }
  });

  // node_modules/antlr4ts/misc/Arrays.js
  var require_Arrays = __commonJS({
    "node_modules/antlr4ts/misc/Arrays.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Arrays = void 0;
      var Arrays;
      (function(Arrays2) {
        function binarySearch(array2, key, fromIndex, toIndex) {
          return binarySearch0(array2, fromIndex !== void 0 ? fromIndex : 0, toIndex !== void 0 ? toIndex : array2.length, key);
        }
        Arrays2.binarySearch = binarySearch;
        function binarySearch0(array2, fromIndex, toIndex, key) {
          let low = fromIndex;
          let high = toIndex - 1;
          while (low <= high) {
            let mid = low + high >>> 1;
            let midVal = array2[mid];
            if (midVal < key) {
              low = mid + 1;
            } else if (midVal > key) {
              high = mid - 1;
            } else {
              return mid;
            }
          }
          return -(low + 1);
        }
        function toString(array2) {
          let result = "[";
          let first = true;
          for (let element of array2) {
            if (first) {
              first = false;
            } else {
              result += ", ";
            }
            if (element === null) {
              result += "null";
            } else if (element === void 0) {
              result += "undefined";
            } else {
              result += element;
            }
          }
          result += "]";
          return result;
        }
        Arrays2.toString = toString;
      })(Arrays = exports.Arrays || (exports.Arrays = {}));
    }
  });

  // node_modules/antlr4ts/misc/IntegerList.js
  var require_IntegerList = __commonJS({
    "node_modules/antlr4ts/misc/IntegerList.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IntegerList = void 0;
      var Arrays_1 = require_Arrays();
      var Decorators_1 = require_Decorators();
      var EMPTY_DATA = new Int32Array(0);
      var INITIAL_SIZE = 4;
      var MAX_ARRAY_SIZE = (1 << 31 >>> 0) - 1 - 8;
      var IntegerList = class _IntegerList {
        constructor(arg) {
          if (!arg) {
            this._data = EMPTY_DATA;
            this._size = 0;
          } else if (arg instanceof _IntegerList) {
            this._data = arg._data.slice(0);
            this._size = arg._size;
          } else if (typeof arg === "number") {
            if (arg === 0) {
              this._data = EMPTY_DATA;
              this._size = 0;
            } else {
              this._data = new Int32Array(arg);
              this._size = 0;
            }
          } else {
            this._data = EMPTY_DATA;
            this._size = 0;
            for (let value of arg) {
              this.add(value);
            }
          }
        }
        add(value) {
          if (this._data.length === this._size) {
            this.ensureCapacity(this._size + 1);
          }
          this._data[this._size] = value;
          this._size++;
        }
        addAll(list) {
          if (Array.isArray(list)) {
            this.ensureCapacity(this._size + list.length);
            this._data.subarray(this._size, this._size + list.length).set(list);
            this._size += list.length;
          } else if (list instanceof _IntegerList) {
            this.ensureCapacity(this._size + list._size);
            this._data.subarray(this._size, this._size + list.size).set(list._data);
            this._size += list._size;
          } else {
            this.ensureCapacity(this._size + list.size);
            let current = 0;
            for (let xi of list) {
              this._data[this._size + current] = xi;
              current++;
            }
            this._size += list.size;
          }
        }
        get(index) {
          if (index < 0 || index >= this._size) {
            throw RangeError();
          }
          return this._data[index];
        }
        contains(value) {
          for (let i = 0; i < this._size; i++) {
            if (this._data[i] === value) {
              return true;
            }
          }
          return false;
        }
        set(index, value) {
          if (index < 0 || index >= this._size) {
            throw RangeError();
          }
          let previous = this._data[index];
          this._data[index] = value;
          return previous;
        }
        removeAt(index) {
          let value = this.get(index);
          this._data.copyWithin(index, index + 1, this._size);
          this._data[this._size - 1] = 0;
          this._size--;
          return value;
        }
        removeRange(fromIndex, toIndex) {
          if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
            throw RangeError();
          }
          if (fromIndex > toIndex) {
            throw RangeError();
          }
          this._data.copyWithin(toIndex, fromIndex, this._size);
          this._data.fill(0, this._size - (toIndex - fromIndex), this._size);
          this._size -= toIndex - fromIndex;
        }
        get isEmpty() {
          return this._size === 0;
        }
        get size() {
          return this._size;
        }
        trimToSize() {
          if (this._data.length === this._size) {
            return;
          }
          this._data = this._data.slice(0, this._size);
        }
        clear() {
          this._data.fill(0, 0, this._size);
          this._size = 0;
        }
        toArray() {
          if (this._size === 0) {
            return [];
          }
          return Array.from(this._data.subarray(0, this._size));
        }
        sort() {
          this._data.subarray(0, this._size).sort();
        }
        /**
         * Compares the specified object with this list for equality.  Returns
         * `true` if and only if the specified object is also an {@link IntegerList},
         * both lists have the same size, and all corresponding pairs of elements in
         * the two lists are equal.  In other words, two lists are defined to be
         * equal if they contain the same elements in the same order.
         *
         * This implementation first checks if the specified object is this
         * list. If so, it returns `true`; if not, it checks if the
         * specified object is an {@link IntegerList}. If not, it returns `false`;
         * if so, it checks the size of both lists. If the lists are not the same size,
         * it returns `false`; otherwise it iterates over both lists, comparing
         * corresponding pairs of elements.  If any comparison returns `false`,
         * this method returns `false`.
         *
         * @param o the object to be compared for equality with this list
         * @returns `true` if the specified object is equal to this list
         */
        equals(o) {
          if (o === this) {
            return true;
          }
          if (!(o instanceof _IntegerList)) {
            return false;
          }
          if (this._size !== o._size) {
            return false;
          }
          for (let i = 0; i < this._size; i++) {
            if (this._data[i] !== o._data[i]) {
              return false;
            }
          }
          return true;
        }
        /**
         * Returns the hash code value for this list.
         *
         * This implementation uses exactly the code that is used to define the
         * list hash function in the documentation for the {@link List#hashCode}
         * method.
         *
         * @returns the hash code value for this list
         */
        hashCode() {
          let hashCode = 1;
          for (let i = 0; i < this._size; i++) {
            hashCode = 31 * hashCode + this._data[i];
          }
          return hashCode;
        }
        /**
         * Returns a string representation of this list.
         */
        toString() {
          return this._data.toString();
        }
        binarySearch(key, fromIndex, toIndex) {
          if (fromIndex === void 0) {
            fromIndex = 0;
          }
          if (toIndex === void 0) {
            toIndex = this._size;
          }
          if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
            throw new RangeError();
          }
          if (fromIndex > toIndex) {
            throw new RangeError();
          }
          return Arrays_1.Arrays.binarySearch(this._data, key, fromIndex, toIndex);
        }
        ensureCapacity(capacity) {
          if (capacity < 0 || capacity > MAX_ARRAY_SIZE) {
            throw new RangeError();
          }
          let newLength;
          if (this._data.length === 0) {
            newLength = INITIAL_SIZE;
          } else {
            newLength = this._data.length;
          }
          while (newLength < capacity) {
            newLength = newLength * 2;
            if (newLength < 0 || newLength > MAX_ARRAY_SIZE) {
              newLength = MAX_ARRAY_SIZE;
            }
          }
          let tmp = new Int32Array(newLength);
          tmp.set(this._data);
          this._data = tmp;
        }
        /** Convert the list to a UTF-16 encoded char array. If all values are less
         *  than the 0xFFFF 16-bit code point limit then this is just a char array
         *  of 16-bit char as usual. For values in the supplementary range, encode
         * them as two UTF-16 code units.
         */
        toCharArray() {
          let resultArray = new Uint16Array(this._size);
          let resultIdx = 0;
          let calculatedPreciseResultSize = false;
          for (let i = 0; i < this._size; i++) {
            let codePoint = this._data[i];
            if (codePoint >= 0 && codePoint < 65536) {
              resultArray[resultIdx] = codePoint;
              resultIdx++;
              continue;
            }
            if (!calculatedPreciseResultSize) {
              let newResultArray = new Uint16Array(this.charArraySize());
              newResultArray.set(resultArray, 0);
              resultArray = newResultArray;
              calculatedPreciseResultSize = true;
            }
            let pair = String.fromCodePoint(codePoint);
            resultArray[resultIdx] = pair.charCodeAt(0);
            resultArray[resultIdx + 1] = pair.charCodeAt(1);
            resultIdx += 2;
          }
          return resultArray;
        }
        charArraySize() {
          let result = 0;
          for (let i = 0; i < this._size; i++) {
            result += this._data[i] >= 65536 ? 2 : 1;
          }
          return result;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], IntegerList.prototype, "_data", void 0);
      __decorate([
        Decorators_1.Override
      ], IntegerList.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], IntegerList.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], IntegerList.prototype, "toString", null);
      exports.IntegerList = IntegerList;
    }
  });

  // node_modules/antlr4ts/misc/Interval.js
  var require_Interval = __commonJS({
    "node_modules/antlr4ts/misc/Interval.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Interval = void 0;
      var Decorators_1 = require_Decorators();
      var INTERVAL_POOL_MAX_VALUE = 1e3;
      var Interval = class _Interval {
        /**
         * @param a The start of the interval
         * @param b The end of the interval (inclusive)
         */
        constructor(a, b) {
          this.a = a;
          this.b = b;
        }
        static get INVALID() {
          return _Interval._INVALID;
        }
        /** Interval objects are used readonly so share all with the
         *  same single value a==b up to some max size.  Use an array as a perfect hash.
         *  Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new
         *  Interval object with a..a in it.  On Java.g4, 218623 IntervalSets
         *  have a..a (set with 1 element).
         */
        static of(a, b) {
          if (a !== b || a < 0 || a > INTERVAL_POOL_MAX_VALUE) {
            return new _Interval(a, b);
          }
          if (_Interval.cache[a] == null) {
            _Interval.cache[a] = new _Interval(a, a);
          }
          return _Interval.cache[a];
        }
        /** return number of elements between a and b inclusively. x..x is length 1.
         *  if b &lt; a, then length is 0.  9..10 has length 2.
         */
        get length() {
          if (this.b < this.a) {
            return 0;
          }
          return this.b - this.a + 1;
        }
        equals(o) {
          if (o === this) {
            return true;
          } else if (!(o instanceof _Interval)) {
            return false;
          }
          return this.a === o.a && this.b === o.b;
        }
        hashCode() {
          let hash = 23;
          hash = hash * 31 + this.a;
          hash = hash * 31 + this.b;
          return hash;
        }
        /** Does this start completely before other? Disjoint */
        startsBeforeDisjoint(other) {
          return this.a < other.a && this.b < other.a;
        }
        /** Does this start at or before other? Nondisjoint */
        startsBeforeNonDisjoint(other) {
          return this.a <= other.a && this.b >= other.a;
        }
        /** Does this.a start after other.b? May or may not be disjoint */
        startsAfter(other) {
          return this.a > other.a;
        }
        /** Does this start completely after other? Disjoint */
        startsAfterDisjoint(other) {
          return this.a > other.b;
        }
        /** Does this start after other? NonDisjoint */
        startsAfterNonDisjoint(other) {
          return this.a > other.a && this.a <= other.b;
        }
        /** Are both ranges disjoint? I.e., no overlap? */
        disjoint(other) {
          return this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);
        }
        /** Are two intervals adjacent such as 0..41 and 42..42? */
        adjacent(other) {
          return this.a === other.b + 1 || this.b === other.a - 1;
        }
        properlyContains(other) {
          return other.a >= this.a && other.b <= this.b;
        }
        /** Return the interval computed from combining this and other */
        union(other) {
          return _Interval.of(Math.min(this.a, other.a), Math.max(this.b, other.b));
        }
        /** Return the interval in common between this and o */
        intersection(other) {
          return _Interval.of(Math.max(this.a, other.a), Math.min(this.b, other.b));
        }
        /** Return the interval with elements from `this` not in `other`;
         *  `other` must not be totally enclosed (properly contained)
         *  within `this`, which would result in two disjoint intervals
         *  instead of the single one returned by this method.
         */
        differenceNotProperlyContained(other) {
          let diff;
          if (other.startsBeforeNonDisjoint(this)) {
            diff = _Interval.of(Math.max(this.a, other.b + 1), this.b);
          } else if (other.startsAfterNonDisjoint(this)) {
            diff = _Interval.of(this.a, other.a - 1);
          }
          return diff;
        }
        toString() {
          return this.a + ".." + this.b;
        }
      };
      Interval._INVALID = new Interval(-1, -2);
      Interval.cache = new Array(INTERVAL_POOL_MAX_VALUE + 1);
      __decorate([
        Decorators_1.Override
      ], Interval.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], Interval.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], Interval.prototype, "toString", null);
      exports.Interval = Interval;
    }
  });

  // node_modules/antlr4ts/Token.js
  var require_Token = __commonJS({
    "node_modules/antlr4ts/Token.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Token = void 0;
      var IntStream_1 = require_IntStream();
      var Token3;
      (function(Token4) {
        Token4.INVALID_TYPE = 0;
        Token4.EPSILON = -2;
        Token4.MIN_USER_TOKEN_TYPE = 1;
        Token4.EOF = IntStream_1.IntStream.EOF;
        Token4.DEFAULT_CHANNEL = 0;
        Token4.HIDDEN_CHANNEL = 1;
        Token4.MIN_USER_CHANNEL_VALUE = 2;
      })(Token3 = exports.Token || (exports.Token = {}));
    }
  });

  // node_modules/antlr4ts/CommonToken.js
  var require_CommonToken = __commonJS({
    "node_modules/antlr4ts/CommonToken.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommonToken = void 0;
      var Interval_1 = require_Interval();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var CommonToken = class CommonToken2 {
        constructor(type, text, source = CommonToken2.EMPTY_SOURCE, channel = Token_1.Token.DEFAULT_CHANNEL, start = 0, stop = 0) {
          this._line = 0;
          this._charPositionInLine = -1;
          this._channel = Token_1.Token.DEFAULT_CHANNEL;
          this.index = -1;
          this._text = text;
          this._type = type;
          this.source = source;
          this._channel = channel;
          this.start = start;
          this.stop = stop;
          if (source.source != null) {
            this._line = source.source.line;
            this._charPositionInLine = source.source.charPositionInLine;
          }
        }
        /**
         * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
         *
         * If `oldToken` is also a {@link CommonToken} instance, the newly
         * constructed token will share a reference to the {@link #text} field and
         * the {@link Tuple2} stored in {@link #source}. Otherwise, {@link #text} will
         * be assigned the result of calling {@link #getText}, and {@link #source}
         * will be constructed from the result of {@link Token#getTokenSource} and
         * {@link Token#getInputStream}.
         *
         * @param oldToken The token to copy.
         */
        static fromToken(oldToken) {
          let result = new CommonToken2(oldToken.type, void 0, CommonToken2.EMPTY_SOURCE, oldToken.channel, oldToken.startIndex, oldToken.stopIndex);
          result._line = oldToken.line;
          result.index = oldToken.tokenIndex;
          result._charPositionInLine = oldToken.charPositionInLine;
          if (oldToken instanceof CommonToken2) {
            result._text = oldToken._text;
            result.source = oldToken.source;
          } else {
            result._text = oldToken.text;
            result.source = { source: oldToken.tokenSource, stream: oldToken.inputStream };
          }
          return result;
        }
        get type() {
          return this._type;
        }
        // @Override
        set type(type) {
          this._type = type;
        }
        get line() {
          return this._line;
        }
        // @Override
        set line(line) {
          this._line = line;
        }
        get text() {
          if (this._text != null) {
            return this._text;
          }
          let input = this.inputStream;
          if (input == null) {
            return void 0;
          }
          let n = input.size;
          if (this.start < n && this.stop < n) {
            return input.getText(Interval_1.Interval.of(this.start, this.stop));
          } else {
            return "<EOF>";
          }
        }
        /**
         * Explicitly set the text for this token. If {code text} is not
         * `undefined`, then {@link #getText} will return this value rather than
         * extracting the text from the input.
         *
         * @param text The explicit text of the token, or `undefined` if the text
         * should be obtained from the input along with the start and stop indexes
         * of the token.
         */
        // @Override
        set text(text) {
          this._text = text;
        }
        get charPositionInLine() {
          return this._charPositionInLine;
        }
        // @Override
        set charPositionInLine(charPositionInLine) {
          this._charPositionInLine = charPositionInLine;
        }
        get channel() {
          return this._channel;
        }
        // @Override
        set channel(channel) {
          this._channel = channel;
        }
        get startIndex() {
          return this.start;
        }
        set startIndex(start) {
          this.start = start;
        }
        get stopIndex() {
          return this.stop;
        }
        set stopIndex(stop) {
          this.stop = stop;
        }
        get tokenIndex() {
          return this.index;
        }
        // @Override
        set tokenIndex(index) {
          this.index = index;
        }
        get tokenSource() {
          return this.source.source;
        }
        get inputStream() {
          return this.source.stream;
        }
        toString(recognizer) {
          let channelStr = "";
          if (this._channel > 0) {
            channelStr = ",channel=" + this._channel;
          }
          let txt = this.text;
          if (txt != null) {
            txt = txt.replace(/\n/g, "\\n");
            txt = txt.replace(/\r/g, "\\r");
            txt = txt.replace(/\t/g, "\\t");
          } else {
            txt = "<no text>";
          }
          let typeString = String(this._type);
          if (recognizer) {
            typeString = recognizer.vocabulary.getDisplayName(this._type);
          }
          return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + txt + "',<" + typeString + ">" + channelStr + "," + this._line + ":" + this.charPositionInLine + "]";
        }
      };
      CommonToken.EMPTY_SOURCE = { source: void 0, stream: void 0 };
      __decorate([
        Decorators_1.NotNull
      ], CommonToken.prototype, "source", void 0);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "type", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "line", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "text", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "charPositionInLine", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "channel", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "startIndex", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "stopIndex", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "tokenIndex", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "tokenSource", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "inputStream", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "toString", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], CommonToken, "fromToken", null);
      CommonToken = __decorate([
        __param(2, Decorators_1.NotNull)
      ], CommonToken);
      exports.CommonToken = CommonToken;
    }
  });

  // node_modules/antlr4ts/CommonTokenFactory.js
  var require_CommonTokenFactory = __commonJS({
    "node_modules/antlr4ts/CommonTokenFactory.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommonTokenFactory = void 0;
      var CommonToken_1 = require_CommonToken();
      var Interval_1 = require_Interval();
      var Decorators_1 = require_Decorators();
      var CommonTokenFactory = class {
        /**
         * Constructs a {@link CommonTokenFactory} with the specified value for
         * {@link #copyText}.
         *
         * When `copyText` is `false`, the {@link #DEFAULT} instance
         * should be used instead of constructing a new instance.
         *
         * @param copyText The value for {@link #copyText}.
         */
        constructor(copyText = false) {
          this.copyText = copyText;
        }
        create(source, type, text, channel, start, stop, line, charPositionInLine) {
          let t = new CommonToken_1.CommonToken(type, text, source, channel, start, stop);
          t.line = line;
          t.charPositionInLine = charPositionInLine;
          if (text == null && this.copyText && source.stream != null) {
            t.text = source.stream.getText(Interval_1.Interval.of(start, stop));
          }
          return t;
        }
        createSimple(type, text) {
          return new CommonToken_1.CommonToken(type, text);
        }
      };
      __decorate([
        Decorators_1.Override
      ], CommonTokenFactory.prototype, "create", null);
      __decorate([
        Decorators_1.Override
      ], CommonTokenFactory.prototype, "createSimple", null);
      exports.CommonTokenFactory = CommonTokenFactory;
      (function(CommonTokenFactory2) {
        CommonTokenFactory2.DEFAULT = new CommonTokenFactory2();
      })(CommonTokenFactory = exports.CommonTokenFactory || (exports.CommonTokenFactory = {}));
    }
  });

  // node_modules/antlr4ts/misc/IntegerStack.js
  var require_IntegerStack = __commonJS({
    "node_modules/antlr4ts/misc/IntegerStack.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IntegerStack = void 0;
      var IntegerList_1 = require_IntegerList();
      var IntegerStack = class extends IntegerList_1.IntegerList {
        constructor(arg) {
          super(arg);
        }
        push(value) {
          this.add(value);
        }
        pop() {
          return this.removeAt(this.size - 1);
        }
        peek() {
          return this.get(this.size - 1);
        }
      };
      exports.IntegerStack = IntegerStack;
    }
  });

  // node_modules/antlr4ts/dfa/AcceptStateInfo.js
  var require_AcceptStateInfo = __commonJS({
    "node_modules/antlr4ts/dfa/AcceptStateInfo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AcceptStateInfo = void 0;
      var AcceptStateInfo = class {
        constructor(prediction, lexerActionExecutor) {
          this._prediction = prediction;
          this._lexerActionExecutor = lexerActionExecutor;
        }
        /**
         * Gets the prediction made by this accept state. Note that this value
         * assumes the predicates, if any, in the {@link DFAState} evaluate to
         * `true`. If predicate evaluation is enabled, the final prediction of
         * the accept state will be determined by the result of predicate
         * evaluation.
         */
        get prediction() {
          return this._prediction;
        }
        /**
         * Gets the {@link LexerActionExecutor} which can be used to execute actions
         * and/or commands after the lexer matches a token.
         */
        get lexerActionExecutor() {
          return this._lexerActionExecutor;
        }
      };
      exports.AcceptStateInfo = AcceptStateInfo;
    }
  });

  // node_modules/antlr4ts/misc/Array2DHashMap.js
  var require_Array2DHashMap = __commonJS({
    "node_modules/antlr4ts/misc/Array2DHashMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Array2DHashMap = void 0;
      var Array2DHashSet_1 = require_Array2DHashSet();
      var MapKeyEqualityComparator = class {
        constructor(keyComparator) {
          this.keyComparator = keyComparator;
        }
        hashCode(obj) {
          return this.keyComparator.hashCode(obj.key);
        }
        equals(a, b) {
          return this.keyComparator.equals(a.key, b.key);
        }
      };
      var Array2DHashMap = class _Array2DHashMap {
        constructor(keyComparer) {
          if (keyComparer instanceof _Array2DHashMap) {
            this.backingStore = new Array2DHashSet_1.Array2DHashSet(keyComparer.backingStore);
          } else {
            this.backingStore = new Array2DHashSet_1.Array2DHashSet(new MapKeyEqualityComparator(keyComparer));
          }
        }
        clear() {
          this.backingStore.clear();
        }
        containsKey(key) {
          return this.backingStore.contains({ key });
        }
        get(key) {
          let bucket = this.backingStore.get({ key });
          if (!bucket) {
            return void 0;
          }
          return bucket.value;
        }
        get isEmpty() {
          return this.backingStore.isEmpty;
        }
        put(key, value) {
          let element = this.backingStore.get({ key, value });
          let result;
          if (!element) {
            this.backingStore.add({ key, value });
          } else {
            result = element.value;
            element.value = value;
          }
          return result;
        }
        putIfAbsent(key, value) {
          let element = this.backingStore.get({ key, value });
          let result;
          if (!element) {
            this.backingStore.add({ key, value });
          } else {
            result = element.value;
          }
          return result;
        }
        get size() {
          return this.backingStore.size;
        }
        hashCode() {
          return this.backingStore.hashCode();
        }
        equals(o) {
          if (!(o instanceof _Array2DHashMap)) {
            return false;
          }
          return this.backingStore.equals(o.backingStore);
        }
      };
      exports.Array2DHashMap = Array2DHashMap;
    }
  });

  // node_modules/antlr4ts/atn/DecisionState.js
  var require_DecisionState = __commonJS({
    "node_modules/antlr4ts/atn/DecisionState.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DecisionState = void 0;
      var ATNState_1 = require_ATNState();
      var DecisionState = class extends ATNState_1.ATNState {
        constructor() {
          super(...arguments);
          this.decision = -1;
          this.nonGreedy = false;
          this.sll = false;
        }
      };
      exports.DecisionState = DecisionState;
    }
  });

  // node_modules/antlr4ts/atn/PredictionContextCache.js
  var require_PredictionContextCache = __commonJS({
    "node_modules/antlr4ts/atn/PredictionContextCache.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PredictionContextCache = void 0;
      var Array2DHashMap_1 = require_Array2DHashMap();
      var Decorators_1 = require_Decorators();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var PredictionContext_1 = require_PredictionContext();
      var assert = require_assert();
      var PredictionContextCache = class _PredictionContextCache {
        constructor(enableCache = true) {
          this.contexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          this.childContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          this.joinContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          this.enableCache = enableCache;
        }
        getAsCached(context) {
          if (!this.enableCache) {
            return context;
          }
          let result = this.contexts.get(context);
          if (!result) {
            result = context;
            this.contexts.put(context, context);
          }
          return result;
        }
        getChild(context, invokingState) {
          if (!this.enableCache) {
            return context.getChild(invokingState);
          }
          let operands = new _PredictionContextCache.PredictionContextAndInt(context, invokingState);
          let result = this.childContexts.get(operands);
          if (!result) {
            result = context.getChild(invokingState);
            result = this.getAsCached(result);
            this.childContexts.put(operands, result);
          }
          return result;
        }
        join(x, y) {
          if (!this.enableCache) {
            return PredictionContext_1.PredictionContext.join(x, y, this);
          }
          let operands = new _PredictionContextCache.IdentityCommutativePredictionContextOperands(x, y);
          let result = this.joinContexts.get(operands);
          if (result) {
            return result;
          }
          result = PredictionContext_1.PredictionContext.join(x, y, this);
          result = this.getAsCached(result);
          this.joinContexts.put(operands, result);
          return result;
        }
      };
      exports.PredictionContextCache = PredictionContextCache;
      PredictionContextCache.UNCACHED = new PredictionContextCache(false);
      (function(PredictionContextCache2) {
        class PredictionContextAndInt {
          constructor(obj, value) {
            this.obj = obj;
            this.value = value;
          }
          equals(obj) {
            if (!(obj instanceof PredictionContextAndInt)) {
              return false;
            } else if (obj === this) {
              return true;
            }
            let other = obj;
            return this.value === other.value && (this.obj === other.obj || this.obj != null && this.obj.equals(other.obj));
          }
          hashCode() {
            let hashCode = 5;
            hashCode = 7 * hashCode + (this.obj != null ? this.obj.hashCode() : 0);
            hashCode = 7 * hashCode + this.value;
            return hashCode;
          }
        }
        __decorate([
          Decorators_1.Override
        ], PredictionContextAndInt.prototype, "equals", null);
        __decorate([
          Decorators_1.Override
        ], PredictionContextAndInt.prototype, "hashCode", null);
        PredictionContextCache2.PredictionContextAndInt = PredictionContextAndInt;
        class IdentityCommutativePredictionContextOperands {
          constructor(x, y) {
            assert(x != null);
            assert(y != null);
            this._x = x;
            this._y = y;
          }
          get x() {
            return this._x;
          }
          get y() {
            return this._y;
          }
          equals(o) {
            if (!(o instanceof IdentityCommutativePredictionContextOperands)) {
              return false;
            } else if (this === o) {
              return true;
            }
            let other = o;
            return this._x === other._x && this._y === other._y || this._x === other._y && this._y === other._x;
          }
          hashCode() {
            return this._x.hashCode() ^ this._y.hashCode();
          }
        }
        __decorate([
          Decorators_1.Override
        ], IdentityCommutativePredictionContextOperands.prototype, "equals", null);
        __decorate([
          Decorators_1.Override
        ], IdentityCommutativePredictionContextOperands.prototype, "hashCode", null);
        PredictionContextCache2.IdentityCommutativePredictionContextOperands = IdentityCommutativePredictionContextOperands;
      })(PredictionContextCache = exports.PredictionContextCache || (exports.PredictionContextCache = {}));
    }
  });

  // node_modules/antlr4ts/atn/PredictionContext.js
  var require_PredictionContext = __commonJS({
    "node_modules/antlr4ts/atn/PredictionContext.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SingletonPredictionContext = exports.PredictionContext = void 0;
      var Array2DHashMap_1 = require_Array2DHashMap();
      var Array2DHashSet_1 = require_Array2DHashSet();
      var Arrays_1 = require_Arrays();
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var PredictionContextCache_1 = require_PredictionContextCache();
      var assert = require_assert();
      var INITIAL_HASH = 1;
      var PredictionContext = class _PredictionContext {
        constructor(cachedHashCode) {
          this.cachedHashCode = cachedHashCode;
        }
        static calculateEmptyHashCode() {
          let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
          hash = MurmurHash_1.MurmurHash.finish(hash, 0);
          return hash;
        }
        static calculateSingleHashCode(parent, returnState) {
          let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
          hash = MurmurHash_1.MurmurHash.update(hash, parent);
          hash = MurmurHash_1.MurmurHash.update(hash, returnState);
          hash = MurmurHash_1.MurmurHash.finish(hash, 2);
          return hash;
        }
        static calculateHashCode(parents, returnStates) {
          let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
          for (let parent of parents) {
            hash = MurmurHash_1.MurmurHash.update(hash, parent);
          }
          for (let returnState of returnStates) {
            hash = MurmurHash_1.MurmurHash.update(hash, returnState);
          }
          hash = MurmurHash_1.MurmurHash.finish(hash, 2 * parents.length);
          return hash;
        }
        static fromRuleContext(atn, outerContext, fullContext = true) {
          if (outerContext.isEmpty) {
            return fullContext ? _PredictionContext.EMPTY_FULL : _PredictionContext.EMPTY_LOCAL;
          }
          let parent;
          if (outerContext._parent) {
            parent = _PredictionContext.fromRuleContext(atn, outerContext._parent, fullContext);
          } else {
            parent = fullContext ? _PredictionContext.EMPTY_FULL : _PredictionContext.EMPTY_LOCAL;
          }
          let state = atn.states[outerContext.invokingState];
          let transition = state.transition(0);
          return parent.getChild(transition.followState.stateNumber);
        }
        static addEmptyContext(context) {
          return context.addEmptyContext();
        }
        static removeEmptyContext(context) {
          return context.removeEmptyContext();
        }
        static join(context0, context1, contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED) {
          if (context0 === context1) {
            return context0;
          }
          if (context0.isEmpty) {
            return _PredictionContext.isEmptyLocal(context0) ? context0 : _PredictionContext.addEmptyContext(context1);
          } else if (context1.isEmpty) {
            return _PredictionContext.isEmptyLocal(context1) ? context1 : _PredictionContext.addEmptyContext(context0);
          }
          let context0size = context0.size;
          let context1size = context1.size;
          if (context0size === 1 && context1size === 1 && context0.getReturnState(0) === context1.getReturnState(0)) {
            let merged = contextCache.join(context0.getParent(0), context1.getParent(0));
            if (merged === context0.getParent(0)) {
              return context0;
            } else if (merged === context1.getParent(0)) {
              return context1;
            } else {
              return merged.getChild(context0.getReturnState(0));
            }
          }
          let count = 0;
          let parentsList = new Array(context0size + context1size);
          let returnStatesList = new Array(parentsList.length);
          let leftIndex = 0;
          let rightIndex = 0;
          let canReturnLeft = true;
          let canReturnRight = true;
          while (leftIndex < context0size && rightIndex < context1size) {
            if (context0.getReturnState(leftIndex) === context1.getReturnState(rightIndex)) {
              parentsList[count] = contextCache.join(context0.getParent(leftIndex), context1.getParent(rightIndex));
              returnStatesList[count] = context0.getReturnState(leftIndex);
              canReturnLeft = canReturnLeft && parentsList[count] === context0.getParent(leftIndex);
              canReturnRight = canReturnRight && parentsList[count] === context1.getParent(rightIndex);
              leftIndex++;
              rightIndex++;
            } else if (context0.getReturnState(leftIndex) < context1.getReturnState(rightIndex)) {
              parentsList[count] = context0.getParent(leftIndex);
              returnStatesList[count] = context0.getReturnState(leftIndex);
              canReturnRight = false;
              leftIndex++;
            } else {
              assert(context1.getReturnState(rightIndex) < context0.getReturnState(leftIndex));
              parentsList[count] = context1.getParent(rightIndex);
              returnStatesList[count] = context1.getReturnState(rightIndex);
              canReturnLeft = false;
              rightIndex++;
            }
            count++;
          }
          while (leftIndex < context0size) {
            parentsList[count] = context0.getParent(leftIndex);
            returnStatesList[count] = context0.getReturnState(leftIndex);
            leftIndex++;
            canReturnRight = false;
            count++;
          }
          while (rightIndex < context1size) {
            parentsList[count] = context1.getParent(rightIndex);
            returnStatesList[count] = context1.getReturnState(rightIndex);
            rightIndex++;
            canReturnLeft = false;
            count++;
          }
          if (canReturnLeft) {
            return context0;
          } else if (canReturnRight) {
            return context1;
          }
          if (count < parentsList.length) {
            parentsList = parentsList.slice(0, count);
            returnStatesList = returnStatesList.slice(0, count);
          }
          if (parentsList.length === 0) {
            return _PredictionContext.EMPTY_FULL;
          } else if (parentsList.length === 1) {
            return new SingletonPredictionContext(parentsList[0], returnStatesList[0]);
          } else {
            return new ArrayPredictionContext(parentsList, returnStatesList);
          }
        }
        static isEmptyLocal(context) {
          return context === _PredictionContext.EMPTY_LOCAL;
        }
        static getCachedContext(context, contextCache, visited) {
          if (context.isEmpty) {
            return context;
          }
          let existing = visited.get(context);
          if (existing) {
            return existing;
          }
          existing = contextCache.get(context);
          if (existing) {
            visited.put(context, existing);
            return existing;
          }
          let changed = false;
          let parents = new Array(context.size);
          for (let i = 0; i < parents.length; i++) {
            let parent = _PredictionContext.getCachedContext(context.getParent(i), contextCache, visited);
            if (changed || parent !== context.getParent(i)) {
              if (!changed) {
                parents = new Array(context.size);
                for (let j = 0; j < context.size; j++) {
                  parents[j] = context.getParent(j);
                }
                changed = true;
              }
              parents[i] = parent;
            }
          }
          if (!changed) {
            existing = contextCache.putIfAbsent(context, context);
            visited.put(context, existing != null ? existing : context);
            return context;
          }
          let updated;
          if (parents.length === 1) {
            updated = new SingletonPredictionContext(parents[0], context.getReturnState(0));
          } else {
            let returnStates = new Array(context.size);
            for (let i = 0; i < context.size; i++) {
              returnStates[i] = context.getReturnState(i);
            }
            updated = new ArrayPredictionContext(parents, returnStates, context.hashCode());
          }
          existing = contextCache.putIfAbsent(updated, updated);
          visited.put(updated, existing || updated);
          visited.put(context, existing || updated);
          return updated;
        }
        appendSingleContext(returnContext, contextCache) {
          return this.appendContext(_PredictionContext.EMPTY_FULL.getChild(returnContext), contextCache);
        }
        getChild(returnState) {
          return new SingletonPredictionContext(this, returnState);
        }
        hashCode() {
          return this.cachedHashCode;
        }
        toStrings(recognizer, currentState, stop = _PredictionContext.EMPTY_FULL) {
          let result = [];
          outer: for (let perm = 0; ; perm++) {
            let offset = 0;
            let last = true;
            let p = this;
            let stateNumber = currentState;
            let localBuffer = "";
            localBuffer += "[";
            while (!p.isEmpty && p !== stop) {
              let index = 0;
              if (p.size > 0) {
                let bits = 1;
                while (1 << bits >>> 0 < p.size) {
                  bits++;
                }
                let mask = (1 << bits >>> 0) - 1;
                index = perm >> offset & mask;
                last = last && index >= p.size - 1;
                if (index >= p.size) {
                  continue outer;
                }
                offset += bits;
              }
              if (recognizer) {
                if (localBuffer.length > 1) {
                  localBuffer += " ";
                }
                let atn = recognizer.atn;
                let s = atn.states[stateNumber];
                let ruleName = recognizer.ruleNames[s.ruleIndex];
                localBuffer += ruleName;
              } else if (p.getReturnState(index) !== _PredictionContext.EMPTY_FULL_STATE_KEY) {
                if (!p.isEmpty) {
                  if (localBuffer.length > 1) {
                    localBuffer += " ";
                  }
                  localBuffer += p.getReturnState(index);
                }
              }
              stateNumber = p.getReturnState(index);
              p = p.getParent(index);
            }
            localBuffer += "]";
            result.push(localBuffer);
            if (last) {
              break;
            }
          }
          return result;
        }
      };
      __decorate([
        Decorators_1.Override
      ], PredictionContext.prototype, "hashCode", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], PredictionContext, "join", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], PredictionContext, "getCachedContext", null);
      exports.PredictionContext = PredictionContext;
      var EmptyPredictionContext = class extends PredictionContext {
        constructor(fullContext) {
          super(PredictionContext.calculateEmptyHashCode());
          this.fullContext = fullContext;
        }
        get isFullContext() {
          return this.fullContext;
        }
        addEmptyContext() {
          return this;
        }
        removeEmptyContext() {
          throw new Error("Cannot remove the empty context from itself.");
        }
        getParent(index) {
          throw new Error("index out of bounds");
        }
        getReturnState(index) {
          throw new Error("index out of bounds");
        }
        findReturnState(returnState) {
          return -1;
        }
        get size() {
          return 0;
        }
        appendSingleContext(returnContext, contextCache) {
          return contextCache.getChild(this, returnContext);
        }
        appendContext(suffix, contextCache) {
          return suffix;
        }
        get isEmpty() {
          return true;
        }
        get hasEmpty() {
          return true;
        }
        equals(o) {
          return this === o;
        }
        toStrings(recognizer, currentState, stop) {
          return ["[]"];
        }
      };
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "addEmptyContext", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "removeEmptyContext", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "getParent", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "getReturnState", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "findReturnState", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "appendSingleContext", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "appendContext", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "isEmpty", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "hasEmpty", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "toStrings", null);
      var ArrayPredictionContext = class ArrayPredictionContext2 extends PredictionContext {
        constructor(parents, returnStates, hashCode) {
          super(hashCode || PredictionContext.calculateHashCode(parents, returnStates));
          assert(parents.length === returnStates.length);
          assert(returnStates.length > 1 || returnStates[0] !== PredictionContext.EMPTY_FULL_STATE_KEY, "Should be using PredictionContext.EMPTY instead.");
          this.parents = parents;
          this.returnStates = returnStates;
        }
        getParent(index) {
          return this.parents[index];
        }
        getReturnState(index) {
          return this.returnStates[index];
        }
        findReturnState(returnState) {
          return Arrays_1.Arrays.binarySearch(this.returnStates, returnState);
        }
        get size() {
          return this.returnStates.length;
        }
        get isEmpty() {
          return false;
        }
        get hasEmpty() {
          return this.returnStates[this.returnStates.length - 1] === PredictionContext.EMPTY_FULL_STATE_KEY;
        }
        addEmptyContext() {
          if (this.hasEmpty) {
            return this;
          }
          let parents2 = this.parents.slice(0);
          let returnStates2 = this.returnStates.slice(0);
          parents2.push(PredictionContext.EMPTY_FULL);
          returnStates2.push(PredictionContext.EMPTY_FULL_STATE_KEY);
          return new ArrayPredictionContext2(parents2, returnStates2);
        }
        removeEmptyContext() {
          if (!this.hasEmpty) {
            return this;
          }
          if (this.returnStates.length === 2) {
            return new SingletonPredictionContext(this.parents[0], this.returnStates[0]);
          } else {
            let parents2 = this.parents.slice(0, this.parents.length - 1);
            let returnStates2 = this.returnStates.slice(0, this.returnStates.length - 1);
            return new ArrayPredictionContext2(parents2, returnStates2);
          }
        }
        appendContext(suffix, contextCache) {
          return ArrayPredictionContext2.appendContextImpl(this, suffix, new PredictionContext.IdentityHashMap());
        }
        static appendContextImpl(context, suffix, visited) {
          if (suffix.isEmpty) {
            if (PredictionContext.isEmptyLocal(suffix)) {
              if (context.hasEmpty) {
                return PredictionContext.EMPTY_LOCAL;
              }
              throw new Error("what to do here?");
            }
            return context;
          }
          if (suffix.size !== 1) {
            throw new Error("Appending a tree suffix is not yet supported.");
          }
          let result = visited.get(context);
          if (!result) {
            if (context.isEmpty) {
              result = suffix;
            } else {
              let parentCount = context.size;
              if (context.hasEmpty) {
                parentCount--;
              }
              let updatedParents = new Array(parentCount);
              let updatedReturnStates = new Array(parentCount);
              for (let i = 0; i < parentCount; i++) {
                updatedReturnStates[i] = context.getReturnState(i);
              }
              for (let i = 0; i < parentCount; i++) {
                updatedParents[i] = ArrayPredictionContext2.appendContextImpl(context.getParent(i), suffix, visited);
              }
              if (updatedParents.length === 1) {
                result = new SingletonPredictionContext(updatedParents[0], updatedReturnStates[0]);
              } else {
                assert(updatedParents.length > 1);
                result = new ArrayPredictionContext2(updatedParents, updatedReturnStates);
              }
              if (context.hasEmpty) {
                result = PredictionContext.join(result, suffix);
              }
            }
            visited.put(context, result);
          }
          return result;
        }
        equals(o) {
          if (this === o) {
            return true;
          } else if (!(o instanceof ArrayPredictionContext2)) {
            return false;
          }
          if (this.hashCode() !== o.hashCode()) {
            return false;
          }
          let other = o;
          return this.equalsImpl(other, new Array2DHashSet_1.Array2DHashSet());
        }
        equalsImpl(other, visited) {
          let selfWorkList = [];
          let otherWorkList = [];
          selfWorkList.push(this);
          otherWorkList.push(other);
          while (true) {
            let currentSelf = selfWorkList.pop();
            let currentOther = otherWorkList.pop();
            if (!currentSelf || !currentOther) {
              break;
            }
            let operands = new PredictionContextCache_1.PredictionContextCache.IdentityCommutativePredictionContextOperands(currentSelf, currentOther);
            if (!visited.add(operands)) {
              continue;
            }
            let selfSize = operands.x.size;
            if (selfSize === 0) {
              if (!operands.x.equals(operands.y)) {
                return false;
              }
              continue;
            }
            let otherSize = operands.y.size;
            if (selfSize !== otherSize) {
              return false;
            }
            for (let i = 0; i < selfSize; i++) {
              if (operands.x.getReturnState(i) !== operands.y.getReturnState(i)) {
                return false;
              }
              let selfParent = operands.x.getParent(i);
              let otherParent = operands.y.getParent(i);
              if (selfParent.hashCode() !== otherParent.hashCode()) {
                return false;
              }
              if (selfParent !== otherParent) {
                selfWorkList.push(selfParent);
                otherWorkList.push(otherParent);
              }
            }
          }
          return true;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ArrayPredictionContext.prototype, "parents", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ArrayPredictionContext.prototype, "returnStates", void 0);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "getParent", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "getReturnState", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "findReturnState", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "isEmpty", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "hasEmpty", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "addEmptyContext", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "removeEmptyContext", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "appendContext", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "equals", null);
      ArrayPredictionContext = __decorate([
        __param(0, Decorators_1.NotNull)
      ], ArrayPredictionContext);
      var SingletonPredictionContext = class SingletonPredictionContext2 extends PredictionContext {
        constructor(parent, returnState) {
          super(PredictionContext.calculateSingleHashCode(parent, returnState));
          this.parent = parent;
          this.returnState = returnState;
        }
        getParent(index) {
          return this.parent;
        }
        getReturnState(index) {
          return this.returnState;
        }
        findReturnState(returnState) {
          return this.returnState === returnState ? 0 : -1;
        }
        get size() {
          return 1;
        }
        get isEmpty() {
          return false;
        }
        get hasEmpty() {
          return false;
        }
        appendContext(suffix, contextCache) {
          return contextCache.getChild(this.parent.appendContext(suffix, contextCache), this.returnState);
        }
        addEmptyContext() {
          let parents = [this.parent, PredictionContext.EMPTY_FULL];
          let returnStates = [this.returnState, PredictionContext.EMPTY_FULL_STATE_KEY];
          return new ArrayPredictionContext(parents, returnStates);
        }
        removeEmptyContext() {
          return this;
        }
        equals(o) {
          if (o === this) {
            return true;
          } else if (!(o instanceof SingletonPredictionContext2)) {
            return false;
          }
          let other = o;
          if (this.hashCode() !== other.hashCode()) {
            return false;
          }
          return this.returnState === other.returnState && this.parent.equals(other.parent);
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], SingletonPredictionContext.prototype, "parent", void 0);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "getParent", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "getReturnState", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "findReturnState", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "isEmpty", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "hasEmpty", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "appendContext", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "addEmptyContext", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "removeEmptyContext", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "equals", null);
      SingletonPredictionContext = __decorate([
        __param(0, Decorators_1.NotNull)
      ], SingletonPredictionContext);
      exports.SingletonPredictionContext = SingletonPredictionContext;
      (function(PredictionContext2) {
        PredictionContext2.EMPTY_LOCAL = new EmptyPredictionContext(false);
        PredictionContext2.EMPTY_FULL = new EmptyPredictionContext(true);
        PredictionContext2.EMPTY_LOCAL_STATE_KEY = -(1 << 31 >>> 0);
        PredictionContext2.EMPTY_FULL_STATE_KEY = (1 << 31 >>> 0) - 1;
        class IdentityHashMap extends Array2DHashMap_1.Array2DHashMap {
          constructor() {
            super(IdentityEqualityComparator.INSTANCE);
          }
        }
        PredictionContext2.IdentityHashMap = IdentityHashMap;
        class IdentityEqualityComparator {
          IdentityEqualityComparator() {
          }
          hashCode(obj) {
            return obj.hashCode();
          }
          equals(a, b) {
            return a === b;
          }
        }
        IdentityEqualityComparator.INSTANCE = new IdentityEqualityComparator();
        __decorate([
          Decorators_1.Override
        ], IdentityEqualityComparator.prototype, "hashCode", null);
        __decorate([
          Decorators_1.Override
        ], IdentityEqualityComparator.prototype, "equals", null);
        PredictionContext2.IdentityEqualityComparator = IdentityEqualityComparator;
      })(PredictionContext = exports.PredictionContext || (exports.PredictionContext = {}));
    }
  });

  // node_modules/antlr4ts/atn/ATNConfig.js
  var require_ATNConfig = __commonJS({
    "node_modules/antlr4ts/atn/ATNConfig.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATNConfig = void 0;
      var Array2DHashMap_1 = require_Array2DHashMap();
      var DecisionState_1 = require_DecisionState();
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var PredictionContext_1 = require_PredictionContext();
      var SemanticContext_1 = require_SemanticContext();
      var assert = require_assert();
      var SUPPRESS_PRECEDENCE_FILTER = 2147483648;
      var ATNConfig = class ATNConfig2 {
        constructor(state, altOrConfig, context) {
          if (typeof altOrConfig === "number") {
            assert((altOrConfig & 16777215) === altOrConfig);
            this._state = state;
            this.altAndOuterContextDepth = altOrConfig;
            this._context = context;
          } else {
            this._state = state;
            this.altAndOuterContextDepth = altOrConfig.altAndOuterContextDepth;
            this._context = context;
          }
        }
        static create(state, alt, context, semanticContext = SemanticContext_1.SemanticContext.NONE, lexerActionExecutor) {
          if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
            if (lexerActionExecutor != null) {
              return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, alt, context, false);
            } else {
              return new SemanticContextATNConfig(semanticContext, state, alt, context);
            }
          } else if (lexerActionExecutor != null) {
            return new ActionATNConfig(lexerActionExecutor, state, alt, context, false);
          } else {
            return new ATNConfig2(state, alt, context);
          }
        }
        /** Gets the ATN state associated with this configuration */
        get state() {
          return this._state;
        }
        /** What alt (or lexer rule) is predicted by this configuration */
        get alt() {
          return this.altAndOuterContextDepth & 16777215;
        }
        get context() {
          return this._context;
        }
        set context(context) {
          this._context = context;
        }
        get reachesIntoOuterContext() {
          return this.outerContextDepth !== 0;
        }
        /**
         * We cannot execute predicates dependent upon local context unless
         * we know for sure we are in the correct context. Because there is
         * no way to do this efficiently, we simply cannot evaluate
         * dependent predicates unless we are in the rule that initially
         * invokes the ATN simulator.
         *
         * closure() tracks the depth of how far we dip into the outer context:
         * depth &gt; 0.  Note that it may not be totally accurate depth since I
         * don't ever decrement. TODO: make it a boolean then
         */
        get outerContextDepth() {
          return this.altAndOuterContextDepth >>> 24 & 127;
        }
        set outerContextDepth(outerContextDepth) {
          assert(outerContextDepth >= 0);
          outerContextDepth = Math.min(outerContextDepth, 127);
          this.altAndOuterContextDepth = outerContextDepth << 24 | (this.altAndOuterContextDepth & ~2130706432) >>> 0;
        }
        get lexerActionExecutor() {
          return void 0;
        }
        get semanticContext() {
          return SemanticContext_1.SemanticContext.NONE;
        }
        get hasPassedThroughNonGreedyDecision() {
          return false;
        }
        clone() {
          return this.transform(this.state, false);
        }
        transform(state, checkNonGreedy, arg2) {
          if (arg2 == null) {
            return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
          } else if (arg2 instanceof PredictionContext_1.PredictionContext) {
            return this.transformImpl(state, arg2, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
          } else if (arg2 instanceof SemanticContext_1.SemanticContext) {
            return this.transformImpl(state, this._context, arg2, checkNonGreedy, this.lexerActionExecutor);
          } else {
            return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, arg2);
          }
        }
        transformImpl(state, context, semanticContext, checkNonGreedy, lexerActionExecutor) {
          let passedThroughNonGreedy = checkNonGreedy && ATNConfig2.checkNonGreedyDecision(this, state);
          if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
            if (lexerActionExecutor != null || passedThroughNonGreedy) {
              return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, this, context, passedThroughNonGreedy);
            } else {
              return new SemanticContextATNConfig(semanticContext, state, this, context);
            }
          } else if (lexerActionExecutor != null || passedThroughNonGreedy) {
            return new ActionATNConfig(lexerActionExecutor, state, this, context, passedThroughNonGreedy);
          } else {
            return new ATNConfig2(state, this, context);
          }
        }
        static checkNonGreedyDecision(source, target) {
          return source.hasPassedThroughNonGreedyDecision || target instanceof DecisionState_1.DecisionState && target.nonGreedy;
        }
        appendContext(context, contextCache) {
          if (typeof context === "number") {
            let appendedContext = this.context.appendSingleContext(context, contextCache);
            let result = this.transform(this.state, false, appendedContext);
            return result;
          } else {
            let appendedContext = this.context.appendContext(context, contextCache);
            let result = this.transform(this.state, false, appendedContext);
            return result;
          }
        }
        /**
         * Determines if this `ATNConfig` fully contains another `ATNConfig`.
         *
         * An ATN configuration represents a position (including context) in an ATN during parsing. Since `ATNConfig` stores
         * the context as a graph, a single `ATNConfig` instance is capable of representing many ATN configurations which
         * are all in the same "location" but have different contexts. These `ATNConfig` instances are again merged when
         * they are added to an `ATNConfigSet`. This method supports `ATNConfigSet.contains` by evaluating whether a
         * particular `ATNConfig` contains all of the ATN configurations represented by another `ATNConfig`.
         *
         * An `ATNConfig` _a_ contains another `ATNConfig` _b_ if all of the following conditions are met:
         *
         * * The configurations are in the same state (`state`)
         * * The configurations predict the same alternative (`alt`)
         * * The semantic context of _a_ implies the semantic context of _b_ (this method performs a weaker equality check)
         * * Joining the prediction contexts of _a_ and _b_ results in the prediction context of _a_
         *
         * This method implements a conservative approximation of containment. As a result, when this method returns `true`
         * it is known that parsing from `subconfig` can only recognize a subset of the inputs which can be recognized
         * starting at the current `ATNConfig`. However, due to the imprecise evaluation of implication for the semantic
         * contexts, no assumptions can be made about the relationship between the configurations when this method returns
         * `false`.
         *
         * @param subconfig The sub configuration.
         * @returns `true` if this configuration contains `subconfig`; otherwise, `false`.
         */
        contains(subconfig) {
          if (this.state.stateNumber !== subconfig.state.stateNumber || this.alt !== subconfig.alt || !this.semanticContext.equals(subconfig.semanticContext)) {
            return false;
          }
          let leftWorkList = [];
          let rightWorkList = [];
          leftWorkList.push(this.context);
          rightWorkList.push(subconfig.context);
          while (true) {
            let left = leftWorkList.pop();
            let right = rightWorkList.pop();
            if (!left || !right) {
              break;
            }
            if (left === right) {
              return true;
            }
            if (left.size < right.size) {
              return false;
            }
            if (right.isEmpty) {
              return left.hasEmpty;
            } else {
              for (let i = 0; i < right.size; i++) {
                let index = left.findReturnState(right.getReturnState(i));
                if (index < 0) {
                  return false;
                }
                leftWorkList.push(left.getParent(index));
                rightWorkList.push(right.getParent(i));
              }
            }
          }
          return false;
        }
        get isPrecedenceFilterSuppressed() {
          return (this.altAndOuterContextDepth & SUPPRESS_PRECEDENCE_FILTER) !== 0;
        }
        set isPrecedenceFilterSuppressed(value) {
          if (value) {
            this.altAndOuterContextDepth |= SUPPRESS_PRECEDENCE_FILTER;
          } else {
            this.altAndOuterContextDepth &= ~SUPPRESS_PRECEDENCE_FILTER;
          }
        }
        /** An ATN configuration is equal to another if both have
         *  the same state, they predict the same alternative, and
         *  syntactic/semantic contexts are the same.
         */
        equals(o) {
          if (this === o) {
            return true;
          } else if (!(o instanceof ATNConfig2)) {
            return false;
          }
          return this.state.stateNumber === o.state.stateNumber && this.alt === o.alt && this.reachesIntoOuterContext === o.reachesIntoOuterContext && this.context.equals(o.context) && this.semanticContext.equals(o.semanticContext) && this.isPrecedenceFilterSuppressed === o.isPrecedenceFilterSuppressed && this.hasPassedThroughNonGreedyDecision === o.hasPassedThroughNonGreedyDecision && ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(this.lexerActionExecutor, o.lexerActionExecutor);
        }
        hashCode() {
          let hashCode = MurmurHash_1.MurmurHash.initialize(7);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.state.stateNumber);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.alt);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.reachesIntoOuterContext ? 1 : 0);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.context);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.semanticContext);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.hasPassedThroughNonGreedyDecision ? 1 : 0);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.lexerActionExecutor);
          hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 7);
          return hashCode;
        }
        /**
         * Returns a graphical representation of the current `ATNConfig` in Graphviz format. The graph can be stored to a
         * **.dot** file and then rendered to an image using Graphviz.
         *
         * @returns A Graphviz graph representing the current `ATNConfig`.
         *
         * @see http://www.graphviz.org/
         */
        toDotString() {
          let builder = "";
          builder += "digraph G {\n";
          builder += "rankdir=LR;\n";
          let visited = new Array2DHashMap_1.Array2DHashMap(PredictionContext_1.PredictionContext.IdentityEqualityComparator.INSTANCE);
          let workList = [];
          function getOrAddContext(context) {
            let newNumber = visited.size;
            let result = visited.putIfAbsent(context, newNumber);
            if (result != null) {
              return result;
            }
            workList.push(context);
            return newNumber;
          }
          workList.push(this.context);
          visited.put(this.context, 0);
          while (true) {
            let current = workList.pop();
            if (!current) {
              break;
            }
            for (let i = 0; i < current.size; i++) {
              builder += "  s" + getOrAddContext(current);
              builder += "->";
              builder += "s" + getOrAddContext(current.getParent(i));
              builder += '[label="' + current.getReturnState(i) + '"];\n';
            }
          }
          builder += "}\n";
          return builder.toString();
        }
        toString(recog, showAlt, showContext) {
          if (showContext == null) {
            showContext = showAlt != null;
          }
          if (showAlt == null) {
            showAlt = true;
          }
          let buf = "";
          let contexts;
          if (showContext) {
            contexts = this.context.toStrings(recog, this.state.stateNumber);
          } else {
            contexts = ["?"];
          }
          let first = true;
          for (let contextDesc of contexts) {
            if (first) {
              first = false;
            } else {
              buf += ", ";
            }
            buf += "(";
            buf += this.state;
            if (showAlt) {
              buf += ",";
              buf += this.alt;
            }
            if (this.context) {
              buf += ",";
              buf += contextDesc;
            }
            if (this.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
              buf += ",";
              buf += this.semanticContext;
            }
            if (this.reachesIntoOuterContext) {
              buf += ",up=" + this.outerContextDepth;
            }
            buf += ")";
          }
          return buf.toString();
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ATNConfig.prototype, "_state", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATNConfig.prototype, "_context", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATNConfig.prototype, "state", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], ATNConfig.prototype, "context", null);
      __decorate([
        Decorators_1.NotNull
      ], ATNConfig.prototype, "semanticContext", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfig.prototype, "clone", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ATNConfig.prototype, "transformImpl", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfig.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfig.prototype, "hashCode", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(3, Decorators_1.NotNull)
      ], ATNConfig, "create", null);
      ATNConfig = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ATNConfig);
      exports.ATNConfig = ATNConfig;
      var SemanticContextATNConfig = class SemanticContextATNConfig extends ATNConfig {
        constructor(semanticContext, state, altOrConfig, context) {
          if (typeof altOrConfig === "number") {
            super(state, altOrConfig, context);
          } else {
            super(state, altOrConfig, context);
          }
          this._semanticContext = semanticContext;
        }
        get semanticContext() {
          return this._semanticContext;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], SemanticContextATNConfig.prototype, "_semanticContext", void 0);
      __decorate([
        Decorators_1.Override
      ], SemanticContextATNConfig.prototype, "semanticContext", null);
      SemanticContextATNConfig = __decorate([
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], SemanticContextATNConfig);
      var ActionATNConfig = class ActionATNConfig extends ATNConfig {
        constructor(lexerActionExecutor, state, altOrConfig, context, passedThroughNonGreedyDecision) {
          if (typeof altOrConfig === "number") {
            super(state, altOrConfig, context);
          } else {
            super(state, altOrConfig, context);
            if (altOrConfig.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
              throw new Error("Not supported");
            }
          }
          this._lexerActionExecutor = lexerActionExecutor;
          this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
        }
        get lexerActionExecutor() {
          return this._lexerActionExecutor;
        }
        get hasPassedThroughNonGreedyDecision() {
          return this.passedThroughNonGreedyDecision;
        }
      };
      __decorate([
        Decorators_1.Override
      ], ActionATNConfig.prototype, "lexerActionExecutor", null);
      __decorate([
        Decorators_1.Override
      ], ActionATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
      ActionATNConfig = __decorate([
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ActionATNConfig);
      var ActionSemanticContextATNConfig = class ActionSemanticContextATNConfig extends SemanticContextATNConfig {
        constructor(lexerActionExecutor, semanticContext, state, altOrConfig, context, passedThroughNonGreedyDecision) {
          if (typeof altOrConfig === "number") {
            super(semanticContext, state, altOrConfig, context);
          } else {
            super(semanticContext, state, altOrConfig, context);
          }
          this._lexerActionExecutor = lexerActionExecutor;
          this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
        }
        get lexerActionExecutor() {
          return this._lexerActionExecutor;
        }
        get hasPassedThroughNonGreedyDecision() {
          return this.passedThroughNonGreedyDecision;
        }
      };
      __decorate([
        Decorators_1.Override
      ], ActionSemanticContextATNConfig.prototype, "lexerActionExecutor", null);
      __decorate([
        Decorators_1.Override
      ], ActionSemanticContextATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
      ActionSemanticContextATNConfig = __decorate([
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ActionSemanticContextATNConfig);
    }
  });

  // shims/util.js
  var require_util = __commonJS({
    "shims/util.js"(exports, module2) {
      "use strict";
      module2.exports = {
        inspect: {
          custom: "util.inspect.custom"
        }
      };
    }
  });

  // node_modules/antlr4ts/misc/BitSet.js
  var require_BitSet = __commonJS({
    "node_modules/antlr4ts/misc/BitSet.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BitSet = void 0;
      var util = require_util();
      var MurmurHash_1 = require_MurmurHash();
      var EMPTY_DATA = new Uint16Array(0);
      function getIndex2(bitNumber) {
        return bitNumber >>> 4;
      }
      function unIndex(n) {
        return n * 16;
      }
      function findLSBSet(word) {
        let bit = 1;
        for (let i = 0; i < 16; i++) {
          if ((word & bit) !== 0) {
            return i;
          }
          bit = bit << 1 >>> 0;
        }
        throw new RangeError("No specified bit found");
      }
      function findMSBSet(word) {
        let bit = 1 << 15 >>> 0;
        for (let i = 15; i >= 0; i--) {
          if ((word & bit) !== 0) {
            return i;
          }
          bit = bit >>> 1;
        }
        throw new RangeError("No specified bit found");
      }
      function bitsFor(fromBit, toBit) {
        fromBit &= 15;
        toBit &= 15;
        if (fromBit === toBit) {
          return 1 << fromBit >>> 0;
        }
        return 65535 >>> 15 - toBit ^ 65535 >>> 16 - fromBit;
      }
      var POP_CNT = new Uint8Array(65536);
      for (let i = 0; i < 16; i++) {
        const stride = 1 << i >>> 0;
        let index = 0;
        while (index < POP_CNT.length) {
          index += stride;
          for (let j = 0; j < stride; j++) {
            POP_CNT[index]++;
            index++;
          }
        }
      }
      var BitSet = class _BitSet {
        /*
        ** constructor implementation
        */
        constructor(arg) {
          if (!arg) {
            this.data = EMPTY_DATA;
          } else if (typeof arg === "number") {
            if (arg < 0) {
              throw new RangeError("nbits cannot be negative");
            } else {
              this.data = new Uint16Array(getIndex2(arg - 1) + 1);
            }
          } else {
            if (arg instanceof _BitSet) {
              this.data = arg.data.slice(0);
            } else {
              let max = -1;
              for (let v of arg) {
                if (max < v) {
                  max = v;
                }
              }
              this.data = new Uint16Array(getIndex2(max - 1) + 1);
              for (let v of arg) {
                this.set(v);
              }
            }
          }
        }
        /**
         * Performs a logical **AND** of this target bit set with the argument bit set. This bit set is modified so that
         * each bit in it has the value `true` if and only if it both initially had the value `true` and the corresponding
         * bit in the bit set argument also had the value `true`.
         */
        and(set) {
          const data = this.data;
          const other = set.data;
          const words = Math.min(data.length, other.length);
          let lastWord = -1;
          for (let i = 0; i < words; i++) {
            let value = data[i] &= other[i];
            if (value !== 0) {
              lastWord = i;
            }
          }
          if (lastWord === -1) {
            this.data = EMPTY_DATA;
          }
          if (lastWord < data.length - 1) {
            this.data = data.slice(0, lastWord + 1);
          }
        }
        /**
         * Clears all of the bits in this `BitSet` whose corresponding bit is set in the specified `BitSet`.
         */
        andNot(set) {
          const data = this.data;
          const other = set.data;
          const words = Math.min(data.length, other.length);
          let lastWord = -1;
          for (let i = 0; i < words; i++) {
            let value = data[i] &= other[i] ^ 65535;
            if (value !== 0) {
              lastWord = i;
            }
          }
          if (lastWord === -1) {
            this.data = EMPTY_DATA;
          }
          if (lastWord < data.length - 1) {
            this.data = data.slice(0, lastWord + 1);
          }
        }
        /**
         * Returns the number of bits set to `true` in this `BitSet`.
         */
        cardinality() {
          if (this.isEmpty) {
            return 0;
          }
          const data = this.data;
          const length = data.length;
          let result = 0;
          for (let i = 0; i < length; i++) {
            result += POP_CNT[data[i]];
          }
          return result;
        }
        clear(fromIndex, toIndex) {
          if (fromIndex == null) {
            this.data.fill(0);
          } else if (toIndex == null) {
            this.set(fromIndex, false);
          } else {
            this.set(fromIndex, toIndex, false);
          }
        }
        flip(fromIndex, toIndex) {
          if (toIndex == null) {
            toIndex = fromIndex;
          }
          if (fromIndex < 0 || toIndex < fromIndex) {
            throw new RangeError();
          }
          let word = getIndex2(fromIndex);
          const lastWord = getIndex2(toIndex);
          if (word === lastWord) {
            this.data[word] ^= bitsFor(fromIndex, toIndex);
          } else {
            this.data[word++] ^= bitsFor(fromIndex, 15);
            while (word < lastWord) {
              this.data[word++] ^= 65535;
            }
            this.data[word++] ^= bitsFor(0, toIndex);
          }
        }
        get(fromIndex, toIndex) {
          if (toIndex === void 0) {
            return !!(this.data[getIndex2(fromIndex)] & bitsFor(fromIndex, fromIndex));
          } else {
            let result = new _BitSet(toIndex + 1);
            for (let i = fromIndex; i <= toIndex; i++) {
              result.set(i, this.get(i));
            }
            return result;
          }
        }
        /**
         * Returns true if the specified `BitSet` has any bits set to `true` that are also set to `true` in this `BitSet`.
         *
         * @param set `BitSet` to intersect with
         */
        intersects(set) {
          let smallerLength = Math.min(this.length(), set.length());
          if (smallerLength === 0) {
            return false;
          }
          let bound = getIndex2(smallerLength - 1);
          for (let i = 0; i <= bound; i++) {
            if ((this.data[i] & set.data[i]) !== 0) {
              return true;
            }
          }
          return false;
        }
        /**
         * Returns true if this `BitSet` contains no bits that are set to `true`.
         */
        get isEmpty() {
          return this.length() === 0;
        }
        /**
         * Returns the "logical size" of this `BitSet`: the index of the highest set bit in the `BitSet` plus one. Returns
         * zero if the `BitSet` contains no set bits.
         */
        length() {
          if (!this.data.length) {
            return 0;
          }
          return this.previousSetBit(unIndex(this.data.length) - 1) + 1;
        }
        /**
         * Returns the index of the first bit that is set to `false` that occurs on or after the specified starting index,
         * If no such bit exists then `-1` is returned.
         *
         * @param fromIndex the index to start checking from (inclusive)
         *
         * @throws RangeError if the specified index is negative
         */
        nextClearBit(fromIndex) {
          if (fromIndex < 0) {
            throw new RangeError("fromIndex cannot be negative");
          }
          const data = this.data;
          const length = data.length;
          let word = getIndex2(fromIndex);
          if (word > length) {
            return -1;
          }
          let ignore2 = 65535 ^ bitsFor(fromIndex, 15);
          if ((data[word] | ignore2) === 65535) {
            word++;
            ignore2 = 0;
            for (; word < length; word++) {
              if (data[word] !== 65535) {
                break;
              }
            }
            if (word === length) {
              return -1;
            }
          }
          return unIndex(word) + findLSBSet((data[word] | ignore2) ^ 65535);
        }
        /**
         * Returns the index of the first bit that is set to `true` that occurs on or after the specified starting index.
         * If no such bit exists then `-1` is returned.
         *
         * To iterate over the `true` bits in a `BitSet`, use the following loop:
         *
         * ```
         * for (let i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {
         *   // operate on index i here
         * }
         * ```
         *
         * @param fromIndex the index to start checking from (inclusive)
         *
         * @throws RangeError if the specified index is negative
         */
        nextSetBit(fromIndex) {
          if (fromIndex < 0) {
            throw new RangeError("fromIndex cannot be negative");
          }
          const data = this.data;
          const length = data.length;
          let word = getIndex2(fromIndex);
          if (word > length) {
            return -1;
          }
          let mask = bitsFor(fromIndex, 15);
          if ((data[word] & mask) === 0) {
            word++;
            mask = 65535;
            for (; word < length; word++) {
              if (data[word] !== 0) {
                break;
              }
            }
            if (word >= length) {
              return -1;
            }
          }
          return unIndex(word) + findLSBSet(data[word] & mask);
        }
        /**
         * Performs a logical **OR** of this bit set with the bit set argument. This bit set is modified so that a bit in it
         * has the value `true` if and only if it either already had the value `true` or the corresponding bit in the bit
         * set argument has the value `true`.
         */
        or(set) {
          const data = this.data;
          const other = set.data;
          const minWords = Math.min(data.length, other.length);
          const words = Math.max(data.length, other.length);
          const dest = data.length === words ? data : new Uint16Array(words);
          let lastWord = -1;
          for (let i = 0; i < minWords; i++) {
            let value = dest[i] = data[i] | other[i];
            if (value !== 0) {
              lastWord = i;
            }
          }
          const longer = data.length > other.length ? data : other;
          for (let i = minWords; i < words; i++) {
            let value = dest[i] = longer[i];
            if (value !== 0) {
              lastWord = i;
            }
          }
          if (lastWord === -1) {
            this.data = EMPTY_DATA;
          } else if (dest.length === lastWord + 1) {
            this.data = dest;
          } else {
            this.data = dest.slice(0, lastWord);
          }
        }
        /**
         * Returns the index of the nearest bit that is set to `false` that occurs on or before the specified starting
         * index. If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.
         *
         * @param fromIndex the index to start checking from (inclusive)
         *
         * @throws RangeError if the specified index is less than `-1`
         */
        previousClearBit(fromIndex) {
          if (fromIndex < 0) {
            throw new RangeError("fromIndex cannot be negative");
          }
          const data = this.data;
          const length = data.length;
          let word = getIndex2(fromIndex);
          if (word >= length) {
            word = length - 1;
          }
          let ignore2 = 65535 ^ bitsFor(0, fromIndex);
          if ((data[word] | ignore2) === 65535) {
            ignore2 = 0;
            word--;
            for (; word >= 0; word--) {
              if (data[word] !== 65535) {
                break;
              }
            }
            if (word < 0) {
              return -1;
            }
          }
          return unIndex(word) + findMSBSet((data[word] | ignore2) ^ 65535);
        }
        /**
         * Returns the index of the nearest bit that is set to `true` that occurs on or before the specified starting index.
         * If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.
         *
         * To iterate over the `true` bits in a `BitSet`, use the following loop:
         *
         * ```
         * for (let i = bs.length(); (i = bs.previousSetBit(i-1)) >= 0; ) {
         *   // operate on index i here
         * }
         * ```
         *
         * @param fromIndex the index to start checking from (inclusive)
         *
         * @throws RangeError if the specified index is less than `-1`
         */
        previousSetBit(fromIndex) {
          if (fromIndex < 0) {
            throw new RangeError("fromIndex cannot be negative");
          }
          const data = this.data;
          const length = data.length;
          let word = getIndex2(fromIndex);
          if (word >= length) {
            word = length - 1;
          }
          let mask = bitsFor(0, fromIndex);
          if ((data[word] & mask) === 0) {
            word--;
            mask = 65535;
            for (; word >= 0; word--) {
              if (data[word] !== 0) {
                break;
              }
            }
            if (word < 0) {
              return -1;
            }
          }
          return unIndex(word) + findMSBSet(data[word] & mask);
        }
        set(fromIndex, toIndex, value) {
          if (toIndex === void 0) {
            toIndex = fromIndex;
            value = true;
          } else if (typeof toIndex === "boolean") {
            value = toIndex;
            toIndex = fromIndex;
          }
          if (value === void 0) {
            value = true;
          }
          if (fromIndex < 0 || fromIndex > toIndex) {
            throw new RangeError();
          }
          let word = getIndex2(fromIndex);
          let lastWord = getIndex2(toIndex);
          if (value && lastWord >= this.data.length) {
            let temp = new Uint16Array(lastWord + 1);
            this.data.forEach((value2, index) => temp[index] = value2);
            this.data = temp;
          } else if (!value) {
            if (word >= this.data.length) {
              return;
            }
            if (lastWord >= this.data.length) {
              lastWord = this.data.length - 1;
              toIndex = this.data.length * 16 - 1;
            }
          }
          if (word === lastWord) {
            this._setBits(word, value, bitsFor(fromIndex, toIndex));
          } else {
            this._setBits(word++, value, bitsFor(fromIndex, 15));
            while (word < lastWord) {
              this.data[word++] = value ? 65535 : 0;
            }
            this._setBits(word, value, bitsFor(0, toIndex));
          }
        }
        _setBits(word, value, mask) {
          if (value) {
            this.data[word] |= mask;
          } else {
            this.data[word] &= 65535 ^ mask;
          }
        }
        /**
         * Returns the number of bits of space actually in use by this `BitSet` to represent bit values. The maximum element
         * in the set is the size - 1st element.
         */
        get size() {
          return this.data.byteLength * 8;
        }
        /**
         * Returns a new byte array containing all the bits in this bit set.
         *
         * More precisely, if
         * `let bytes = s.toByteArray();`
         * then `bytes.length === (s.length()+7)/8` and `s.get(n) === ((bytes[n/8] & (1<<(n%8))) != 0)` for all
         * `n < 8 * bytes.length`.
         */
        // toByteArray(): Int8Array {
        // 	throw new Error("NOT IMPLEMENTED");
        // }
        /**
         * Returns a new integer array containing all the bits in this bit set.
         *
         * More precisely, if
         * `let integers = s.toIntegerArray();`
         * then `integers.length === (s.length()+31)/32` and `s.get(n) === ((integers[n/32] & (1<<(n%32))) != 0)` for all
         * `n < 32 * integers.length`.
         */
        // toIntegerArray(): Int32Array {
        // 	throw new Error("NOT IMPLEMENTED");
        // }
        hashCode() {
          return MurmurHash_1.MurmurHash.hashCode(this.data, 22);
        }
        /**
         * Compares this object against the specified object. The result is `true` if and only if the argument is not
         * `undefined` and is a `Bitset` object that has exactly the same set of bits set to `true` as this bit set. That
         * is, for every nonnegative index `k`,
         *
         * ```
         * ((BitSet)obj).get(k) == this.get(k)
         * ```
         *
         * must be true. The current sizes of the two bit sets are not compared.
         */
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof _BitSet)) {
            return false;
          }
          const len = this.length();
          if (len !== obj.length()) {
            return false;
          }
          if (len === 0) {
            return true;
          }
          let bound = getIndex2(len - 1);
          for (let i = 0; i <= bound; i++) {
            if (this.data[i] !== obj.data[i]) {
              return false;
            }
          }
          return true;
        }
        /**
         * Returns a string representation of this bit set. For every index for which this `BitSet` contains a bit in the
         * set state, the decimal representation of that index is included in the result. Such indices are listed in order
         * from lowest to highest, separated by ", " (a comma and a space) and surrounded by braces, resulting in the usual
         * mathematical notation for a set of integers.
         *
         * Example:
         *
         *     BitSet drPepper = new BitSet();
         *
         * Now `drPepper.toString()` returns `"{}"`.
         *
         *     drPepper.set(2);
         *
         * Now `drPepper.toString()` returns `"{2}"`.
         *
         *     drPepper.set(4);
         *     drPepper.set(10);
         *
         * Now `drPepper.toString()` returns `"{2, 4, 10}"`.
         */
        toString() {
          let result = "{";
          let first = true;
          for (let i = this.nextSetBit(0); i >= 0; i = this.nextSetBit(i + 1)) {
            if (first) {
              first = false;
            } else {
              result += ", ";
            }
            result += i;
          }
          result += "}";
          return result;
        }
        // static valueOf(bytes: Int8Array): BitSet;
        // static valueOf(buffer: ArrayBuffer): BitSet;
        // static valueOf(integers: Int32Array): BitSet;
        // static valueOf(data: Int8Array | Int32Array | ArrayBuffer): BitSet {
        // 	throw new Error("NOT IMPLEMENTED");
        // }
        /**
         * Performs a logical **XOR** of this bit set with the bit set argument. This bit set is modified so that a bit in
         * it has the value `true` if and only if one of the following statements holds:
         *
         * * The bit initially has the value `true`, and the corresponding bit in the argument has the value `false`.
         * * The bit initially has the value `false`, and the corresponding bit in the argument has the value `true`.
         */
        xor(set) {
          const data = this.data;
          const other = set.data;
          const minWords = Math.min(data.length, other.length);
          const words = Math.max(data.length, other.length);
          const dest = data.length === words ? data : new Uint16Array(words);
          let lastWord = -1;
          for (let i = 0; i < minWords; i++) {
            let value = dest[i] = data[i] ^ other[i];
            if (value !== 0) {
              lastWord = i;
            }
          }
          const longer = data.length > other.length ? data : other;
          for (let i = minWords; i < words; i++) {
            let value = dest[i] = longer[i];
            if (value !== 0) {
              lastWord = i;
            }
          }
          if (lastWord === -1) {
            this.data = EMPTY_DATA;
          } else if (dest.length === lastWord + 1) {
            this.data = dest;
          } else {
            this.data = dest.slice(0, lastWord + 1);
          }
        }
        clone() {
          return new _BitSet(this);
        }
        [Symbol.iterator]() {
          return new BitSetIterator(this.data);
        }
        // Overrides formatting for nodejs assert etc.
        [util.inspect.custom]() {
          return "BitSet " + this.toString();
        }
      };
      exports.BitSet = BitSet;
      var BitSetIterator = class {
        constructor(data) {
          this.data = data;
          this.index = 0;
          this.mask = 65535;
        }
        next() {
          while (this.index < this.data.length) {
            const bits = this.data[this.index] & this.mask;
            if (bits !== 0) {
              const bitNumber = unIndex(this.index) + findLSBSet(bits);
              this.mask = bitsFor(bitNumber + 1, 15);
              return { done: false, value: bitNumber };
            }
            this.index++;
            this.mask = 65535;
          }
          return { done: true, value: -1 };
        }
        [Symbol.iterator]() {
          return this;
        }
      };
    }
  });

  // node_modules/antlr4ts/atn/ATNConfigSet.js
  var require_ATNConfigSet = __commonJS({
    "node_modules/antlr4ts/atn/ATNConfigSet.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATNConfigSet = void 0;
      var Array2DHashMap_1 = require_Array2DHashMap();
      var Array2DHashSet_1 = require_Array2DHashSet();
      var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
      var ATN_1 = require_ATN();
      var ATNConfig_1 = require_ATNConfig();
      var BitSet_1 = require_BitSet();
      var Decorators_1 = require_Decorators();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var PredictionContext_1 = require_PredictionContext();
      var PredictionContextCache_1 = require_PredictionContextCache();
      var SemanticContext_1 = require_SemanticContext();
      var assert = require_assert();
      var Utils3 = require_Utils();
      var KeyTypeEqualityComparer = class {
        hashCode(key) {
          return key.state ^ key.alt;
        }
        equals(a, b) {
          return a.state === b.state && a.alt === b.alt;
        }
      };
      KeyTypeEqualityComparer.INSTANCE = new KeyTypeEqualityComparer();
      function NewKeyedConfigMap(map) {
        if (map) {
          return new Array2DHashMap_1.Array2DHashMap(map);
        } else {
          return new Array2DHashMap_1.Array2DHashMap(KeyTypeEqualityComparer.INSTANCE);
        }
      }
      var ATNConfigSet = class _ATNConfigSet {
        constructor(set, readonly) {
          this._uniqueAlt = 0;
          this._hasSemanticContext = false;
          this._dipsIntoOuterContext = false;
          this.outermostConfigSet = false;
          this.cachedHashCode = -1;
          if (!set) {
            this.mergedConfigs = NewKeyedConfigMap();
            this.unmerged = [];
            this.configs = [];
            this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
          } else {
            if (readonly) {
              this.mergedConfigs = void 0;
              this.unmerged = void 0;
            } else if (!set.isReadOnly) {
              this.mergedConfigs = NewKeyedConfigMap(set.mergedConfigs);
              this.unmerged = set.unmerged.slice(0);
            } else {
              this.mergedConfigs = NewKeyedConfigMap();
              this.unmerged = [];
            }
            this.configs = set.configs.slice(0);
            this._dipsIntoOuterContext = set._dipsIntoOuterContext;
            this._hasSemanticContext = set._hasSemanticContext;
            this.outermostConfigSet = set.outermostConfigSet;
            if (readonly || !set.isReadOnly) {
              this._uniqueAlt = set._uniqueAlt;
              this._conflictInfo = set._conflictInfo;
            }
          }
        }
        /**
         * Get the set of all alternatives represented by configurations in this
         * set.
         */
        getRepresentedAlternatives() {
          if (this._conflictInfo != null) {
            return this._conflictInfo.conflictedAlts.clone();
          }
          let alts = new BitSet_1.BitSet();
          for (let config of this) {
            alts.set(config.alt);
          }
          return alts;
        }
        get isReadOnly() {
          return this.mergedConfigs == null;
        }
        get isOutermostConfigSet() {
          return this.outermostConfigSet;
        }
        set isOutermostConfigSet(outermostConfigSet) {
          if (this.outermostConfigSet && !outermostConfigSet) {
            throw new Error("IllegalStateException");
          }
          assert(!outermostConfigSet || !this._dipsIntoOuterContext);
          this.outermostConfigSet = outermostConfigSet;
        }
        getStates() {
          let states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          for (let c of this.configs) {
            states.add(c.state);
          }
          return states;
        }
        optimizeConfigs(interpreter) {
          if (this.configs.length === 0) {
            return;
          }
          for (let config of this.configs) {
            config.context = interpreter.atn.getCachedContext(config.context);
          }
        }
        clone(readonly) {
          let copy = new _ATNConfigSet(this, readonly);
          if (!readonly && this.isReadOnly) {
            copy.addAll(this.configs);
          }
          return copy;
        }
        get size() {
          return this.configs.length;
        }
        get isEmpty() {
          return this.configs.length === 0;
        }
        contains(o) {
          if (!(o instanceof ATNConfig_1.ATNConfig)) {
            return false;
          }
          if (this.mergedConfigs && this.unmerged) {
            let config = o;
            let configKey = this.getKey(config);
            let mergedConfig = this.mergedConfigs.get(configKey);
            if (mergedConfig != null && this.canMerge(config, configKey, mergedConfig)) {
              return mergedConfig.contains(config);
            }
            for (let c of this.unmerged) {
              if (c.contains(o)) {
                return true;
              }
            }
          } else {
            for (let c of this.configs) {
              if (c.contains(o)) {
                return true;
              }
            }
          }
          return false;
        }
        *[Symbol.iterator]() {
          yield* this.configs;
        }
        toArray() {
          return this.configs;
        }
        add(e, contextCache) {
          this.ensureWritable();
          if (!this.mergedConfigs || !this.unmerged) {
            throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
          }
          assert(!this.outermostConfigSet || !e.reachesIntoOuterContext);
          if (contextCache == null) {
            contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
          }
          let addKey;
          let key = this.getKey(e);
          let mergedConfig = this.mergedConfigs.get(key);
          addKey = mergedConfig == null;
          if (mergedConfig != null && this.canMerge(e, key, mergedConfig)) {
            mergedConfig.outerContextDepth = Math.max(mergedConfig.outerContextDepth, e.outerContextDepth);
            if (e.isPrecedenceFilterSuppressed) {
              mergedConfig.isPrecedenceFilterSuppressed = true;
            }
            let joined = PredictionContext_1.PredictionContext.join(mergedConfig.context, e.context, contextCache);
            this.updatePropertiesForMergedConfig(e);
            if (mergedConfig.context === joined) {
              return false;
            }
            mergedConfig.context = joined;
            return true;
          }
          for (let i = 0; i < this.unmerged.length; i++) {
            let unmergedConfig = this.unmerged[i];
            if (this.canMerge(e, key, unmergedConfig)) {
              unmergedConfig.outerContextDepth = Math.max(unmergedConfig.outerContextDepth, e.outerContextDepth);
              if (e.isPrecedenceFilterSuppressed) {
                unmergedConfig.isPrecedenceFilterSuppressed = true;
              }
              let joined = PredictionContext_1.PredictionContext.join(unmergedConfig.context, e.context, contextCache);
              this.updatePropertiesForMergedConfig(e);
              if (unmergedConfig.context === joined) {
                return false;
              }
              unmergedConfig.context = joined;
              if (addKey) {
                this.mergedConfigs.put(key, unmergedConfig);
                this.unmerged.splice(i, 1);
              }
              return true;
            }
          }
          this.configs.push(e);
          if (addKey) {
            this.mergedConfigs.put(key, e);
          } else {
            this.unmerged.push(e);
          }
          this.updatePropertiesForAddedConfig(e);
          return true;
        }
        updatePropertiesForMergedConfig(config) {
          this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;
          assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);
        }
        updatePropertiesForAddedConfig(config) {
          if (this.configs.length === 1) {
            this._uniqueAlt = config.alt;
          } else if (this._uniqueAlt !== config.alt) {
            this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
          }
          this._hasSemanticContext = this._hasSemanticContext || !SemanticContext_1.SemanticContext.NONE.equals(config.semanticContext);
          this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;
          assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);
        }
        canMerge(left, leftKey, right) {
          if (left.state.stateNumber !== right.state.stateNumber) {
            return false;
          }
          if (leftKey.alt !== right.alt) {
            return false;
          }
          return left.semanticContext.equals(right.semanticContext);
        }
        getKey(e) {
          return { state: e.state.stateNumber, alt: e.alt };
        }
        containsAll(c) {
          for (let o of c) {
            if (!(o instanceof ATNConfig_1.ATNConfig)) {
              return false;
            }
            if (!this.contains(o)) {
              return false;
            }
          }
          return true;
        }
        addAll(c, contextCache) {
          this.ensureWritable();
          let changed = false;
          for (let group of c) {
            if (this.add(group, contextCache)) {
              changed = true;
            }
          }
          return changed;
        }
        clear() {
          this.ensureWritable();
          if (!this.mergedConfigs || !this.unmerged) {
            throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
          }
          this.mergedConfigs.clear();
          this.unmerged.length = 0;
          this.configs.length = 0;
          this._dipsIntoOuterContext = false;
          this._hasSemanticContext = false;
          this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
          this._conflictInfo = void 0;
        }
        equals(obj) {
          if (this === obj) {
            return true;
          }
          if (!(obj instanceof _ATNConfigSet)) {
            return false;
          }
          return this.outermostConfigSet === obj.outermostConfigSet && Utils3.equals(this._conflictInfo, obj._conflictInfo) && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.configs, obj.configs);
        }
        hashCode() {
          if (this.isReadOnly && this.cachedHashCode !== -1) {
            return this.cachedHashCode;
          }
          let hashCode = 1;
          hashCode = 5 * hashCode ^ (this.outermostConfigSet ? 1 : 0);
          hashCode = 5 * hashCode ^ ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.hashCode(this.configs);
          if (this.isReadOnly) {
            this.cachedHashCode = hashCode;
          }
          return hashCode;
        }
        toString(showContext) {
          if (showContext == null) {
            showContext = false;
          }
          let buf = "";
          let sortedConfigs = this.configs.slice(0);
          sortedConfigs.sort((o1, o2) => {
            if (o1.alt !== o2.alt) {
              return o1.alt - o2.alt;
            } else if (o1.state.stateNumber !== o2.state.stateNumber) {
              return o1.state.stateNumber - o2.state.stateNumber;
            } else {
              return o1.semanticContext.toString().localeCompare(o2.semanticContext.toString());
            }
          });
          buf += "[";
          for (let i = 0; i < sortedConfigs.length; i++) {
            if (i > 0) {
              buf += ", ";
            }
            buf += sortedConfigs[i].toString(void 0, true, showContext);
          }
          buf += "]";
          if (this._hasSemanticContext) {
            buf += ",hasSemanticContext=" + this._hasSemanticContext;
          }
          if (this._uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            buf += ",uniqueAlt=" + this._uniqueAlt;
          }
          if (this._conflictInfo != null) {
            buf += ",conflictingAlts=" + this._conflictInfo.conflictedAlts;
            if (!this._conflictInfo.isExact) {
              buf += "*";
            }
          }
          if (this._dipsIntoOuterContext) {
            buf += ",dipsIntoOuterContext";
          }
          return buf.toString();
        }
        get uniqueAlt() {
          return this._uniqueAlt;
        }
        get hasSemanticContext() {
          return this._hasSemanticContext;
        }
        set hasSemanticContext(value) {
          this.ensureWritable();
          this._hasSemanticContext = value;
        }
        get conflictInfo() {
          return this._conflictInfo;
        }
        set conflictInfo(conflictInfo) {
          this.ensureWritable();
          this._conflictInfo = conflictInfo;
        }
        get conflictingAlts() {
          if (this._conflictInfo == null) {
            return void 0;
          }
          return this._conflictInfo.conflictedAlts;
        }
        get isExactConflict() {
          if (this._conflictInfo == null) {
            return false;
          }
          return this._conflictInfo.isExact;
        }
        get dipsIntoOuterContext() {
          return this._dipsIntoOuterContext;
        }
        get(index) {
          return this.configs[index];
        }
        ensureWritable() {
          if (this.isReadOnly) {
            throw new Error("This ATNConfigSet is read only.");
          }
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ATNConfigSet.prototype, "getRepresentedAlternatives", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, "isEmpty", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, "contains", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, Symbol.iterator, null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, "toArray", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, "containsAll", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, "clear", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, "hashCode", null);
      exports.ATNConfigSet = ATNConfigSet;
    }
  });

  // node_modules/antlr4ts/dfa/DFAState.js
  var require_DFAState = __commonJS({
    "node_modules/antlr4ts/dfa/DFAState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DFAState = void 0;
      var ATN_1 = require_ATN();
      var BitSet_1 = require_BitSet();
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var PredictionContext_1 = require_PredictionContext();
      var assert = require_assert();
      var DFAState = class _DFAState {
        /**
         * Constructs a new `DFAState`.
         *
         * @param configs The set of ATN configurations defining this state.
         */
        constructor(configs) {
          this.stateNumber = -1;
          this.configs = configs;
          this.edges = /* @__PURE__ */ new Map();
          this.contextEdges = /* @__PURE__ */ new Map();
        }
        get isContextSensitive() {
          return !!this.contextSymbols;
        }
        isContextSymbol(symbol) {
          if (!this.isContextSensitive) {
            return false;
          }
          return this.contextSymbols.get(symbol);
        }
        setContextSymbol(symbol) {
          assert(this.isContextSensitive);
          this.contextSymbols.set(symbol);
        }
        setContextSensitive(atn) {
          assert(!this.configs.isOutermostConfigSet);
          if (this.isContextSensitive) {
            return;
          }
          if (!this.contextSymbols) {
            this.contextSymbols = new BitSet_1.BitSet();
          }
        }
        get acceptStateInfo() {
          return this._acceptStateInfo;
        }
        set acceptStateInfo(acceptStateInfo) {
          this._acceptStateInfo = acceptStateInfo;
        }
        get isAcceptState() {
          return !!this._acceptStateInfo;
        }
        get prediction() {
          if (!this._acceptStateInfo) {
            return ATN_1.ATN.INVALID_ALT_NUMBER;
          }
          return this._acceptStateInfo.prediction;
        }
        get lexerActionExecutor() {
          if (!this._acceptStateInfo) {
            return void 0;
          }
          return this._acceptStateInfo.lexerActionExecutor;
        }
        getTarget(symbol) {
          return this.edges.get(symbol);
        }
        setTarget(symbol, target) {
          this.edges.set(symbol, target);
        }
        getEdgeMap() {
          return this.edges;
        }
        getContextTarget(invokingState) {
          if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            invokingState = -1;
          }
          return this.contextEdges.get(invokingState);
        }
        setContextTarget(invokingState, target) {
          if (!this.isContextSensitive) {
            throw new Error("The state is not context sensitive.");
          }
          if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            invokingState = -1;
          }
          this.contextEdges.set(invokingState, target);
        }
        getContextEdgeMap() {
          let map = new Map(this.contextEdges);
          let existing = map.get(-1);
          if (existing !== void 0) {
            if (map.size === 1) {
              let result = /* @__PURE__ */ new Map();
              result.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
              return result;
            } else {
              map.delete(-1);
              map.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
            }
          }
          return map;
        }
        hashCode() {
          let hash = MurmurHash_1.MurmurHash.initialize(7);
          hash = MurmurHash_1.MurmurHash.update(hash, this.configs.hashCode());
          hash = MurmurHash_1.MurmurHash.finish(hash, 1);
          return hash;
        }
        /**
         * Two {@link DFAState} instances are equal if their ATN configuration sets
         * are the same. This method is used to see if a state already exists.
         *
         * Because the number of alternatives and number of ATN configurations are
         * finite, there is a finite number of DFA states that can be processed.
         * This is necessary to show that the algorithm terminates.
         *
         * Cannot test the DFA state numbers here because in
         * {@link ParserATNSimulator#addDFAState} we need to know if any other state
         * exists that has this exact set of ATN configurations. The
         * {@link #stateNumber} is irrelevant.
         */
        equals(o) {
          if (this === o) {
            return true;
          }
          if (!(o instanceof _DFAState)) {
            return false;
          }
          let other = o;
          let sameSet = this.configs.equals(other.configs);
          return sameSet;
        }
        toString() {
          let buf = "";
          buf += this.stateNumber + ":" + this.configs;
          if (this.isAcceptState) {
            buf += "=>";
            if (this.predicates) {
              buf += this.predicates;
            } else {
              buf += this.prediction;
            }
          }
          return buf.toString();
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], DFAState.prototype, "configs", void 0);
      __decorate([
        Decorators_1.NotNull
      ], DFAState.prototype, "edges", void 0);
      __decorate([
        Decorators_1.NotNull
      ], DFAState.prototype, "contextEdges", void 0);
      __decorate([
        Decorators_1.Override
      ], DFAState.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], DFAState.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], DFAState.prototype, "toString", null);
      exports.DFAState = DFAState;
      (function(DFAState2) {
        let PredPrediction = class PredPrediction {
          constructor(pred, alt) {
            this.alt = alt;
            this.pred = pred;
          }
          toString() {
            return "(" + this.pred + ", " + this.alt + ")";
          }
        };
        __decorate([
          Decorators_1.NotNull
        ], PredPrediction.prototype, "pred", void 0);
        __decorate([
          Decorators_1.Override
        ], PredPrediction.prototype, "toString", null);
        PredPrediction = __decorate([
          __param(0, Decorators_1.NotNull)
        ], PredPrediction);
        DFAState2.PredPrediction = PredPrediction;
      })(DFAState = exports.DFAState || (exports.DFAState = {}));
    }
  });

  // node_modules/antlr4ts/atn/ATNSimulator.js
  var require_ATNSimulator = __commonJS({
    "node_modules/antlr4ts/atn/ATNSimulator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATNSimulator = void 0;
      var ATNConfigSet_1 = require_ATNConfigSet();
      var DFAState_1 = require_DFAState();
      var Decorators_1 = require_Decorators();
      var PredictionContext_1 = require_PredictionContext();
      var ATNSimulator = class ATNSimulator2 {
        constructor(atn) {
          this.atn = atn;
        }
        static get ERROR() {
          if (!ATNSimulator2._ERROR) {
            ATNSimulator2._ERROR = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
            ATNSimulator2._ERROR.stateNumber = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
          }
          return ATNSimulator2._ERROR;
        }
        /**
         * Clear the DFA cache used by the current instance. Since the DFA cache may
         * be shared by multiple ATN simulators, this method may affect the
         * performance (but not accuracy) of other parsers which are being used
         * concurrently.
         *
         * @ if the current instance does not
         * support clearing the DFA.
         *
         * @since 4.3
         */
        clearDFA() {
          this.atn.clearDFA();
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ATNSimulator.prototype, "atn", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATNSimulator, "ERROR", null);
      ATNSimulator = __decorate([
        __param(0, Decorators_1.NotNull)
      ], ATNSimulator);
      exports.ATNSimulator = ATNSimulator;
      /* @__PURE__ */ (function(ATNSimulator2) {
        const RULE_VARIANT_DELIMITER = "$";
        const RULE_LF_VARIANT_MARKER = "$lf$";
        const RULE_NOLF_VARIANT_MARKER = "$nolf$";
      })(ATNSimulator = exports.ATNSimulator || (exports.ATNSimulator = {}));
      exports.ATNSimulator = ATNSimulator;
    }
  });

  // node_modules/antlr4ts/ConsoleErrorListener.js
  var require_ConsoleErrorListener = __commonJS({
    "node_modules/antlr4ts/ConsoleErrorListener.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConsoleErrorListener = void 0;
      var ConsoleErrorListener = class {
        /**
         * {@inheritDoc}
         *
         * This implementation prints messages to {@link System#err} containing the
         * values of `line`, `charPositionInLine`, and `msg` using
         * the following format.
         *
         * <pre>
         * line *line*:*charPositionInLine* *msg*
         * </pre>
         */
        syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
          console.error(`line ${line}:${charPositionInLine} ${msg}`);
        }
      };
      exports.ConsoleErrorListener = ConsoleErrorListener;
      ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();
    }
  });

  // node_modules/antlr4ts/ProxyErrorListener.js
  var require_ProxyErrorListener = __commonJS({
    "node_modules/antlr4ts/ProxyErrorListener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProxyErrorListener = void 0;
      var Decorators_1 = require_Decorators();
      var ProxyErrorListener = class {
        constructor(delegates) {
          this.delegates = delegates;
          if (!delegates) {
            throw new Error("Invalid delegates");
          }
        }
        getDelegates() {
          return this.delegates;
        }
        syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
          this.delegates.forEach((listener) => {
            if (listener.syntaxError) {
              listener.syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e);
            }
          });
        }
      };
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull),
        __param(4, Decorators_1.NotNull)
      ], ProxyErrorListener.prototype, "syntaxError", null);
      exports.ProxyErrorListener = ProxyErrorListener;
    }
  });

  // node_modules/antlr4ts/Recognizer.js
  var require_Recognizer = __commonJS({
    "node_modules/antlr4ts/Recognizer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Recognizer = void 0;
      var ConsoleErrorListener_1 = require_ConsoleErrorListener();
      var ProxyErrorListener_1 = require_ProxyErrorListener();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var Utils3 = require_Utils();
      var Recognizer = class _Recognizer {
        constructor() {
          this._listeners = [ConsoleErrorListener_1.ConsoleErrorListener.INSTANCE];
          this._stateNumber = -1;
        }
        /**
         * Get a map from token names to token types.
         *
         * Used for XPath and tree pattern compilation.
         */
        getTokenTypeMap() {
          let vocabulary = this.vocabulary;
          let result = _Recognizer.tokenTypeMapCache.get(vocabulary);
          if (result == null) {
            let intermediateResult = /* @__PURE__ */ new Map();
            for (let i = 0; i <= this.atn.maxTokenType; i++) {
              let literalName = vocabulary.getLiteralName(i);
              if (literalName != null) {
                intermediateResult.set(literalName, i);
              }
              let symbolicName = vocabulary.getSymbolicName(i);
              if (symbolicName != null) {
                intermediateResult.set(symbolicName, i);
              }
            }
            intermediateResult.set("EOF", Token_1.Token.EOF);
            result = intermediateResult;
            _Recognizer.tokenTypeMapCache.set(vocabulary, result);
          }
          return result;
        }
        /**
         * Get a map from rule names to rule indexes.
         *
         * Used for XPath and tree pattern compilation.
         */
        getRuleIndexMap() {
          let ruleNames = this.ruleNames;
          if (ruleNames == null) {
            throw new Error("The current recognizer does not provide a list of rule names.");
          }
          let result = _Recognizer.ruleIndexMapCache.get(ruleNames);
          if (result == null) {
            result = Utils3.toMap(ruleNames);
            _Recognizer.ruleIndexMapCache.set(ruleNames, result);
          }
          return result;
        }
        getTokenType(tokenName) {
          let ttype = this.getTokenTypeMap().get(tokenName);
          if (ttype != null) {
            return ttype;
          }
          return Token_1.Token.INVALID_TYPE;
        }
        /**
         * If this recognizer was generated, it will have a serialized ATN
         * representation of the grammar.
         *
         * For interpreters, we don't know their serialized ATN despite having
         * created the interpreter from it.
         */
        get serializedATN() {
          throw new Error("there is no serialized ATN");
        }
        /**
         * Get the {@link ATN} used by the recognizer for prediction.
         *
         * @returns The {@link ATN} used by the recognizer for prediction.
         */
        get atn() {
          return this._interp.atn;
        }
        /**
         * Get the ATN interpreter used by the recognizer for prediction.
         *
         * @returns The ATN interpreter used by the recognizer for prediction.
         */
        get interpreter() {
          return this._interp;
        }
        /**
         * Set the ATN interpreter used by the recognizer for prediction.
         *
         * @param interpreter The ATN interpreter used by the recognizer for
         * prediction.
         */
        set interpreter(interpreter) {
          this._interp = interpreter;
        }
        /** If profiling during the parse/lex, this will return DecisionInfo records
         *  for each decision in recognizer in a ParseInfo object.
         *
         * @since 4.3
         */
        get parseInfo() {
          return Promise.resolve(void 0);
        }
        /** What is the error header, normally line/character position information? */
        getErrorHeader(e) {
          let token = e.getOffendingToken();
          if (!token) {
            return "";
          }
          let line = token.line;
          let charPositionInLine = token.charPositionInLine;
          return "line " + line + ":" + charPositionInLine;
        }
        /**
         * @exception NullPointerException if `listener` is `undefined`.
         */
        addErrorListener(listener) {
          if (!listener) {
            throw new TypeError("listener must not be null");
          }
          this._listeners.push(listener);
        }
        removeErrorListener(listener) {
          let position = this._listeners.indexOf(listener);
          if (position !== -1) {
            this._listeners.splice(position, 1);
          }
        }
        removeErrorListeners() {
          this._listeners.length = 0;
        }
        getErrorListeners() {
          return this._listeners.slice(0);
        }
        getErrorListenerDispatch() {
          return new ProxyErrorListener_1.ProxyErrorListener(this.getErrorListeners());
        }
        // subclass needs to override these if there are sempreds or actions
        // that the ATN interp needs to execute
        sempred(_localctx, ruleIndex, actionIndex) {
          return true;
        }
        precpred(localctx, precedence) {
          return true;
        }
        action(_localctx, ruleIndex, actionIndex) {
        }
        get state() {
          return this._stateNumber;
        }
        /** Indicate that the recognizer has changed internal state that is
         *  consistent with the ATN state passed in.  This way we always know
         *  where we are in the ATN as the parser goes along. The rule
         *  context objects form a stack that lets us see the stack of
         *  invoking rules. Combine this and we have complete ATN
         *  configuration information.
         */
        set state(atnState) {
          this._stateNumber = atnState;
        }
      };
      Recognizer.EOF = -1;
      Recognizer.tokenTypeMapCache = /* @__PURE__ */ new WeakMap();
      Recognizer.ruleIndexMapCache = /* @__PURE__ */ new WeakMap();
      __decorate([
        Decorators_1.SuppressWarnings("serial"),
        Decorators_1.NotNull
      ], Recognizer.prototype, "_listeners", void 0);
      __decorate([
        Decorators_1.NotNull
      ], Recognizer.prototype, "getTokenTypeMap", null);
      __decorate([
        Decorators_1.NotNull
      ], Recognizer.prototype, "getRuleIndexMap", null);
      __decorate([
        Decorators_1.NotNull
      ], Recognizer.prototype, "serializedATN", null);
      __decorate([
        Decorators_1.NotNull
      ], Recognizer.prototype, "atn", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], Recognizer.prototype, "interpreter", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], Recognizer.prototype, "getErrorHeader", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], Recognizer.prototype, "addErrorListener", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], Recognizer.prototype, "removeErrorListener", null);
      __decorate([
        Decorators_1.NotNull
      ], Recognizer.prototype, "getErrorListeners", null);
      exports.Recognizer = Recognizer;
    }
  });

  // node_modules/antlr4ts/VocabularyImpl.js
  var require_VocabularyImpl = __commonJS({
    "node_modules/antlr4ts/VocabularyImpl.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.VocabularyImpl = void 0;
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var VocabularyImpl3 = class {
        /**
         * Constructs a new instance of {@link VocabularyImpl} from the specified
         * literal, symbolic, and display token names.
         *
         * @param literalNames The literal names assigned to tokens, or an empty array
         * if no literal names are assigned.
         * @param symbolicNames The symbolic names assigned to tokens, or
         * an empty array if no symbolic names are assigned.
         * @param displayNames The display names assigned to tokens, or an empty array
         * to use the values in `literalNames` and `symbolicNames` as
         * the source of display names, as described in
         * {@link #getDisplayName(int)}.
         *
         * @see #getLiteralName(int)
         * @see #getSymbolicName(int)
         * @see #getDisplayName(int)
         */
        constructor(literalNames, symbolicNames, displayNames) {
          this.literalNames = literalNames;
          this.symbolicNames = symbolicNames;
          this.displayNames = displayNames;
          this._maxTokenType = Math.max(this.displayNames.length, Math.max(this.literalNames.length, this.symbolicNames.length)) - 1;
        }
        get maxTokenType() {
          return this._maxTokenType;
        }
        getLiteralName(tokenType) {
          if (tokenType >= 0 && tokenType < this.literalNames.length) {
            return this.literalNames[tokenType];
          }
          return void 0;
        }
        getSymbolicName(tokenType) {
          if (tokenType >= 0 && tokenType < this.symbolicNames.length) {
            return this.symbolicNames[tokenType];
          }
          if (tokenType === Token_1.Token.EOF) {
            return "EOF";
          }
          return void 0;
        }
        getDisplayName(tokenType) {
          if (tokenType >= 0 && tokenType < this.displayNames.length) {
            let displayName = this.displayNames[tokenType];
            if (displayName) {
              return displayName;
            }
          }
          let literalName = this.getLiteralName(tokenType);
          if (literalName) {
            return literalName;
          }
          let symbolicName = this.getSymbolicName(tokenType);
          if (symbolicName) {
            return symbolicName;
          }
          return String(tokenType);
        }
      };
      VocabularyImpl3.EMPTY_VOCABULARY = new VocabularyImpl3([], [], []);
      __decorate([
        Decorators_1.NotNull
      ], VocabularyImpl3.prototype, "literalNames", void 0);
      __decorate([
        Decorators_1.NotNull
      ], VocabularyImpl3.prototype, "symbolicNames", void 0);
      __decorate([
        Decorators_1.NotNull
      ], VocabularyImpl3.prototype, "displayNames", void 0);
      __decorate([
        Decorators_1.Override
      ], VocabularyImpl3.prototype, "maxTokenType", null);
      __decorate([
        Decorators_1.Override
      ], VocabularyImpl3.prototype, "getLiteralName", null);
      __decorate([
        Decorators_1.Override
      ], VocabularyImpl3.prototype, "getSymbolicName", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], VocabularyImpl3.prototype, "getDisplayName", null);
      __decorate([
        Decorators_1.NotNull
      ], VocabularyImpl3, "EMPTY_VOCABULARY", void 0);
      exports.VocabularyImpl = VocabularyImpl3;
    }
  });

  // node_modules/antlr4ts/dfa/DFASerializer.js
  var require_DFASerializer = __commonJS({
    "node_modules/antlr4ts/dfa/DFASerializer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DFASerializer = void 0;
      var ATNSimulator_1 = require_ATNSimulator();
      var Decorators_1 = require_Decorators();
      var PredictionContext_1 = require_PredictionContext();
      var Recognizer_1 = require_Recognizer();
      var VocabularyImpl_1 = require_VocabularyImpl();
      var DFASerializer = class {
        constructor(dfa, vocabulary, ruleNames, atn) {
          if (vocabulary instanceof Recognizer_1.Recognizer) {
            ruleNames = vocabulary.ruleNames;
            atn = vocabulary.atn;
            vocabulary = vocabulary.vocabulary;
          } else if (!vocabulary) {
            vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
          }
          this.dfa = dfa;
          this.vocabulary = vocabulary;
          this.ruleNames = ruleNames;
          this.atn = atn;
        }
        toString() {
          if (!this.dfa.s0) {
            return "";
          }
          let buf = "";
          if (this.dfa.states) {
            let states = new Array(...this.dfa.states.toArray());
            states.sort((o1, o2) => o1.stateNumber - o2.stateNumber);
            for (let s of states) {
              let edges = s.getEdgeMap();
              let edgeKeys = [...edges.keys()].sort((a, b) => a - b);
              let contextEdges = s.getContextEdgeMap();
              let contextEdgeKeys = [...contextEdges.keys()].sort((a, b) => a - b);
              for (let entry of edgeKeys) {
                let value = edges.get(entry);
                if ((value == null || value === ATNSimulator_1.ATNSimulator.ERROR) && !s.isContextSymbol(entry)) {
                  continue;
                }
                let contextSymbol = false;
                buf += this.getStateString(s) + "-" + this.getEdgeLabel(entry) + "->";
                if (s.isContextSymbol(entry)) {
                  buf += "!";
                  contextSymbol = true;
                }
                let t = value;
                if (t && t.stateNumber !== ATNSimulator_1.ATNSimulator.ERROR.stateNumber) {
                  buf += this.getStateString(t) + "\n";
                } else if (contextSymbol) {
                  buf += "ctx\n";
                }
              }
              if (s.isContextSensitive) {
                for (let entry of contextEdgeKeys) {
                  buf += this.getStateString(s) + "-" + this.getContextLabel(entry) + "->" + this.getStateString(contextEdges.get(entry)) + "\n";
                }
              }
            }
          }
          let output = buf;
          if (output.length === 0) {
            return "";
          }
          return output;
        }
        getContextLabel(i) {
          if (i === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            return "ctx:EMPTY_FULL";
          } else if (i === PredictionContext_1.PredictionContext.EMPTY_LOCAL_STATE_KEY) {
            return "ctx:EMPTY_LOCAL";
          }
          if (this.atn && i > 0 && i <= this.atn.states.length) {
            let state = this.atn.states[i];
            let ruleIndex = state.ruleIndex;
            if (this.ruleNames && ruleIndex >= 0 && ruleIndex < this.ruleNames.length) {
              return "ctx:" + String(i) + "(" + this.ruleNames[ruleIndex] + ")";
            }
          }
          return "ctx:" + String(i);
        }
        getEdgeLabel(i) {
          return this.vocabulary.getDisplayName(i);
        }
        getStateString(s) {
          if (s === ATNSimulator_1.ATNSimulator.ERROR) {
            return "ERROR";
          }
          let n = s.stateNumber;
          let stateStr = "s" + n;
          if (s.isAcceptState) {
            if (s.predicates) {
              stateStr = ":s" + n + "=>" + s.predicates;
            } else {
              stateStr = ":s" + n + "=>" + s.prediction;
            }
          }
          if (s.isContextSensitive) {
            stateStr += "*";
            for (let config of s.configs) {
              if (config.reachesIntoOuterContext) {
                stateStr += "*";
                break;
              }
            }
          }
          return stateStr;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], DFASerializer.prototype, "dfa", void 0);
      __decorate([
        Decorators_1.NotNull
      ], DFASerializer.prototype, "vocabulary", void 0);
      __decorate([
        Decorators_1.Override
      ], DFASerializer.prototype, "toString", null);
      exports.DFASerializer = DFASerializer;
    }
  });

  // node_modules/antlr4ts/dfa/LexerDFASerializer.js
  var require_LexerDFASerializer = __commonJS({
    "node_modules/antlr4ts/dfa/LexerDFASerializer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerDFASerializer = void 0;
      var DFASerializer_1 = require_DFASerializer();
      var Decorators_1 = require_Decorators();
      var VocabularyImpl_1 = require_VocabularyImpl();
      var LexerDFASerializer = class LexerDFASerializer extends DFASerializer_1.DFASerializer {
        constructor(dfa) {
          super(dfa, VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY);
        }
        getEdgeLabel(i) {
          return "'" + String.fromCodePoint(i) + "'";
        }
      };
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], LexerDFASerializer.prototype, "getEdgeLabel", null);
      LexerDFASerializer = __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerDFASerializer);
      exports.LexerDFASerializer = LexerDFASerializer;
    }
  });

  // node_modules/antlr4ts/atn/StarLoopEntryState.js
  var require_StarLoopEntryState = __commonJS({
    "node_modules/antlr4ts/atn/StarLoopEntryState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StarLoopEntryState = void 0;
      var ATNStateType_1 = require_ATNStateType();
      var BitSet_1 = require_BitSet();
      var DecisionState_1 = require_DecisionState();
      var Decorators_1 = require_Decorators();
      var StarLoopEntryState = class extends DecisionState_1.DecisionState {
        constructor() {
          super(...arguments);
          this.precedenceRuleDecision = false;
          this.precedenceLoopbackStates = new BitSet_1.BitSet();
        }
        get stateType() {
          return ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY;
        }
      };
      __decorate([
        Decorators_1.Override
      ], StarLoopEntryState.prototype, "stateType", null);
      exports.StarLoopEntryState = StarLoopEntryState;
    }
  });

  // node_modules/antlr4ts/dfa/DFA.js
  var require_DFA = __commonJS({
    "node_modules/antlr4ts/dfa/DFA.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DFA = void 0;
      var Array2DHashSet_1 = require_Array2DHashSet();
      var ATNConfigSet_1 = require_ATNConfigSet();
      var DFASerializer_1 = require_DFASerializer();
      var DFAState_1 = require_DFAState();
      var LexerDFASerializer_1 = require_LexerDFASerializer();
      var Decorators_1 = require_Decorators();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var StarLoopEntryState_1 = require_StarLoopEntryState();
      var VocabularyImpl_1 = require_VocabularyImpl();
      var DFA = class DFA {
        constructor(atnStartState, decision = 0) {
          this.states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          this.nextStateNumber = 0;
          if (!atnStartState.atn) {
            throw new Error("The ATNState must be associated with an ATN");
          }
          this.atnStartState = atnStartState;
          this.atn = atnStartState.atn;
          this.decision = decision;
          let isPrecedenceDfa = false;
          if (atnStartState instanceof StarLoopEntryState_1.StarLoopEntryState) {
            if (atnStartState.precedenceRuleDecision) {
              isPrecedenceDfa = true;
              this.s0 = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
              this.s0full = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
            }
          }
          this.precedenceDfa = isPrecedenceDfa;
        }
        /**
         * Gets whether this DFA is a precedence DFA. Precedence DFAs use a special
         * start state {@link #s0} which is not stored in {@link #states}. The
         * {@link DFAState#edges} array for this start state contains outgoing edges
         * supplying individual start states corresponding to specific precedence
         * values.
         *
         * @returns `true` if this is a precedence DFA; otherwise,
         * `false`.
         * @see Parser.precedence
         */
        get isPrecedenceDfa() {
          return this.precedenceDfa;
        }
        /**
         * Get the start state for a specific precedence value.
         *
         * @param precedence The current precedence.
         * @returns The start state corresponding to the specified precedence, or
         * `undefined` if no start state exists for the specified precedence.
         *
         * @ if this is not a precedence DFA.
         * @see `isPrecedenceDfa`
         */
        getPrecedenceStartState(precedence, fullContext) {
          if (!this.isPrecedenceDfa) {
            throw new Error("Only precedence DFAs may contain a precedence start state.");
          }
          if (fullContext) {
            return this.s0full.getTarget(precedence);
          } else {
            return this.s0.getTarget(precedence);
          }
        }
        /**
         * Set the start state for a specific precedence value.
         *
         * @param precedence The current precedence.
         * @param startState The start state corresponding to the specified
         * precedence.
         *
         * @ if this is not a precedence DFA.
         * @see `isPrecedenceDfa`
         */
        setPrecedenceStartState(precedence, fullContext, startState) {
          if (!this.isPrecedenceDfa) {
            throw new Error("Only precedence DFAs may contain a precedence start state.");
          }
          if (precedence < 0) {
            return;
          }
          if (fullContext) {
            this.s0full.setTarget(precedence, startState);
          } else {
            this.s0.setTarget(precedence, startState);
          }
        }
        get isEmpty() {
          if (this.isPrecedenceDfa) {
            return this.s0.getEdgeMap().size === 0 && this.s0full.getEdgeMap().size === 0;
          }
          return this.s0 == null && this.s0full == null;
        }
        get isContextSensitive() {
          if (this.isPrecedenceDfa) {
            return this.s0full.getEdgeMap().size > 0;
          }
          return this.s0full != null;
        }
        addState(state) {
          state.stateNumber = this.nextStateNumber++;
          return this.states.getOrAdd(state);
        }
        toString(vocabulary, ruleNames) {
          if (!vocabulary) {
            vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
          }
          if (!this.s0) {
            return "";
          }
          let serializer;
          if (ruleNames) {
            serializer = new DFASerializer_1.DFASerializer(this, vocabulary, ruleNames, this.atnStartState.atn);
          } else {
            serializer = new DFASerializer_1.DFASerializer(this, vocabulary);
          }
          return serializer.toString();
        }
        toLexerString() {
          if (!this.s0) {
            return "";
          }
          let serializer = new LexerDFASerializer_1.LexerDFASerializer(this);
          return serializer.toString();
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], DFA.prototype, "states", void 0);
      __decorate([
        Decorators_1.NotNull
      ], DFA.prototype, "atnStartState", void 0);
      __decorate([
        Decorators_1.NotNull
      ], DFA.prototype, "atn", void 0);
      DFA = __decorate([
        __param(0, Decorators_1.NotNull)
      ], DFA);
      exports.DFA = DFA;
    }
  });

  // node_modules/antlr4ts/atn/BasicState.js
  var require_BasicState = __commonJS({
    "node_modules/antlr4ts/atn/BasicState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BasicState = void 0;
      var ATNState_1 = require_ATNState();
      var ATNStateType_1 = require_ATNStateType();
      var Decorators_1 = require_Decorators();
      var BasicState = class extends ATNState_1.ATNState {
        get stateType() {
          return ATNStateType_1.ATNStateType.BASIC;
        }
      };
      __decorate([
        Decorators_1.Override
      ], BasicState.prototype, "stateType", null);
      exports.BasicState = BasicState;
    }
  });

  // node_modules/antlr4ts/atn/InvalidState.js
  var require_InvalidState = __commonJS({
    "node_modules/antlr4ts/atn/InvalidState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InvalidState = void 0;
      var ATNStateType_1 = require_ATNStateType();
      var BasicState_1 = require_BasicState();
      var Decorators_1 = require_Decorators();
      var InvalidState = class extends BasicState_1.BasicState {
        get stateType() {
          return ATNStateType_1.ATNStateType.INVALID_TYPE;
        }
      };
      __decorate([
        Decorators_1.Override
      ], InvalidState.prototype, "stateType", null);
      exports.InvalidState = InvalidState;
    }
  });

  // node_modules/antlr4ts/atn/SetTransition.js
  var require_SetTransition = __commonJS({
    "node_modules/antlr4ts/atn/SetTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetTransition = void 0;
      var IntervalSet_1 = require_IntervalSet();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var Transition_1 = require_Transition();
      var SetTransition = class SetTransition extends Transition_1.Transition {
        // TODO (sam): should we really allow undefined here?
        constructor(target, set) {
          super(target);
          if (set == null) {
            set = IntervalSet_1.IntervalSet.of(Token_1.Token.INVALID_TYPE);
          }
          this.set = set;
        }
        get serializationType() {
          return 7;
        }
        get label() {
          return this.set;
        }
        matches(symbol, minVocabSymbol, maxVocabSymbol) {
          return this.set.contains(symbol);
        }
        toString() {
          return this.set.toString();
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], SetTransition.prototype, "set", void 0);
      __decorate([
        Decorators_1.Override
      ], SetTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], SetTransition.prototype, "label", null);
      __decorate([
        Decorators_1.Override
      ], SetTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], SetTransition.prototype, "toString", null);
      SetTransition = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.Nullable)
      ], SetTransition);
      exports.SetTransition = SetTransition;
    }
  });

  // node_modules/antlr4ts/atn/NotSetTransition.js
  var require_NotSetTransition = __commonJS({
    "node_modules/antlr4ts/atn/NotSetTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NotSetTransition = void 0;
      var Decorators_1 = require_Decorators();
      var SetTransition_1 = require_SetTransition();
      var NotSetTransition = class NotSetTransition extends SetTransition_1.SetTransition {
        constructor(target, set) {
          super(target, set);
        }
        get serializationType() {
          return 8;
        }
        matches(symbol, minVocabSymbol, maxVocabSymbol) {
          return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);
        }
        toString() {
          return "~" + super.toString();
        }
      };
      __decorate([
        Decorators_1.Override
      ], NotSetTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override
      ], NotSetTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override
      ], NotSetTransition.prototype, "toString", null);
      NotSetTransition = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.Nullable)
      ], NotSetTransition);
      exports.NotSetTransition = NotSetTransition;
    }
  });

  // node_modules/antlr4ts/atn/RuleStopState.js
  var require_RuleStopState = __commonJS({
    "node_modules/antlr4ts/atn/RuleStopState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleStopState = void 0;
      var ATNState_1 = require_ATNState();
      var ATNStateType_1 = require_ATNStateType();
      var Decorators_1 = require_Decorators();
      var RuleStopState = class extends ATNState_1.ATNState {
        get nonStopStateNumber() {
          return -1;
        }
        get stateType() {
          return ATNStateType_1.ATNStateType.RULE_STOP;
        }
      };
      __decorate([
        Decorators_1.Override
      ], RuleStopState.prototype, "nonStopStateNumber", null);
      __decorate([
        Decorators_1.Override
      ], RuleStopState.prototype, "stateType", null);
      exports.RuleStopState = RuleStopState;
    }
  });

  // node_modules/antlr4ts/atn/RuleTransition.js
  var require_RuleTransition = __commonJS({
    "node_modules/antlr4ts/atn/RuleTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleTransition = void 0;
      var Decorators_1 = require_Decorators();
      var Transition_1 = require_Transition();
      var RuleTransition = class RuleTransition extends Transition_1.Transition {
        constructor(ruleStart, ruleIndex, precedence, followState) {
          super(ruleStart);
          this.tailCall = false;
          this.optimizedTailCall = false;
          this.ruleIndex = ruleIndex;
          this.precedence = precedence;
          this.followState = followState;
        }
        get serializationType() {
          return 3;
        }
        get isEpsilon() {
          return true;
        }
        matches(symbol, minVocabSymbol, maxVocabSymbol) {
          return false;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], RuleTransition.prototype, "followState", void 0);
      __decorate([
        Decorators_1.Override
      ], RuleTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override
      ], RuleTransition.prototype, "isEpsilon", null);
      __decorate([
        Decorators_1.Override
      ], RuleTransition.prototype, "matches", null);
      RuleTransition = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(3, Decorators_1.NotNull)
      ], RuleTransition);
      exports.RuleTransition = RuleTransition;
    }
  });

  // node_modules/antlr4ts/atn/WildcardTransition.js
  var require_WildcardTransition = __commonJS({
    "node_modules/antlr4ts/atn/WildcardTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WildcardTransition = void 0;
      var Decorators_1 = require_Decorators();
      var Transition_1 = require_Transition();
      var WildcardTransition = class WildcardTransition extends Transition_1.Transition {
        constructor(target) {
          super(target);
        }
        get serializationType() {
          return 9;
        }
        matches(symbol, minVocabSymbol, maxVocabSymbol) {
          return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
        }
        toString() {
          return ".";
        }
      };
      __decorate([
        Decorators_1.Override
      ], WildcardTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override
      ], WildcardTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], WildcardTransition.prototype, "toString", null);
      WildcardTransition = __decorate([
        __param(0, Decorators_1.NotNull)
      ], WildcardTransition);
      exports.WildcardTransition = WildcardTransition;
    }
  });

  // node_modules/antlr4ts/atn/LL1Analyzer.js
  var require_LL1Analyzer = __commonJS({
    "node_modules/antlr4ts/atn/LL1Analyzer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LL1Analyzer = void 0;
      var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
      var Array2DHashSet_1 = require_Array2DHashSet();
      var ATNConfig_1 = require_ATNConfig();
      var BitSet_1 = require_BitSet();
      var IntervalSet_1 = require_IntervalSet();
      var Decorators_1 = require_Decorators();
      var NotSetTransition_1 = require_NotSetTransition();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var PredictionContext_1 = require_PredictionContext();
      var RuleStopState_1 = require_RuleStopState();
      var RuleTransition_1 = require_RuleTransition();
      var Token_1 = require_Token();
      var WildcardTransition_1 = require_WildcardTransition();
      var LL1Analyzer = class LL1Analyzer2 {
        constructor(atn) {
          this.atn = atn;
        }
        /**
         * Calculates the SLL(1) expected lookahead set for each outgoing transition
         * of an {@link ATNState}. The returned array has one element for each
         * outgoing transition in `s`. If the closure from transition
         * *i* leads to a semantic predicate before matching a symbol, the
         * element at index *i* of the result will be `undefined`.
         *
         * @param s the ATN state
         * @returns the expected symbols for each outgoing transition of `s`.
         */
        getDecisionLookahead(s) {
          if (s == null) {
            return void 0;
          }
          let look = new Array(s.numberOfTransitions);
          for (let alt = 0; alt < s.numberOfTransitions; alt++) {
            let current = new IntervalSet_1.IntervalSet();
            look[alt] = current;
            let lookBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
            let seeThruPreds = false;
            this._LOOK(s.transition(alt).target, void 0, PredictionContext_1.PredictionContext.EMPTY_LOCAL, current, lookBusy, new BitSet_1.BitSet(), seeThruPreds, false);
            if (current.size === 0 || current.contains(LL1Analyzer2.HIT_PRED)) {
              current = void 0;
              look[alt] = current;
            }
          }
          return look;
        }
        LOOK(s, ctx, stopState) {
          if (stopState === void 0) {
            if (s.atn == null) {
              throw new Error("Illegal state");
            }
            stopState = s.atn.ruleToStopState[s.ruleIndex];
          } else if (stopState === null) {
            stopState = void 0;
          }
          let r = new IntervalSet_1.IntervalSet();
          let seeThruPreds = true;
          let addEOF = true;
          this._LOOK(s, stopState, ctx, r, new Array2DHashSet_1.Array2DHashSet(), new BitSet_1.BitSet(), seeThruPreds, addEOF);
          return r;
        }
        /**
         * Compute set of tokens that can follow `s` in the ATN in the
         * specified `ctx`.
         * <p/>
         * If `ctx` is {@link PredictionContext#EMPTY_LOCAL} and
         * `stopState` or the end of the rule containing `s` is reached,
         * {@link Token#EPSILON} is added to the result set. If `ctx` is not
         * {@link PredictionContext#EMPTY_LOCAL} and `addEOF` is `true`
         * and `stopState` or the end of the outermost rule is reached,
         * {@link Token#EOF} is added to the result set.
         *
         * @param s the ATN state.
         * @param stopState the ATN state to stop at. This can be a
         * {@link BlockEndState} to detect epsilon paths through a closure.
         * @param ctx The outer context, or {@link PredictionContext#EMPTY_LOCAL} if
         * the outer context should not be used.
         * @param look The result lookahead set.
         * @param lookBusy A set used for preventing epsilon closures in the ATN
         * from causing a stack overflow. Outside code should pass
         * `new HashSet<ATNConfig>` for this argument.
         * @param calledRuleStack A set used for preventing left recursion in the
         * ATN from causing a stack overflow. Outside code should pass
         * `new BitSet()` for this argument.
         * @param seeThruPreds `true` to true semantic predicates as
         * implicitly `true` and "see through them", otherwise `false`
         * to treat semantic predicates as opaque and add {@link #HIT_PRED} to the
         * result if one is encountered.
         * @param addEOF Add {@link Token#EOF} to the result if the end of the
         * outermost context is reached. This parameter has no effect if `ctx`
         * is {@link PredictionContext#EMPTY_LOCAL}.
         */
        _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
          let c = ATNConfig_1.ATNConfig.create(s, 0, ctx);
          if (!lookBusy.add(c)) {
            return;
          }
          if (s === stopState) {
            if (PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
              look.add(Token_1.Token.EPSILON);
              return;
            } else if (ctx.isEmpty) {
              if (addEOF) {
                look.add(Token_1.Token.EOF);
              }
              return;
            }
          }
          if (s instanceof RuleStopState_1.RuleStopState) {
            if (ctx.isEmpty && !PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
              if (addEOF) {
                look.add(Token_1.Token.EOF);
              }
              return;
            }
            let removed = calledRuleStack.get(s.ruleIndex);
            try {
              calledRuleStack.clear(s.ruleIndex);
              for (let i = 0; i < ctx.size; i++) {
                if (ctx.getReturnState(i) === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                  continue;
                }
                let returnState = this.atn.states[ctx.getReturnState(i)];
                this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
              }
            } finally {
              if (removed) {
                calledRuleStack.set(s.ruleIndex);
              }
            }
          }
          let n = s.numberOfTransitions;
          for (let i = 0; i < n; i++) {
            let t = s.transition(i);
            if (t instanceof RuleTransition_1.RuleTransition) {
              if (calledRuleStack.get(t.ruleIndex)) {
                continue;
              }
              let newContext = ctx.getChild(t.followState.stateNumber);
              try {
                calledRuleStack.set(t.ruleIndex);
                this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
              } finally {
                calledRuleStack.clear(t.ruleIndex);
              }
            } else if (t instanceof AbstractPredicateTransition_1.AbstractPredicateTransition) {
              if (seeThruPreds) {
                this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
              } else {
                look.add(LL1Analyzer2.HIT_PRED);
              }
            } else if (t.isEpsilon) {
              this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } else if (t instanceof WildcardTransition_1.WildcardTransition) {
              look.addAll(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
            } else {
              let set = t.label;
              if (set != null) {
                if (t instanceof NotSetTransition_1.NotSetTransition) {
                  set = set.complement(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
                }
                look.addAll(set);
              }
            }
          }
        }
      };
      LL1Analyzer.HIT_PRED = Token_1.Token.INVALID_TYPE;
      __decorate([
        Decorators_1.NotNull
      ], LL1Analyzer.prototype, "atn", void 0);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], LL1Analyzer.prototype, "LOOK", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull),
        __param(3, Decorators_1.NotNull),
        __param(4, Decorators_1.NotNull),
        __param(5, Decorators_1.NotNull)
      ], LL1Analyzer.prototype, "_LOOK", null);
      LL1Analyzer = __decorate([
        __param(0, Decorators_1.NotNull)
      ], LL1Analyzer);
      exports.LL1Analyzer = LL1Analyzer;
    }
  });

  // node_modules/antlr4ts/atn/ATN.js
  var require_ATN = __commonJS({
    "node_modules/antlr4ts/atn/ATN.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATN = void 0;
      var Array2DHashMap_1 = require_Array2DHashMap();
      var DFA_1 = require_DFA();
      var IntervalSet_1 = require_IntervalSet();
      var InvalidState_1 = require_InvalidState();
      var LL1Analyzer_1 = require_LL1Analyzer();
      var Decorators_1 = require_Decorators();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var PredictionContext_1 = require_PredictionContext();
      var Token_1 = require_Token();
      var assert = require_assert();
      var ATN2 = class ATN {
        /** Used for runtime deserialization of ATNs from strings */
        constructor(grammarType, maxTokenType) {
          this.states = [];
          this.decisionToState = [];
          this.modeNameToStartState = /* @__PURE__ */ new Map();
          this.modeToStartState = [];
          this.contextCache = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          this.decisionToDFA = [];
          this.modeToDFA = [];
          this.LL1Table = /* @__PURE__ */ new Map();
          this.grammarType = grammarType;
          this.maxTokenType = maxTokenType;
        }
        clearDFA() {
          this.decisionToDFA = new Array(this.decisionToState.length);
          for (let i = 0; i < this.decisionToDFA.length; i++) {
            this.decisionToDFA[i] = new DFA_1.DFA(this.decisionToState[i], i);
          }
          this.modeToDFA = new Array(this.modeToStartState.length);
          for (let i = 0; i < this.modeToDFA.length; i++) {
            this.modeToDFA[i] = new DFA_1.DFA(this.modeToStartState[i]);
          }
          this.contextCache.clear();
          this.LL1Table.clear();
        }
        get contextCacheSize() {
          return this.contextCache.size;
        }
        getCachedContext(context) {
          return PredictionContext_1.PredictionContext.getCachedContext(context, this.contextCache, new PredictionContext_1.PredictionContext.IdentityHashMap());
        }
        getDecisionToDFA() {
          assert(this.decisionToDFA != null && this.decisionToDFA.length === this.decisionToState.length);
          return this.decisionToDFA;
        }
        nextTokens(s, ctx) {
          if (ctx) {
            let anal = new LL1Analyzer_1.LL1Analyzer(this);
            let next = anal.LOOK(s, ctx);
            return next;
          } else {
            if (s.nextTokenWithinRule) {
              return s.nextTokenWithinRule;
            }
            s.nextTokenWithinRule = this.nextTokens(s, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
            s.nextTokenWithinRule.setReadonly(true);
            return s.nextTokenWithinRule;
          }
        }
        addState(state) {
          state.atn = this;
          state.stateNumber = this.states.length;
          this.states.push(state);
        }
        removeState(state) {
          let invalidState = new InvalidState_1.InvalidState();
          invalidState.atn = this;
          invalidState.stateNumber = state.stateNumber;
          this.states[state.stateNumber] = invalidState;
        }
        defineMode(name, s) {
          this.modeNameToStartState.set(name, s);
          this.modeToStartState.push(s);
          this.modeToDFA.push(new DFA_1.DFA(s));
          this.defineDecisionState(s);
        }
        defineDecisionState(s) {
          this.decisionToState.push(s);
          s.decision = this.decisionToState.length - 1;
          this.decisionToDFA.push(new DFA_1.DFA(s, s.decision));
          return s.decision;
        }
        getDecisionState(decision) {
          if (this.decisionToState.length > 0) {
            return this.decisionToState[decision];
          }
          return void 0;
        }
        get numberOfDecisions() {
          return this.decisionToState.length;
        }
        /**
         * Computes the set of input symbols which could follow ATN state number
         * `stateNumber` in the specified full `context`. This method
         * considers the complete parser context, but does not evaluate semantic
         * predicates (i.e. all predicates encountered during the calculation are
         * assumed true). If a path in the ATN exists from the starting state to the
         * {@link RuleStopState} of the outermost context without matching any
         * symbols, {@link Token#EOF} is added to the returned set.
         *
         * If `context` is `undefined`, it is treated as
         * {@link ParserRuleContext#EMPTY}.
         *
         * Note that this does NOT give you the set of all tokens that could
         * appear at a given token position in the input phrase.  In other words, it
         * does not answer:
         *
         * > Given a specific partial input phrase, return the set of all
         * > tokens that can follow the last token in the input phrase.
         *
         * The big difference is that with just the input, the parser could land
         * right in the middle of a lookahead decision. Getting all
         * *possible* tokens given a partial input stream is a separate
         * computation. See https://github.com/antlr/antlr4/issues/1428
         *
         * For this function, we are specifying an ATN state and call stack to
         * compute what token(s) can come next and specifically: outside of a
         * lookahead decision. That is what you want for error reporting and
         * recovery upon parse error.
         *
         * @param stateNumber the ATN state number
         * @param context the full parse context
         * @returns The set of potentially valid input symbols which could follow the
         * specified state in the specified context.
         * @ if the ATN does not contain a state with
         * number `stateNumber`
         */
        getExpectedTokens(stateNumber, context) {
          if (stateNumber < 0 || stateNumber >= this.states.length) {
            throw new RangeError("Invalid state number.");
          }
          let ctx = context;
          let s = this.states[stateNumber];
          let following = this.nextTokens(s);
          if (!following.contains(Token_1.Token.EPSILON)) {
            return following;
          }
          let expected = new IntervalSet_1.IntervalSet();
          expected.addAll(following);
          expected.remove(Token_1.Token.EPSILON);
          while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
            let invokingState = this.states[ctx.invokingState];
            let rt = invokingState.transition(0);
            following = this.nextTokens(rt.followState);
            expected.addAll(following);
            expected.remove(Token_1.Token.EPSILON);
            ctx = ctx._parent;
          }
          if (following.contains(Token_1.Token.EPSILON)) {
            expected.add(Token_1.Token.EOF);
          }
          return expected;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ATN2.prototype, "states", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATN2.prototype, "decisionToState", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATN2.prototype, "modeNameToStartState", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATN2.prototype, "modeToStartState", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATN2.prototype, "decisionToDFA", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATN2.prototype, "modeToDFA", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATN2.prototype, "nextTokens", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ATN2.prototype, "removeState", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ATN2.prototype, "defineMode", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ATN2.prototype, "defineDecisionState", null);
      __decorate([
        Decorators_1.NotNull
      ], ATN2.prototype, "getExpectedTokens", null);
      ATN2 = __decorate([
        __param(0, Decorators_1.NotNull)
      ], ATN2);
      exports.ATN = ATN2;
      (function(ATN3) {
        ATN3.INVALID_ALT_NUMBER = 0;
      })(ATN2 = exports.ATN || (exports.ATN = {}));
      exports.ATN = ATN2;
    }
  });

  // node_modules/antlr4ts/atn/LexerIndexedCustomAction.js
  var require_LexerIndexedCustomAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerIndexedCustomAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerIndexedCustomAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerIndexedCustomAction = class LexerIndexedCustomAction2 {
        /**
         * Constructs a new indexed custom action by associating a character offset
         * with a {@link LexerAction}.
         *
         * Note: This class is only required for lexer actions for which
         * {@link LexerAction#isPositionDependent} returns `true`.
         *
         * @param offset The offset into the input {@link CharStream}, relative to
         * the token start index, at which the specified lexer action should be
         * executed.
         * @param action The lexer action to execute at a particular offset in the
         * input {@link CharStream}.
         */
        constructor(offset, action) {
          this._offset = offset;
          this._action = action;
        }
        /**
         * Gets the location in the input {@link CharStream} at which the lexer
         * action should be executed. The value is interpreted as an offset relative
         * to the token start index.
         *
         * @returns The location in the input {@link CharStream} at which the lexer
         * action should be executed.
         */
        get offset() {
          return this._offset;
        }
        /**
         * Gets the lexer action to execute.
         *
         * @returns A {@link LexerAction} object which executes the lexer action.
         */
        get action() {
          return this._action;
        }
        /**
         * {@inheritDoc}
         *
         * @returns This method returns the result of calling {@link #getActionType}
         * on the {@link LexerAction} returned by {@link #getAction}.
         */
        get actionType() {
          return this._action.actionType;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns `true`.
         */
        get isPositionDependent() {
          return true;
        }
        /**
         * {@inheritDoc}
         *
         * This method calls {@link #execute} on the result of {@link #getAction}
         * using the provided `lexer`.
         */
        execute(lexer) {
          this._action.execute(lexer);
        }
        hashCode() {
          let hash = MurmurHash_1.MurmurHash.initialize();
          hash = MurmurHash_1.MurmurHash.update(hash, this._offset);
          hash = MurmurHash_1.MurmurHash.update(hash, this._action);
          return MurmurHash_1.MurmurHash.finish(hash, 2);
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof LexerIndexedCustomAction2)) {
            return false;
          }
          return this._offset === obj._offset && this._action.equals(obj._action);
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], LexerIndexedCustomAction.prototype, "action", null);
      __decorate([
        Decorators_1.Override
      ], LexerIndexedCustomAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerIndexedCustomAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override
      ], LexerIndexedCustomAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerIndexedCustomAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerIndexedCustomAction.prototype, "equals", null);
      LexerIndexedCustomAction = __decorate([
        __param(1, Decorators_1.NotNull)
      ], LexerIndexedCustomAction);
      exports.LexerIndexedCustomAction = LexerIndexedCustomAction;
    }
  });

  // node_modules/antlr4ts/atn/LexerActionExecutor.js
  var require_LexerActionExecutor = __commonJS({
    "node_modules/antlr4ts/atn/LexerActionExecutor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerActionExecutor = void 0;
      var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
      var LexerIndexedCustomAction_1 = require_LexerIndexedCustomAction();
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerActionExecutor = class LexerActionExecutor2 {
        /**
         * Constructs an executor for a sequence of {@link LexerAction} actions.
         * @param lexerActions The lexer actions to execute.
         */
        constructor(lexerActions) {
          this._lexerActions = lexerActions;
          let hash = MurmurHash_1.MurmurHash.initialize();
          for (let lexerAction of lexerActions) {
            hash = MurmurHash_1.MurmurHash.update(hash, lexerAction);
          }
          this.cachedHashCode = MurmurHash_1.MurmurHash.finish(hash, lexerActions.length);
        }
        /**
         * Creates a {@link LexerActionExecutor} which executes the actions for
         * the input `lexerActionExecutor` followed by a specified
         * `lexerAction`.
         *
         * @param lexerActionExecutor The executor for actions already traversed by
         * the lexer while matching a token within a particular
         * {@link ATNConfig}. If this is `undefined`, the method behaves as though
         * it were an empty executor.
         * @param lexerAction The lexer action to execute after the actions
         * specified in `lexerActionExecutor`.
         *
         * @returns A {@link LexerActionExecutor} for executing the combine actions
         * of `lexerActionExecutor` and `lexerAction`.
         */
        static append(lexerActionExecutor, lexerAction) {
          if (!lexerActionExecutor) {
            return new LexerActionExecutor2([lexerAction]);
          }
          let lexerActions = lexerActionExecutor._lexerActions.slice(0);
          lexerActions.push(lexerAction);
          return new LexerActionExecutor2(lexerActions);
        }
        /**
         * Creates a {@link LexerActionExecutor} which encodes the current offset
         * for position-dependent lexer actions.
         *
         * Normally, when the executor encounters lexer actions where
         * {@link LexerAction#isPositionDependent} returns `true`, it calls
         * {@link IntStream#seek} on the input {@link CharStream} to set the input
         * position to the *end* of the current token. This behavior provides
         * for efficient DFA representation of lexer actions which appear at the end
         * of a lexer rule, even when the lexer rule matches a variable number of
         * characters.
         *
         * Prior to traversing a match transition in the ATN, the current offset
         * from the token start index is assigned to all position-dependent lexer
         * actions which have not already been assigned a fixed offset. By storing
         * the offsets relative to the token start index, the DFA representation of
         * lexer actions which appear in the middle of tokens remains efficient due
         * to sharing among tokens of the same length, regardless of their absolute
         * position in the input stream.
         *
         * If the current executor already has offsets assigned to all
         * position-dependent lexer actions, the method returns `this`.
         *
         * @param offset The current offset to assign to all position-dependent
         * lexer actions which do not already have offsets assigned.
         *
         * @returns A {@link LexerActionExecutor} which stores input stream offsets
         * for all position-dependent lexer actions.
         */
        fixOffsetBeforeMatch(offset) {
          let updatedLexerActions;
          for (let i = 0; i < this._lexerActions.length; i++) {
            if (this._lexerActions[i].isPositionDependent && !(this._lexerActions[i] instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction)) {
              if (!updatedLexerActions) {
                updatedLexerActions = this._lexerActions.slice(0);
              }
              updatedLexerActions[i] = new LexerIndexedCustomAction_1.LexerIndexedCustomAction(offset, this._lexerActions[i]);
            }
          }
          if (!updatedLexerActions) {
            return this;
          }
          return new LexerActionExecutor2(updatedLexerActions);
        }
        /**
         * Gets the lexer actions to be executed by this executor.
         * @returns The lexer actions to be executed by this executor.
         */
        get lexerActions() {
          return this._lexerActions;
        }
        /**
         * Execute the actions encapsulated by this executor within the context of a
         * particular {@link Lexer}.
         *
         * This method calls {@link IntStream#seek} to set the position of the
         * `input` {@link CharStream} prior to calling
         * {@link LexerAction#execute} on a position-dependent action. Before the
         * method returns, the input position will be restored to the same position
         * it was in when the method was invoked.
         *
         * @param lexer The lexer instance.
         * @param input The input stream which is the source for the current token.
         * When this method is called, the current {@link IntStream#index} for
         * `input` should be the start of the following token, i.e. 1
         * character past the end of the current token.
         * @param startIndex The token start index. This value may be passed to
         * {@link IntStream#seek} to set the `input` position to the beginning
         * of the token.
         */
        execute(lexer, input, startIndex) {
          let requiresSeek = false;
          let stopIndex = input.index;
          try {
            for (let lexerAction of this._lexerActions) {
              if (lexerAction instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction) {
                let offset = lexerAction.offset;
                input.seek(startIndex + offset);
                lexerAction = lexerAction.action;
                requiresSeek = startIndex + offset !== stopIndex;
              } else if (lexerAction.isPositionDependent) {
                input.seek(stopIndex);
                requiresSeek = false;
              }
              lexerAction.execute(lexer);
            }
          } finally {
            if (requiresSeek) {
              input.seek(stopIndex);
            }
          }
        }
        hashCode() {
          return this.cachedHashCode;
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof LexerActionExecutor2)) {
            return false;
          }
          return this.cachedHashCode === obj.cachedHashCode && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._lexerActions, obj._lexerActions);
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], LexerActionExecutor.prototype, "_lexerActions", void 0);
      __decorate([
        Decorators_1.NotNull
      ], LexerActionExecutor.prototype, "lexerActions", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerActionExecutor.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerActionExecutor.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerActionExecutor.prototype, "equals", null);
      __decorate([
        Decorators_1.NotNull,
        __param(1, Decorators_1.NotNull)
      ], LexerActionExecutor, "append", null);
      LexerActionExecutor = __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerActionExecutor);
      exports.LexerActionExecutor = LexerActionExecutor;
    }
  });

  // node_modules/antlr4ts/LexerNoViableAltException.js
  var require_LexerNoViableAltException = __commonJS({
    "node_modules/antlr4ts/LexerNoViableAltException.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerNoViableAltException = void 0;
      var RecognitionException_1 = require_RecognitionException();
      var Decorators_1 = require_Decorators();
      var Interval_1 = require_Interval();
      var Utils3 = require_Utils();
      var LexerNoViableAltException = class LexerNoViableAltException extends RecognitionException_1.RecognitionException {
        constructor(lexer, input, startIndex, deadEndConfigs) {
          super(lexer, input);
          this._startIndex = startIndex;
          this._deadEndConfigs = deadEndConfigs;
        }
        get startIndex() {
          return this._startIndex;
        }
        get deadEndConfigs() {
          return this._deadEndConfigs;
        }
        get inputStream() {
          return super.inputStream;
        }
        toString() {
          let symbol = "";
          if (this._startIndex >= 0 && this._startIndex < this.inputStream.size) {
            symbol = this.inputStream.getText(Interval_1.Interval.of(this._startIndex, this._startIndex));
            symbol = Utils3.escapeWhitespace(symbol, false);
          }
          return `LexerNoViableAltException('${symbol}')`;
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerNoViableAltException.prototype, "inputStream", null);
      __decorate([
        Decorators_1.Override
      ], LexerNoViableAltException.prototype, "toString", null);
      LexerNoViableAltException = __decorate([
        __param(1, Decorators_1.NotNull)
      ], LexerNoViableAltException);
      exports.LexerNoViableAltException = LexerNoViableAltException;
    }
  });

  // node_modules/antlr4ts/atn/OrderedATNConfigSet.js
  var require_OrderedATNConfigSet = __commonJS({
    "node_modules/antlr4ts/atn/OrderedATNConfigSet.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.OrderedATNConfigSet = void 0;
      var ATNConfigSet_1 = require_ATNConfigSet();
      var Decorators_1 = require_Decorators();
      var OrderedATNConfigSet = class _OrderedATNConfigSet extends ATNConfigSet_1.ATNConfigSet {
        constructor(set, readonly) {
          if (set != null && readonly != null) {
            super(set, readonly);
          } else {
            super();
          }
        }
        clone(readonly) {
          let copy = new _OrderedATNConfigSet(this, readonly);
          if (!readonly && this.isReadOnly) {
            copy.addAll(this);
          }
          return copy;
        }
        getKey(e) {
          return { state: 0, alt: e.hashCode() };
        }
        canMerge(left, leftKey, right) {
          return left.equals(right);
        }
      };
      __decorate([
        Decorators_1.Override
      ], OrderedATNConfigSet.prototype, "clone", null);
      __decorate([
        Decorators_1.Override
      ], OrderedATNConfigSet.prototype, "getKey", null);
      __decorate([
        Decorators_1.Override
      ], OrderedATNConfigSet.prototype, "canMerge", null);
      exports.OrderedATNConfigSet = OrderedATNConfigSet;
    }
  });

  // node_modules/antlr4ts/atn/LexerATNSimulator.js
  var require_LexerATNSimulator = __commonJS({
    "node_modules/antlr4ts/atn/LexerATNSimulator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerATNSimulator = void 0;
      var AcceptStateInfo_1 = require_AcceptStateInfo();
      var ATN_1 = require_ATN();
      var ATNConfig_1 = require_ATNConfig();
      var ATNConfigSet_1 = require_ATNConfigSet();
      var ATNSimulator_1 = require_ATNSimulator();
      var DFAState_1 = require_DFAState();
      var Interval_1 = require_Interval();
      var IntStream_1 = require_IntStream();
      var Lexer_1 = require_Lexer();
      var LexerActionExecutor_1 = require_LexerActionExecutor();
      var LexerNoViableAltException_1 = require_LexerNoViableAltException();
      var Decorators_1 = require_Decorators();
      var OrderedATNConfigSet_1 = require_OrderedATNConfigSet();
      var PredictionContext_1 = require_PredictionContext();
      var RuleStopState_1 = require_RuleStopState();
      var Token_1 = require_Token();
      var assert = require_assert();
      var LexerATNSimulator2 = class LexerATNSimulator3 extends ATNSimulator_1.ATNSimulator {
        constructor(atn, recog) {
          super(atn);
          this.optimize_tail_calls = true;
          this.startIndex = -1;
          this._line = 1;
          this._charPositionInLine = 0;
          this.mode = Lexer_1.Lexer.DEFAULT_MODE;
          this.prevAccept = new LexerATNSimulator3.SimState();
          this.recog = recog;
        }
        copyState(simulator) {
          this._charPositionInLine = simulator.charPositionInLine;
          this._line = simulator._line;
          this.mode = simulator.mode;
          this.startIndex = simulator.startIndex;
        }
        match(input, mode) {
          this.mode = mode;
          let mark = input.mark();
          try {
            this.startIndex = input.index;
            this.prevAccept.reset();
            let s0 = this.atn.modeToDFA[mode].s0;
            if (s0 == null) {
              return this.matchATN(input);
            } else {
              return this.execATN(input, s0);
            }
          } finally {
            input.release(mark);
          }
        }
        reset() {
          this.prevAccept.reset();
          this.startIndex = -1;
          this._line = 1;
          this._charPositionInLine = 0;
          this.mode = Lexer_1.Lexer.DEFAULT_MODE;
        }
        matchATN(input) {
          let startState = this.atn.modeToStartState[this.mode];
          if (LexerATNSimulator3.debug) {
            console.log(`matchATN mode ${this.mode} start: ${startState}`);
          }
          let old_mode = this.mode;
          let s0_closure = this.computeStartState(input, startState);
          let suppressEdge = s0_closure.hasSemanticContext;
          if (suppressEdge) {
            s0_closure.hasSemanticContext = false;
          }
          let next = this.addDFAState(s0_closure);
          if (!suppressEdge) {
            let dfa = this.atn.modeToDFA[this.mode];
            if (!dfa.s0) {
              dfa.s0 = next;
            } else {
              next = dfa.s0;
            }
          }
          let predict = this.execATN(input, next);
          if (LexerATNSimulator3.debug) {
            console.log(`DFA after matchATN: ${this.atn.modeToDFA[old_mode].toLexerString()}`);
          }
          return predict;
        }
        execATN(input, ds0) {
          if (LexerATNSimulator3.debug) {
            console.log(`start state closure=${ds0.configs}`);
          }
          if (ds0.isAcceptState) {
            this.captureSimState(this.prevAccept, input, ds0);
          }
          let t = input.LA(1);
          let s = ds0;
          while (true) {
            if (LexerATNSimulator3.debug) {
              console.log(`execATN loop starting closure: ${s.configs}`);
            }
            let target = this.getExistingTargetState(s, t);
            if (target == null) {
              target = this.computeTargetState(input, s, t);
            }
            if (target === ATNSimulator_1.ATNSimulator.ERROR) {
              break;
            }
            if (t !== IntStream_1.IntStream.EOF) {
              this.consume(input);
            }
            if (target.isAcceptState) {
              this.captureSimState(this.prevAccept, input, target);
              if (t === IntStream_1.IntStream.EOF) {
                break;
              }
            }
            t = input.LA(1);
            s = target;
          }
          return this.failOrAccept(this.prevAccept, input, s.configs, t);
        }
        /**
         * Get an existing target state for an edge in the DFA. If the target state
         * for the edge has not yet been computed or is otherwise not available,
         * this method returns `undefined`.
         *
         * @param s The current DFA state
         * @param t The next input symbol
         * @returns The existing target DFA state for the given input symbol
         * `t`, or `undefined` if the target state for this edge is not
         * already cached
         */
        getExistingTargetState(s, t) {
          let target = s.getTarget(t);
          if (LexerATNSimulator3.debug && target != null) {
            console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
          }
          return target;
        }
        /**
         * Compute a target state for an edge in the DFA, and attempt to add the
         * computed state and corresponding edge to the DFA.
         *
         * @param input The input stream
         * @param s The current DFA state
         * @param t The next input symbol
         *
         * @returns The computed target DFA state for the given input symbol
         * `t`. If `t` does not lead to a valid DFA state, this method
         * returns {@link #ERROR}.
         */
        computeTargetState(input, s, t) {
          let reach = new OrderedATNConfigSet_1.OrderedATNConfigSet();
          this.getReachableConfigSet(input, s.configs, reach, t);
          if (reach.isEmpty) {
            if (!reach.hasSemanticContext) {
              this.addDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
            }
            return ATNSimulator_1.ATNSimulator.ERROR;
          }
          return this.addDFAEdge(s, t, reach);
        }
        failOrAccept(prevAccept, input, reach, t) {
          if (prevAccept.dfaState != null) {
            let lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
            this.accept(input, lexerActionExecutor, this.startIndex, prevAccept.index, prevAccept.line, prevAccept.charPos);
            return prevAccept.dfaState.prediction;
          } else {
            if (t === IntStream_1.IntStream.EOF && input.index === this.startIndex) {
              return Token_1.Token.EOF;
            }
            throw new LexerNoViableAltException_1.LexerNoViableAltException(this.recog, input, this.startIndex, reach);
          }
        }
        /** Given a starting configuration set, figure out all ATN configurations
         *  we can reach upon input `t`. Parameter `reach` is a return
         *  parameter.
         */
        getReachableConfigSet(input, closure, reach, t) {
          let skipAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
          for (let c of closure) {
            let currentAltReachedAcceptState = c.alt === skipAlt;
            if (currentAltReachedAcceptState && c.hasPassedThroughNonGreedyDecision) {
              continue;
            }
            if (LexerATNSimulator3.debug) {
              console.log(`testing ${this.getTokenName(t)} at ${c.toString(this.recog, true)}`);
            }
            let n = c.state.numberOfOptimizedTransitions;
            for (let ti = 0; ti < n; ti++) {
              let trans = c.state.getOptimizedTransition(ti);
              let target = this.getReachableTarget(trans, t);
              if (target != null) {
                let lexerActionExecutor = c.lexerActionExecutor;
                let config;
                if (lexerActionExecutor != null) {
                  lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
                  config = c.transform(target, true, lexerActionExecutor);
                } else {
                  assert(c.lexerActionExecutor == null);
                  config = c.transform(target, true);
                }
                let treatEofAsEpsilon = t === IntStream_1.IntStream.EOF;
                if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
                  skipAlt = c.alt;
                  break;
                }
              }
            }
          }
        }
        accept(input, lexerActionExecutor, startIndex, index, line, charPos) {
          if (LexerATNSimulator3.debug) {
            console.log(`ACTION ${lexerActionExecutor}`);
          }
          input.seek(index);
          this._line = line;
          this._charPositionInLine = charPos;
          if (lexerActionExecutor != null && this.recog != null) {
            lexerActionExecutor.execute(this.recog, input, startIndex);
          }
        }
        getReachableTarget(trans, t) {
          if (trans.matches(t, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
            return trans.target;
          }
          return void 0;
        }
        computeStartState(input, p) {
          let initialContext = PredictionContext_1.PredictionContext.EMPTY_FULL;
          let configs = new OrderedATNConfigSet_1.OrderedATNConfigSet();
          for (let i = 0; i < p.numberOfTransitions; i++) {
            let target = p.transition(i).target;
            let c = ATNConfig_1.ATNConfig.create(target, i + 1, initialContext);
            this.closure(input, c, configs, false, false, false);
          }
          return configs;
        }
        /**
         * Since the alternatives within any lexer decision are ordered by
         * preference, this method stops pursuing the closure as soon as an accept
         * state is reached. After the first accept state is reached by depth-first
         * search from `config`, all other (potentially reachable) states for
         * this rule would have a lower priority.
         *
         * @returns `true` if an accept state is reached, otherwise
         * `false`.
         */
        closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
          if (LexerATNSimulator3.debug) {
            console.log("closure(" + config.toString(this.recog, true) + ")");
          }
          if (config.state instanceof RuleStopState_1.RuleStopState) {
            if (LexerATNSimulator3.debug) {
              if (this.recog != null) {
                console.log(`closure at ${this.recog.ruleNames[config.state.ruleIndex]} rule stop ${config}`);
              } else {
                console.log(`closure at rule stop ${config}`);
              }
            }
            let context = config.context;
            if (context.isEmpty) {
              configs.add(config);
              return true;
            } else if (context.hasEmpty) {
              configs.add(config.transform(config.state, true, PredictionContext_1.PredictionContext.EMPTY_FULL));
              currentAltReachedAcceptState = true;
            }
            for (let i = 0; i < context.size; i++) {
              let returnStateNumber = context.getReturnState(i);
              if (returnStateNumber === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                continue;
              }
              let newContext = context.getParent(i);
              let returnState = this.atn.states[returnStateNumber];
              let c = config.transform(returnState, false, newContext);
              currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
            }
            return currentAltReachedAcceptState;
          }
          if (!config.state.onlyHasEpsilonTransitions) {
            if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision) {
              configs.add(config);
            }
          }
          let p = config.state;
          for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {
            let t = p.getOptimizedTransition(i);
            let c = this.getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon);
            if (c != null) {
              currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
            }
          }
          return currentAltReachedAcceptState;
        }
        // side-effect: can alter configs.hasSemanticContext
        getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon) {
          let c;
          switch (t.serializationType) {
            case 3:
              let ruleTransition = t;
              if (this.optimize_tail_calls && ruleTransition.optimizedTailCall && !config.context.hasEmpty) {
                c = config.transform(t.target, true);
              } else {
                let newContext = config.context.getChild(ruleTransition.followState.stateNumber);
                c = config.transform(t.target, true, newContext);
              }
              break;
            case 10:
              throw new Error("Precedence predicates are not supported in lexers.");
            case 4:
              let pt = t;
              if (LexerATNSimulator3.debug) {
                console.log("EVAL rule " + pt.ruleIndex + ":" + pt.predIndex);
              }
              configs.hasSemanticContext = true;
              if (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) {
                c = config.transform(t.target, true);
              } else {
                c = void 0;
              }
              break;
            case 6:
              if (config.context.hasEmpty) {
                let lexerActionExecutor = LexerActionExecutor_1.LexerActionExecutor.append(config.lexerActionExecutor, this.atn.lexerActions[t.actionIndex]);
                c = config.transform(t.target, true, lexerActionExecutor);
                break;
              } else {
                c = config.transform(t.target, true);
                break;
              }
            case 1:
              c = config.transform(t.target, true);
              break;
            case 5:
            case 2:
            case 7:
              if (treatEofAsEpsilon) {
                if (t.matches(IntStream_1.IntStream.EOF, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
                  c = config.transform(t.target, false);
                  break;
                }
              }
              c = void 0;
              break;
            default:
              c = void 0;
              break;
          }
          return c;
        }
        /**
         * Evaluate a predicate specified in the lexer.
         *
         * If `speculative` is `true`, this method was called before
         * {@link #consume} for the matched character. This method should call
         * {@link #consume} before evaluating the predicate to ensure position
         * sensitive values, including {@link Lexer#getText}, {@link Lexer#getLine},
         * and {@link Lexer#getCharPositionInLine}, properly reflect the current
         * lexer state. This method should restore `input` and the simulator
         * to the original state before returning (i.e. undo the actions made by the
         * call to {@link #consume}.
         *
         * @param input The input stream.
         * @param ruleIndex The rule containing the predicate.
         * @param predIndex The index of the predicate within the rule.
         * @param speculative `true` if the current index in `input` is
         * one character before the predicate's location.
         *
         * @returns `true` if the specified predicate evaluates to
         * `true`.
         */
        evaluatePredicate(input, ruleIndex, predIndex, speculative) {
          if (this.recog == null) {
            return true;
          }
          if (!speculative) {
            return this.recog.sempred(void 0, ruleIndex, predIndex);
          }
          let savedCharPositionInLine = this._charPositionInLine;
          let savedLine = this._line;
          let index = input.index;
          let marker = input.mark();
          try {
            this.consume(input);
            return this.recog.sempred(void 0, ruleIndex, predIndex);
          } finally {
            this._charPositionInLine = savedCharPositionInLine;
            this._line = savedLine;
            input.seek(index);
            input.release(marker);
          }
        }
        captureSimState(settings, input, dfaState) {
          settings.index = input.index;
          settings.line = this._line;
          settings.charPos = this._charPositionInLine;
          settings.dfaState = dfaState;
        }
        addDFAEdge(p, t, q) {
          if (q instanceof ATNConfigSet_1.ATNConfigSet) {
            let suppressEdge = q.hasSemanticContext;
            if (suppressEdge) {
              q.hasSemanticContext = false;
            }
            let to = this.addDFAState(q);
            if (suppressEdge) {
              return to;
            }
            this.addDFAEdge(p, t, to);
            return to;
          } else {
            if (LexerATNSimulator3.debug) {
              console.log("EDGE " + p + " -> " + q + " upon " + String.fromCharCode(t));
            }
            if (p != null) {
              p.setTarget(t, q);
            }
          }
        }
        /** Add a new DFA state if there isn't one with this set of
         * 	configurations already. This method also detects the first
         * 	configuration containing an ATN rule stop state. Later, when
         * 	traversing the DFA, we will know which rule to accept.
         */
        addDFAState(configs) {
          assert(!configs.hasSemanticContext);
          let proposed = new DFAState_1.DFAState(configs);
          let existing = this.atn.modeToDFA[this.mode].states.get(proposed);
          if (existing != null) {
            return existing;
          }
          configs.optimizeConfigs(this);
          let newState = new DFAState_1.DFAState(configs.clone(true));
          let firstConfigWithRuleStopState;
          for (let c of configs) {
            if (c.state instanceof RuleStopState_1.RuleStopState) {
              firstConfigWithRuleStopState = c;
              break;
            }
          }
          if (firstConfigWithRuleStopState != null) {
            let prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
            let lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
            newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(prediction, lexerActionExecutor);
          }
          return this.atn.modeToDFA[this.mode].addState(newState);
        }
        getDFA(mode) {
          return this.atn.modeToDFA[mode];
        }
        /** Get the text matched so far for the current token.
         */
        getText(input) {
          return input.getText(Interval_1.Interval.of(this.startIndex, input.index - 1));
        }
        get line() {
          return this._line;
        }
        set line(line) {
          this._line = line;
        }
        get charPositionInLine() {
          return this._charPositionInLine;
        }
        set charPositionInLine(charPositionInLine) {
          this._charPositionInLine = charPositionInLine;
        }
        consume(input) {
          let curChar = input.LA(1);
          if (curChar === "\n".charCodeAt(0)) {
            this._line++;
            this._charPositionInLine = 0;
          } else {
            this._charPositionInLine++;
          }
          input.consume();
        }
        getTokenName(t) {
          if (t === -1) {
            return "EOF";
          }
          return "'" + String.fromCharCode(t) + "'";
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], LexerATNSimulator2.prototype, "prevAccept", void 0);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "copyState", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "match", null);
      __decorate([
        Decorators_1.Override
      ], LexerATNSimulator2.prototype, "reset", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "matchATN", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "execATN", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "getExistingTargetState", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "computeTargetState", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "getReachableConfigSet", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "accept", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "computeStartState", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "closure", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull),
        __param(3, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "getEpsilonTarget", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "evaluatePredicate", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "captureSimState", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "addDFAState", null);
      __decorate([
        Decorators_1.NotNull
      ], LexerATNSimulator2.prototype, "getDFA", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "getText", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "consume", null);
      __decorate([
        Decorators_1.NotNull
      ], LexerATNSimulator2.prototype, "getTokenName", null);
      LexerATNSimulator2 = __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2);
      exports.LexerATNSimulator = LexerATNSimulator2;
      (function(LexerATNSimulator3) {
        LexerATNSimulator3.debug = false;
        LexerATNSimulator3.dfa_debug = false;
        class SimState {
          constructor() {
            this.index = -1;
            this.line = 0;
            this.charPos = -1;
          }
          reset() {
            this.index = -1;
            this.line = 0;
            this.charPos = -1;
            this.dfaState = void 0;
          }
        }
        LexerATNSimulator3.SimState = SimState;
      })(LexerATNSimulator2 = exports.LexerATNSimulator || (exports.LexerATNSimulator = {}));
      exports.LexerATNSimulator = LexerATNSimulator2;
    }
  });

  // node_modules/antlr4ts/Lexer.js
  var require_Lexer = __commonJS({
    "node_modules/antlr4ts/Lexer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Lexer = void 0;
      var CommonTokenFactory_1 = require_CommonTokenFactory();
      var IntegerStack_1 = require_IntegerStack();
      var Interval_1 = require_Interval();
      var IntStream_1 = require_IntStream();
      var LexerATNSimulator_1 = require_LexerATNSimulator();
      var LexerNoViableAltException_1 = require_LexerNoViableAltException();
      var Decorators_1 = require_Decorators();
      var Recognizer_1 = require_Recognizer();
      var Token_1 = require_Token();
      var Lexer2 = class _Lexer extends Recognizer_1.Recognizer {
        constructor(input) {
          super();
          this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
          this._tokenStartCharIndex = -1;
          this._tokenStartLine = 0;
          this._tokenStartCharPositionInLine = 0;
          this._hitEOF = false;
          this._channel = 0;
          this._type = 0;
          this._modeStack = new IntegerStack_1.IntegerStack();
          this._mode = _Lexer.DEFAULT_MODE;
          this._input = input;
          this._tokenFactorySourcePair = { source: this, stream: input };
        }
        static get DEFAULT_TOKEN_CHANNEL() {
          return Token_1.Token.DEFAULT_CHANNEL;
        }
        static get HIDDEN() {
          return Token_1.Token.HIDDEN_CHANNEL;
        }
        reset(resetInput) {
          if (resetInput === void 0 || resetInput) {
            this._input.seek(0);
          }
          this._token = void 0;
          this._type = Token_1.Token.INVALID_TYPE;
          this._channel = Token_1.Token.DEFAULT_CHANNEL;
          this._tokenStartCharIndex = -1;
          this._tokenStartCharPositionInLine = -1;
          this._tokenStartLine = -1;
          this._text = void 0;
          this._hitEOF = false;
          this._mode = _Lexer.DEFAULT_MODE;
          this._modeStack.clear();
          this.interpreter.reset();
        }
        /** Return a token from this source; i.e., match a token on the char
         *  stream.
         */
        nextToken() {
          if (this._input == null) {
            throw new Error("nextToken requires a non-null input stream.");
          }
          let tokenStartMarker = this._input.mark();
          try {
            outer: while (true) {
              if (this._hitEOF) {
                return this.emitEOF();
              }
              this._token = void 0;
              this._channel = Token_1.Token.DEFAULT_CHANNEL;
              this._tokenStartCharIndex = this._input.index;
              this._tokenStartCharPositionInLine = this.interpreter.charPositionInLine;
              this._tokenStartLine = this.interpreter.line;
              this._text = void 0;
              do {
                this._type = Token_1.Token.INVALID_TYPE;
                let ttype;
                try {
                  ttype = this.interpreter.match(this._input, this._mode);
                } catch (e) {
                  if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
                    this.notifyListeners(e);
                    this.recover(e);
                    ttype = _Lexer.SKIP;
                  } else {
                    throw e;
                  }
                }
                if (this._input.LA(1) === IntStream_1.IntStream.EOF) {
                  this._hitEOF = true;
                }
                if (this._type === Token_1.Token.INVALID_TYPE) {
                  this._type = ttype;
                }
                if (this._type === _Lexer.SKIP) {
                  continue outer;
                }
              } while (this._type === _Lexer.MORE);
              if (this._token == null) {
                return this.emit();
              }
              return this._token;
            }
          } finally {
            this._input.release(tokenStartMarker);
          }
        }
        /** Instruct the lexer to skip creating a token for current lexer rule
         *  and look for another token.  nextToken() knows to keep looking when
         *  a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
         *  if token==undefined at end of any token rule, it creates one for you
         *  and emits it.
         */
        skip() {
          this._type = _Lexer.SKIP;
        }
        more() {
          this._type = _Lexer.MORE;
        }
        mode(m) {
          this._mode = m;
        }
        pushMode(m) {
          if (LexerATNSimulator_1.LexerATNSimulator.debug) {
            console.log("pushMode " + m);
          }
          this._modeStack.push(this._mode);
          this.mode(m);
        }
        popMode() {
          if (this._modeStack.isEmpty) {
            throw new Error("EmptyStackException");
          }
          if (LexerATNSimulator_1.LexerATNSimulator.debug) {
            console.log("popMode back to " + this._modeStack.peek());
          }
          this.mode(this._modeStack.pop());
          return this._mode;
        }
        get tokenFactory() {
          return this._factory;
        }
        // @Override
        set tokenFactory(factory) {
          this._factory = factory;
        }
        get inputStream() {
          return this._input;
        }
        /** Set the char stream and reset the lexer */
        set inputStream(input) {
          this.reset(false);
          this._input = input;
          this._tokenFactorySourcePair = { source: this, stream: this._input };
        }
        get sourceName() {
          return this._input.sourceName;
        }
        emit(token) {
          if (!token) {
            token = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.charIndex - 1, this._tokenStartLine, this._tokenStartCharPositionInLine);
          }
          this._token = token;
          return token;
        }
        emitEOF() {
          let cpos = this.charPositionInLine;
          let line = this.line;
          let eof = this._factory.create(this._tokenFactorySourcePair, Token_1.Token.EOF, void 0, Token_1.Token.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, line, cpos);
          this.emit(eof);
          return eof;
        }
        get line() {
          return this.interpreter.line;
        }
        set line(line) {
          this.interpreter.line = line;
        }
        get charPositionInLine() {
          return this.interpreter.charPositionInLine;
        }
        set charPositionInLine(charPositionInLine) {
          this.interpreter.charPositionInLine = charPositionInLine;
        }
        /** What is the index of the current character of lookahead? */
        get charIndex() {
          return this._input.index;
        }
        /** Return the text matched so far for the current token or any
         *  text override.
         */
        get text() {
          if (this._text != null) {
            return this._text;
          }
          return this.interpreter.getText(this._input);
        }
        /** Set the complete text of this token; it wipes any previous
         *  changes to the text.
         */
        set text(text) {
          this._text = text;
        }
        /** Override if emitting multiple tokens. */
        get token() {
          return this._token;
        }
        set token(_token) {
          this._token = _token;
        }
        set type(ttype) {
          this._type = ttype;
        }
        get type() {
          return this._type;
        }
        set channel(channel) {
          this._channel = channel;
        }
        get channel() {
          return this._channel;
        }
        /** Return a list of all Token objects in input char stream.
         *  Forces load of all tokens. Does not include EOF token.
         */
        getAllTokens() {
          let tokens = [];
          let t = this.nextToken();
          while (t.type !== Token_1.Token.EOF) {
            tokens.push(t);
            t = this.nextToken();
          }
          return tokens;
        }
        notifyListeners(e) {
          let text = this._input.getText(Interval_1.Interval.of(this._tokenStartCharIndex, this._input.index));
          let msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
          let listener = this.getErrorListenerDispatch();
          if (listener.syntaxError) {
            listener.syntaxError(this, void 0, this._tokenStartLine, this._tokenStartCharPositionInLine, msg, e);
          }
        }
        getErrorDisplay(s) {
          if (typeof s === "number") {
            switch (s) {
              case Token_1.Token.EOF:
                return "<EOF>";
              case 10:
                return "\\n";
              case 9:
                return "\\t";
              case 13:
                return "\\r";
            }
            return String.fromCharCode(s);
          }
          return s.replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r");
        }
        getCharErrorDisplay(c) {
          let s = this.getErrorDisplay(c);
          return "'" + s + "'";
        }
        recover(re) {
          if (re instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
            if (this._input.LA(1) !== IntStream_1.IntStream.EOF) {
              this.interpreter.consume(this._input);
            }
          } else {
            this._input.consume();
          }
        }
      };
      Lexer2.DEFAULT_MODE = 0;
      Lexer2.MORE = -2;
      Lexer2.SKIP = -3;
      Lexer2.MIN_CHAR_VALUE = 0;
      Lexer2.MAX_CHAR_VALUE = 1114111;
      __decorate([
        Decorators_1.Override
      ], Lexer2.prototype, "nextToken", null);
      __decorate([
        Decorators_1.Override
      ], Lexer2.prototype, "tokenFactory", null);
      __decorate([
        Decorators_1.Override
      ], Lexer2.prototype, "inputStream", null);
      __decorate([
        Decorators_1.Override
      ], Lexer2.prototype, "sourceName", null);
      __decorate([
        Decorators_1.Override
      ], Lexer2.prototype, "line", null);
      __decorate([
        Decorators_1.Override
      ], Lexer2.prototype, "charPositionInLine", null);
      exports.Lexer = Lexer2;
    }
  });

  // node_modules/antlr4ts/misc/IntervalSet.js
  var require_IntervalSet = __commonJS({
    "node_modules/antlr4ts/misc/IntervalSet.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IntervalSet = void 0;
      var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
      var IntegerList_1 = require_IntegerList();
      var Interval_1 = require_Interval();
      var Lexer_1 = require_Lexer();
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var IntervalSet = class _IntervalSet {
        constructor(intervals) {
          this.readonly = false;
          if (intervals != null) {
            this._intervals = intervals.slice(0);
          } else {
            this._intervals = [];
          }
        }
        static get COMPLETE_CHAR_SET() {
          if (_IntervalSet._COMPLETE_CHAR_SET === void 0) {
            _IntervalSet._COMPLETE_CHAR_SET = _IntervalSet.of(Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE);
            _IntervalSet._COMPLETE_CHAR_SET.setReadonly(true);
          }
          return _IntervalSet._COMPLETE_CHAR_SET;
        }
        static get EMPTY_SET() {
          if (_IntervalSet._EMPTY_SET == null) {
            _IntervalSet._EMPTY_SET = new _IntervalSet();
            _IntervalSet._EMPTY_SET.setReadonly(true);
          }
          return _IntervalSet._EMPTY_SET;
        }
        /**
         * Create a set with all ints within range [a..b] (inclusive). If b is omitted, the set contains the single element
         * a.
         */
        static of(a, b = a) {
          let s = new _IntervalSet();
          s.add(a, b);
          return s;
        }
        clear() {
          if (this.readonly) {
            throw new Error("can't alter readonly IntervalSet");
          }
          this._intervals.length = 0;
        }
        /** Add interval; i.e., add all integers from a to b to set.
         *  If b&lt;a, do nothing.
         *  Keep list in sorted order (by left range value).
         *  If overlap, combine ranges.  For example,
         *  If this is {1..5, 10..20}, adding 6..7 yields
         *  {1..5, 6..7, 10..20}.  Adding 4..8 yields {1..8, 10..20}.
         */
        add(a, b = a) {
          this.addRange(Interval_1.Interval.of(a, b));
        }
        // copy on write so we can cache a..a intervals and sets of that
        addRange(addition) {
          if (this.readonly) {
            throw new Error("can't alter readonly IntervalSet");
          }
          if (addition.b < addition.a) {
            return;
          }
          for (let i = 0; i < this._intervals.length; i++) {
            let r = this._intervals[i];
            if (addition.equals(r)) {
              return;
            }
            if (addition.adjacent(r) || !addition.disjoint(r)) {
              let bigger = addition.union(r);
              this._intervals[i] = bigger;
              while (i < this._intervals.length - 1) {
                i++;
                let next = this._intervals[i];
                if (!bigger.adjacent(next) && bigger.disjoint(next)) {
                  break;
                }
                this._intervals.splice(i, 1);
                i--;
                this._intervals[i] = bigger.union(next);
              }
              return;
            }
            if (addition.startsBeforeDisjoint(r)) {
              this._intervals.splice(i, 0, addition);
              return;
            }
          }
          this._intervals.push(addition);
        }
        /** combine all sets in the array returned the or'd value */
        static or(sets) {
          let r = new _IntervalSet();
          for (let s of sets) {
            r.addAll(s);
          }
          return r;
        }
        addAll(set) {
          if (set == null) {
            return this;
          }
          if (set instanceof _IntervalSet) {
            let other = set;
            let n = other._intervals.length;
            for (let i = 0; i < n; i++) {
              let I = other._intervals[i];
              this.add(I.a, I.b);
            }
          } else {
            for (let value of set.toArray()) {
              this.add(value);
            }
          }
          return this;
        }
        complementRange(minElement, maxElement) {
          return this.complement(_IntervalSet.of(minElement, maxElement));
        }
        /** {@inheritDoc} */
        complement(vocabulary) {
          if (vocabulary.isNil) {
            return _IntervalSet.EMPTY_SET;
          }
          let vocabularyIS;
          if (vocabulary instanceof _IntervalSet) {
            vocabularyIS = vocabulary;
          } else {
            vocabularyIS = new _IntervalSet();
            vocabularyIS.addAll(vocabulary);
          }
          return vocabularyIS.subtract(this);
        }
        subtract(a) {
          if (a == null || a.isNil) {
            return new _IntervalSet(this._intervals);
          }
          if (a instanceof _IntervalSet) {
            return _IntervalSet.subtract(this, a);
          }
          let other = new _IntervalSet();
          other.addAll(a);
          return _IntervalSet.subtract(this, other);
        }
        /**
         * Compute the set difference between two interval sets. The specific
         * operation is `left - right`.
         */
        static subtract(left, right) {
          if (left.isNil) {
            return new _IntervalSet();
          }
          let result = new _IntervalSet(left._intervals);
          if (right.isNil) {
            return result;
          }
          let resultI = 0;
          let rightI = 0;
          while (resultI < result._intervals.length && rightI < right._intervals.length) {
            let resultInterval = result._intervals[resultI];
            let rightInterval = right._intervals[rightI];
            if (rightInterval.b < resultInterval.a) {
              rightI++;
              continue;
            }
            if (rightInterval.a > resultInterval.b) {
              resultI++;
              continue;
            }
            let beforeCurrent;
            let afterCurrent;
            if (rightInterval.a > resultInterval.a) {
              beforeCurrent = new Interval_1.Interval(resultInterval.a, rightInterval.a - 1);
            }
            if (rightInterval.b < resultInterval.b) {
              afterCurrent = new Interval_1.Interval(rightInterval.b + 1, resultInterval.b);
            }
            if (beforeCurrent) {
              if (afterCurrent) {
                result._intervals[resultI] = beforeCurrent;
                result._intervals.splice(resultI + 1, 0, afterCurrent);
                resultI++;
                rightI++;
                continue;
              } else {
                result._intervals[resultI] = beforeCurrent;
                resultI++;
                continue;
              }
            } else {
              if (afterCurrent) {
                result._intervals[resultI] = afterCurrent;
                rightI++;
                continue;
              } else {
                result._intervals.splice(resultI, 1);
                continue;
              }
            }
          }
          return result;
        }
        or(a) {
          let o = new _IntervalSet();
          o.addAll(this);
          o.addAll(a);
          return o;
        }
        /** {@inheritDoc} */
        and(other) {
          if (other.isNil) {
            return new _IntervalSet();
          }
          let myIntervals = this._intervals;
          let theirIntervals = other._intervals;
          let intersection;
          let mySize = myIntervals.length;
          let theirSize = theirIntervals.length;
          let i = 0;
          let j = 0;
          while (i < mySize && j < theirSize) {
            let mine = myIntervals[i];
            let theirs = theirIntervals[j];
            if (mine.startsBeforeDisjoint(theirs)) {
              i++;
            } else if (theirs.startsBeforeDisjoint(mine)) {
              j++;
            } else if (mine.properlyContains(theirs)) {
              if (!intersection) {
                intersection = new _IntervalSet();
              }
              intersection.addRange(mine.intersection(theirs));
              j++;
            } else if (theirs.properlyContains(mine)) {
              if (!intersection) {
                intersection = new _IntervalSet();
              }
              intersection.addRange(mine.intersection(theirs));
              i++;
            } else if (!mine.disjoint(theirs)) {
              if (!intersection) {
                intersection = new _IntervalSet();
              }
              intersection.addRange(mine.intersection(theirs));
              if (mine.startsAfterNonDisjoint(theirs)) {
                j++;
              } else if (theirs.startsAfterNonDisjoint(mine)) {
                i++;
              }
            }
          }
          if (!intersection) {
            return new _IntervalSet();
          }
          return intersection;
        }
        /** {@inheritDoc} */
        contains(el) {
          let n = this._intervals.length;
          let l = 0;
          let r = n - 1;
          while (l <= r) {
            let m = l + r >> 1;
            let I = this._intervals[m];
            let a = I.a;
            let b = I.b;
            if (b < el) {
              l = m + 1;
            } else if (a > el) {
              r = m - 1;
            } else {
              return true;
            }
          }
          return false;
        }
        /** {@inheritDoc} */
        get isNil() {
          return this._intervals == null || this._intervals.length === 0;
        }
        /**
         * Returns the maximum value contained in the set if not isNil.
         *
         * @return the maximum value contained in the set.
         * @throws RangeError if set is empty
         */
        get maxElement() {
          if (this.isNil) {
            throw new RangeError("set is empty");
          }
          let last = this._intervals[this._intervals.length - 1];
          return last.b;
        }
        /**
         * Returns the minimum value contained in the set if not isNil.
         *
         * @return the minimum value contained in the set.
         * @throws RangeError if set is empty
         */
        get minElement() {
          if (this.isNil) {
            throw new RangeError("set is empty");
          }
          return this._intervals[0].a;
        }
        /** Return a list of Interval objects. */
        get intervals() {
          return this._intervals;
        }
        hashCode() {
          let hash = MurmurHash_1.MurmurHash.initialize();
          for (let I of this._intervals) {
            hash = MurmurHash_1.MurmurHash.update(hash, I.a);
            hash = MurmurHash_1.MurmurHash.update(hash, I.b);
          }
          hash = MurmurHash_1.MurmurHash.finish(hash, this._intervals.length * 2);
          return hash;
        }
        /** Are two IntervalSets equal?  Because all intervals are sorted
         *  and disjoint, equals is a simple linear walk over both lists
         *  to make sure they are the same.  Interval.equals() is used
         *  by the List.equals() method to check the ranges.
         */
        equals(o) {
          if (o == null || !(o instanceof _IntervalSet)) {
            return false;
          }
          return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._intervals, o._intervals);
        }
        toString(elemAreChar = false) {
          let buf = "";
          if (this._intervals == null || this._intervals.length === 0) {
            return "{}";
          }
          if (this.size > 1) {
            buf += "{";
          }
          let first = true;
          for (let I of this._intervals) {
            if (first) {
              first = false;
            } else {
              buf += ", ";
            }
            let a = I.a;
            let b = I.b;
            if (a === b) {
              if (a === Token_1.Token.EOF) {
                buf += "<EOF>";
              } else if (elemAreChar) {
                buf += "'" + String.fromCodePoint(a) + "'";
              } else {
                buf += a;
              }
            } else {
              if (elemAreChar) {
                buf += "'" + String.fromCodePoint(a) + "'..'" + String.fromCodePoint(b) + "'";
              } else {
                buf += a + ".." + b;
              }
            }
          }
          if (this.size > 1) {
            buf += "}";
          }
          return buf;
        }
        toStringVocabulary(vocabulary) {
          if (this._intervals == null || this._intervals.length === 0) {
            return "{}";
          }
          let buf = "";
          if (this.size > 1) {
            buf += "{";
          }
          let first = true;
          for (let I of this._intervals) {
            if (first) {
              first = false;
            } else {
              buf += ", ";
            }
            let a = I.a;
            let b = I.b;
            if (a === b) {
              buf += this.elementName(vocabulary, a);
            } else {
              for (let i = a; i <= b; i++) {
                if (i > a) {
                  buf += ", ";
                }
                buf += this.elementName(vocabulary, i);
              }
            }
          }
          if (this.size > 1) {
            buf += "}";
          }
          return buf;
        }
        elementName(vocabulary, a) {
          if (a === Token_1.Token.EOF) {
            return "<EOF>";
          } else if (a === Token_1.Token.EPSILON) {
            return "<EPSILON>";
          } else {
            return vocabulary.getDisplayName(a);
          }
        }
        get size() {
          let n = 0;
          let numIntervals = this._intervals.length;
          if (numIntervals === 1) {
            let firstInterval = this._intervals[0];
            return firstInterval.b - firstInterval.a + 1;
          }
          for (let i = 0; i < numIntervals; i++) {
            let I = this._intervals[i];
            n += I.b - I.a + 1;
          }
          return n;
        }
        toIntegerList() {
          let values = new IntegerList_1.IntegerList(this.size);
          let n = this._intervals.length;
          for (let i = 0; i < n; i++) {
            let I = this._intervals[i];
            let a = I.a;
            let b = I.b;
            for (let v = a; v <= b; v++) {
              values.add(v);
            }
          }
          return values;
        }
        toSet() {
          let s = /* @__PURE__ */ new Set();
          for (let I of this._intervals) {
            let a = I.a;
            let b = I.b;
            for (let v = a; v <= b; v++) {
              s.add(v);
            }
          }
          return s;
        }
        toArray() {
          let values = new Array();
          let n = this._intervals.length;
          for (let i = 0; i < n; i++) {
            let I = this._intervals[i];
            let a = I.a;
            let b = I.b;
            for (let v = a; v <= b; v++) {
              values.push(v);
            }
          }
          return values;
        }
        remove(el) {
          if (this.readonly) {
            throw new Error("can't alter readonly IntervalSet");
          }
          let n = this._intervals.length;
          for (let i = 0; i < n; i++) {
            let I = this._intervals[i];
            let a = I.a;
            let b = I.b;
            if (el < a) {
              break;
            }
            if (el === a && el === b) {
              this._intervals.splice(i, 1);
              break;
            }
            if (el === a) {
              this._intervals[i] = Interval_1.Interval.of(I.a + 1, I.b);
              break;
            }
            if (el === b) {
              this._intervals[i] = Interval_1.Interval.of(I.a, I.b - 1);
              break;
            }
            if (el > a && el < b) {
              let oldb = I.b;
              this._intervals[i] = Interval_1.Interval.of(I.a, el - 1);
              this.add(el + 1, oldb);
            }
          }
        }
        get isReadonly() {
          return this.readonly;
        }
        setReadonly(readonly) {
          if (this.readonly && !readonly) {
            throw new Error("can't alter readonly IntervalSet");
          }
          this.readonly = readonly;
        }
      };
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "addAll", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "complement", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "subtract", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "or", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "and", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "contains", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "isNil", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "equals", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], IntervalSet.prototype, "toStringVocabulary", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], IntervalSet.prototype, "elementName", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "remove", null);
      __decorate([
        Decorators_1.NotNull
      ], IntervalSet, "of", null);
      __decorate([
        Decorators_1.NotNull
      ], IntervalSet, "subtract", null);
      exports.IntervalSet = IntervalSet;
    }
  });

  // node_modules/antlr4ts/atn/ATNDeserializationOptions.js
  var require_ATNDeserializationOptions = __commonJS({
    "node_modules/antlr4ts/atn/ATNDeserializationOptions.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATNDeserializationOptions = void 0;
      var Decorators_1 = require_Decorators();
      var ATNDeserializationOptions = class _ATNDeserializationOptions {
        constructor(options) {
          this.readOnly = false;
          if (options) {
            this.verifyATN = options.verifyATN;
            this.generateRuleBypassTransitions = options.generateRuleBypassTransitions;
            this.optimize = options.optimize;
          } else {
            this.verifyATN = true;
            this.generateRuleBypassTransitions = false;
            this.optimize = true;
          }
        }
        static get defaultOptions() {
          if (_ATNDeserializationOptions._defaultOptions == null) {
            _ATNDeserializationOptions._defaultOptions = new _ATNDeserializationOptions();
            _ATNDeserializationOptions._defaultOptions.makeReadOnly();
          }
          return _ATNDeserializationOptions._defaultOptions;
        }
        get isReadOnly() {
          return this.readOnly;
        }
        makeReadOnly() {
          this.readOnly = true;
        }
        get isVerifyATN() {
          return this.verifyATN;
        }
        set isVerifyATN(verifyATN) {
          this.throwIfReadOnly();
          this.verifyATN = verifyATN;
        }
        get isGenerateRuleBypassTransitions() {
          return this.generateRuleBypassTransitions;
        }
        set isGenerateRuleBypassTransitions(generateRuleBypassTransitions) {
          this.throwIfReadOnly();
          this.generateRuleBypassTransitions = generateRuleBypassTransitions;
        }
        get isOptimize() {
          return this.optimize;
        }
        set isOptimize(optimize) {
          this.throwIfReadOnly();
          this.optimize = optimize;
        }
        throwIfReadOnly() {
          if (this.isReadOnly) {
            throw new Error("The object is read only.");
          }
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ATNDeserializationOptions, "defaultOptions", null);
      exports.ATNDeserializationOptions = ATNDeserializationOptions;
    }
  });

  // node_modules/antlr4ts/atn/ActionTransition.js
  var require_ActionTransition = __commonJS({
    "node_modules/antlr4ts/atn/ActionTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ActionTransition = void 0;
      var Decorators_1 = require_Decorators();
      var Transition_1 = require_Transition();
      var ActionTransition = class ActionTransition extends Transition_1.Transition {
        constructor(target, ruleIndex, actionIndex = -1, isCtxDependent = false) {
          super(target);
          this.ruleIndex = ruleIndex;
          this.actionIndex = actionIndex;
          this.isCtxDependent = isCtxDependent;
        }
        get serializationType() {
          return 6;
        }
        get isEpsilon() {
          return true;
        }
        matches(symbol, minVocabSymbol, maxVocabSymbol) {
          return false;
        }
        toString() {
          return "action_" + this.ruleIndex + ":" + this.actionIndex;
        }
      };
      __decorate([
        Decorators_1.Override
      ], ActionTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override
      ], ActionTransition.prototype, "isEpsilon", null);
      __decorate([
        Decorators_1.Override
      ], ActionTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override
      ], ActionTransition.prototype, "toString", null);
      ActionTransition = __decorate([
        __param(0, Decorators_1.NotNull)
      ], ActionTransition);
      exports.ActionTransition = ActionTransition;
    }
  });

  // node_modules/antlr4ts/atn/AtomTransition.js
  var require_AtomTransition = __commonJS({
    "node_modules/antlr4ts/atn/AtomTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AtomTransition = void 0;
      var IntervalSet_1 = require_IntervalSet();
      var Decorators_1 = require_Decorators();
      var Transition_1 = require_Transition();
      var AtomTransition = class AtomTransition extends Transition_1.Transition {
        constructor(target, label) {
          super(target);
          this._label = label;
        }
        get serializationType() {
          return 5;
        }
        get label() {
          return IntervalSet_1.IntervalSet.of(this._label);
        }
        matches(symbol, minVocabSymbol, maxVocabSymbol) {
          return this._label === symbol;
        }
        toString() {
          return String(this.label);
        }
      };
      __decorate([
        Decorators_1.Override
      ], AtomTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], AtomTransition.prototype, "label", null);
      __decorate([
        Decorators_1.Override
      ], AtomTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], AtomTransition.prototype, "toString", null);
      AtomTransition = __decorate([
        __param(0, Decorators_1.NotNull)
      ], AtomTransition);
      exports.AtomTransition = AtomTransition;
    }
  });

  // node_modules/antlr4ts/atn/BlockStartState.js
  var require_BlockStartState = __commonJS({
    "node_modules/antlr4ts/atn/BlockStartState.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BlockStartState = void 0;
      var DecisionState_1 = require_DecisionState();
      var BlockStartState = class extends DecisionState_1.DecisionState {
      };
      exports.BlockStartState = BlockStartState;
    }
  });

  // node_modules/antlr4ts/atn/BasicBlockStartState.js
  var require_BasicBlockStartState = __commonJS({
    "node_modules/antlr4ts/atn/BasicBlockStartState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BasicBlockStartState = void 0;
      var ATNStateType_1 = require_ATNStateType();
      var BlockStartState_1 = require_BlockStartState();
      var Decorators_1 = require_Decorators();
      var BasicBlockStartState = class extends BlockStartState_1.BlockStartState {
        get stateType() {
          return ATNStateType_1.ATNStateType.BLOCK_START;
        }
      };
      __decorate([
        Decorators_1.Override
      ], BasicBlockStartState.prototype, "stateType", null);
      exports.BasicBlockStartState = BasicBlockStartState;
    }
  });

  // node_modules/antlr4ts/atn/BlockEndState.js
  var require_BlockEndState = __commonJS({
    "node_modules/antlr4ts/atn/BlockEndState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BlockEndState = void 0;
      var ATNState_1 = require_ATNState();
      var ATNStateType_1 = require_ATNStateType();
      var Decorators_1 = require_Decorators();
      var BlockEndState = class extends ATNState_1.ATNState {
        get stateType() {
          return ATNStateType_1.ATNStateType.BLOCK_END;
        }
      };
      __decorate([
        Decorators_1.Override
      ], BlockEndState.prototype, "stateType", null);
      exports.BlockEndState = BlockEndState;
    }
  });

  // node_modules/antlr4ts/atn/EpsilonTransition.js
  var require_EpsilonTransition = __commonJS({
    "node_modules/antlr4ts/atn/EpsilonTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EpsilonTransition = void 0;
      var Decorators_1 = require_Decorators();
      var Transition_1 = require_Transition();
      var EpsilonTransition = class EpsilonTransition extends Transition_1.Transition {
        constructor(target, outermostPrecedenceReturn = -1) {
          super(target);
          this._outermostPrecedenceReturn = outermostPrecedenceReturn;
        }
        /**
         * @returns the rule index of a precedence rule for which this transition is
         * returning from, where the precedence value is 0; otherwise, -1.
         *
         * @see ATNConfig.isPrecedenceFilterSuppressed
         * @see ParserATNSimulator#applyPrecedenceFilter(ATNConfigSet, ParserRuleContext, PredictionContextCache)
         * @since 4.4.1
         */
        get outermostPrecedenceReturn() {
          return this._outermostPrecedenceReturn;
        }
        get serializationType() {
          return 1;
        }
        get isEpsilon() {
          return true;
        }
        matches(symbol, minVocabSymbol, maxVocabSymbol) {
          return false;
        }
        toString() {
          return "epsilon";
        }
      };
      __decorate([
        Decorators_1.Override
      ], EpsilonTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override
      ], EpsilonTransition.prototype, "isEpsilon", null);
      __decorate([
        Decorators_1.Override
      ], EpsilonTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], EpsilonTransition.prototype, "toString", null);
      EpsilonTransition = __decorate([
        __param(0, Decorators_1.NotNull)
      ], EpsilonTransition);
      exports.EpsilonTransition = EpsilonTransition;
    }
  });

  // node_modules/antlr4ts/atn/LexerChannelAction.js
  var require_LexerChannelAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerChannelAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerChannelAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerChannelAction = class _LexerChannelAction {
        /**
         * Constructs a new `channel` action with the specified channel value.
         * @param channel The channel value to pass to {@link Lexer#setChannel}.
         */
        constructor(channel) {
          this._channel = channel;
        }
        /**
         * Gets the channel to use for the {@link Token} created by the lexer.
         *
         * @returns The channel to use for the {@link Token} created by the lexer.
         */
        get channel() {
          return this._channel;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns {@link LexerActionType#CHANNEL}.
         */
        get actionType() {
          return 0;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns `false`.
         */
        get isPositionDependent() {
          return false;
        }
        /**
         * {@inheritDoc}
         *
         * This action is implemented by calling {@link Lexer#setChannel} with the
         * value provided by {@link #getChannel}.
         */
        execute(lexer) {
          lexer.channel = this._channel;
        }
        hashCode() {
          let hash = MurmurHash_1.MurmurHash.initialize();
          hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
          hash = MurmurHash_1.MurmurHash.update(hash, this._channel);
          return MurmurHash_1.MurmurHash.finish(hash, 2);
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof _LexerChannelAction)) {
            return false;
          }
          return this._channel === obj._channel;
        }
        toString() {
          return `channel(${this._channel})`;
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerChannelAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerChannelAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], LexerChannelAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerChannelAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerChannelAction.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], LexerChannelAction.prototype, "toString", null);
      exports.LexerChannelAction = LexerChannelAction;
    }
  });

  // node_modules/antlr4ts/atn/LexerCustomAction.js
  var require_LexerCustomAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerCustomAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerCustomAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerCustomAction = class _LexerCustomAction {
        /**
         * Constructs a custom lexer action with the specified rule and action
         * indexes.
         *
         * @param ruleIndex The rule index to use for calls to
         * {@link Recognizer#action}.
         * @param actionIndex The action index to use for calls to
         * {@link Recognizer#action}.
         */
        constructor(ruleIndex, actionIndex) {
          this._ruleIndex = ruleIndex;
          this._actionIndex = actionIndex;
        }
        /**
         * Gets the rule index to use for calls to {@link Recognizer#action}.
         *
         * @returns The rule index for the custom action.
         */
        get ruleIndex() {
          return this._ruleIndex;
        }
        /**
         * Gets the action index to use for calls to {@link Recognizer#action}.
         *
         * @returns The action index for the custom action.
         */
        get actionIndex() {
          return this._actionIndex;
        }
        /**
         * {@inheritDoc}
         *
         * @returns This method returns {@link LexerActionType#CUSTOM}.
         */
        get actionType() {
          return 1;
        }
        /**
         * Gets whether the lexer action is position-dependent. Position-dependent
         * actions may have different semantics depending on the {@link CharStream}
         * index at the time the action is executed.
         *
         * Custom actions are position-dependent since they may represent a
         * user-defined embedded action which makes calls to methods like
         * {@link Lexer#getText}.
         *
         * @returns This method returns `true`.
         */
        get isPositionDependent() {
          return true;
        }
        /**
         * {@inheritDoc}
         *
         * Custom actions are implemented by calling {@link Lexer#action} with the
         * appropriate rule and action indexes.
         */
        execute(lexer) {
          lexer.action(void 0, this._ruleIndex, this._actionIndex);
        }
        hashCode() {
          let hash = MurmurHash_1.MurmurHash.initialize();
          hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
          hash = MurmurHash_1.MurmurHash.update(hash, this._ruleIndex);
          hash = MurmurHash_1.MurmurHash.update(hash, this._actionIndex);
          return MurmurHash_1.MurmurHash.finish(hash, 3);
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof _LexerCustomAction)) {
            return false;
          }
          return this._ruleIndex === obj._ruleIndex && this._actionIndex === obj._actionIndex;
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerCustomAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerCustomAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], LexerCustomAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerCustomAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerCustomAction.prototype, "equals", null);
      exports.LexerCustomAction = LexerCustomAction;
    }
  });

  // node_modules/antlr4ts/atn/LexerModeAction.js
  var require_LexerModeAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerModeAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerModeAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerModeAction = class _LexerModeAction {
        /**
         * Constructs a new `mode` action with the specified mode value.
         * @param mode The mode value to pass to {@link Lexer#mode}.
         */
        constructor(mode) {
          this._mode = mode;
        }
        /**
         * Get the lexer mode this action should transition the lexer to.
         *
         * @returns The lexer mode for this `mode` command.
         */
        get mode() {
          return this._mode;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns {@link LexerActionType#MODE}.
         */
        get actionType() {
          return 2;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns `false`.
         */
        get isPositionDependent() {
          return false;
        }
        /**
         * {@inheritDoc}
         *
         * This action is implemented by calling {@link Lexer#mode} with the
         * value provided by {@link #getMode}.
         */
        execute(lexer) {
          lexer.mode(this._mode);
        }
        hashCode() {
          let hash = MurmurHash_1.MurmurHash.initialize();
          hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
          hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
          return MurmurHash_1.MurmurHash.finish(hash, 2);
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof _LexerModeAction)) {
            return false;
          }
          return this._mode === obj._mode;
        }
        toString() {
          return `mode(${this._mode})`;
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerModeAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerModeAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], LexerModeAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerModeAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerModeAction.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], LexerModeAction.prototype, "toString", null);
      exports.LexerModeAction = LexerModeAction;
    }
  });

  // node_modules/antlr4ts/atn/LexerMoreAction.js
  var require_LexerMoreAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerMoreAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerMoreAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerMoreAction = class {
        /**
         * Constructs the singleton instance of the lexer `more` command.
         */
        constructor() {
        }
        /**
         * {@inheritDoc}
         * @returns This method returns {@link LexerActionType#MORE}.
         */
        get actionType() {
          return 3;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns `false`.
         */
        get isPositionDependent() {
          return false;
        }
        /**
         * {@inheritDoc}
         *
         * This action is implemented by calling {@link Lexer#more}.
         */
        execute(lexer) {
          lexer.more();
        }
        hashCode() {
          let hash = MurmurHash_1.MurmurHash.initialize();
          hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
          return MurmurHash_1.MurmurHash.finish(hash, 1);
        }
        equals(obj) {
          return obj === this;
        }
        toString() {
          return "more";
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerMoreAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerMoreAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], LexerMoreAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerMoreAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerMoreAction.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], LexerMoreAction.prototype, "toString", null);
      exports.LexerMoreAction = LexerMoreAction;
      (function(LexerMoreAction2) {
        LexerMoreAction2.INSTANCE = new LexerMoreAction2();
      })(LexerMoreAction = exports.LexerMoreAction || (exports.LexerMoreAction = {}));
    }
  });

  // node_modules/antlr4ts/atn/LexerPopModeAction.js
  var require_LexerPopModeAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerPopModeAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerPopModeAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerPopModeAction = class {
        /**
         * Constructs the singleton instance of the lexer `popMode` command.
         */
        constructor() {
        }
        /**
         * {@inheritDoc}
         * @returns This method returns {@link LexerActionType#POP_MODE}.
         */
        get actionType() {
          return 4;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns `false`.
         */
        get isPositionDependent() {
          return false;
        }
        /**
         * {@inheritDoc}
         *
         * This action is implemented by calling {@link Lexer#popMode}.
         */
        execute(lexer) {
          lexer.popMode();
        }
        hashCode() {
          let hash = MurmurHash_1.MurmurHash.initialize();
          hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
          return MurmurHash_1.MurmurHash.finish(hash, 1);
        }
        equals(obj) {
          return obj === this;
        }
        toString() {
          return "popMode";
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerPopModeAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerPopModeAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], LexerPopModeAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerPopModeAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerPopModeAction.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], LexerPopModeAction.prototype, "toString", null);
      exports.LexerPopModeAction = LexerPopModeAction;
      (function(LexerPopModeAction2) {
        LexerPopModeAction2.INSTANCE = new LexerPopModeAction2();
      })(LexerPopModeAction = exports.LexerPopModeAction || (exports.LexerPopModeAction = {}));
    }
  });

  // node_modules/antlr4ts/atn/LexerPushModeAction.js
  var require_LexerPushModeAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerPushModeAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerPushModeAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerPushModeAction = class _LexerPushModeAction {
        /**
         * Constructs a new `pushMode` action with the specified mode value.
         * @param mode The mode value to pass to {@link Lexer#pushMode}.
         */
        constructor(mode) {
          this._mode = mode;
        }
        /**
         * Get the lexer mode this action should transition the lexer to.
         *
         * @returns The lexer mode for this `pushMode` command.
         */
        get mode() {
          return this._mode;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns {@link LexerActionType#PUSH_MODE}.
         */
        get actionType() {
          return 5;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns `false`.
         */
        get isPositionDependent() {
          return false;
        }
        /**
         * {@inheritDoc}
         *
         * This action is implemented by calling {@link Lexer#pushMode} with the
         * value provided by {@link #getMode}.
         */
        execute(lexer) {
          lexer.pushMode(this._mode);
        }
        hashCode() {
          let hash = MurmurHash_1.MurmurHash.initialize();
          hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
          hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
          return MurmurHash_1.MurmurHash.finish(hash, 2);
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof _LexerPushModeAction)) {
            return false;
          }
          return this._mode === obj._mode;
        }
        toString() {
          return `pushMode(${this._mode})`;
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerPushModeAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerPushModeAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], LexerPushModeAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerPushModeAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerPushModeAction.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], LexerPushModeAction.prototype, "toString", null);
      exports.LexerPushModeAction = LexerPushModeAction;
    }
  });

  // node_modules/antlr4ts/atn/LexerSkipAction.js
  var require_LexerSkipAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerSkipAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerSkipAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerSkipAction = class {
        /**
         * Constructs the singleton instance of the lexer `skip` command.
         */
        constructor() {
        }
        /**
         * {@inheritDoc}
         * @returns This method returns {@link LexerActionType#SKIP}.
         */
        get actionType() {
          return 6;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns `false`.
         */
        get isPositionDependent() {
          return false;
        }
        /**
         * {@inheritDoc}
         *
         * This action is implemented by calling {@link Lexer#skip}.
         */
        execute(lexer) {
          lexer.skip();
        }
        hashCode() {
          let hash = MurmurHash_1.MurmurHash.initialize();
          hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
          return MurmurHash_1.MurmurHash.finish(hash, 1);
        }
        equals(obj) {
          return obj === this;
        }
        toString() {
          return "skip";
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerSkipAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerSkipAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], LexerSkipAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerSkipAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerSkipAction.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], LexerSkipAction.prototype, "toString", null);
      exports.LexerSkipAction = LexerSkipAction;
      (function(LexerSkipAction2) {
        LexerSkipAction2.INSTANCE = new LexerSkipAction2();
      })(LexerSkipAction = exports.LexerSkipAction || (exports.LexerSkipAction = {}));
    }
  });

  // node_modules/antlr4ts/atn/LexerTypeAction.js
  var require_LexerTypeAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerTypeAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerTypeAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerTypeAction = class _LexerTypeAction {
        /**
         * Constructs a new `type` action with the specified token type value.
         * @param type The type to assign to the token using `Lexer.type`.
         */
        constructor(type) {
          this._type = type;
        }
        /**
         * Gets the type to assign to a token created by the lexer.
         * @returns The type to assign to a token created by the lexer.
         */
        get type() {
          return this._type;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns {@link LexerActionType#TYPE}.
         */
        get actionType() {
          return 7;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns `false`.
         */
        get isPositionDependent() {
          return false;
        }
        /**
         * {@inheritDoc}
         *
         * This action is implemented by setting `Lexer.type` with the
         * value provided by `type`.
         */
        execute(lexer) {
          lexer.type = this._type;
        }
        hashCode() {
          let hash = MurmurHash_1.MurmurHash.initialize();
          hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
          hash = MurmurHash_1.MurmurHash.update(hash, this._type);
          return MurmurHash_1.MurmurHash.finish(hash, 2);
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof _LexerTypeAction)) {
            return false;
          }
          return this._type === obj._type;
        }
        toString() {
          return `type(${this._type})`;
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerTypeAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerTypeAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], LexerTypeAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerTypeAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerTypeAction.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], LexerTypeAction.prototype, "toString", null);
      exports.LexerTypeAction = LexerTypeAction;
    }
  });

  // node_modules/antlr4ts/atn/LoopEndState.js
  var require_LoopEndState = __commonJS({
    "node_modules/antlr4ts/atn/LoopEndState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LoopEndState = void 0;
      var ATNState_1 = require_ATNState();
      var ATNStateType_1 = require_ATNStateType();
      var Decorators_1 = require_Decorators();
      var LoopEndState = class extends ATNState_1.ATNState {
        get stateType() {
          return ATNStateType_1.ATNStateType.LOOP_END;
        }
      };
      __decorate([
        Decorators_1.Override
      ], LoopEndState.prototype, "stateType", null);
      exports.LoopEndState = LoopEndState;
    }
  });

  // node_modules/antlr4ts/atn/ConflictInfo.js
  var require_ConflictInfo = __commonJS({
    "node_modules/antlr4ts/atn/ConflictInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConflictInfo = void 0;
      var Decorators_1 = require_Decorators();
      var Utils3 = require_Utils();
      var ConflictInfo = class _ConflictInfo {
        constructor(conflictedAlts, exact) {
          this._conflictedAlts = conflictedAlts;
          this.exact = exact;
        }
        /**
         * Gets the set of conflicting alternatives for the configuration set.
         */
        get conflictedAlts() {
          return this._conflictedAlts;
        }
        /**
         * Gets whether or not the configuration conflict is an exact conflict.
         * An exact conflict occurs when the prediction algorithm determines that
         * the represented alternatives for a particular configuration set cannot be
         * further reduced by consuming additional input. After reaching an exact
         * conflict during an SLL prediction, only switch to full-context prediction
         * could reduce the set of viable alternatives. In LL prediction, an exact
         * conflict indicates a true ambiguity in the input.
         *
         * For the {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} prediction mode,
         * accept states are conflicting but not exact are treated as non-accept
         * states.
         */
        get isExact() {
          return this.exact;
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof _ConflictInfo)) {
            return false;
          }
          return this.isExact === obj.isExact && Utils3.equals(this.conflictedAlts, obj.conflictedAlts);
        }
        hashCode() {
          return this.conflictedAlts.hashCode();
        }
      };
      __decorate([
        Decorators_1.Override
      ], ConflictInfo.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], ConflictInfo.prototype, "hashCode", null);
      exports.ConflictInfo = ConflictInfo;
    }
  });

  // node_modules/antlr4ts/tree/TerminalNode.js
  var require_TerminalNode = __commonJS({
    "node_modules/antlr4ts/tree/TerminalNode.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TerminalNode = void 0;
      var Interval_1 = require_Interval();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var TerminalNode2 = class {
        constructor(symbol) {
          this._symbol = symbol;
        }
        getChild(i) {
          throw new RangeError("Terminal Node has no children.");
        }
        get symbol() {
          return this._symbol;
        }
        get parent() {
          return this._parent;
        }
        setParent(parent) {
          this._parent = parent;
        }
        get payload() {
          return this._symbol;
        }
        get sourceInterval() {
          let tokenIndex = this._symbol.tokenIndex;
          return new Interval_1.Interval(tokenIndex, tokenIndex);
        }
        get childCount() {
          return 0;
        }
        accept(visitor) {
          return visitor.visitTerminal(this);
        }
        get text() {
          return this._symbol.text || "";
        }
        toStringTree(parser) {
          return this.toString();
        }
        toString() {
          if (this._symbol.type === Token_1.Token.EOF) {
            return "<EOF>";
          }
          return this._symbol.text || "";
        }
      };
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "getChild", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "parent", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "setParent", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "payload", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "sourceInterval", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "childCount", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "accept", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "text", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "toStringTree", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "toString", null);
      exports.TerminalNode = TerminalNode2;
    }
  });

  // node_modules/antlr4ts/tree/ErrorNode.js
  var require_ErrorNode = __commonJS({
    "node_modules/antlr4ts/tree/ErrorNode.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ErrorNode = void 0;
      var Decorators_1 = require_Decorators();
      var TerminalNode_1 = require_TerminalNode();
      var ErrorNode2 = class extends TerminalNode_1.TerminalNode {
        constructor(token) {
          super(token);
        }
        accept(visitor) {
          return visitor.visitErrorNode(this);
        }
      };
      __decorate([
        Decorators_1.Override
      ], ErrorNode2.prototype, "accept", null);
      exports.ErrorNode = ErrorNode2;
    }
  });

  // node_modules/antlr4ts/tree/RuleNode.js
  var require_RuleNode = __commonJS({
    "node_modules/antlr4ts/tree/RuleNode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleNode = void 0;
      var RuleNode = class {
      };
      exports.RuleNode = RuleNode;
    }
  });

  // node_modules/antlr4ts/tree/Trees.js
  var require_Trees = __commonJS({
    "node_modules/antlr4ts/tree/Trees.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Trees = void 0;
      var ATN_1 = require_ATN();
      var CommonToken_1 = require_CommonToken();
      var ErrorNode_1 = require_ErrorNode();
      var Decorators_1 = require_Decorators();
      var Parser_1 = require_Parser();
      var ParserRuleContext_1 = require_ParserRuleContext();
      var RuleNode_1 = require_RuleNode();
      var TerminalNode_1 = require_TerminalNode();
      var Token_1 = require_Token();
      var Utils3 = require_Utils();
      var Trees = class _Trees {
        static toStringTree(t, arg2) {
          let ruleNames;
          if (arg2 instanceof Parser_1.Parser) {
            ruleNames = arg2.ruleNames;
          } else {
            ruleNames = arg2;
          }
          let s = Utils3.escapeWhitespace(this.getNodeText(t, ruleNames), false);
          if (t.childCount === 0) {
            return s;
          }
          let buf = "";
          buf += "(";
          s = Utils3.escapeWhitespace(this.getNodeText(t, ruleNames), false);
          buf += s;
          buf += " ";
          for (let i = 0; i < t.childCount; i++) {
            if (i > 0) {
              buf += " ";
            }
            buf += this.toStringTree(t.getChild(i), ruleNames);
          }
          buf += ")";
          return buf;
        }
        static getNodeText(t, arg2) {
          let ruleNames;
          if (arg2 instanceof Parser_1.Parser) {
            ruleNames = arg2.ruleNames;
          } else if (arg2) {
            ruleNames = arg2;
          } else {
            let payload = t.payload;
            if (typeof payload.text === "string") {
              return payload.text;
            }
            return t.payload.toString();
          }
          if (t instanceof RuleNode_1.RuleNode) {
            let ruleContext = t.ruleContext;
            let ruleIndex = ruleContext.ruleIndex;
            let ruleName = ruleNames[ruleIndex];
            let altNumber = ruleContext.altNumber;
            if (altNumber !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              return ruleName + ":" + altNumber;
            }
            return ruleName;
          } else if (t instanceof ErrorNode_1.ErrorNode) {
            return t.toString();
          } else if (t instanceof TerminalNode_1.TerminalNode) {
            let symbol = t.symbol;
            return symbol.text || "";
          }
          throw new TypeError("Unexpected node type");
        }
        static getChildren(t) {
          let kids = [];
          for (let i = 0; i < t.childCount; i++) {
            kids.push(t.getChild(i));
          }
          return kids;
        }
        static getAncestors(t) {
          let ancestors = [];
          let p = t.parent;
          while (p) {
            ancestors.unshift(p);
            p = p.parent;
          }
          return ancestors;
        }
        /** Return true if t is u's parent or a node on path to root from u.
         *  Use === not equals().
         *
         *  @since 4.5.1
         */
        static isAncestorOf(t, u) {
          if (!t || !u || !t.parent) {
            return false;
          }
          let p = u.parent;
          while (p) {
            if (t === p) {
              return true;
            }
            p = p.parent;
          }
          return false;
        }
        static findAllTokenNodes(t, ttype) {
          return _Trees.findAllNodes(t, ttype, true);
        }
        static findAllRuleNodes(t, ruleIndex) {
          return _Trees.findAllNodes(t, ruleIndex, false);
        }
        static findAllNodes(t, index, findTokens) {
          let nodes = [];
          _Trees._findAllNodes(t, index, findTokens, nodes);
          return nodes;
        }
        static _findAllNodes(t, index, findTokens, nodes) {
          if (findTokens && t instanceof TerminalNode_1.TerminalNode) {
            if (t.symbol.type === index) {
              nodes.push(t);
            }
          } else if (!findTokens && t instanceof ParserRuleContext_1.ParserRuleContext) {
            if (t.ruleIndex === index) {
              nodes.push(t);
            }
          }
          for (let i = 0; i < t.childCount; i++) {
            _Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);
          }
        }
        /** Get all descendents; includes t itself.
         *
         * @since 4.5.1
         */
        static getDescendants(t) {
          let nodes = [];
          function recurse(e) {
            nodes.push(e);
            const n = e.childCount;
            for (let i = 0; i < n; i++) {
              recurse(e.getChild(i));
            }
          }
          recurse(t);
          return nodes;
        }
        /** Find smallest subtree of t enclosing range startTokenIndex..stopTokenIndex
         *  inclusively using postorder traversal.  Recursive depth-first-search.
         *
         *  @since 4.5
         */
        static getRootOfSubtreeEnclosingRegion(t, startTokenIndex, stopTokenIndex) {
          let n = t.childCount;
          for (let i = 0; i < n; i++) {
            let child = t.getChild(i);
            let r = _Trees.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);
            if (r) {
              return r;
            }
          }
          if (t instanceof ParserRuleContext_1.ParserRuleContext) {
            let stopToken = t.stop;
            if (startTokenIndex >= t.start.tokenIndex && // is range fully contained in t?
            (stopToken == null || stopTokenIndex <= stopToken.tokenIndex)) {
              return t;
            }
          }
          return void 0;
        }
        /** Replace any subtree siblings of root that are completely to left
         *  or right of lookahead range with a CommonToken(Token.INVALID_TYPE,"...")
         *  node. The source interval for t is not altered to suit smaller range!
         *
         *  WARNING: destructive to t.
         *
         *  @since 4.5.1
         */
        static stripChildrenOutOfRange(t, root, startIndex, stopIndex) {
          if (!t) {
            return;
          }
          let count = t.childCount;
          for (let i = 0; i < count; i++) {
            let child = t.getChild(i);
            let range = child.sourceInterval;
            if (child instanceof ParserRuleContext_1.ParserRuleContext && (range.b < startIndex || range.a > stopIndex)) {
              if (_Trees.isAncestorOf(child, root)) {
                let abbrev = new CommonToken_1.CommonToken(Token_1.Token.INVALID_TYPE, "...");
                t.children[i] = new TerminalNode_1.TerminalNode(abbrev);
              }
            }
          }
        }
        static findNodeSuchThat(t, pred) {
          if (pred(t)) {
            return t;
          }
          let n = t.childCount;
          for (let i = 0; i < n; i++) {
            let u = _Trees.findNodeSuchThat(t.getChild(i), pred);
            if (u !== void 0) {
              return u;
            }
          }
          return void 0;
        }
      };
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], Trees, "toStringTree", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], Trees, "getAncestors", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], Trees, "getRootOfSubtreeEnclosingRegion", null);
      exports.Trees = Trees;
    }
  });

  // node_modules/antlr4ts/RuleContext.js
  var require_RuleContext = __commonJS({
    "node_modules/antlr4ts/RuleContext.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleContext = void 0;
      var ATN_1 = require_ATN();
      var Recognizer_1 = require_Recognizer();
      var RuleNode_1 = require_RuleNode();
      var Interval_1 = require_Interval();
      var Decorators_1 = require_Decorators();
      var Trees_1 = require_Trees();
      var ParserRuleContext_1 = require_ParserRuleContext();
      var RuleContext = class _RuleContext extends RuleNode_1.RuleNode {
        constructor(parent, invokingState) {
          super();
          this._parent = parent;
          this.invokingState = invokingState != null ? invokingState : -1;
        }
        static getChildContext(parent, invokingState) {
          return new _RuleContext(parent, invokingState);
        }
        depth() {
          let n = 0;
          let p = this;
          while (p) {
            p = p._parent;
            n++;
          }
          return n;
        }
        /** A context is empty if there is no invoking state; meaning nobody called
         *  current context.
         */
        get isEmpty() {
          return this.invokingState === -1;
        }
        // satisfy the ParseTree / SyntaxTree interface
        get sourceInterval() {
          return Interval_1.Interval.INVALID;
        }
        get ruleContext() {
          return this;
        }
        get parent() {
          return this._parent;
        }
        /** @since 4.7. {@see ParseTree#setParent} comment */
        setParent(parent) {
          this._parent = parent;
        }
        get payload() {
          return this;
        }
        /** Return the combined text of all child nodes. This method only considers
         *  tokens which have been added to the parse tree.
         *
         *  Since tokens on hidden channels (e.g. whitespace or comments) are not
         *  added to the parse trees, they will not appear in the output of this
         *  method.
         */
        get text() {
          if (this.childCount === 0) {
            return "";
          }
          let builder = "";
          for (let i = 0; i < this.childCount; i++) {
            builder += this.getChild(i).text;
          }
          return builder.toString();
        }
        get ruleIndex() {
          return -1;
        }
        /** For rule associated with this parse tree internal node, return
         *  the outer alternative number used to match the input. Default
         *  implementation does not compute nor store this alt num. Create
         *  a subclass of ParserRuleContext with backing field and set
         *  option contextSuperClass.
         *  to set it.
         *
         *  @since 4.5.3
         */
        get altNumber() {
          return ATN_1.ATN.INVALID_ALT_NUMBER;
        }
        /** Set the outer alternative number for this context node. Default
         *  implementation does nothing to avoid backing field overhead for
         *  trees that don't need it.  Create
         *  a subclass of ParserRuleContext with backing field and set
         *  option contextSuperClass.
         *
         *  @since 4.5.3
         */
        set altNumber(altNumber) {
        }
        getChild(i) {
          throw new RangeError("i must be greater than or equal to 0 and less than childCount");
        }
        get childCount() {
          return 0;
        }
        accept(visitor) {
          return visitor.visitChildren(this);
        }
        toStringTree(recog) {
          return Trees_1.Trees.toStringTree(this, recog);
        }
        toString(arg1, stop) {
          const ruleNames = arg1 instanceof Recognizer_1.Recognizer ? arg1.ruleNames : arg1;
          stop = stop || ParserRuleContext_1.ParserRuleContext.emptyContext();
          let buf = "";
          let p = this;
          buf += "[";
          while (p && p !== stop) {
            if (!ruleNames) {
              if (!p.isEmpty) {
                buf += p.invokingState;
              }
            } else {
              let ruleIndex = p.ruleIndex;
              let ruleName = ruleIndex >= 0 && ruleIndex < ruleNames.length ? ruleNames[ruleIndex] : ruleIndex.toString();
              buf += ruleName;
            }
            if (p._parent && (ruleNames || !p._parent.isEmpty)) {
              buf += " ";
            }
            p = p._parent;
          }
          buf += "]";
          return buf.toString();
        }
      };
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "sourceInterval", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "ruleContext", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "parent", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "setParent", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "payload", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "text", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "getChild", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "childCount", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "accept", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "toStringTree", null);
      exports.RuleContext = RuleContext;
    }
  });

  // node_modules/antlr4ts/ParserRuleContext.js
  var require_ParserRuleContext = __commonJS({
    "node_modules/antlr4ts/ParserRuleContext.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParserRuleContext = void 0;
      var ErrorNode_1 = require_ErrorNode();
      var Interval_1 = require_Interval();
      var Decorators_1 = require_Decorators();
      var RuleContext_1 = require_RuleContext();
      var TerminalNode_1 = require_TerminalNode();
      var ParserRuleContext2 = class _ParserRuleContext extends RuleContext_1.RuleContext {
        constructor(parent, invokingStateNumber) {
          if (invokingStateNumber == null) {
            super();
          } else {
            super(parent, invokingStateNumber);
          }
        }
        static emptyContext() {
          return _ParserRuleContext.EMPTY;
        }
        /**
         * COPY a ctx (I'm deliberately not using copy constructor) to avoid
         * confusion with creating node with parent. Does not copy children
         * (except error leaves).
         *
         * This is used in the generated parser code to flip a generic XContext
         * node for rule X to a YContext for alt label Y. In that sense, it is not
         * really a generic copy function.
         *
         * If we do an error sync() at start of a rule, we might add error nodes
         * to the generic XContext so this function must copy those nodes to the
         * YContext as well else they are lost!
         */
        copyFrom(ctx) {
          this._parent = ctx._parent;
          this.invokingState = ctx.invokingState;
          this._start = ctx._start;
          this._stop = ctx._stop;
          if (ctx.children) {
            this.children = [];
            for (let child of ctx.children) {
              if (child instanceof ErrorNode_1.ErrorNode) {
                this.addChild(child);
              }
            }
          }
        }
        // Double dispatch methods for listeners
        enterRule(listener) {
        }
        exitRule(listener) {
        }
        /** Add a parse tree node to this as a child.  Works for
         *  internal and leaf nodes. Does not set parent link;
         *  other add methods must do that. Other addChild methods
         *  call this.
         *
         *  We cannot set the parent pointer of the incoming node
         *  because the existing interfaces do not have a setParent()
         *  method and I don't want to break backward compatibility for this.
         *
         *  @since 4.7
         */
        addAnyChild(t) {
          if (!this.children) {
            this.children = [t];
          } else {
            this.children.push(t);
          }
          return t;
        }
        addChild(t) {
          let result;
          if (t instanceof TerminalNode_1.TerminalNode) {
            t.setParent(this);
            this.addAnyChild(t);
            return;
          } else if (t instanceof RuleContext_1.RuleContext) {
            this.addAnyChild(t);
            return;
          } else {
            t = new TerminalNode_1.TerminalNode(t);
            this.addAnyChild(t);
            t.setParent(this);
            return t;
          }
        }
        addErrorNode(node) {
          if (node instanceof ErrorNode_1.ErrorNode) {
            const errorNode = node;
            errorNode.setParent(this);
            return this.addAnyChild(errorNode);
          } else {
            const badToken = node;
            let t = new ErrorNode_1.ErrorNode(badToken);
            this.addAnyChild(t);
            t.setParent(this);
            return t;
          }
        }
        //	public void trace(int s) {
        //		if ( states==null ) states = new ArrayList<Integer>();
        //		states.add(s);
        //	}
        /** Used by enterOuterAlt to toss out a RuleContext previously added as
         *  we entered a rule. If we have # label, we will need to remove
         *  generic ruleContext object.
         */
        removeLastChild() {
          if (this.children) {
            this.children.pop();
          }
        }
        get parent() {
          let parent = super.parent;
          if (parent === void 0 || parent instanceof _ParserRuleContext) {
            return parent;
          }
          throw new TypeError("Invalid parent type for ParserRuleContext");
        }
        // Note: in TypeScript, order or arguments reversed
        getChild(i, ctxType) {
          if (!this.children || i < 0 || i >= this.children.length) {
            throw new RangeError("index parameter must be between >= 0 and <= number of children.");
          }
          if (ctxType == null) {
            return this.children[i];
          }
          let result = this.tryGetChild(i, ctxType);
          if (result === void 0) {
            throw new Error("The specified node does not exist");
          }
          return result;
        }
        tryGetChild(i, ctxType) {
          if (!this.children || i < 0 || i >= this.children.length) {
            return void 0;
          }
          let j = -1;
          for (let o of this.children) {
            if (o instanceof ctxType) {
              j++;
              if (j === i) {
                return o;
              }
            }
          }
          return void 0;
        }
        getToken(ttype, i) {
          let result = this.tryGetToken(ttype, i);
          if (result === void 0) {
            throw new Error("The specified token does not exist");
          }
          return result;
        }
        tryGetToken(ttype, i) {
          if (!this.children || i < 0 || i >= this.children.length) {
            return void 0;
          }
          let j = -1;
          for (let o of this.children) {
            if (o instanceof TerminalNode_1.TerminalNode) {
              let symbol = o.symbol;
              if (symbol.type === ttype) {
                j++;
                if (j === i) {
                  return o;
                }
              }
            }
          }
          return void 0;
        }
        getTokens(ttype) {
          let tokens = [];
          if (!this.children) {
            return tokens;
          }
          for (let o of this.children) {
            if (o instanceof TerminalNode_1.TerminalNode) {
              let symbol = o.symbol;
              if (symbol.type === ttype) {
                tokens.push(o);
              }
            }
          }
          return tokens;
        }
        get ruleContext() {
          return this;
        }
        // NOTE: argument order change from Java version
        getRuleContext(i, ctxType) {
          return this.getChild(i, ctxType);
        }
        tryGetRuleContext(i, ctxType) {
          return this.tryGetChild(i, ctxType);
        }
        getRuleContexts(ctxType) {
          let contexts = [];
          if (!this.children) {
            return contexts;
          }
          for (let o of this.children) {
            if (o instanceof ctxType) {
              contexts.push(o);
            }
          }
          return contexts;
        }
        get childCount() {
          return this.children ? this.children.length : 0;
        }
        get sourceInterval() {
          if (!this._start) {
            return Interval_1.Interval.INVALID;
          }
          if (!this._stop || this._stop.tokenIndex < this._start.tokenIndex) {
            return Interval_1.Interval.of(this._start.tokenIndex, this._start.tokenIndex - 1);
          }
          return Interval_1.Interval.of(this._start.tokenIndex, this._stop.tokenIndex);
        }
        /**
         * Get the initial token in this context.
         * Note that the range from start to stop is inclusive, so for rules that do not consume anything
         * (for example, zero length or error productions) this token may exceed stop.
         */
        get start() {
          return this._start;
        }
        /**
         * Get the final token in this context.
         * Note that the range from start to stop is inclusive, so for rules that do not consume anything
         * (for example, zero length or error productions) this token may precede start.
         */
        get stop() {
          return this._stop;
        }
        /** Used for rule context info debugging during parse-time, not so much for ATN debugging */
        toInfoString(recognizer) {
          let rules = recognizer.getRuleInvocationStack(this).reverse();
          return "ParserRuleContext" + rules + "{start=" + this._start + ", stop=" + this._stop + "}";
        }
      };
      ParserRuleContext2.EMPTY = new ParserRuleContext2();
      __decorate([
        Decorators_1.Override
      ], ParserRuleContext2.prototype, "parent", null);
      __decorate([
        Decorators_1.Override
      ], ParserRuleContext2.prototype, "childCount", null);
      __decorate([
        Decorators_1.Override
      ], ParserRuleContext2.prototype, "sourceInterval", null);
      exports.ParserRuleContext = ParserRuleContext2;
    }
  });

  // node_modules/antlr4ts/atn/PredictionMode.js
  var require_PredictionMode = __commonJS({
    "node_modules/antlr4ts/atn/PredictionMode.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PredictionMode = void 0;
      var Array2DHashMap_1 = require_Array2DHashMap();
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var RuleStopState_1 = require_RuleStopState();
      var PredictionMode;
      (function(PredictionMode2) {
        PredictionMode2[PredictionMode2["SLL"] = 0] = "SLL";
        PredictionMode2[PredictionMode2["LL"] = 1] = "LL";
        PredictionMode2[PredictionMode2["LL_EXACT_AMBIG_DETECTION"] = 2] = "LL_EXACT_AMBIG_DETECTION";
      })(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));
      (function(PredictionMode2) {
        class AltAndContextMap extends Array2DHashMap_1.Array2DHashMap {
          constructor() {
            super(AltAndContextConfigEqualityComparator.INSTANCE);
          }
        }
        class AltAndContextConfigEqualityComparator {
          AltAndContextConfigEqualityComparator() {
          }
          /**
           * The hash code is only a function of the {@link ATNState#stateNumber}
           * and {@link ATNConfig#context}.
           */
          hashCode(o) {
            let hashCode = MurmurHash_1.MurmurHash.initialize(7);
            hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.state.stateNumber);
            hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.context);
            hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 2);
            return hashCode;
          }
          equals(a, b) {
            if (a === b) {
              return true;
            }
            if (a == null || b == null) {
              return false;
            }
            return a.state.stateNumber === b.state.stateNumber && a.context.equals(b.context);
          }
        }
        AltAndContextConfigEqualityComparator.INSTANCE = new AltAndContextConfigEqualityComparator();
        __decorate([
          Decorators_1.Override
        ], AltAndContextConfigEqualityComparator.prototype, "hashCode", null);
        __decorate([
          Decorators_1.Override
        ], AltAndContextConfigEqualityComparator.prototype, "equals", null);
        function hasConfigInRuleStopState(configs) {
          for (let c of configs) {
            if (c.state instanceof RuleStopState_1.RuleStopState) {
              return true;
            }
          }
          return false;
        }
        PredictionMode2.hasConfigInRuleStopState = hasConfigInRuleStopState;
        function allConfigsInRuleStopStates(configs) {
          for (let config of configs) {
            if (!(config.state instanceof RuleStopState_1.RuleStopState)) {
              return false;
            }
          }
          return true;
        }
        PredictionMode2.allConfigsInRuleStopStates = allConfigsInRuleStopStates;
      })(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));
    }
  });

  // node_modules/antlr4ts/atn/SimulatorState.js
  var require_SimulatorState = __commonJS({
    "node_modules/antlr4ts/atn/SimulatorState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SimulatorState = void 0;
      var Decorators_1 = require_Decorators();
      var ParserRuleContext_1 = require_ParserRuleContext();
      var SimulatorState = class SimulatorState {
        constructor(outerContext, s0, useContext, remainingOuterContext) {
          this.outerContext = outerContext != null ? outerContext : ParserRuleContext_1.ParserRuleContext.emptyContext();
          this.s0 = s0;
          this.useContext = useContext;
          this.remainingOuterContext = remainingOuterContext;
        }
      };
      SimulatorState = __decorate([
        __param(1, Decorators_1.NotNull)
      ], SimulatorState);
      exports.SimulatorState = SimulatorState;
    }
  });

  // node_modules/antlr4ts/atn/ParserATNSimulator.js
  var require_ParserATNSimulator = __commonJS({
    "node_modules/antlr4ts/atn/ParserATNSimulator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParserATNSimulator = void 0;
      var AcceptStateInfo_1 = require_AcceptStateInfo();
      var ActionTransition_1 = require_ActionTransition();
      var Array2DHashSet_1 = require_Array2DHashSet();
      var Arrays_1 = require_Arrays();
      var ATN_1 = require_ATN();
      var ATNConfig_1 = require_ATNConfig();
      var ATNConfigSet_1 = require_ATNConfigSet();
      var ATNSimulator_1 = require_ATNSimulator();
      var ATNStateType_1 = require_ATNStateType();
      var AtomTransition_1 = require_AtomTransition();
      var BitSet_1 = require_BitSet();
      var ConflictInfo_1 = require_ConflictInfo();
      var DecisionState_1 = require_DecisionState();
      var DFAState_1 = require_DFAState();
      var IntegerList_1 = require_IntegerList();
      var Interval_1 = require_Interval();
      var IntStream_1 = require_IntStream();
      var Decorators_1 = require_Decorators();
      var NotSetTransition_1 = require_NotSetTransition();
      var NoViableAltException_1 = require_NoViableAltException();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var ParserRuleContext_1 = require_ParserRuleContext();
      var PredictionContext_1 = require_PredictionContext();
      var PredictionContextCache_1 = require_PredictionContextCache();
      var PredictionMode_1 = require_PredictionMode();
      var RuleStopState_1 = require_RuleStopState();
      var RuleTransition_1 = require_RuleTransition();
      var SemanticContext_1 = require_SemanticContext();
      var SetTransition_1 = require_SetTransition();
      var SimulatorState_1 = require_SimulatorState();
      var Token_1 = require_Token();
      var VocabularyImpl_1 = require_VocabularyImpl();
      var assert = require_assert();
      var MAX_SHORT_VALUE = 65535;
      var MIN_INTEGER_VALUE = -(1 << 31 >>> 0);
      var ParserATNSimulator2 = class ParserATNSimulator3 extends ATNSimulator_1.ATNSimulator {
        constructor(atn, parser) {
          super(atn);
          this.predictionMode = PredictionMode_1.PredictionMode.LL;
          this.force_global_context = false;
          this.always_try_local_context = true;
          this.enable_global_context_dfa = false;
          this.optimize_unique_closure = true;
          this.optimize_ll1 = true;
          this.optimize_tail_calls = true;
          this.tail_call_preserves_sll = true;
          this.treat_sllk1_conflict_as_ambiguity = false;
          this.reportAmbiguities = false;
          this.userWantsCtxSensitive = true;
          this._parser = parser;
        }
        getPredictionMode() {
          return this.predictionMode;
        }
        setPredictionMode(predictionMode) {
          this.predictionMode = predictionMode;
        }
        reset() {
        }
        adaptivePredict(input, decision, outerContext, useContext) {
          if (useContext === void 0) {
            useContext = false;
          }
          let dfa = this.atn.decisionToDFA[decision];
          assert(dfa != null);
          if (this.optimize_ll1 && !dfa.isPrecedenceDfa && !dfa.isEmpty) {
            let ll_1 = input.LA(1);
            if (ll_1 >= 0 && ll_1 <= 65535) {
              let key = (decision << 16 >>> 0) + ll_1;
              let alt = this.atn.LL1Table.get(key);
              if (alt != null) {
                return alt;
              }
            }
          }
          this.dfa = dfa;
          if (this.force_global_context) {
            useContext = true;
          } else if (!this.always_try_local_context) {
            useContext = useContext || dfa.isContextSensitive;
          }
          this.userWantsCtxSensitive = useContext || this.predictionMode !== PredictionMode_1.PredictionMode.SLL && outerContext != null && !this.atn.decisionToState[decision].sll;
          if (outerContext == null) {
            outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
          }
          let state;
          if (!dfa.isEmpty) {
            state = this.getStartState(dfa, input, outerContext, useContext);
          }
          if (state == null) {
            if (outerContext == null) {
              outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
            }
            if (ParserATNSimulator3.debug) {
              console.log("ATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
            }
            state = this.computeStartState(dfa, outerContext, useContext);
          }
          let m = input.mark();
          let index = input.index;
          try {
            let alt = this.execDFA(dfa, input, index, state);
            if (ParserATNSimulator3.debug) {
              console.log("DFA after predictATN: " + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
            }
            return alt;
          } finally {
            this.dfa = void 0;
            input.seek(index);
            input.release(m);
          }
        }
        getStartState(dfa, input, outerContext, useContext) {
          if (!useContext) {
            if (dfa.isPrecedenceDfa) {
              let state = dfa.getPrecedenceStartState(this._parser.precedence, false);
              if (state == null) {
                return void 0;
              }
              return new SimulatorState_1.SimulatorState(outerContext, state, false, outerContext);
            } else {
              if (dfa.s0 == null) {
                return void 0;
              }
              return new SimulatorState_1.SimulatorState(outerContext, dfa.s0, false, outerContext);
            }
          }
          if (!this.enable_global_context_dfa) {
            return void 0;
          }
          let remainingContext = outerContext;
          assert(outerContext != null);
          let s0;
          if (dfa.isPrecedenceDfa) {
            s0 = dfa.getPrecedenceStartState(this._parser.precedence, true);
          } else {
            s0 = dfa.s0full;
          }
          while (remainingContext != null && s0 != null && s0.isContextSensitive) {
            remainingContext = this.skipTailCalls(remainingContext);
            s0 = s0.getContextTarget(this.getReturnState(remainingContext));
            if (remainingContext.isEmpty) {
              assert(s0 == null || !s0.isContextSensitive);
            } else {
              remainingContext = remainingContext.parent;
            }
          }
          if (s0 == null) {
            return void 0;
          }
          return new SimulatorState_1.SimulatorState(outerContext, s0, useContext, remainingContext);
        }
        execDFA(dfa, input, startIndex, state) {
          let outerContext = state.outerContext;
          if (ParserATNSimulator3.dfa_debug) {
            console.log("DFA decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
          }
          if (ParserATNSimulator3.dfa_debug) {
            console.log(dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
          }
          let s = state.s0;
          let t = input.LA(1);
          let remainingOuterContext = state.remainingOuterContext;
          while (true) {
            if (ParserATNSimulator3.dfa_debug) {
              console.log("DFA state " + s.stateNumber + " LA(1)==" + this.getLookaheadName(input));
            }
            if (state.useContext) {
              while (s.isContextSymbol(t)) {
                let next;
                if (remainingOuterContext != null) {
                  remainingOuterContext = this.skipTailCalls(remainingOuterContext);
                  next = s.getContextTarget(this.getReturnState(remainingOuterContext));
                }
                if (next == null) {
                  let initialState = new SimulatorState_1.SimulatorState(state.outerContext, s, state.useContext, remainingOuterContext);
                  return this.execATN(dfa, input, startIndex, initialState);
                }
                assert(remainingOuterContext != null);
                remainingOuterContext = remainingOuterContext.parent;
                s = next;
              }
            }
            if (this.isAcceptState(s, state.useContext)) {
              if (s.predicates != null) {
                if (ParserATNSimulator3.dfa_debug) {
                  console.log("accept " + s);
                }
              } else {
                if (ParserATNSimulator3.dfa_debug) {
                  console.log("accept; predict " + s.prediction + " in state " + s.stateNumber);
                }
              }
              break;
            }
            assert(!this.isAcceptState(s, state.useContext));
            let target = this.getExistingTargetState(s, t);
            if (target == null) {
              if (ParserATNSimulator3.dfa_debug && t >= 0) {
                console.log("no edge for " + this._parser.vocabulary.getDisplayName(t));
              }
              let alt;
              if (ParserATNSimulator3.dfa_debug) {
                let interval = Interval_1.Interval.of(startIndex, this._parser.inputStream.index);
                console.log("ATN exec upon " + this._parser.inputStream.getText(interval) + " at DFA state " + s.stateNumber);
              }
              let initialState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
              alt = this.execATN(dfa, input, startIndex, initialState);
              if (ParserATNSimulator3.dfa_debug) {
                console.log("back from DFA update, alt=" + alt + ", dfa=\n" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
              }
              if (ParserATNSimulator3.dfa_debug) {
                console.log("DFA decision " + dfa.decision + " predicts " + alt);
              }
              return alt;
            } else if (target === ATNSimulator_1.ATNSimulator.ERROR) {
              let errorState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
              return this.handleNoViableAlt(input, startIndex, errorState);
            }
            s = target;
            if (!this.isAcceptState(s, state.useContext) && t !== IntStream_1.IntStream.EOF) {
              input.consume();
              t = input.LA(1);
            }
          }
          if (!state.useContext && s.configs.conflictInfo != null) {
            if (dfa.atnStartState instanceof DecisionState_1.DecisionState) {
              if (!this.userWantsCtxSensitive || !s.configs.dipsIntoOuterContext && s.configs.isExactConflict || this.treat_sllk1_conflict_as_ambiguity && input.index === startIndex) {
              } else {
                assert(!state.useContext);
                let conflictingAlts;
                let predicates2 = s.predicates;
                if (predicates2 != null) {
                  let conflictIndex = input.index;
                  if (conflictIndex !== startIndex) {
                    input.seek(startIndex);
                  }
                  conflictingAlts = this.evalSemanticContext(predicates2, outerContext, true);
                  if (conflictingAlts.cardinality() === 1) {
                    return conflictingAlts.nextSetBit(0);
                  }
                  if (conflictIndex !== startIndex) {
                    input.seek(conflictIndex);
                  }
                }
                if (this.reportAmbiguities) {
                  let conflictState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
                  this.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, input.index);
                }
                input.seek(startIndex);
                return this.adaptivePredict(input, dfa.decision, outerContext, true);
              }
            }
          }
          let predicates = s.predicates;
          if (predicates != null) {
            let stopIndex = input.index;
            if (startIndex !== stopIndex) {
              input.seek(startIndex);
            }
            let alts = this.evalSemanticContext(predicates, outerContext, this.reportAmbiguities && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION);
            switch (alts.cardinality()) {
              case 0:
                throw this.noViableAlt(input, outerContext, s.configs, startIndex);
              case 1:
                return alts.nextSetBit(0);
              default:
                if (startIndex !== stopIndex) {
                  input.seek(stopIndex);
                }
                this.reportAmbiguity(dfa, s, startIndex, stopIndex, s.configs.isExactConflict, alts, s.configs);
                return alts.nextSetBit(0);
            }
          }
          if (ParserATNSimulator3.dfa_debug) {
            console.log("DFA decision " + dfa.decision + " predicts " + s.prediction);
          }
          return s.prediction;
        }
        /**
         * Determines if a particular DFA state should be treated as an accept state
         * for the current prediction mode. In addition to the `useContext`
         * parameter, the {@link #getPredictionMode()} method provides the
         * prediction mode controlling the prediction algorithm as a whole.
         *
         * The default implementation simply returns the value of
         * `DFAState.isAcceptState` except for conflict states when
         * `useContext` is `true` and {@link #getPredictionMode()} is
         * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}. In that case, only
         * conflict states where {@link ATNConfigSet#isExactConflict} is
         * `true` are considered accept states.
         *
         * @param state The DFA state to check.
         * @param useContext `true` if the prediction algorithm is currently
         * considering the full parser context; otherwise, `false` if the
         * algorithm is currently performing a local context prediction.
         *
         * @returns `true` if the specified `state` is an accept state;
         * otherwise, `false`.
         */
        isAcceptState(state, useContext) {
          if (!state.isAcceptState) {
            return false;
          }
          if (state.configs.conflictingAlts == null) {
            return true;
          }
          if (useContext && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION) {
            return state.configs.isExactConflict;
          }
          return true;
        }
        /** Performs ATN simulation to compute a predicted alternative based
         *  upon the remaining input, but also updates the DFA cache to avoid
         *  having to traverse the ATN again for the same input sequence.
         *
         * There are some key conditions we're looking for after computing a new
         * set of ATN configs (proposed DFA state):
         *
         * * if the set is empty, there is no viable alternative for current symbol
         * * does the state uniquely predict an alternative?
         * * does the state have a conflict that would prevent us from
         *   putting it on the work list?
         * * if in non-greedy decision is there a config at a rule stop state?
         *
         * We also have some key operations to do:
         *
         * * add an edge from previous DFA state to potentially new DFA state, D,
         *   upon current symbol but only if adding to work list, which means in all
         *   cases except no viable alternative (and possibly non-greedy decisions?)
         * * collecting predicates and adding semantic context to DFA accept states
         * * adding rule context to context-sensitive DFA accept states
         * * consuming an input symbol
         * * reporting a conflict
         * * reporting an ambiguity
         * * reporting a context sensitivity
         * * reporting insufficient predicates
         *
         * We should isolate those operations, which are side-effecting, to the
         * main work loop. We can isolate lots of code into other functions, but
         * they should be side effect free. They can return package that
         * indicates whether we should report something, whether we need to add a
         * DFA edge, whether we need to augment accept state with semantic
         * context or rule invocation context. Actually, it seems like we always
         * add predicates if they exist, so that can simply be done in the main
         * loop for any accept state creation or modification request.
         *
         * cover these cases:
         *   dead end
         *   single alt
         *   single alt + preds
         *   conflict
         *   conflict + preds
         *
         * TODO: greedy + those
         */
        execATN(dfa, input, startIndex, initialState) {
          if (ParserATNSimulator3.debug) {
            console.log("execATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input));
          }
          let outerContext = initialState.outerContext;
          let useContext = initialState.useContext;
          let t = input.LA(1);
          let previous = initialState;
          let contextCache = new PredictionContextCache_1.PredictionContextCache();
          while (true) {
            let nextState = this.computeReachSet(dfa, previous, t, contextCache);
            if (nextState == null) {
              this.setDFAEdge(previous.s0, input.LA(1), ATNSimulator_1.ATNSimulator.ERROR);
              return this.handleNoViableAlt(input, startIndex, previous);
            }
            let D = nextState.s0;
            assert(D.isAcceptState || D.prediction === ATN_1.ATN.INVALID_ALT_NUMBER);
            assert(D.isAcceptState || D.configs.conflictInfo == null);
            if (this.isAcceptState(D, useContext)) {
              let conflictingAlts = D.configs.conflictingAlts;
              let predictedAlt = conflictingAlts == null ? D.prediction : ATN_1.ATN.INVALID_ALT_NUMBER;
              if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                if (this.optimize_ll1 && input.index === startIndex && !dfa.isPrecedenceDfa && nextState.outerContext === nextState.remainingOuterContext && dfa.decision >= 0 && !D.configs.hasSemanticContext) {
                  if (t >= 0 && t <= MAX_SHORT_VALUE) {
                    let key = (dfa.decision << 16 >>> 0) + t;
                    this.atn.LL1Table.set(key, predictedAlt);
                  }
                }
                if (useContext && this.always_try_local_context) {
                  this.reportContextSensitivity(dfa, predictedAlt, nextState, startIndex, input.index);
                }
              }
              predictedAlt = D.prediction;
              let attemptFullContext = conflictingAlts != null && this.userWantsCtxSensitive;
              if (attemptFullContext) {
                attemptFullContext = !useContext && (D.configs.dipsIntoOuterContext || !D.configs.isExactConflict) && (!this.treat_sllk1_conflict_as_ambiguity || input.index !== startIndex);
              }
              if (D.configs.hasSemanticContext) {
                let predPredictions = D.predicates;
                if (predPredictions != null) {
                  let conflictIndex = input.index;
                  if (conflictIndex !== startIndex) {
                    input.seek(startIndex);
                  }
                  conflictingAlts = this.evalSemanticContext(predPredictions, outerContext, attemptFullContext || this.reportAmbiguities);
                  switch (conflictingAlts.cardinality()) {
                    case 0:
                      throw this.noViableAlt(input, outerContext, D.configs, startIndex);
                    case 1:
                      return conflictingAlts.nextSetBit(0);
                    default:
                      break;
                  }
                  if (conflictIndex !== startIndex) {
                    input.seek(conflictIndex);
                  }
                }
              }
              if (!attemptFullContext) {
                if (conflictingAlts != null) {
                  if (this.reportAmbiguities && conflictingAlts.cardinality() > 1) {
                    this.reportAmbiguity(dfa, D, startIndex, input.index, D.configs.isExactConflict, conflictingAlts, D.configs);
                  }
                  predictedAlt = conflictingAlts.nextSetBit(0);
                }
                return predictedAlt;
              } else {
                assert(!useContext);
                assert(this.isAcceptState(D, false));
                if (ParserATNSimulator3.debug) {
                  console.log("RETRY with outerContext=" + outerContext);
                }
                let fullContextState = this.computeStartState(dfa, outerContext, true);
                if (this.reportAmbiguities) {
                  this.reportAttemptingFullContext(dfa, conflictingAlts, nextState, startIndex, input.index);
                }
                input.seek(startIndex);
                return this.execATN(dfa, input, startIndex, fullContextState);
              }
            }
            previous = nextState;
            if (t !== IntStream_1.IntStream.EOF) {
              input.consume();
              t = input.LA(1);
            }
          }
        }
        /**
         * This method is used to improve the localization of error messages by
         * choosing an alternative rather than throwing a
         * {@link NoViableAltException} in particular prediction scenarios where the
         * {@link #ERROR} state was reached during ATN simulation.
         *
         * The default implementation of this method uses the following
         * algorithm to identify an ATN configuration which successfully parsed the
         * decision entry rule. Choosing such an alternative ensures that the
         * {@link ParserRuleContext} returned by the calling rule will be complete
         * and valid, and the syntax error will be reported later at a more
         * localized location.
         *
         * * If no configuration in `configs` reached the end of the
         *   decision rule, return {@link ATN#INVALID_ALT_NUMBER}.
         * * If all configurations in `configs` which reached the end of the
         *   decision rule predict the same alternative, return that alternative.
         * * If the configurations in `configs` which reached the end of the
         *   decision rule predict multiple alternatives (call this *S*),
         *   choose an alternative in the following order.
         *
         *     1. Filter the configurations in `configs` to only those
         *        configurations which remain viable after evaluating semantic predicates.
         *        If the set of these filtered configurations which also reached the end of
         *        the decision rule is not empty, return the minimum alternative
         *        represented in this set.
         *     1. Otherwise, choose the minimum alternative in *S*.
         *
         * In some scenarios, the algorithm described above could predict an
         * alternative which will result in a {@link FailedPredicateException} in
         * parser. Specifically, this could occur if the *only* configuration
         * capable of successfully parsing to the end of the decision rule is
         * blocked by a semantic predicate. By choosing this alternative within
         * {@link #adaptivePredict} instead of throwing a
         * {@link NoViableAltException}, the resulting
         * {@link FailedPredicateException} in the parser will identify the specific
         * predicate which is preventing the parser from successfully parsing the
         * decision rule, which helps developers identify and correct logic errors
         * in semantic predicates.
         *
         * @param input The input {@link TokenStream}
         * @param startIndex The start index for the current prediction, which is
         * the input index where any semantic context in `configs` should be
         * evaluated
         * @param previous The ATN simulation state immediately before the
         * {@link #ERROR} state was reached
         *
         * @returns The value to return from {@link #adaptivePredict}, or
         * {@link ATN#INVALID_ALT_NUMBER} if a suitable alternative was not
         * identified and {@link #adaptivePredict} should report an error instead.
         */
        handleNoViableAlt(input, startIndex, previous) {
          if (previous.s0 != null) {
            let alts = new BitSet_1.BitSet();
            let maxAlt = 0;
            for (let config of previous.s0.configs) {
              if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {
                alts.set(config.alt);
                maxAlt = Math.max(maxAlt, config.alt);
              }
            }
            switch (alts.cardinality()) {
              case 0:
                break;
              case 1:
                return alts.nextSetBit(0);
              default:
                if (!previous.s0.configs.hasSemanticContext) {
                  return alts.nextSetBit(0);
                }
                let filteredConfigs = new ATNConfigSet_1.ATNConfigSet();
                for (let config of previous.s0.configs) {
                  if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {
                    filteredConfigs.add(config);
                  }
                }
                let altToPred = this.getPredsForAmbigAlts(alts, filteredConfigs, maxAlt);
                if (altToPred != null) {
                  let predicates = this.getPredicatePredictions(alts, altToPred);
                  if (predicates != null) {
                    let stopIndex = input.index;
                    try {
                      input.seek(startIndex);
                      let filteredAlts = this.evalSemanticContext(predicates, previous.outerContext, false);
                      if (!filteredAlts.isEmpty) {
                        return filteredAlts.nextSetBit(0);
                      }
                    } finally {
                      input.seek(stopIndex);
                    }
                  }
                }
                return alts.nextSetBit(0);
            }
          }
          throw this.noViableAlt(input, previous.outerContext, previous.s0.configs, startIndex);
        }
        computeReachSet(dfa, previous, t, contextCache) {
          let useContext = previous.useContext;
          let remainingGlobalContext = previous.remainingOuterContext;
          let s = previous.s0;
          if (useContext) {
            while (s.isContextSymbol(t)) {
              let next;
              if (remainingGlobalContext != null) {
                remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
                next = s.getContextTarget(this.getReturnState(remainingGlobalContext));
              }
              if (next == null) {
                break;
              }
              assert(remainingGlobalContext != null);
              remainingGlobalContext = remainingGlobalContext.parent;
              s = next;
            }
          }
          assert(!this.isAcceptState(s, useContext));
          if (this.isAcceptState(s, useContext)) {
            return new SimulatorState_1.SimulatorState(previous.outerContext, s, useContext, remainingGlobalContext);
          }
          let s0 = s;
          let target = this.getExistingTargetState(s0, t);
          if (target == null) {
            let result = this.computeTargetState(dfa, s0, remainingGlobalContext, t, useContext, contextCache);
            target = result[0];
            remainingGlobalContext = result[1];
          }
          if (target === ATNSimulator_1.ATNSimulator.ERROR) {
            return void 0;
          }
          assert(!useContext || !target.configs.dipsIntoOuterContext);
          return new SimulatorState_1.SimulatorState(previous.outerContext, target, useContext, remainingGlobalContext);
        }
        /**
         * Get an existing target state for an edge in the DFA. If the target state
         * for the edge has not yet been computed or is otherwise not available,
         * this method returns `undefined`.
         *
         * @param s The current DFA state
         * @param t The next input symbol
         * @returns The existing target DFA state for the given input symbol
         * `t`, or `undefined` if the target state for this edge is not
         * already cached
         */
        getExistingTargetState(s, t) {
          return s.getTarget(t);
        }
        /**
         * Compute a target state for an edge in the DFA, and attempt to add the
         * computed state and corresponding edge to the DFA.
         *
         * @param dfa
         * @param s The current DFA state
         * @param remainingGlobalContext
         * @param t The next input symbol
         * @param useContext
         * @param contextCache
         *
         * @returns The computed target DFA state for the given input symbol
         * `t`. If `t` does not lead to a valid DFA state, this method
         * returns {@link #ERROR}.
         */
        computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
          let closureConfigs = s.configs.toArray();
          let contextElements;
          let reach = new ATNConfigSet_1.ATNConfigSet();
          let stepIntoGlobal;
          do {
            let hasMoreContext = !useContext || remainingGlobalContext != null;
            if (!hasMoreContext) {
              reach.isOutermostConfigSet = true;
            }
            let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
            let skippedStopStates;
            for (let c of closureConfigs) {
              if (ParserATNSimulator3.debug) {
                console.log("testing " + this.getTokenName(t) + " at " + c.toString());
              }
              if (c.state instanceof RuleStopState_1.RuleStopState) {
                assert(c.context.isEmpty);
                if (useContext && !c.reachesIntoOuterContext || t === IntStream_1.IntStream.EOF) {
                  if (skippedStopStates == null) {
                    skippedStopStates = [];
                  }
                  skippedStopStates.push(c);
                }
                continue;
              }
              let n = c.state.numberOfOptimizedTransitions;
              for (let ti = 0; ti < n; ti++) {
                let trans = c.state.getOptimizedTransition(ti);
                let target = this.getReachableTarget(c, trans, t);
                if (target != null) {
                  reachIntermediate.add(c.transform(target, false), contextCache);
                }
              }
            }
            if (this.optimize_unique_closure && skippedStopStates == null && t !== Token_1.Token.EOF && reachIntermediate.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              reachIntermediate.isOutermostConfigSet = reach.isOutermostConfigSet;
              reach = reachIntermediate;
              break;
            }
            let collectPredicates = false;
            let treatEofAsEpsilon = t === Token_1.Token.EOF;
            this.closure(reachIntermediate, reach, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon);
            stepIntoGlobal = reach.dipsIntoOuterContext;
            if (t === IntStream_1.IntStream.EOF) {
              reach = this.removeAllConfigsNotInRuleStopState(reach, contextCache);
            }
            if (skippedStopStates != null && (!useContext || !PredictionMode_1.PredictionMode.hasConfigInRuleStopState(reach))) {
              assert(skippedStopStates.length > 0);
              for (let c of skippedStopStates) {
                reach.add(c, contextCache);
              }
            }
            if (useContext && stepIntoGlobal) {
              reach.clear();
              remainingGlobalContext = remainingGlobalContext;
              remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
              let nextContextElement = this.getReturnState(remainingGlobalContext);
              if (contextElements == null) {
                contextElements = new IntegerList_1.IntegerList();
              }
              if (remainingGlobalContext.isEmpty) {
                remainingGlobalContext = void 0;
              } else {
                remainingGlobalContext = remainingGlobalContext.parent;
              }
              contextElements.add(nextContextElement);
              if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                for (let i = 0; i < closureConfigs.length; i++) {
                  closureConfigs[i] = closureConfigs[i].appendContext(nextContextElement, contextCache);
                }
              }
            }
          } while (useContext && stepIntoGlobal);
          if (reach.isEmpty) {
            this.setDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
            return [ATNSimulator_1.ATNSimulator.ERROR, remainingGlobalContext];
          }
          let result = this.addDFAEdge(dfa, s, t, contextElements, reach, contextCache);
          return [result, remainingGlobalContext];
        }
        /**
         * Return a configuration set containing only the configurations from
         * `configs` which are in a {@link RuleStopState}. If all
         * configurations in `configs` are already in a rule stop state, this
         * method simply returns `configs`.
         *
         * @param configs the configuration set to update
         * @param contextCache the {@link PredictionContext} cache
         *
         * @returns `configs` if all configurations in `configs` are in a
         * rule stop state, otherwise return a new configuration set containing only
         * the configurations from `configs` which are in a rule stop state
         */
        removeAllConfigsNotInRuleStopState(configs, contextCache) {
          if (PredictionMode_1.PredictionMode.allConfigsInRuleStopStates(configs)) {
            return configs;
          }
          let result = new ATNConfigSet_1.ATNConfigSet();
          for (let config of configs) {
            if (!(config.state instanceof RuleStopState_1.RuleStopState)) {
              continue;
            }
            result.add(config, contextCache);
          }
          return result;
        }
        computeStartState(dfa, globalContext, useContext) {
          let s0 = dfa.isPrecedenceDfa ? dfa.getPrecedenceStartState(this._parser.precedence, useContext) : useContext ? dfa.s0full : dfa.s0;
          if (s0 != null) {
            if (!useContext) {
              return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, globalContext);
            }
            s0.setContextSensitive(this.atn);
          }
          let decision = dfa.decision;
          let p = dfa.atnStartState;
          let previousContext = 0;
          let remainingGlobalContext = globalContext;
          let initialContext = useContext ? PredictionContext_1.PredictionContext.EMPTY_FULL : PredictionContext_1.PredictionContext.EMPTY_LOCAL;
          let contextCache = new PredictionContextCache_1.PredictionContextCache();
          if (useContext) {
            if (!this.enable_global_context_dfa) {
              while (remainingGlobalContext != null) {
                if (remainingGlobalContext.isEmpty) {
                  previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
                  remainingGlobalContext = void 0;
                } else {
                  previousContext = this.getReturnState(remainingGlobalContext);
                  initialContext = initialContext.appendSingleContext(previousContext, contextCache);
                  remainingGlobalContext = remainingGlobalContext.parent;
                }
              }
            }
            while (s0 != null && s0.isContextSensitive && remainingGlobalContext != null) {
              let next;
              remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
              if (remainingGlobalContext.isEmpty) {
                next = s0.getContextTarget(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY);
                previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
                remainingGlobalContext = void 0;
              } else {
                previousContext = this.getReturnState(remainingGlobalContext);
                next = s0.getContextTarget(previousContext);
                initialContext = initialContext.appendSingleContext(previousContext, contextCache);
                remainingGlobalContext = remainingGlobalContext.parent;
              }
              if (next == null) {
                break;
              }
              s0 = next;
            }
          }
          if (s0 != null && !s0.isContextSensitive) {
            return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
          }
          let configs = new ATNConfigSet_1.ATNConfigSet();
          while (true) {
            let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
            let n = p.numberOfTransitions;
            for (let ti = 0; ti < n; ti++) {
              let target = p.transition(ti).target;
              reachIntermediate.add(ATNConfig_1.ATNConfig.create(target, ti + 1, initialContext));
            }
            let hasMoreContext = remainingGlobalContext != null;
            if (!hasMoreContext) {
              configs.isOutermostConfigSet = true;
            }
            let collectPredicates = true;
            this.closure(reachIntermediate, configs, collectPredicates, hasMoreContext, contextCache, false);
            let stepIntoGlobal = configs.dipsIntoOuterContext;
            let next;
            if (useContext && !this.enable_global_context_dfa) {
              s0 = this.addDFAState(dfa, configs, contextCache);
              break;
            } else if (s0 == null) {
              if (!dfa.isPrecedenceDfa) {
                next = this.addDFAState(dfa, configs, contextCache);
                if (useContext) {
                  if (!dfa.s0full) {
                    dfa.s0full = next;
                  } else {
                    next = dfa.s0full;
                  }
                } else {
                  if (!dfa.s0) {
                    dfa.s0 = next;
                  } else {
                    next = dfa.s0;
                  }
                }
              } else {
                configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
                next = this.addDFAState(dfa, configs, contextCache);
                dfa.setPrecedenceStartState(this._parser.precedence, useContext, next);
              }
            } else {
              if (dfa.isPrecedenceDfa) {
                configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
              }
              next = this.addDFAState(dfa, configs, contextCache);
              s0.setContextTarget(previousContext, next);
            }
            s0 = next;
            if (!useContext || !stepIntoGlobal) {
              break;
            }
            next.setContextSensitive(this.atn);
            remainingGlobalContext = remainingGlobalContext;
            configs.clear();
            remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
            let nextContextElement = this.getReturnState(remainingGlobalContext);
            if (remainingGlobalContext.isEmpty) {
              remainingGlobalContext = void 0;
            } else {
              remainingGlobalContext = remainingGlobalContext.parent;
            }
            if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              initialContext = initialContext.appendSingleContext(nextContextElement, contextCache);
            }
            previousContext = nextContextElement;
          }
          return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
        }
        /**
         * This method transforms the start state computed by
         * {@link #computeStartState} to the special start state used by a
         * precedence DFA for a particular precedence value. The transformation
         * process applies the following changes to the start state's configuration
         * set.
         *
         * 1. Evaluate the precedence predicates for each configuration using
         *    {@link SemanticContext#evalPrecedence}.
         * 1. When {@link ATNConfig#isPrecedenceFilterSuppressed} is `false`,
         *    remove all configurations which predict an alternative greater than 1,
         *    for which another configuration that predicts alternative 1 is in the
         *    same ATN state with the same prediction context. This transformation is
         *    valid for the following reasons:
         *
         *     * The closure block cannot contain any epsilon transitions which bypass
         *       the body of the closure, so all states reachable via alternative 1 are
         *       part of the precedence alternatives of the transformed left-recursive
         *       rule.
         *     * The "primary" portion of a left recursive rule cannot contain an
         *       epsilon transition, so the only way an alternative other than 1 can exist
         *       in a state that is also reachable via alternative 1 is by nesting calls
         *       to the left-recursive rule, with the outer calls not being at the
         *       preferred precedence level. The
         *       {@link ATNConfig#isPrecedenceFilterSuppressed} property marks ATN
         *       configurations which do not meet this condition, and therefore are not
         *       eligible for elimination during the filtering process.
         *
         * The prediction context must be considered by this filter to address
         * situations like the following.
         *
         * ```antlr
         * grammar TA;
         * prog: statement* EOF;
         * statement: letterA | statement letterA 'b' ;
         * letterA: 'a';
         * ```
         *
         * If the above grammar, the ATN state immediately before the token
         * reference `'a'` in `letterA` is reachable from the left edge
         * of both the primary and closure blocks of the left-recursive rule
         * `statement`. The prediction context associated with each of these
         * configurations distinguishes between them, and prevents the alternative
         * which stepped out to `prog` (and then back in to `statement`
         * from being eliminated by the filter.
         *
         * @param configs The configuration set computed by
         * {@link #computeStartState} as the start state for the DFA.
         * @returns The transformed configuration set representing the start state
         * for a precedence DFA at a particular precedence level (determined by
         * calling {@link Parser#getPrecedence}).
         */
        applyPrecedenceFilter(configs, globalContext, contextCache) {
          let statesFromAlt1 = /* @__PURE__ */ new Map();
          let configSet = new ATNConfigSet_1.ATNConfigSet();
          for (let config of configs) {
            if (config.alt !== 1) {
              continue;
            }
            let updatedContext = config.semanticContext.evalPrecedence(this._parser, globalContext);
            if (updatedContext == null) {
              continue;
            }
            statesFromAlt1.set(config.state.stateNumber, config.context);
            if (updatedContext !== config.semanticContext) {
              configSet.add(config.transform(config.state, false, updatedContext), contextCache);
            } else {
              configSet.add(config, contextCache);
            }
          }
          for (let config of configs) {
            if (config.alt === 1) {
              continue;
            }
            if (!config.isPrecedenceFilterSuppressed) {
              let context = statesFromAlt1.get(config.state.stateNumber);
              if (context != null && context.equals(config.context)) {
                continue;
              }
            }
            configSet.add(config, contextCache);
          }
          return configSet;
        }
        getReachableTarget(source, trans, ttype) {
          if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
            return trans.target;
          }
          return void 0;
        }
        /** collect and set D's semantic context */
        predicateDFAState(D, configs, nalts) {
          let conflictingAlts = this.getConflictingAltsFromConfigSet(configs);
          if (!conflictingAlts) {
            throw new Error("This unhandled scenario is intended to be unreachable, but I'm currently not sure of why we know that's the case.");
          }
          if (ParserATNSimulator3.debug) {
            console.log("predicateDFAState " + D);
          }
          let altToPred = this.getPredsForAmbigAlts(conflictingAlts, configs, nalts);
          let predPredictions;
          if (altToPred != null) {
            predPredictions = this.getPredicatePredictions(conflictingAlts, altToPred);
            D.predicates = predPredictions;
          }
          return predPredictions;
        }
        getPredsForAmbigAlts(ambigAlts, configs, nalts) {
          let altToPred = new Array(nalts + 1);
          let n = altToPred.length;
          for (let c of configs) {
            if (ambigAlts.get(c.alt)) {
              altToPred[c.alt] = SemanticContext_1.SemanticContext.or(altToPred[c.alt], c.semanticContext);
            }
          }
          let nPredAlts = 0;
          for (let i = 0; i < n; i++) {
            if (altToPred[i] == null) {
              altToPred[i] = SemanticContext_1.SemanticContext.NONE;
            } else if (altToPred[i] !== SemanticContext_1.SemanticContext.NONE) {
              nPredAlts++;
            }
          }
          let result = altToPred;
          if (nPredAlts === 0) {
            result = void 0;
          }
          if (ParserATNSimulator3.debug) {
            console.log("getPredsForAmbigAlts result " + (result ? Arrays_1.Arrays.toString(result) : "undefined"));
          }
          return result;
        }
        getPredicatePredictions(ambigAlts, altToPred) {
          let pairs = [];
          let containsPredicate = false;
          for (let i = 1; i < altToPred.length; i++) {
            let pred = altToPred[i];
            assert(pred != null);
            if (ambigAlts != null && ambigAlts.get(i) && pred === SemanticContext_1.SemanticContext.NONE) {
              pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));
            } else if (pred !== SemanticContext_1.SemanticContext.NONE) {
              containsPredicate = true;
              pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));
            }
          }
          if (!containsPredicate) {
            return void 0;
          }
          return pairs;
        }
        /** Look through a list of predicate/alt pairs, returning alts for the
         *  pairs that win. An `undefined` predicate indicates an alt containing an
         *  unpredicated config which behaves as "always true."
         */
        evalSemanticContext(predPredictions, outerContext, complete) {
          let predictions = new BitSet_1.BitSet();
          for (let pair of predPredictions) {
            if (pair.pred === SemanticContext_1.SemanticContext.NONE) {
              predictions.set(pair.alt);
              if (!complete) {
                break;
              }
              continue;
            }
            let evaluatedResult = this.evalSemanticContextImpl(pair.pred, outerContext, pair.alt);
            if (ParserATNSimulator3.debug || ParserATNSimulator3.dfa_debug) {
              console.log("eval pred " + pair + "=" + evaluatedResult);
            }
            if (evaluatedResult) {
              if (ParserATNSimulator3.debug || ParserATNSimulator3.dfa_debug) {
                console.log("PREDICT " + pair.alt);
              }
              predictions.set(pair.alt);
              if (!complete) {
                break;
              }
            }
          }
          return predictions;
        }
        /**
         * Evaluate a semantic context within a specific parser context.
         *
         * This method might not be called for every semantic context evaluated
         * during the prediction process. In particular, we currently do not
         * evaluate the following but it may change in the future:
         *
         * * Precedence predicates (represented by
         *   {@link SemanticContext.PrecedencePredicate}) are not currently evaluated
         *   through this method.
         * * Operator predicates (represented by {@link SemanticContext.AND} and
         *   {@link SemanticContext.OR}) are evaluated as a single semantic
         *   context, rather than evaluating the operands individually.
         *   Implementations which require evaluation results from individual
         *   predicates should override this method to explicitly handle evaluation of
         *   the operands within operator predicates.
         *
         * @param pred The semantic context to evaluate
         * @param parserCallStack The parser context in which to evaluate the
         * semantic context
         * @param alt The alternative which is guarded by `pred`
         *
         * @since 4.3
         */
        evalSemanticContextImpl(pred, parserCallStack, alt) {
          return pred.eval(this._parser, parserCallStack);
        }
        /* TODO: If we are doing predicates, there is no point in pursuing
             closure operations if we reach a DFA state that uniquely predicts
             alternative. We will not be caching that DFA state and it is a
             waste to pursue the closure. Might have to advance when we do
             ambig detection thought :(
              */
        closure(sourceConfigs, configs, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon) {
          if (contextCache == null) {
            contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
          }
          let currentConfigs = sourceConfigs;
          let closureBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          while (currentConfigs.size > 0) {
            let intermediate = new ATNConfigSet_1.ATNConfigSet();
            for (let config of currentConfigs) {
              this.closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContext, contextCache, 0, treatEofAsEpsilon);
            }
            currentConfigs = intermediate;
          }
        }
        closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth, treatEofAsEpsilon) {
          if (ParserATNSimulator3.debug) {
            console.log("closure(" + config.toString(this._parser, true) + ")");
          }
          if (config.state instanceof RuleStopState_1.RuleStopState) {
            if (!config.context.isEmpty) {
              let hasEmpty = config.context.hasEmpty;
              let nonEmptySize = config.context.size - (hasEmpty ? 1 : 0);
              for (let i = 0; i < nonEmptySize; i++) {
                let newContext = config.context.getParent(i);
                let returnState = this.atn.states[config.context.getReturnState(i)];
                let c = ATNConfig_1.ATNConfig.create(returnState, config.alt, newContext, config.semanticContext);
                c.outerContextDepth = config.outerContextDepth;
                c.isPrecedenceFilterSuppressed = config.isPrecedenceFilterSuppressed;
                assert(depth > MIN_INTEGER_VALUE);
                this.closureImpl(c, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth - 1, treatEofAsEpsilon);
              }
              if (!hasEmpty || !hasMoreContexts) {
                return;
              }
              config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
            } else if (!hasMoreContexts) {
              configs.add(config, contextCache);
              return;
            } else {
              if (ParserATNSimulator3.debug) {
                console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
              }
              if (config.context === PredictionContext_1.PredictionContext.EMPTY_FULL) {
                config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
              } else if (!config.reachesIntoOuterContext && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {
                configs.add(config, contextCache);
              }
            }
          }
          let p = config.state;
          if (!p.onlyHasEpsilonTransitions) {
            configs.add(config, contextCache);
            if (ParserATNSimulator3.debug) {
              console.log("added config " + configs);
            }
          }
          for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {
            if (i === 0 && p.stateType === ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY && p.precedenceRuleDecision && !config.context.hasEmpty) {
              let precedenceDecision = p;
              let suppress = true;
              for (let j = 0; j < config.context.size; j++) {
                if (!precedenceDecision.precedenceLoopbackStates.get(config.context.getReturnState(j))) {
                  suppress = false;
                  break;
                }
              }
              if (suppress) {
                continue;
              }
            }
            let t = p.getOptimizedTransition(i);
            let continueCollecting = !(t instanceof ActionTransition_1.ActionTransition) && collectPredicates;
            let c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, contextCache, treatEofAsEpsilon);
            if (c != null) {
              if (t instanceof RuleTransition_1.RuleTransition) {
                if (intermediate != null && !collectPredicates) {
                  intermediate.add(c, contextCache);
                  continue;
                }
              }
              let newDepth = depth;
              if (config.state instanceof RuleStopState_1.RuleStopState) {
                if (this.dfa != null && this.dfa.isPrecedenceDfa) {
                  let outermostPrecedenceReturn = t.outermostPrecedenceReturn;
                  if (outermostPrecedenceReturn === this.dfa.atnStartState.ruleIndex) {
                    c.isPrecedenceFilterSuppressed = true;
                  }
                }
                c.outerContextDepth = c.outerContextDepth + 1;
                if (!closureBusy.add(c)) {
                  continue;
                }
                assert(newDepth > MIN_INTEGER_VALUE);
                newDepth--;
                if (ParserATNSimulator3.debug) {
                  console.log("dips into outer ctx: " + c);
                }
              } else if (t instanceof RuleTransition_1.RuleTransition) {
                if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {
                  assert(c.context === config.context);
                  if (newDepth === 0) {
                    newDepth--;
                    if (!this.tail_call_preserves_sll && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {
                      c.outerContextDepth = c.outerContextDepth + 1;
                    }
                  }
                } else {
                  if (newDepth >= 0) {
                    newDepth++;
                  }
                }
              } else {
                if (!t.isEpsilon && !closureBusy.add(c)) {
                  continue;
                }
              }
              this.closureImpl(c, configs, intermediate, closureBusy, continueCollecting, hasMoreContexts, contextCache, newDepth, treatEofAsEpsilon);
            }
          }
        }
        getRuleName(index) {
          if (this._parser != null && index >= 0) {
            return this._parser.ruleNames[index];
          }
          return "<rule " + index + ">";
        }
        getEpsilonTarget(config, t, collectPredicates, inContext, contextCache, treatEofAsEpsilon) {
          switch (t.serializationType) {
            case 3:
              return this.ruleTransition(config, t, contextCache);
            case 10:
              return this.precedenceTransition(config, t, collectPredicates, inContext);
            case 4:
              return this.predTransition(config, t, collectPredicates, inContext);
            case 6:
              return this.actionTransition(config, t);
            case 1:
              return config.transform(t.target, false);
            case 5:
            case 2:
            case 7:
              if (treatEofAsEpsilon) {
                if (t.matches(Token_1.Token.EOF, 0, 1)) {
                  return config.transform(t.target, false);
                }
              }
              return void 0;
            default:
              return void 0;
          }
        }
        actionTransition(config, t) {
          if (ParserATNSimulator3.debug) {
            console.log("ACTION edge " + t.ruleIndex + ":" + t.actionIndex);
          }
          return config.transform(t.target, false);
        }
        precedenceTransition(config, pt, collectPredicates, inContext) {
          if (ParserATNSimulator3.debug) {
            console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.precedence + ">=_p, ctx dependent=true");
            if (this._parser != null) {
              console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
            }
          }
          let c;
          if (collectPredicates && inContext) {
            let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);
            c = config.transform(pt.target, false, newSemCtx);
          } else {
            c = config.transform(pt.target, false);
          }
          if (ParserATNSimulator3.debug) {
            console.log("config from pred transition=" + c);
          }
          return c;
        }
        predTransition(config, pt, collectPredicates, inContext) {
          if (ParserATNSimulator3.debug) {
            console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex + ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
            if (this._parser != null) {
              console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
            }
          }
          let c;
          if (collectPredicates && (!pt.isCtxDependent || pt.isCtxDependent && inContext)) {
            let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);
            c = config.transform(pt.target, false, newSemCtx);
          } else {
            c = config.transform(pt.target, false);
          }
          if (ParserATNSimulator3.debug) {
            console.log("config from pred transition=" + c);
          }
          return c;
        }
        ruleTransition(config, t, contextCache) {
          if (ParserATNSimulator3.debug) {
            console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
          }
          let returnState = t.followState;
          let newContext;
          if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {
            newContext = config.context;
          } else if (contextCache != null) {
            newContext = contextCache.getChild(config.context, returnState.stateNumber);
          } else {
            newContext = config.context.getChild(returnState.stateNumber);
          }
          return config.transform(t.target, false, newContext);
        }
        isConflicted(configset, contextCache) {
          if (configset.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER || configset.size <= 1) {
            return void 0;
          }
          let configs = configset.toArray();
          configs.sort(ParserATNSimulator3.STATE_ALT_SORT_COMPARATOR);
          let exact = !configset.dipsIntoOuterContext;
          let alts = new BitSet_1.BitSet();
          let minAlt = configs[0].alt;
          alts.set(minAlt);
          let currentState = configs[0].state.nonStopStateNumber;
          for (let config of configs) {
            let stateNumber = config.state.nonStopStateNumber;
            if (stateNumber !== currentState) {
              if (config.alt !== minAlt) {
                return void 0;
              }
              currentState = stateNumber;
            }
          }
          let representedAlts;
          if (exact) {
            currentState = configs[0].state.nonStopStateNumber;
            representedAlts = new BitSet_1.BitSet();
            let maxAlt = minAlt;
            for (let config of configs) {
              if (config.state.nonStopStateNumber !== currentState) {
                break;
              }
              let alt = config.alt;
              representedAlts.set(alt);
              maxAlt = alt;
            }
            currentState = configs[0].state.nonStopStateNumber;
            let currentAlt = minAlt;
            for (let config of configs) {
              let stateNumber = config.state.nonStopStateNumber;
              let alt = config.alt;
              if (stateNumber !== currentState) {
                if (currentAlt !== maxAlt) {
                  exact = false;
                  break;
                }
                currentState = stateNumber;
                currentAlt = minAlt;
              } else if (alt !== currentAlt) {
                if (alt !== representedAlts.nextSetBit(currentAlt + 1)) {
                  exact = false;
                  break;
                }
                currentAlt = alt;
              }
            }
          }
          currentState = configs[0].state.nonStopStateNumber;
          let firstIndexCurrentState = 0;
          let lastIndexCurrentStateMinAlt = 0;
          let joinedCheckContext = configs[0].context;
          for (let i = 1; i < configs.length; i++) {
            let config = configs[i];
            if (config.alt !== minAlt) {
              break;
            }
            if (config.state.nonStopStateNumber !== currentState) {
              break;
            }
            lastIndexCurrentStateMinAlt = i;
            joinedCheckContext = contextCache.join(joinedCheckContext, configs[i].context);
          }
          for (let i = lastIndexCurrentStateMinAlt + 1; i < configs.length; i++) {
            let config = configs[i];
            let state = config.state;
            alts.set(config.alt);
            if (state.nonStopStateNumber !== currentState) {
              currentState = state.nonStopStateNumber;
              firstIndexCurrentState = i;
              lastIndexCurrentStateMinAlt = i;
              joinedCheckContext = config.context;
              for (let j = firstIndexCurrentState + 1; j < configs.length; j++) {
                let config2 = configs[j];
                if (config2.alt !== minAlt) {
                  break;
                }
                if (config2.state.nonStopStateNumber !== currentState) {
                  break;
                }
                lastIndexCurrentStateMinAlt = j;
                joinedCheckContext = contextCache.join(joinedCheckContext, config2.context);
              }
              i = lastIndexCurrentStateMinAlt;
              continue;
            }
            let joinedCheckContext2 = config.context;
            let currentAlt = config.alt;
            let lastIndexCurrentStateCurrentAlt = i;
            for (let j = lastIndexCurrentStateCurrentAlt + 1; j < configs.length; j++) {
              let config2 = configs[j];
              if (config2.alt !== currentAlt) {
                break;
              }
              if (config2.state.nonStopStateNumber !== currentState) {
                break;
              }
              lastIndexCurrentStateCurrentAlt = j;
              joinedCheckContext2 = contextCache.join(joinedCheckContext2, config2.context);
            }
            i = lastIndexCurrentStateCurrentAlt;
            let check = contextCache.join(joinedCheckContext, joinedCheckContext2);
            if (!joinedCheckContext.equals(check)) {
              return void 0;
            }
            exact = exact && joinedCheckContext.equals(joinedCheckContext2);
          }
          return new ConflictInfo_1.ConflictInfo(alts, exact);
        }
        getConflictingAltsFromConfigSet(configs) {
          let conflictingAlts = configs.conflictingAlts;
          if (conflictingAlts == null && configs.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            conflictingAlts = new BitSet_1.BitSet();
            conflictingAlts.set(configs.uniqueAlt);
          }
          return conflictingAlts;
        }
        getTokenName(t) {
          if (t === Token_1.Token.EOF) {
            return "EOF";
          }
          let vocabulary = this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
          let displayName = vocabulary.getDisplayName(t);
          if (displayName === String(t)) {
            return displayName;
          }
          return displayName + "<" + t + ">";
        }
        getLookaheadName(input) {
          return this.getTokenName(input.LA(1));
        }
        dumpDeadEndConfigs(nvae) {
          console.log("dead end configs: ");
          let deadEndConfigs = nvae.deadEndConfigs;
          if (!deadEndConfigs) {
            return;
          }
          for (let c of deadEndConfigs) {
            let trans = "no edges";
            if (c.state.numberOfOptimizedTransitions > 0) {
              let t = c.state.getOptimizedTransition(0);
              if (t instanceof AtomTransition_1.AtomTransition) {
                trans = "Atom " + this.getTokenName(t._label);
              } else if (t instanceof SetTransition_1.SetTransition) {
                let not2 = t instanceof NotSetTransition_1.NotSetTransition;
                trans = (not2 ? "~" : "") + "Set " + t.set.toString();
              }
            }
            console.log(c.toString(this._parser, true) + ":" + trans);
          }
        }
        noViableAlt(input, outerContext, configs, startIndex) {
          return new NoViableAltException_1.NoViableAltException(this._parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
        }
        getUniqueAlt(configs) {
          let alt = ATN_1.ATN.INVALID_ALT_NUMBER;
          for (let c of configs) {
            if (alt === ATN_1.ATN.INVALID_ALT_NUMBER) {
              alt = c.alt;
            } else if (c.alt !== alt) {
              return ATN_1.ATN.INVALID_ALT_NUMBER;
            }
          }
          return alt;
        }
        configWithAltAtStopState(configs, alt) {
          for (let c of configs) {
            if (c.alt === alt) {
              if (c.state instanceof RuleStopState_1.RuleStopState) {
                return true;
              }
            }
          }
          return false;
        }
        addDFAEdge(dfa, fromState, t, contextTransitions, toConfigs, contextCache) {
          assert(contextTransitions == null || contextTransitions.isEmpty || dfa.isContextSensitive);
          let from = fromState;
          let to = this.addDFAState(dfa, toConfigs, contextCache);
          if (contextTransitions != null) {
            for (let context of contextTransitions.toArray()) {
              if (context === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                if (from.configs.isOutermostConfigSet) {
                  continue;
                }
              }
              from.setContextSensitive(this.atn);
              from.setContextSymbol(t);
              let next = from.getContextTarget(context);
              if (next != null) {
                from = next;
                continue;
              }
              next = this.addDFAContextState(dfa, from.configs, context, contextCache);
              assert(context !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY || next.configs.isOutermostConfigSet);
              from.setContextTarget(context, next);
              from = next;
            }
          }
          if (ParserATNSimulator3.debug) {
            console.log("EDGE " + from + " -> " + to + " upon " + this.getTokenName(t));
          }
          this.setDFAEdge(from, t, to);
          if (ParserATNSimulator3.debug) {
            console.log("DFA=\n" + dfa.toString(this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY, this._parser != null ? this._parser.ruleNames : void 0));
          }
          return to;
        }
        setDFAEdge(p, t, q) {
          if (p != null) {
            p.setTarget(t, q);
          }
        }
        /** See comment on LexerInterpreter.addDFAState. */
        addDFAContextState(dfa, configs, returnContext, contextCache) {
          if (returnContext !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            let contextConfigs = new ATNConfigSet_1.ATNConfigSet();
            for (let config of configs) {
              contextConfigs.add(config.appendContext(returnContext, contextCache));
            }
            return this.addDFAState(dfa, contextConfigs, contextCache);
          } else {
            assert(!configs.isOutermostConfigSet, "Shouldn't be adding a duplicate edge.");
            configs = configs.clone(true);
            configs.isOutermostConfigSet = true;
            return this.addDFAState(dfa, configs, contextCache);
          }
        }
        /** See comment on LexerInterpreter.addDFAState. */
        addDFAState(dfa, configs, contextCache) {
          let enableDfa = this.enable_global_context_dfa || !configs.isOutermostConfigSet;
          if (enableDfa) {
            if (!configs.isReadOnly) {
              configs.optimizeConfigs(this);
            }
            let proposed = this.createDFAState(dfa, configs);
            let existing = dfa.states.get(proposed);
            if (existing != null) {
              return existing;
            }
          }
          if (!configs.isReadOnly) {
            if (configs.conflictInfo == null) {
              configs.conflictInfo = this.isConflicted(configs, contextCache);
            }
          }
          let newState = this.createDFAState(dfa, configs.clone(true));
          let decisionState = this.atn.getDecisionState(dfa.decision);
          let predictedAlt = this.getUniqueAlt(configs);
          if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(predictedAlt);
          } else if (configs.conflictingAlts != null) {
            let conflictingAlts = configs.conflictingAlts;
            if (conflictingAlts) {
              newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(conflictingAlts.nextSetBit(0));
            }
          }
          if (newState.isAcceptState && configs.hasSemanticContext) {
            this.predicateDFAState(newState, configs, decisionState.numberOfTransitions);
          }
          if (!enableDfa) {
            return newState;
          }
          let added = dfa.addState(newState);
          if (ParserATNSimulator3.debug && added === newState) {
            console.log("adding new DFA state: " + newState);
          }
          return added;
        }
        createDFAState(dfa, configs) {
          return new DFAState_1.DFAState(configs);
        }
        reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
          if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
            let interval = Interval_1.Interval.of(startIndex, stopIndex);
            console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + conflictState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
          }
          if (this._parser != null) {
            let listener = this._parser.getErrorListenerDispatch();
            if (listener.reportAttemptingFullContext) {
              listener.reportAttemptingFullContext(this._parser, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
            }
          }
        }
        reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
          if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
            let interval = Interval_1.Interval.of(startIndex, stopIndex);
            console.log("reportContextSensitivity decision=" + dfa.decision + ":" + acceptState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
          }
          if (this._parser != null) {
            let listener = this._parser.getErrorListenerDispatch();
            if (listener.reportContextSensitivity) {
              listener.reportContextSensitivity(this._parser, dfa, startIndex, stopIndex, prediction, acceptState);
            }
          }
        }
        /** If context sensitive parsing, we know it's ambiguity not conflict */
        reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
          if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
            let interval = Interval_1.Interval.of(startIndex, stopIndex);
            console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this._parser.inputStream.getText(interval));
          }
          if (this._parser != null) {
            let listener = this._parser.getErrorListenerDispatch();
            if (listener.reportAmbiguity) {
              listener.reportAmbiguity(this._parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
            }
          }
        }
        getReturnState(context) {
          if (context.isEmpty) {
            return PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
          }
          let state = this.atn.states[context.invokingState];
          let transition = state.transition(0);
          return transition.followState.stateNumber;
        }
        skipTailCalls(context) {
          if (!this.optimize_tail_calls) {
            return context;
          }
          while (!context.isEmpty) {
            let state = this.atn.states[context.invokingState];
            assert(
              state.numberOfTransitions === 1 && state.transition(0).serializationType === 3
              /* RULE */
            );
            let transition = state.transition(0);
            if (!transition.tailCall) {
              break;
            }
            context = context.parent;
          }
          return context;
        }
        /**
         * @since 4.3
         */
        get parser() {
          return this._parser;
        }
      };
      ParserATNSimulator2.debug = false;
      ParserATNSimulator2.dfa_debug = false;
      ParserATNSimulator2.retry_debug = false;
      ParserATNSimulator2.STATE_ALT_SORT_COMPARATOR = (o1, o2) => {
        let diff = o1.state.nonStopStateNumber - o2.state.nonStopStateNumber;
        if (diff !== 0) {
          return diff;
        }
        diff = o1.alt - o2.alt;
        if (diff !== 0) {
          return diff;
        }
        return 0;
      };
      __decorate([
        Decorators_1.NotNull
      ], ParserATNSimulator2.prototype, "predictionMode", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ParserATNSimulator2.prototype, "getPredictionMode", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "setPredictionMode", null);
      __decorate([
        Decorators_1.Override
      ], ParserATNSimulator2.prototype, "reset", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "adaptivePredict", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "getStartState", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(3, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "execDFA", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(3, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "execATN", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "handleNoViableAlt", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "getExistingTargetState", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "computeTargetState", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "removeAllConfigsNotInRuleStopState", null);
      __decorate([
        Decorators_1.NotNull
      ], ParserATNSimulator2.prototype, "computeStartState", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "applyPrecedenceFilter", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "getReachableTarget", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "getPredsForAmbigAlts", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "evalSemanticContext", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "evalSemanticContextImpl", null);
      __decorate([
        __param(1, Decorators_1.NotNull),
        __param(4, Decorators_1.Nullable)
      ], ParserATNSimulator2.prototype, "closure", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.Nullable),
        __param(3, Decorators_1.NotNull),
        __param(6, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "closureImpl", null);
      __decorate([
        Decorators_1.NotNull
      ], ParserATNSimulator2.prototype, "getRuleName", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "getEpsilonTarget", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "actionTransition", null);
      __decorate([
        Decorators_1.Nullable,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "precedenceTransition", null);
      __decorate([
        Decorators_1.Nullable,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "predTransition", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.Nullable)
      ], ParserATNSimulator2.prototype, "ruleTransition", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "isConflicted", null);
      __decorate([
        Decorators_1.NotNull
      ], ParserATNSimulator2.prototype, "getTokenName", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "dumpDeadEndConfigs", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "noViableAlt", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "getUniqueAlt", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "configWithAltAtStopState", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(4, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "addDFAEdge", null);
      __decorate([
        __param(0, Decorators_1.Nullable),
        __param(2, Decorators_1.Nullable)
      ], ParserATNSimulator2.prototype, "setDFAEdge", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "addDFAContextState", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "addDFAState", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "createDFAState", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "reportAttemptingFullContext", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "reportContextSensitivity", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(5, Decorators_1.NotNull),
        __param(6, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "reportAmbiguity", null);
      ParserATNSimulator2 = __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2);
      exports.ParserATNSimulator = ParserATNSimulator2;
    }
  });

  // node_modules/antlr4ts/atn/PlusBlockStartState.js
  var require_PlusBlockStartState = __commonJS({
    "node_modules/antlr4ts/atn/PlusBlockStartState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PlusBlockStartState = void 0;
      var ATNStateType_1 = require_ATNStateType();
      var BlockStartState_1 = require_BlockStartState();
      var Decorators_1 = require_Decorators();
      var PlusBlockStartState = class extends BlockStartState_1.BlockStartState {
        get stateType() {
          return ATNStateType_1.ATNStateType.PLUS_BLOCK_START;
        }
      };
      __decorate([
        Decorators_1.Override
      ], PlusBlockStartState.prototype, "stateType", null);
      exports.PlusBlockStartState = PlusBlockStartState;
    }
  });

  // node_modules/antlr4ts/atn/PlusLoopbackState.js
  var require_PlusLoopbackState = __commonJS({
    "node_modules/antlr4ts/atn/PlusLoopbackState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PlusLoopbackState = void 0;
      var ATNStateType_1 = require_ATNStateType();
      var DecisionState_1 = require_DecisionState();
      var Decorators_1 = require_Decorators();
      var PlusLoopbackState = class extends DecisionState_1.DecisionState {
        get stateType() {
          return ATNStateType_1.ATNStateType.PLUS_LOOP_BACK;
        }
      };
      __decorate([
        Decorators_1.Override
      ], PlusLoopbackState.prototype, "stateType", null);
      exports.PlusLoopbackState = PlusLoopbackState;
    }
  });

  // node_modules/antlr4ts/atn/PrecedencePredicateTransition.js
  var require_PrecedencePredicateTransition = __commonJS({
    "node_modules/antlr4ts/atn/PrecedencePredicateTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PrecedencePredicateTransition = void 0;
      var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
      var Decorators_1 = require_Decorators();
      var SemanticContext_1 = require_SemanticContext();
      var PrecedencePredicateTransition = class PrecedencePredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {
        constructor(target, precedence) {
          super(target);
          this.precedence = precedence;
        }
        get serializationType() {
          return 10;
        }
        get isEpsilon() {
          return true;
        }
        matches(symbol, minVocabSymbol, maxVocabSymbol) {
          return false;
        }
        get predicate() {
          return new SemanticContext_1.SemanticContext.PrecedencePredicate(this.precedence);
        }
        toString() {
          return this.precedence + " >= _p";
        }
      };
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicateTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicateTransition.prototype, "isEpsilon", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicateTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicateTransition.prototype, "toString", null);
      PrecedencePredicateTransition = __decorate([
        __param(0, Decorators_1.NotNull)
      ], PrecedencePredicateTransition);
      exports.PrecedencePredicateTransition = PrecedencePredicateTransition;
    }
  });

  // node_modules/antlr4ts/atn/RangeTransition.js
  var require_RangeTransition = __commonJS({
    "node_modules/antlr4ts/atn/RangeTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RangeTransition = void 0;
      var IntervalSet_1 = require_IntervalSet();
      var Decorators_1 = require_Decorators();
      var Transition_1 = require_Transition();
      var RangeTransition = class RangeTransition extends Transition_1.Transition {
        constructor(target, from, to) {
          super(target);
          this.from = from;
          this.to = to;
        }
        get serializationType() {
          return 2;
        }
        get label() {
          return IntervalSet_1.IntervalSet.of(this.from, this.to);
        }
        matches(symbol, minVocabSymbol, maxVocabSymbol) {
          return symbol >= this.from && symbol <= this.to;
        }
        toString() {
          return "'" + String.fromCodePoint(this.from) + "'..'" + String.fromCodePoint(this.to) + "'";
        }
      };
      __decorate([
        Decorators_1.Override
      ], RangeTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], RangeTransition.prototype, "label", null);
      __decorate([
        Decorators_1.Override
      ], RangeTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], RangeTransition.prototype, "toString", null);
      RangeTransition = __decorate([
        __param(0, Decorators_1.NotNull)
      ], RangeTransition);
      exports.RangeTransition = RangeTransition;
    }
  });

  // node_modules/antlr4ts/atn/RuleStartState.js
  var require_RuleStartState = __commonJS({
    "node_modules/antlr4ts/atn/RuleStartState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleStartState = void 0;
      var ATNState_1 = require_ATNState();
      var ATNStateType_1 = require_ATNStateType();
      var Decorators_1 = require_Decorators();
      var RuleStartState = class extends ATNState_1.ATNState {
        constructor() {
          super(...arguments);
          this.isPrecedenceRule = false;
          this.leftFactored = false;
        }
        get stateType() {
          return ATNStateType_1.ATNStateType.RULE_START;
        }
      };
      __decorate([
        Decorators_1.Override
      ], RuleStartState.prototype, "stateType", null);
      exports.RuleStartState = RuleStartState;
    }
  });

  // node_modules/antlr4ts/atn/StarBlockStartState.js
  var require_StarBlockStartState = __commonJS({
    "node_modules/antlr4ts/atn/StarBlockStartState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StarBlockStartState = void 0;
      var ATNStateType_1 = require_ATNStateType();
      var BlockStartState_1 = require_BlockStartState();
      var Decorators_1 = require_Decorators();
      var StarBlockStartState = class extends BlockStartState_1.BlockStartState {
        get stateType() {
          return ATNStateType_1.ATNStateType.STAR_BLOCK_START;
        }
      };
      __decorate([
        Decorators_1.Override
      ], StarBlockStartState.prototype, "stateType", null);
      exports.StarBlockStartState = StarBlockStartState;
    }
  });

  // node_modules/antlr4ts/atn/StarLoopbackState.js
  var require_StarLoopbackState = __commonJS({
    "node_modules/antlr4ts/atn/StarLoopbackState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StarLoopbackState = void 0;
      var ATNState_1 = require_ATNState();
      var ATNStateType_1 = require_ATNStateType();
      var Decorators_1 = require_Decorators();
      var StarLoopbackState = class extends ATNState_1.ATNState {
        get loopEntryState() {
          return this.transition(0).target;
        }
        get stateType() {
          return ATNStateType_1.ATNStateType.STAR_LOOP_BACK;
        }
      };
      __decorate([
        Decorators_1.Override
      ], StarLoopbackState.prototype, "stateType", null);
      exports.StarLoopbackState = StarLoopbackState;
    }
  });

  // node_modules/antlr4ts/atn/TokensStartState.js
  var require_TokensStartState = __commonJS({
    "node_modules/antlr4ts/atn/TokensStartState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TokensStartState = void 0;
      var ATNStateType_1 = require_ATNStateType();
      var DecisionState_1 = require_DecisionState();
      var Decorators_1 = require_Decorators();
      var TokensStartState = class extends DecisionState_1.DecisionState {
        get stateType() {
          return ATNStateType_1.ATNStateType.TOKEN_START;
        }
      };
      __decorate([
        Decorators_1.Override
      ], TokensStartState.prototype, "stateType", null);
      exports.TokensStartState = TokensStartState;
    }
  });

  // node_modules/antlr4ts/misc/UUID.js
  var require_UUID = __commonJS({
    "node_modules/antlr4ts/misc/UUID.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UUID = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var UUID = class _UUID {
        constructor(mostSigBits, moreSigBits, lessSigBits, leastSigBits) {
          this.data = new Uint32Array(4);
          this.data[0] = mostSigBits;
          this.data[1] = moreSigBits;
          this.data[2] = lessSigBits;
          this.data[3] = leastSigBits;
        }
        static fromString(data) {
          if (!/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(data)) {
            throw new Error("Incorrectly formatted UUID");
          }
          let segments = data.split("-");
          let mostSigBits = parseInt(segments[0], 16);
          let moreSigBits = (parseInt(segments[1], 16) << 16 >>> 0) + parseInt(segments[2], 16);
          let lessSigBits = (parseInt(segments[3], 16) << 16 >>> 0) + parseInt(segments[4].substr(0, 4), 16);
          let leastSigBits = parseInt(segments[4].substr(-8), 16);
          return new _UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
        }
        hashCode() {
          return MurmurHash_1.MurmurHash.hashCode([this.data[0], this.data[1], this.data[2], this.data[3]]);
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof _UUID)) {
            return false;
          }
          return this.data[0] === obj.data[0] && this.data[1] === obj.data[1] && this.data[2] === obj.data[2] && this.data[3] === obj.data[3];
        }
        toString() {
          return ("00000000" + this.data[0].toString(16)).substr(-8) + "-" + ("0000" + (this.data[1] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[1].toString(16)).substr(-4) + "-" + ("0000" + (this.data[2] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[2].toString(16)).substr(-4) + ("00000000" + this.data[3].toString(16)).substr(-8);
        }
      };
      exports.UUID = UUID;
    }
  });

  // node_modules/antlr4ts/atn/ATNDeserializer.js
  var require_ATNDeserializer = __commonJS({
    "node_modules/antlr4ts/atn/ATNDeserializer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATNDeserializer = void 0;
      var ActionTransition_1 = require_ActionTransition();
      var Array2DHashSet_1 = require_Array2DHashSet();
      var ATN_1 = require_ATN();
      var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();
      var ATNStateType_1 = require_ATNStateType();
      var AtomTransition_1 = require_AtomTransition();
      var BasicBlockStartState_1 = require_BasicBlockStartState();
      var BasicState_1 = require_BasicState();
      var BitSet_1 = require_BitSet();
      var BlockEndState_1 = require_BlockEndState();
      var BlockStartState_1 = require_BlockStartState();
      var DecisionState_1 = require_DecisionState();
      var DFA_1 = require_DFA();
      var EpsilonTransition_1 = require_EpsilonTransition();
      var IntervalSet_1 = require_IntervalSet();
      var InvalidState_1 = require_InvalidState();
      var LexerChannelAction_1 = require_LexerChannelAction();
      var LexerCustomAction_1 = require_LexerCustomAction();
      var LexerModeAction_1 = require_LexerModeAction();
      var LexerMoreAction_1 = require_LexerMoreAction();
      var LexerPopModeAction_1 = require_LexerPopModeAction();
      var LexerPushModeAction_1 = require_LexerPushModeAction();
      var LexerSkipAction_1 = require_LexerSkipAction();
      var LexerTypeAction_1 = require_LexerTypeAction();
      var LoopEndState_1 = require_LoopEndState();
      var Decorators_1 = require_Decorators();
      var NotSetTransition_1 = require_NotSetTransition();
      var ParserATNSimulator_1 = require_ParserATNSimulator();
      var PlusBlockStartState_1 = require_PlusBlockStartState();
      var PlusLoopbackState_1 = require_PlusLoopbackState();
      var PrecedencePredicateTransition_1 = require_PrecedencePredicateTransition();
      var PredicateTransition_1 = require_PredicateTransition();
      var RangeTransition_1 = require_RangeTransition();
      var RuleStartState_1 = require_RuleStartState();
      var RuleStopState_1 = require_RuleStopState();
      var RuleTransition_1 = require_RuleTransition();
      var SetTransition_1 = require_SetTransition();
      var StarBlockStartState_1 = require_StarBlockStartState();
      var StarLoopbackState_1 = require_StarLoopbackState();
      var StarLoopEntryState_1 = require_StarLoopEntryState();
      var Token_1 = require_Token();
      var TokensStartState_1 = require_TokensStartState();
      var UUID_1 = require_UUID();
      var WildcardTransition_1 = require_WildcardTransition();
      var UnicodeDeserializingMode;
      (function(UnicodeDeserializingMode2) {
        UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_BMP"] = 0] = "UNICODE_BMP";
        UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_SMP"] = 1] = "UNICODE_SMP";
      })(UnicodeDeserializingMode || (UnicodeDeserializingMode = {}));
      var ATNDeserializer3 = class _ATNDeserializer {
        constructor(deserializationOptions) {
          if (deserializationOptions === void 0) {
            deserializationOptions = ATNDeserializationOptions_1.ATNDeserializationOptions.defaultOptions;
          }
          this.deserializationOptions = deserializationOptions;
        }
        static get SERIALIZED_VERSION() {
          return 3;
        }
        /**
         * Determines if a particular serialized representation of an ATN supports
         * a particular feature, identified by the {@link UUID} used for serializing
         * the ATN at the time the feature was first introduced.
         *
         * @param feature The {@link UUID} marking the first time the feature was
         * supported in the serialized ATN.
         * @param actualUuid The {@link UUID} of the actual serialized ATN which is
         * currently being deserialized.
         * @returns `true` if the `actualUuid` value represents a
         * serialized ATN at or after the feature identified by `feature` was
         * introduced; otherwise, `false`.
         */
        static isFeatureSupported(feature, actualUuid) {
          let featureIndex = _ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(feature));
          if (featureIndex < 0) {
            return false;
          }
          return _ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(actualUuid)) >= featureIndex;
        }
        static getUnicodeDeserializer(mode) {
          if (mode === 0) {
            return {
              readUnicode: (data, p) => {
                return _ATNDeserializer.toInt(data[p]);
              },
              size: 1
            };
          } else {
            return {
              readUnicode: (data, p) => {
                return _ATNDeserializer.toInt32(data, p);
              },
              size: 2
            };
          }
        }
        deserialize(data) {
          data = data.slice(0);
          for (let i = 1; i < data.length; i++) {
            data[i] = data[i] - 2 & 65535;
          }
          let p = 0;
          let version = _ATNDeserializer.toInt(data[p++]);
          if (version !== _ATNDeserializer.SERIALIZED_VERSION) {
            let reason = `Could not deserialize ATN with version ${version} (expected ${_ATNDeserializer.SERIALIZED_VERSION}).`;
            throw new Error(reason);
          }
          let uuid = _ATNDeserializer.toUUID(data, p);
          p += 8;
          if (_ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(uuid)) < 0) {
            let reason = `Could not deserialize ATN with UUID ${uuid} (expected ${_ATNDeserializer.SERIALIZED_UUID} or a legacy UUID).`;
            throw new Error(reason);
          }
          let supportsLexerActions = _ATNDeserializer.isFeatureSupported(_ATNDeserializer.ADDED_LEXER_ACTIONS, uuid);
          let grammarType = _ATNDeserializer.toInt(data[p++]);
          let maxTokenType = _ATNDeserializer.toInt(data[p++]);
          let atn = new ATN_1.ATN(grammarType, maxTokenType);
          let loopBackStateNumbers = [];
          let endStateNumbers = [];
          let nstates = _ATNDeserializer.toInt(data[p++]);
          for (let i = 0; i < nstates; i++) {
            let stype = _ATNDeserializer.toInt(data[p++]);
            if (stype === ATNStateType_1.ATNStateType.INVALID_TYPE) {
              atn.addState(new InvalidState_1.InvalidState());
              continue;
            }
            let ruleIndex = _ATNDeserializer.toInt(data[p++]);
            if (ruleIndex === 65535) {
              ruleIndex = -1;
            }
            let s = this.stateFactory(stype, ruleIndex);
            if (stype === ATNStateType_1.ATNStateType.LOOP_END) {
              let loopBackStateNumber = _ATNDeserializer.toInt(data[p++]);
              loopBackStateNumbers.push([s, loopBackStateNumber]);
            } else if (s instanceof BlockStartState_1.BlockStartState) {
              let endStateNumber = _ATNDeserializer.toInt(data[p++]);
              endStateNumbers.push([s, endStateNumber]);
            }
            atn.addState(s);
          }
          for (let pair of loopBackStateNumbers) {
            pair[0].loopBackState = atn.states[pair[1]];
          }
          for (let pair of endStateNumbers) {
            pair[0].endState = atn.states[pair[1]];
          }
          let numNonGreedyStates = _ATNDeserializer.toInt(data[p++]);
          for (let i = 0; i < numNonGreedyStates; i++) {
            let stateNumber = _ATNDeserializer.toInt(data[p++]);
            atn.states[stateNumber].nonGreedy = true;
          }
          let numSllDecisions = _ATNDeserializer.toInt(data[p++]);
          for (let i = 0; i < numSllDecisions; i++) {
            let stateNumber = _ATNDeserializer.toInt(data[p++]);
            atn.states[stateNumber].sll = true;
          }
          let numPrecedenceStates = _ATNDeserializer.toInt(data[p++]);
          for (let i = 0; i < numPrecedenceStates; i++) {
            let stateNumber = _ATNDeserializer.toInt(data[p++]);
            atn.states[stateNumber].isPrecedenceRule = true;
          }
          let nrules = _ATNDeserializer.toInt(data[p++]);
          if (atn.grammarType === 0) {
            atn.ruleToTokenType = new Int32Array(nrules);
          }
          atn.ruleToStartState = new Array(nrules);
          for (let i = 0; i < nrules; i++) {
            let s = _ATNDeserializer.toInt(data[p++]);
            let startState = atn.states[s];
            startState.leftFactored = _ATNDeserializer.toInt(data[p++]) !== 0;
            atn.ruleToStartState[i] = startState;
            if (atn.grammarType === 0) {
              let tokenType = _ATNDeserializer.toInt(data[p++]);
              if (tokenType === 65535) {
                tokenType = Token_1.Token.EOF;
              }
              atn.ruleToTokenType[i] = tokenType;
              if (!_ATNDeserializer.isFeatureSupported(_ATNDeserializer.ADDED_LEXER_ACTIONS, uuid)) {
                let actionIndexIgnored = _ATNDeserializer.toInt(data[p++]);
                if (actionIndexIgnored === 65535) {
                  actionIndexIgnored = -1;
                }
              }
            }
          }
          atn.ruleToStopState = new Array(nrules);
          for (let state of atn.states) {
            if (!(state instanceof RuleStopState_1.RuleStopState)) {
              continue;
            }
            atn.ruleToStopState[state.ruleIndex] = state;
            atn.ruleToStartState[state.ruleIndex].stopState = state;
          }
          let nmodes = _ATNDeserializer.toInt(data[p++]);
          for (let i = 0; i < nmodes; i++) {
            let s = _ATNDeserializer.toInt(data[p++]);
            atn.modeToStartState.push(atn.states[s]);
          }
          atn.modeToDFA = new Array(nmodes);
          for (let i = 0; i < nmodes; i++) {
            atn.modeToDFA[i] = new DFA_1.DFA(atn.modeToStartState[i]);
          }
          let sets = [];
          p = this.deserializeSets(data, p, sets, _ATNDeserializer.getUnicodeDeserializer(
            0
            /* UNICODE_BMP */
          ));
          if (_ATNDeserializer.isFeatureSupported(_ATNDeserializer.ADDED_UNICODE_SMP, uuid)) {
            p = this.deserializeSets(data, p, sets, _ATNDeserializer.getUnicodeDeserializer(
              1
              /* UNICODE_SMP */
            ));
          }
          let nedges = _ATNDeserializer.toInt(data[p++]);
          for (let i = 0; i < nedges; i++) {
            let src = _ATNDeserializer.toInt(data[p]);
            let trg = _ATNDeserializer.toInt(data[p + 1]);
            let ttype = _ATNDeserializer.toInt(data[p + 2]);
            let arg1 = _ATNDeserializer.toInt(data[p + 3]);
            let arg2 = _ATNDeserializer.toInt(data[p + 4]);
            let arg3 = _ATNDeserializer.toInt(data[p + 5]);
            let trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
            let srcState = atn.states[src];
            srcState.addTransition(trans);
            p += 6;
          }
          let returnTransitionsSet = new Array2DHashSet_1.Array2DHashSet({
            hashCode: (o) => o.stopState ^ o.returnState ^ o.outermostPrecedenceReturn,
            equals: (a, b) => {
              return a.stopState === b.stopState && a.returnState === b.returnState && a.outermostPrecedenceReturn === b.outermostPrecedenceReturn;
            }
          });
          let returnTransitions = [];
          for (let state of atn.states) {
            let returningToLeftFactored = state.ruleIndex >= 0 && atn.ruleToStartState[state.ruleIndex].leftFactored;
            for (let i = 0; i < state.numberOfTransitions; i++) {
              let t = state.transition(i);
              if (!(t instanceof RuleTransition_1.RuleTransition)) {
                continue;
              }
              let ruleTransition = t;
              let returningFromLeftFactored = atn.ruleToStartState[ruleTransition.target.ruleIndex].leftFactored;
              if (!returningFromLeftFactored && returningToLeftFactored) {
                continue;
              }
              let outermostPrecedenceReturn = -1;
              if (atn.ruleToStartState[ruleTransition.target.ruleIndex].isPrecedenceRule) {
                if (ruleTransition.precedence === 0) {
                  outermostPrecedenceReturn = ruleTransition.target.ruleIndex;
                }
              }
              let current = { stopState: ruleTransition.target.ruleIndex, returnState: ruleTransition.followState.stateNumber, outermostPrecedenceReturn };
              if (returnTransitionsSet.add(current)) {
                returnTransitions.push(current);
              }
            }
          }
          for (let returnTransition of returnTransitions) {
            let transition = new EpsilonTransition_1.EpsilonTransition(atn.states[returnTransition.returnState], returnTransition.outermostPrecedenceReturn);
            atn.ruleToStopState[returnTransition.stopState].addTransition(transition);
          }
          for (let state of atn.states) {
            if (state instanceof BlockStartState_1.BlockStartState) {
              if (state.endState === void 0) {
                throw new Error("IllegalStateException");
              }
              if (state.endState.startState !== void 0) {
                throw new Error("IllegalStateException");
              }
              state.endState.startState = state;
            }
            if (state instanceof PlusLoopbackState_1.PlusLoopbackState) {
              let loopbackState = state;
              for (let i = 0; i < loopbackState.numberOfTransitions; i++) {
                let target = loopbackState.transition(i).target;
                if (target instanceof PlusBlockStartState_1.PlusBlockStartState) {
                  target.loopBackState = loopbackState;
                }
              }
            } else if (state instanceof StarLoopbackState_1.StarLoopbackState) {
              let loopbackState = state;
              for (let i = 0; i < loopbackState.numberOfTransitions; i++) {
                let target = loopbackState.transition(i).target;
                if (target instanceof StarLoopEntryState_1.StarLoopEntryState) {
                  target.loopBackState = loopbackState;
                }
              }
            }
          }
          let ndecisions = _ATNDeserializer.toInt(data[p++]);
          for (let i = 1; i <= ndecisions; i++) {
            let s = _ATNDeserializer.toInt(data[p++]);
            let decState = atn.states[s];
            atn.decisionToState.push(decState);
            decState.decision = i - 1;
          }
          if (atn.grammarType === 0) {
            if (supportsLexerActions) {
              atn.lexerActions = new Array(_ATNDeserializer.toInt(data[p++]));
              for (let i = 0; i < atn.lexerActions.length; i++) {
                let actionType = _ATNDeserializer.toInt(data[p++]);
                let data1 = _ATNDeserializer.toInt(data[p++]);
                if (data1 === 65535) {
                  data1 = -1;
                }
                let data2 = _ATNDeserializer.toInt(data[p++]);
                if (data2 === 65535) {
                  data2 = -1;
                }
                let lexerAction = this.lexerActionFactory(actionType, data1, data2);
                atn.lexerActions[i] = lexerAction;
              }
            } else {
              let legacyLexerActions = [];
              for (let state of atn.states) {
                for (let i = 0; i < state.numberOfTransitions; i++) {
                  let transition = state.transition(i);
                  if (!(transition instanceof ActionTransition_1.ActionTransition)) {
                    continue;
                  }
                  let ruleIndex = transition.ruleIndex;
                  let actionIndex = transition.actionIndex;
                  let lexerAction = new LexerCustomAction_1.LexerCustomAction(ruleIndex, actionIndex);
                  state.setTransition(i, new ActionTransition_1.ActionTransition(transition.target, ruleIndex, legacyLexerActions.length, false));
                  legacyLexerActions.push(lexerAction);
                }
              }
              atn.lexerActions = legacyLexerActions;
            }
          }
          this.markPrecedenceDecisions(atn);
          atn.decisionToDFA = new Array(ndecisions);
          for (let i = 0; i < ndecisions; i++) {
            atn.decisionToDFA[i] = new DFA_1.DFA(atn.decisionToState[i], i);
          }
          if (this.deserializationOptions.isVerifyATN) {
            this.verifyATN(atn);
          }
          if (this.deserializationOptions.isGenerateRuleBypassTransitions && atn.grammarType === 1) {
            atn.ruleToTokenType = new Int32Array(atn.ruleToStartState.length);
            for (let i = 0; i < atn.ruleToStartState.length; i++) {
              atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
            }
            for (let i = 0; i < atn.ruleToStartState.length; i++) {
              let bypassStart = new BasicBlockStartState_1.BasicBlockStartState();
              bypassStart.ruleIndex = i;
              atn.addState(bypassStart);
              let bypassStop = new BlockEndState_1.BlockEndState();
              bypassStop.ruleIndex = i;
              atn.addState(bypassStop);
              bypassStart.endState = bypassStop;
              atn.defineDecisionState(bypassStart);
              bypassStop.startState = bypassStart;
              let endState;
              let excludeTransition;
              if (atn.ruleToStartState[i].isPrecedenceRule) {
                endState = void 0;
                for (let state of atn.states) {
                  if (state.ruleIndex !== i) {
                    continue;
                  }
                  if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
                    continue;
                  }
                  let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
                  if (!(maybeLoopEndState instanceof LoopEndState_1.LoopEndState)) {
                    continue;
                  }
                  if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                    endState = state;
                    break;
                  }
                }
                if (!endState) {
                  throw new Error("Couldn't identify final state of the precedence rule prefix section.");
                }
                excludeTransition = endState.loopBackState.transition(0);
              } else {
                endState = atn.ruleToStopState[i];
              }
              for (let state of atn.states) {
                for (let i2 = 0; i2 < state.numberOfTransitions; i2++) {
                  let transition = state.transition(i2);
                  if (transition === excludeTransition) {
                    continue;
                  }
                  if (transition.target === endState) {
                    transition.target = bypassStop;
                  }
                }
              }
              while (atn.ruleToStartState[i].numberOfTransitions > 0) {
                let transition = atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].numberOfTransitions - 1);
                bypassStart.addTransition(transition);
              }
              atn.ruleToStartState[i].addTransition(new EpsilonTransition_1.EpsilonTransition(bypassStart));
              bypassStop.addTransition(new EpsilonTransition_1.EpsilonTransition(endState));
              let matchState = new BasicState_1.BasicState();
              atn.addState(matchState);
              matchState.addTransition(new AtomTransition_1.AtomTransition(bypassStop, atn.ruleToTokenType[i]));
              bypassStart.addTransition(new EpsilonTransition_1.EpsilonTransition(matchState));
            }
            if (this.deserializationOptions.isVerifyATN) {
              this.verifyATN(atn);
            }
          }
          if (this.deserializationOptions.isOptimize) {
            while (true) {
              let optimizationCount = 0;
              optimizationCount += _ATNDeserializer.inlineSetRules(atn);
              optimizationCount += _ATNDeserializer.combineChainedEpsilons(atn);
              let preserveOrder = atn.grammarType === 0;
              optimizationCount += _ATNDeserializer.optimizeSets(atn, preserveOrder);
              if (optimizationCount === 0) {
                break;
              }
            }
            if (this.deserializationOptions.isVerifyATN) {
              this.verifyATN(atn);
            }
          }
          _ATNDeserializer.identifyTailCalls(atn);
          return atn;
        }
        deserializeSets(data, p, sets, unicodeDeserializer) {
          let nsets = _ATNDeserializer.toInt(data[p++]);
          for (let i = 0; i < nsets; i++) {
            let nintervals = _ATNDeserializer.toInt(data[p]);
            p++;
            let set = new IntervalSet_1.IntervalSet();
            sets.push(set);
            let containsEof = _ATNDeserializer.toInt(data[p++]) !== 0;
            if (containsEof) {
              set.add(-1);
            }
            for (let j = 0; j < nintervals; j++) {
              let a = unicodeDeserializer.readUnicode(data, p);
              p += unicodeDeserializer.size;
              let b = unicodeDeserializer.readUnicode(data, p);
              p += unicodeDeserializer.size;
              set.add(a, b);
            }
          }
          return p;
        }
        /**
         * Analyze the {@link StarLoopEntryState} states in the specified ATN to set
         * the {@link StarLoopEntryState#precedenceRuleDecision} field to the
         * correct value.
         *
         * @param atn The ATN.
         */
        markPrecedenceDecisions(atn) {
          let rulePrecedenceDecisions = /* @__PURE__ */ new Map();
          for (let state of atn.states) {
            if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
              continue;
            }
            if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
              let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
              if (maybeLoopEndState instanceof LoopEndState_1.LoopEndState) {
                if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                  rulePrecedenceDecisions.set(state.ruleIndex, state);
                  state.precedenceRuleDecision = true;
                  state.precedenceLoopbackStates = new BitSet_1.BitSet(atn.states.length);
                }
              }
            }
          }
          for (let precedenceDecision of rulePrecedenceDecisions) {
            for (let transition of atn.ruleToStopState[precedenceDecision[0]].getTransitions()) {
              if (transition.serializationType !== 1) {
                continue;
              }
              let epsilonTransition = transition;
              if (epsilonTransition.outermostPrecedenceReturn !== -1) {
                continue;
              }
              precedenceDecision[1].precedenceLoopbackStates.set(transition.target.stateNumber);
            }
          }
        }
        verifyATN(atn) {
          for (let state of atn.states) {
            this.checkCondition(state !== void 0, "ATN states should not be undefined.");
            if (state.stateType === ATNStateType_1.ATNStateType.INVALID_TYPE) {
              continue;
            }
            this.checkCondition(state.onlyHasEpsilonTransitions || state.numberOfTransitions <= 1);
            if (state instanceof PlusBlockStartState_1.PlusBlockStartState) {
              this.checkCondition(state.loopBackState !== void 0);
            }
            if (state instanceof StarLoopEntryState_1.StarLoopEntryState) {
              let starLoopEntryState = state;
              this.checkCondition(starLoopEntryState.loopBackState !== void 0);
              this.checkCondition(starLoopEntryState.numberOfTransitions === 2);
              if (starLoopEntryState.transition(0).target instanceof StarBlockStartState_1.StarBlockStartState) {
                this.checkCondition(starLoopEntryState.transition(1).target instanceof LoopEndState_1.LoopEndState);
                this.checkCondition(!starLoopEntryState.nonGreedy);
              } else if (starLoopEntryState.transition(0).target instanceof LoopEndState_1.LoopEndState) {
                this.checkCondition(starLoopEntryState.transition(1).target instanceof StarBlockStartState_1.StarBlockStartState);
                this.checkCondition(starLoopEntryState.nonGreedy);
              } else {
                throw new Error("IllegalStateException");
              }
            }
            if (state instanceof StarLoopbackState_1.StarLoopbackState) {
              this.checkCondition(state.numberOfTransitions === 1);
              this.checkCondition(state.transition(0).target instanceof StarLoopEntryState_1.StarLoopEntryState);
            }
            if (state instanceof LoopEndState_1.LoopEndState) {
              this.checkCondition(state.loopBackState !== void 0);
            }
            if (state instanceof RuleStartState_1.RuleStartState) {
              this.checkCondition(state.stopState !== void 0);
            }
            if (state instanceof BlockStartState_1.BlockStartState) {
              this.checkCondition(state.endState !== void 0);
            }
            if (state instanceof BlockEndState_1.BlockEndState) {
              this.checkCondition(state.startState !== void 0);
            }
            if (state instanceof DecisionState_1.DecisionState) {
              let decisionState = state;
              this.checkCondition(decisionState.numberOfTransitions <= 1 || decisionState.decision >= 0);
            } else {
              this.checkCondition(state.numberOfTransitions <= 1 || state instanceof RuleStopState_1.RuleStopState);
            }
          }
        }
        checkCondition(condition, message) {
          if (!condition) {
            throw new Error("IllegalStateException: " + message);
          }
        }
        static inlineSetRules(atn) {
          let inlinedCalls = 0;
          let ruleToInlineTransition = new Array(atn.ruleToStartState.length);
          for (let i = 0; i < atn.ruleToStartState.length; i++) {
            let startState = atn.ruleToStartState[i];
            let middleState = startState;
            while (middleState.onlyHasEpsilonTransitions && middleState.numberOfOptimizedTransitions === 1 && middleState.getOptimizedTransition(0).serializationType === 1) {
              middleState = middleState.getOptimizedTransition(0).target;
            }
            if (middleState.numberOfOptimizedTransitions !== 1) {
              continue;
            }
            let matchTransition = middleState.getOptimizedTransition(0);
            let matchTarget = matchTransition.target;
            if (matchTransition.isEpsilon || !matchTarget.onlyHasEpsilonTransitions || matchTarget.numberOfOptimizedTransitions !== 1 || !(matchTarget.getOptimizedTransition(0).target instanceof RuleStopState_1.RuleStopState)) {
              continue;
            }
            switch (matchTransition.serializationType) {
              case 5:
              case 2:
              case 7:
                ruleToInlineTransition[i] = matchTransition;
                break;
              case 8:
              case 9:
                continue;
              default:
                continue;
            }
          }
          for (let state of atn.states) {
            if (state.ruleIndex < 0) {
              continue;
            }
            let optimizedTransitions;
            for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
              let transition = state.getOptimizedTransition(i);
              if (!(transition instanceof RuleTransition_1.RuleTransition)) {
                if (optimizedTransitions !== void 0) {
                  optimizedTransitions.push(transition);
                }
                continue;
              }
              let ruleTransition = transition;
              let effective = ruleToInlineTransition[ruleTransition.target.ruleIndex];
              if (effective === void 0) {
                if (optimizedTransitions !== void 0) {
                  optimizedTransitions.push(transition);
                }
                continue;
              }
              if (optimizedTransitions === void 0) {
                optimizedTransitions = [];
                for (let j = 0; j < i; j++) {
                  optimizedTransitions.push(state.getOptimizedTransition(i));
                }
              }
              inlinedCalls++;
              let target = ruleTransition.followState;
              let intermediateState = new BasicState_1.BasicState();
              intermediateState.setRuleIndex(target.ruleIndex);
              atn.addState(intermediateState);
              optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(intermediateState));
              switch (effective.serializationType) {
                case 5:
                  intermediateState.addTransition(new AtomTransition_1.AtomTransition(target, effective._label));
                  break;
                case 2:
                  intermediateState.addTransition(new RangeTransition_1.RangeTransition(target, effective.from, effective.to));
                  break;
                case 7:
                  intermediateState.addTransition(new SetTransition_1.SetTransition(target, effective.label));
                  break;
                default:
                  throw new Error("UnsupportedOperationException");
              }
            }
            if (optimizedTransitions !== void 0) {
              if (state.isOptimized) {
                while (state.numberOfOptimizedTransitions > 0) {
                  state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
                }
              }
              for (let transition of optimizedTransitions) {
                state.addOptimizedTransition(transition);
              }
            }
          }
          if (ParserATNSimulator_1.ParserATNSimulator.debug) {
            console.log("ATN runtime optimizer removed " + inlinedCalls + " rule invocations by inlining sets.");
          }
          return inlinedCalls;
        }
        static combineChainedEpsilons(atn) {
          let removedEdges = 0;
          for (let state of atn.states) {
            if (!state.onlyHasEpsilonTransitions || state instanceof RuleStopState_1.RuleStopState) {
              continue;
            }
            let optimizedTransitions;
            nextTransition: for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
              let transition = state.getOptimizedTransition(i);
              let intermediate = transition.target;
              if (transition.serializationType !== 1 || transition.outermostPrecedenceReturn !== -1 || intermediate.stateType !== ATNStateType_1.ATNStateType.BASIC || !intermediate.onlyHasEpsilonTransitions) {
                if (optimizedTransitions !== void 0) {
                  optimizedTransitions.push(transition);
                }
                continue nextTransition;
              }
              for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
                if (intermediate.getOptimizedTransition(j).serializationType !== 1 || intermediate.getOptimizedTransition(j).outermostPrecedenceReturn !== -1) {
                  if (optimizedTransitions !== void 0) {
                    optimizedTransitions.push(transition);
                  }
                  continue nextTransition;
                }
              }
              removedEdges++;
              if (optimizedTransitions === void 0) {
                optimizedTransitions = [];
                for (let j = 0; j < i; j++) {
                  optimizedTransitions.push(state.getOptimizedTransition(j));
                }
              }
              for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
                let target = intermediate.getOptimizedTransition(j).target;
                optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(target));
              }
            }
            if (optimizedTransitions !== void 0) {
              if (state.isOptimized) {
                while (state.numberOfOptimizedTransitions > 0) {
                  state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
                }
              }
              for (let transition of optimizedTransitions) {
                state.addOptimizedTransition(transition);
              }
            }
          }
          if (ParserATNSimulator_1.ParserATNSimulator.debug) {
            console.log("ATN runtime optimizer removed " + removedEdges + " transitions by combining chained epsilon transitions.");
          }
          return removedEdges;
        }
        static optimizeSets(atn, preserveOrder) {
          if (preserveOrder) {
            return 0;
          }
          let removedPaths = 0;
          let decisions = atn.decisionToState;
          for (let decision of decisions) {
            let setTransitions = new IntervalSet_1.IntervalSet();
            for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {
              let epsTransition = decision.getOptimizedTransition(i);
              if (!(epsTransition instanceof EpsilonTransition_1.EpsilonTransition)) {
                continue;
              }
              if (epsTransition.target.numberOfOptimizedTransitions !== 1) {
                continue;
              }
              let transition = epsTransition.target.getOptimizedTransition(0);
              if (!(transition.target instanceof BlockEndState_1.BlockEndState)) {
                continue;
              }
              if (transition instanceof NotSetTransition_1.NotSetTransition) {
                continue;
              }
              if (transition instanceof AtomTransition_1.AtomTransition || transition instanceof RangeTransition_1.RangeTransition || transition instanceof SetTransition_1.SetTransition) {
                setTransitions.add(i);
              }
            }
            if (setTransitions.size <= 1) {
              continue;
            }
            let optimizedTransitions = [];
            for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {
              if (!setTransitions.contains(i)) {
                optimizedTransitions.push(decision.getOptimizedTransition(i));
              }
            }
            let blockEndState = decision.getOptimizedTransition(setTransitions.minElement).target.getOptimizedTransition(0).target;
            let matchSet = new IntervalSet_1.IntervalSet();
            for (let interval of setTransitions.intervals) {
              for (let j = interval.a; j <= interval.b; j++) {
                let matchTransition = decision.getOptimizedTransition(j).target.getOptimizedTransition(0);
                if (matchTransition instanceof NotSetTransition_1.NotSetTransition) {
                  throw new Error("Not yet implemented.");
                } else {
                  matchSet.addAll(matchTransition.label);
                }
              }
            }
            let newTransition;
            if (matchSet.intervals.length === 1) {
              if (matchSet.size === 1) {
                newTransition = new AtomTransition_1.AtomTransition(blockEndState, matchSet.minElement);
              } else {
                let matchInterval = matchSet.intervals[0];
                newTransition = new RangeTransition_1.RangeTransition(blockEndState, matchInterval.a, matchInterval.b);
              }
            } else {
              newTransition = new SetTransition_1.SetTransition(blockEndState, matchSet);
            }
            let setOptimizedState = new BasicState_1.BasicState();
            setOptimizedState.setRuleIndex(decision.ruleIndex);
            atn.addState(setOptimizedState);
            setOptimizedState.addTransition(newTransition);
            optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(setOptimizedState));
            removedPaths += decision.numberOfOptimizedTransitions - optimizedTransitions.length;
            if (decision.isOptimized) {
              while (decision.numberOfOptimizedTransitions > 0) {
                decision.removeOptimizedTransition(decision.numberOfOptimizedTransitions - 1);
              }
            }
            for (let transition of optimizedTransitions) {
              decision.addOptimizedTransition(transition);
            }
          }
          if (ParserATNSimulator_1.ParserATNSimulator.debug) {
            console.log("ATN runtime optimizer removed " + removedPaths + " paths by collapsing sets.");
          }
          return removedPaths;
        }
        static identifyTailCalls(atn) {
          for (let state of atn.states) {
            for (let i = 0; i < state.numberOfTransitions; i++) {
              let transition = state.transition(i);
              if (!(transition instanceof RuleTransition_1.RuleTransition)) {
                continue;
              }
              transition.tailCall = this.testTailCall(atn, transition, false);
              transition.optimizedTailCall = this.testTailCall(atn, transition, true);
            }
            if (!state.isOptimized) {
              continue;
            }
            for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
              let transition = state.getOptimizedTransition(i);
              if (!(transition instanceof RuleTransition_1.RuleTransition)) {
                continue;
              }
              transition.tailCall = this.testTailCall(atn, transition, false);
              transition.optimizedTailCall = this.testTailCall(atn, transition, true);
            }
          }
        }
        static testTailCall(atn, transition, optimizedPath) {
          if (!optimizedPath && transition.tailCall) {
            return true;
          }
          if (optimizedPath && transition.optimizedTailCall) {
            return true;
          }
          let reachable = new BitSet_1.BitSet(atn.states.length);
          let worklist = [];
          worklist.push(transition.followState);
          while (true) {
            let state = worklist.pop();
            if (!state) {
              break;
            }
            if (reachable.get(state.stateNumber)) {
              continue;
            }
            if (state instanceof RuleStopState_1.RuleStopState) {
              continue;
            }
            if (!state.onlyHasEpsilonTransitions) {
              return false;
            }
            let transitionCount = optimizedPath ? state.numberOfOptimizedTransitions : state.numberOfTransitions;
            for (let i = 0; i < transitionCount; i++) {
              let t = optimizedPath ? state.getOptimizedTransition(i) : state.transition(i);
              if (t.serializationType !== 1) {
                return false;
              }
              worklist.push(t.target);
            }
          }
          return true;
        }
        static toInt(c) {
          return c;
        }
        static toInt32(data, offset) {
          return (data[offset] | data[offset + 1] << 16) >>> 0;
        }
        static toUUID(data, offset) {
          let leastSigBits = _ATNDeserializer.toInt32(data, offset);
          let lessSigBits = _ATNDeserializer.toInt32(data, offset + 2);
          let moreSigBits = _ATNDeserializer.toInt32(data, offset + 4);
          let mostSigBits = _ATNDeserializer.toInt32(data, offset + 6);
          return new UUID_1.UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
        }
        edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {
          let target = atn.states[trg];
          switch (type) {
            case 1:
              return new EpsilonTransition_1.EpsilonTransition(target);
            case 2:
              if (arg3 !== 0) {
                return new RangeTransition_1.RangeTransition(target, Token_1.Token.EOF, arg2);
              } else {
                return new RangeTransition_1.RangeTransition(target, arg1, arg2);
              }
            case 3:
              let rt = new RuleTransition_1.RuleTransition(atn.states[arg1], arg2, arg3, target);
              return rt;
            case 4:
              let pt = new PredicateTransition_1.PredicateTransition(target, arg1, arg2, arg3 !== 0);
              return pt;
            case 10:
              return new PrecedencePredicateTransition_1.PrecedencePredicateTransition(target, arg1);
            case 5:
              if (arg3 !== 0) {
                return new AtomTransition_1.AtomTransition(target, Token_1.Token.EOF);
              } else {
                return new AtomTransition_1.AtomTransition(target, arg1);
              }
            case 6:
              let a = new ActionTransition_1.ActionTransition(target, arg1, arg2, arg3 !== 0);
              return a;
            case 7:
              return new SetTransition_1.SetTransition(target, sets[arg1]);
            case 8:
              return new NotSetTransition_1.NotSetTransition(target, sets[arg1]);
            case 9:
              return new WildcardTransition_1.WildcardTransition(target);
          }
          throw new Error("The specified transition type is not valid.");
        }
        stateFactory(type, ruleIndex) {
          let s;
          switch (type) {
            case ATNStateType_1.ATNStateType.INVALID_TYPE:
              return new InvalidState_1.InvalidState();
            case ATNStateType_1.ATNStateType.BASIC:
              s = new BasicState_1.BasicState();
              break;
            case ATNStateType_1.ATNStateType.RULE_START:
              s = new RuleStartState_1.RuleStartState();
              break;
            case ATNStateType_1.ATNStateType.BLOCK_START:
              s = new BasicBlockStartState_1.BasicBlockStartState();
              break;
            case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
              s = new PlusBlockStartState_1.PlusBlockStartState();
              break;
            case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
              s = new StarBlockStartState_1.StarBlockStartState();
              break;
            case ATNStateType_1.ATNStateType.TOKEN_START:
              s = new TokensStartState_1.TokensStartState();
              break;
            case ATNStateType_1.ATNStateType.RULE_STOP:
              s = new RuleStopState_1.RuleStopState();
              break;
            case ATNStateType_1.ATNStateType.BLOCK_END:
              s = new BlockEndState_1.BlockEndState();
              break;
            case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
              s = new StarLoopbackState_1.StarLoopbackState();
              break;
            case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
              s = new StarLoopEntryState_1.StarLoopEntryState();
              break;
            case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
              s = new PlusLoopbackState_1.PlusLoopbackState();
              break;
            case ATNStateType_1.ATNStateType.LOOP_END:
              s = new LoopEndState_1.LoopEndState();
              break;
            default:
              let message = `The specified state type ${type} is not valid.`;
              throw new Error(message);
          }
          s.ruleIndex = ruleIndex;
          return s;
        }
        lexerActionFactory(type, data1, data2) {
          switch (type) {
            case 0:
              return new LexerChannelAction_1.LexerChannelAction(data1);
            case 1:
              return new LexerCustomAction_1.LexerCustomAction(data1, data2);
            case 2:
              return new LexerModeAction_1.LexerModeAction(data1);
            case 3:
              return LexerMoreAction_1.LexerMoreAction.INSTANCE;
            case 4:
              return LexerPopModeAction_1.LexerPopModeAction.INSTANCE;
            case 5:
              return new LexerPushModeAction_1.LexerPushModeAction(data1);
            case 6:
              return LexerSkipAction_1.LexerSkipAction.INSTANCE;
            case 7:
              return new LexerTypeAction_1.LexerTypeAction(data1);
            default:
              let message = `The specified lexer action type ${type} is not valid.`;
              throw new Error(message);
          }
        }
      };
      ATNDeserializer3.BASE_SERIALIZED_UUID = UUID_1.UUID.fromString("E4178468-DF95-44D0-AD87-F22A5D5FB6D3");
      ATNDeserializer3.ADDED_LEXER_ACTIONS = UUID_1.UUID.fromString("AB35191A-1603-487E-B75A-479B831EAF6D");
      ATNDeserializer3.ADDED_UNICODE_SMP = UUID_1.UUID.fromString("C23FEA89-0605-4f51-AFB8-058BCAB8C91B");
      ATNDeserializer3.SUPPORTED_UUIDS = [
        ATNDeserializer3.BASE_SERIALIZED_UUID,
        ATNDeserializer3.ADDED_LEXER_ACTIONS,
        ATNDeserializer3.ADDED_UNICODE_SMP
      ];
      ATNDeserializer3.SERIALIZED_UUID = ATNDeserializer3.ADDED_UNICODE_SMP;
      __decorate([
        Decorators_1.NotNull
      ], ATNDeserializer3.prototype, "deserializationOptions", void 0);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ATNDeserializer3.prototype, "deserialize", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ATNDeserializer3.prototype, "markPrecedenceDecisions", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], ATNDeserializer3.prototype, "edgeFactory", null);
      exports.ATNDeserializer = ATNDeserializer3;
    }
  });

  // node_modules/antlr4ts/atn/ParseInfo.js
  var require_ParseInfo = __commonJS({
    "node_modules/antlr4ts/atn/ParseInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParseInfo = void 0;
      var Decorators_1 = require_Decorators();
      var ParseInfo = class ParseInfo {
        constructor(atnSimulator) {
          this.atnSimulator = atnSimulator;
        }
        /**
         * Gets an array of {@link DecisionInfo} instances containing the profiling
         * information gathered for each decision in the ATN.
         *
         * @returns An array of {@link DecisionInfo} instances, indexed by decision
         * number.
         */
        getDecisionInfo() {
          return this.atnSimulator.getDecisionInfo();
        }
        /**
         * Gets the decision numbers for decisions that required one or more
         * full-context predictions during parsing. These are decisions for which
         * {@link DecisionInfo#LL_Fallback} is non-zero.
         *
         * @returns A list of decision numbers which required one or more
         * full-context predictions during parsing.
         */
        getLLDecisions() {
          let decisions = this.atnSimulator.getDecisionInfo();
          let LL = [];
          for (let i = 0; i < decisions.length; i++) {
            let fallBack = decisions[i].LL_Fallback;
            if (fallBack > 0) {
              LL.push(i);
            }
          }
          return LL;
        }
        /**
         * Gets the total time spent during prediction across all decisions made
         * during parsing. This value is the sum of
         * {@link DecisionInfo#timeInPrediction} for all decisions.
         */
        getTotalTimeInPrediction() {
          let decisions = this.atnSimulator.getDecisionInfo();
          let t = 0;
          for (let decision of decisions) {
            t += decision.timeInPrediction;
          }
          return t;
        }
        /**
         * Gets the total number of SLL lookahead operations across all decisions
         * made during parsing. This value is the sum of
         * {@link DecisionInfo#SLL_TotalLook} for all decisions.
         */
        getTotalSLLLookaheadOps() {
          let decisions = this.atnSimulator.getDecisionInfo();
          let k = 0;
          for (let decision of decisions) {
            k += decision.SLL_TotalLook;
          }
          return k;
        }
        /**
         * Gets the total number of LL lookahead operations across all decisions
         * made during parsing. This value is the sum of
         * {@link DecisionInfo#LL_TotalLook} for all decisions.
         */
        getTotalLLLookaheadOps() {
          let decisions = this.atnSimulator.getDecisionInfo();
          let k = 0;
          for (let decision of decisions) {
            k += decision.LL_TotalLook;
          }
          return k;
        }
        /**
         * Gets the total number of ATN lookahead operations for SLL prediction
         * across all decisions made during parsing.
         */
        getTotalSLLATNLookaheadOps() {
          let decisions = this.atnSimulator.getDecisionInfo();
          let k = 0;
          for (let decision of decisions) {
            k += decision.SLL_ATNTransitions;
          }
          return k;
        }
        /**
         * Gets the total number of ATN lookahead operations for LL prediction
         * across all decisions made during parsing.
         */
        getTotalLLATNLookaheadOps() {
          let decisions = this.atnSimulator.getDecisionInfo();
          let k = 0;
          for (let decision of decisions) {
            k += decision.LL_ATNTransitions;
          }
          return k;
        }
        /**
         * Gets the total number of ATN lookahead operations for SLL and LL
         * prediction across all decisions made during parsing.
         *
         * This value is the sum of {@link #getTotalSLLATNLookaheadOps} and
         * {@link #getTotalLLATNLookaheadOps}.
         */
        getTotalATNLookaheadOps() {
          let decisions = this.atnSimulator.getDecisionInfo();
          let k = 0;
          for (let decision of decisions) {
            k += decision.SLL_ATNTransitions;
            k += decision.LL_ATNTransitions;
          }
          return k;
        }
        getDFASize(decision) {
          if (decision) {
            let decisionToDFA = this.atnSimulator.atn.decisionToDFA[decision];
            return decisionToDFA.states.size;
          } else {
            let n = 0;
            let decisionToDFA = this.atnSimulator.atn.decisionToDFA;
            for (let i = 0; i < decisionToDFA.length; i++) {
              n += this.getDFASize(i);
            }
            return n;
          }
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ParseInfo.prototype, "getDecisionInfo", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseInfo.prototype, "getLLDecisions", null);
      ParseInfo = __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParseInfo);
      exports.ParseInfo = ParseInfo;
    }
  });

  // node_modules/antlr4ts/ProxyParserErrorListener.js
  var require_ProxyParserErrorListener = __commonJS({
    "node_modules/antlr4ts/ProxyParserErrorListener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProxyParserErrorListener = void 0;
      var ProxyErrorListener_1 = require_ProxyErrorListener();
      var Decorators_1 = require_Decorators();
      var ProxyParserErrorListener = class extends ProxyErrorListener_1.ProxyErrorListener {
        constructor(delegates) {
          super(delegates);
        }
        reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
          this.getDelegates().forEach((listener) => {
            if (listener.reportAmbiguity) {
              listener.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
            }
          });
        }
        reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
          this.getDelegates().forEach((listener) => {
            if (listener.reportAttemptingFullContext) {
              listener.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
            }
          });
        }
        reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
          this.getDelegates().forEach((listener) => {
            if (listener.reportContextSensitivity) {
              listener.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState);
            }
          });
        }
      };
      __decorate([
        Decorators_1.Override
      ], ProxyParserErrorListener.prototype, "reportAmbiguity", null);
      __decorate([
        Decorators_1.Override
      ], ProxyParserErrorListener.prototype, "reportAttemptingFullContext", null);
      __decorate([
        Decorators_1.Override
      ], ProxyParserErrorListener.prototype, "reportContextSensitivity", null);
      exports.ProxyParserErrorListener = ProxyParserErrorListener;
    }
  });

  // node_modules/antlr4ts/misc/Character.js
  var require_Character = __commonJS({
    "node_modules/antlr4ts/misc/Character.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isSupplementaryCodePoint = exports.isLowSurrogate = exports.isHighSurrogate = void 0;
      function isHighSurrogate(ch) {
        return ch >= 55296 && ch <= 56319;
      }
      exports.isHighSurrogate = isHighSurrogate;
      function isLowSurrogate(ch) {
        return ch >= 56320 && ch <= 57343;
      }
      exports.isLowSurrogate = isLowSurrogate;
      function isSupplementaryCodePoint(ch) {
        return ch >= 65536;
      }
      exports.isSupplementaryCodePoint = isSupplementaryCodePoint;
    }
  });

  // node_modules/antlr4ts/CodePointBuffer.js
  var require_CodePointBuffer = __commonJS({
    "node_modules/antlr4ts/CodePointBuffer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CodePointBuffer = void 0;
      var assert = require_assert();
      var Character = require_Character();
      var CodePointBuffer = class _CodePointBuffer {
        constructor(buffer, size) {
          this.buffer = buffer;
          this._position = 0;
          this._size = size;
        }
        static withArray(buffer) {
          return new _CodePointBuffer(buffer, buffer.length);
        }
        get position() {
          return this._position;
        }
        set position(newPosition) {
          if (newPosition < 0 || newPosition > this._size) {
            throw new RangeError();
          }
          this._position = newPosition;
        }
        get remaining() {
          return this._size - this.position;
        }
        get(offset) {
          return this.buffer[offset];
        }
        array() {
          return this.buffer.slice(0, this._size);
        }
        static builder(initialBufferSize) {
          return new _CodePointBuffer.Builder(initialBufferSize);
        }
      };
      exports.CodePointBuffer = CodePointBuffer;
      (function(CodePointBuffer2) {
        let Type;
        (function(Type2) {
          Type2[Type2["BYTE"] = 0] = "BYTE";
          Type2[Type2["CHAR"] = 1] = "CHAR";
          Type2[Type2["INT"] = 2] = "INT";
        })(Type || (Type = {}));
        class Builder {
          constructor(initialBufferSize) {
            this.type = 0;
            this.buffer = new Uint8Array(initialBufferSize);
            this.prevHighSurrogate = -1;
            this.position = 0;
          }
          build() {
            return new CodePointBuffer2(this.buffer, this.position);
          }
          static roundUpToNextPowerOfTwo(i) {
            let nextPowerOfTwo = 32 - Math.clz32(i - 1);
            return Math.pow(2, nextPowerOfTwo);
          }
          ensureRemaining(remainingNeeded) {
            switch (this.type) {
              case 0:
                if (this.buffer.length - this.position < remainingNeeded) {
                  let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                  let newBuffer = new Uint8Array(newCapacity);
                  newBuffer.set(this.buffer.subarray(0, this.position), 0);
                  this.buffer = newBuffer;
                }
                break;
              case 1:
                if (this.buffer.length - this.position < remainingNeeded) {
                  let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                  let newBuffer = new Uint16Array(newCapacity);
                  newBuffer.set(this.buffer.subarray(0, this.position), 0);
                  this.buffer = newBuffer;
                }
                break;
              case 2:
                if (this.buffer.length - this.position < remainingNeeded) {
                  let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                  let newBuffer = new Int32Array(newCapacity);
                  newBuffer.set(this.buffer.subarray(0, this.position), 0);
                  this.buffer = newBuffer;
                }
                break;
            }
          }
          append(utf16In) {
            this.ensureRemaining(utf16In.length);
            this.appendArray(utf16In);
          }
          appendArray(utf16In) {
            switch (this.type) {
              case 0:
                this.appendArrayByte(utf16In);
                break;
              case 1:
                this.appendArrayChar(utf16In);
                break;
              case 2:
                this.appendArrayInt(utf16In);
                break;
            }
          }
          appendArrayByte(utf16In) {
            assert(this.prevHighSurrogate === -1);
            let input = utf16In;
            let inOffset = 0;
            let inLimit = utf16In.length;
            let outByte = this.buffer;
            let outOffset = this.position;
            while (inOffset < inLimit) {
              let c = input[inOffset];
              if (c <= 255) {
                outByte[outOffset] = c;
              } else {
                utf16In = utf16In.subarray(inOffset, inLimit);
                this.position = outOffset;
                if (!Character.isHighSurrogate(c)) {
                  this.byteToCharBuffer(utf16In.length);
                  this.appendArrayChar(utf16In);
                  return;
                } else {
                  this.byteToIntBuffer(utf16In.length);
                  this.appendArrayInt(utf16In);
                  return;
                }
              }
              inOffset++;
              outOffset++;
            }
            this.position = outOffset;
          }
          appendArrayChar(utf16In) {
            assert(this.prevHighSurrogate === -1);
            let input = utf16In;
            let inOffset = 0;
            let inLimit = utf16In.length;
            let outChar = this.buffer;
            let outOffset = this.position;
            while (inOffset < inLimit) {
              let c = input[inOffset];
              if (!Character.isHighSurrogate(c)) {
                outChar[outOffset] = c;
              } else {
                utf16In = utf16In.subarray(inOffset, inLimit);
                this.position = outOffset;
                this.charToIntBuffer(utf16In.length);
                this.appendArrayInt(utf16In);
                return;
              }
              inOffset++;
              outOffset++;
            }
            this.position = outOffset;
          }
          appendArrayInt(utf16In) {
            let input = utf16In;
            let inOffset = 0;
            let inLimit = utf16In.length;
            let outInt = this.buffer;
            let outOffset = this.position;
            while (inOffset < inLimit) {
              let c = input[inOffset];
              inOffset++;
              if (this.prevHighSurrogate !== -1) {
                if (Character.isLowSurrogate(c)) {
                  outInt[outOffset] = String.fromCharCode(this.prevHighSurrogate, c).codePointAt(0);
                  outOffset++;
                  this.prevHighSurrogate = -1;
                } else {
                  outInt[outOffset] = this.prevHighSurrogate;
                  outOffset++;
                  if (Character.isHighSurrogate(c)) {
                    this.prevHighSurrogate = c;
                  } else {
                    outInt[outOffset] = c;
                    outOffset++;
                    this.prevHighSurrogate = -1;
                  }
                }
              } else if (Character.isHighSurrogate(c)) {
                this.prevHighSurrogate = c;
              } else {
                outInt[outOffset] = c;
                outOffset++;
              }
            }
            if (this.prevHighSurrogate !== -1) {
              outInt[outOffset] = this.prevHighSurrogate;
              outOffset++;
            }
            this.position = outOffset;
          }
          byteToCharBuffer(toAppend) {
            let newBuffer = new Uint16Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
            newBuffer.set(this.buffer.subarray(0, this.position), 0);
            this.type = 1;
            this.buffer = newBuffer;
          }
          byteToIntBuffer(toAppend) {
            let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 2));
            newBuffer.set(this.buffer.subarray(0, this.position), 0);
            this.type = 2;
            this.buffer = newBuffer;
          }
          charToIntBuffer(toAppend) {
            let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
            newBuffer.set(this.buffer.subarray(0, this.position), 0);
            this.type = 2;
            this.buffer = newBuffer;
          }
        }
        CodePointBuffer2.Builder = Builder;
      })(CodePointBuffer = exports.CodePointBuffer || (exports.CodePointBuffer = {}));
    }
  });

  // node_modules/antlr4ts/CodePointCharStream.js
  var require_CodePointCharStream = __commonJS({
    "node_modules/antlr4ts/CodePointCharStream.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CodePointCharStream = void 0;
      var assert = require_assert();
      var IntStream_1 = require_IntStream();
      var Interval_1 = require_Interval();
      var Decorators_1 = require_Decorators();
      var CodePointCharStream = class _CodePointCharStream {
        // Use the factory method {@link #fromBuffer(CodePointBuffer)} to
        // construct instances of this type.
        constructor(array2, position, remaining, name) {
          assert(position === 0);
          this._array = array2;
          this._size = remaining;
          this._name = name;
          this._position = 0;
        }
        get internalStorage() {
          return this._array;
        }
        static fromBuffer(codePointBuffer, name) {
          if (name === void 0 || name.length === 0) {
            name = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
          }
          return new _CodePointCharStream(codePointBuffer.array(), codePointBuffer.position, codePointBuffer.remaining, name);
        }
        consume() {
          if (this._size - this._position === 0) {
            assert(this.LA(1) === IntStream_1.IntStream.EOF);
            throw new RangeError("cannot consume EOF");
          }
          this._position++;
        }
        get index() {
          return this._position;
        }
        get size() {
          return this._size;
        }
        /** mark/release do nothing; we have entire buffer */
        mark() {
          return -1;
        }
        release(marker) {
        }
        seek(index) {
          this._position = index;
        }
        get sourceName() {
          return this._name;
        }
        toString() {
          return this.getText(Interval_1.Interval.of(0, this.size - 1));
        }
        LA(i) {
          let offset;
          switch (Math.sign(i)) {
            case -1:
              offset = this.index + i;
              if (offset < 0) {
                return IntStream_1.IntStream.EOF;
              }
              return this._array[offset];
            case 0:
              return 0;
            case 1:
              offset = this.index + i - 1;
              if (offset >= this.size) {
                return IntStream_1.IntStream.EOF;
              }
              return this._array[offset];
          }
          throw new RangeError("Not reached");
        }
        /** Return the UTF-16 encoded string for the given interval */
        getText(interval) {
          const startIdx = Math.min(interval.a, this.size);
          const len = Math.min(interval.b - interval.a + 1, this.size - startIdx);
          if (this._array instanceof Int32Array) {
            return String.fromCodePoint(...Array.from(this._array.subarray(startIdx, startIdx + len)));
          } else {
            return String.fromCharCode(...Array.from(this._array.subarray(startIdx, startIdx + len)));
          }
        }
      };
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "consume", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "index", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "mark", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "release", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "seek", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "sourceName", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "toString", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "LA", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "getText", null);
      exports.CodePointCharStream = CodePointCharStream;
    }
  });

  // node_modules/antlr4ts/CharStreams.js
  var require_CharStreams = __commonJS({
    "node_modules/antlr4ts/CharStreams.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CharStreams = void 0;
      var CodePointBuffer_1 = require_CodePointBuffer();
      var CodePointCharStream_1 = require_CodePointCharStream();
      var IntStream_1 = require_IntStream();
      var CharStreams2;
      (function(CharStreams3) {
        function fromString2(s, sourceName) {
          if (sourceName === void 0 || sourceName.length === 0) {
            sourceName = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
          }
          let codePointBufferBuilder = CodePointBuffer_1.CodePointBuffer.builder(s.length);
          let cb = new Uint16Array(s.length);
          for (let i = 0; i < s.length; i++) {
            cb[i] = s.charCodeAt(i);
          }
          codePointBufferBuilder.append(cb);
          return CodePointCharStream_1.CodePointCharStream.fromBuffer(codePointBufferBuilder.build(), sourceName);
        }
        CharStreams3.fromString = fromString2;
      })(CharStreams2 = exports.CharStreams || (exports.CharStreams = {}));
    }
  });

  // node_modules/antlr4ts/BufferedTokenStream.js
  var require_BufferedTokenStream = __commonJS({
    "node_modules/antlr4ts/BufferedTokenStream.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BufferedTokenStream = void 0;
      var assert = require_assert();
      var CommonToken_1 = require_CommonToken();
      var Interval_1 = require_Interval();
      var Lexer_1 = require_Lexer();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var BufferedTokenStream = class BufferedTokenStream {
        constructor(tokenSource) {
          this.tokens = [];
          this.p = -1;
          this.fetchedEOF = false;
          if (tokenSource == null) {
            throw new Error("tokenSource cannot be null");
          }
          this._tokenSource = tokenSource;
        }
        get tokenSource() {
          return this._tokenSource;
        }
        /** Reset this token stream by setting its token source. */
        set tokenSource(tokenSource) {
          this._tokenSource = tokenSource;
          this.tokens.length = 0;
          this.p = -1;
          this.fetchedEOF = false;
        }
        get index() {
          return this.p;
        }
        mark() {
          return 0;
        }
        release(marker) {
        }
        seek(index) {
          this.lazyInit();
          this.p = this.adjustSeekIndex(index);
        }
        get size() {
          return this.tokens.length;
        }
        consume() {
          let skipEofCheck;
          if (this.p >= 0) {
            if (this.fetchedEOF) {
              skipEofCheck = this.p < this.tokens.length - 1;
            } else {
              skipEofCheck = this.p < this.tokens.length;
            }
          } else {
            skipEofCheck = false;
          }
          if (!skipEofCheck && this.LA(1) === Token_1.Token.EOF) {
            throw new Error("cannot consume EOF");
          }
          if (this.sync(this.p + 1)) {
            this.p = this.adjustSeekIndex(this.p + 1);
          }
        }
        /** Make sure index `i` in tokens has a token.
         *
         * @returns `true` if a token is located at index `i`, otherwise
         *    `false`.
         * @see #get(int i)
         */
        sync(i) {
          assert(i >= 0);
          let n = i - this.tokens.length + 1;
          if (n > 0) {
            let fetched = this.fetch(n);
            return fetched >= n;
          }
          return true;
        }
        /** Add `n` elements to buffer.
         *
         * @returns The actual number of elements added to the buffer.
         */
        fetch(n) {
          if (this.fetchedEOF) {
            return 0;
          }
          for (let i = 0; i < n; i++) {
            let t = this.tokenSource.nextToken();
            if (this.isWritableToken(t)) {
              t.tokenIndex = this.tokens.length;
            }
            this.tokens.push(t);
            if (t.type === Token_1.Token.EOF) {
              this.fetchedEOF = true;
              return i + 1;
            }
          }
          return n;
        }
        get(i) {
          if (i < 0 || i >= this.tokens.length) {
            throw new RangeError("token index " + i + " out of range 0.." + (this.tokens.length - 1));
          }
          return this.tokens[i];
        }
        /** Get all tokens from start..stop inclusively. */
        getRange(start, stop) {
          if (start < 0 || stop < 0) {
            return [];
          }
          this.lazyInit();
          let subset = new Array();
          if (stop >= this.tokens.length) {
            stop = this.tokens.length - 1;
          }
          for (let i = start; i <= stop; i++) {
            let t = this.tokens[i];
            if (t.type === Token_1.Token.EOF) {
              break;
            }
            subset.push(t);
          }
          return subset;
        }
        LA(i) {
          let token = this.LT(i);
          if (!token) {
            return Token_1.Token.INVALID_TYPE;
          }
          return token.type;
        }
        tryLB(k) {
          if (this.p - k < 0) {
            return void 0;
          }
          return this.tokens[this.p - k];
        }
        LT(k) {
          let result = this.tryLT(k);
          if (result === void 0) {
            throw new RangeError("requested lookback index out of range");
          }
          return result;
        }
        tryLT(k) {
          this.lazyInit();
          if (k === 0) {
            throw new RangeError("0 is not a valid lookahead index");
          }
          if (k < 0) {
            return this.tryLB(-k);
          }
          let i = this.p + k - 1;
          this.sync(i);
          if (i >= this.tokens.length) {
            return this.tokens[this.tokens.length - 1];
          }
          return this.tokens[i];
        }
        /**
         * Allowed derived classes to modify the behavior of operations which change
         * the current stream position by adjusting the target token index of a seek
         * operation. The default implementation simply returns `i`. If an
         * exception is thrown in this method, the current stream index should not be
         * changed.
         *
         * For example, {@link CommonTokenStream} overrides this method to ensure that
         * the seek target is always an on-channel token.
         *
         * @param i The target token index.
         * @returns The adjusted target token index.
         */
        adjustSeekIndex(i) {
          return i;
        }
        lazyInit() {
          if (this.p === -1) {
            this.setup();
          }
        }
        setup() {
          this.sync(0);
          this.p = this.adjustSeekIndex(0);
        }
        /** Given a start and stop index, return a `List` of all tokens in
         *  the token type `BitSet`.  Return an empty array if no tokens were found.  This
         *  method looks at both on and off channel tokens.
         */
        getTokens(start, stop, types) {
          this.lazyInit();
          if (start === void 0) {
            assert(stop === void 0 && types === void 0);
            return this.tokens;
          } else if (stop === void 0) {
            stop = this.tokens.length - 1;
          }
          if (start < 0 || stop >= this.tokens.length || stop < 0 || start >= this.tokens.length) {
            throw new RangeError("start " + start + " or stop " + stop + " not in 0.." + (this.tokens.length - 1));
          }
          if (start > stop) {
            return [];
          }
          if (types === void 0) {
            return this.tokens.slice(start, stop + 1);
          } else if (typeof types === "number") {
            types = (/* @__PURE__ */ new Set()).add(types);
          }
          let typesSet = types;
          let filteredTokens = this.tokens.slice(start, stop + 1);
          filteredTokens = filteredTokens.filter((value) => typesSet.has(value.type));
          return filteredTokens;
        }
        /**
         * Given a starting index, return the index of the next token on channel.
         * Return `i` if `tokens[i]` is on channel. Return the index of
         * the EOF token if there are no tokens on channel between `i` and
         * EOF.
         */
        nextTokenOnChannel(i, channel) {
          this.sync(i);
          if (i >= this.size) {
            return this.size - 1;
          }
          let token = this.tokens[i];
          while (token.channel !== channel) {
            if (token.type === Token_1.Token.EOF) {
              return i;
            }
            i++;
            this.sync(i);
            token = this.tokens[i];
          }
          return i;
        }
        /**
         * Given a starting index, return the index of the previous token on
         * channel. Return `i` if `tokens[i]` is on channel. Return -1
         * if there are no tokens on channel between `i` and 0.
         *
         * If `i` specifies an index at or after the EOF token, the EOF token
         * index is returned. This is due to the fact that the EOF token is treated
         * as though it were on every channel.
         */
        previousTokenOnChannel(i, channel) {
          this.sync(i);
          if (i >= this.size) {
            return this.size - 1;
          }
          while (i >= 0) {
            let token = this.tokens[i];
            if (token.type === Token_1.Token.EOF || token.channel === channel) {
              return i;
            }
            i--;
          }
          return i;
        }
        /** Collect all tokens on specified channel to the right of
         *  the current token up until we see a token on {@link Lexer#DEFAULT_TOKEN_CHANNEL} or
         *  EOF. If `channel` is `-1`, find any non default channel token.
         */
        getHiddenTokensToRight(tokenIndex, channel = -1) {
          this.lazyInit();
          if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
            throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
          }
          let nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
          let to;
          let from = tokenIndex + 1;
          if (nextOnChannel === -1) {
            to = this.size - 1;
          } else {
            to = nextOnChannel;
          }
          return this.filterForChannel(from, to, channel);
        }
        /** Collect all tokens on specified channel to the left of
         *  the current token up until we see a token on {@link Lexer#DEFAULT_TOKEN_CHANNEL}.
         *  If `channel` is `-1`, find any non default channel token.
         */
        getHiddenTokensToLeft(tokenIndex, channel = -1) {
          this.lazyInit();
          if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
            throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
          }
          if (tokenIndex === 0) {
            return [];
          }
          let prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
          if (prevOnChannel === tokenIndex - 1) {
            return [];
          }
          let from = prevOnChannel + 1;
          let to = tokenIndex - 1;
          return this.filterForChannel(from, to, channel);
        }
        filterForChannel(from, to, channel) {
          let hidden = new Array();
          for (let i = from; i <= to; i++) {
            let t = this.tokens[i];
            if (channel === -1) {
              if (t.channel !== Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL) {
                hidden.push(t);
              }
            } else {
              if (t.channel === channel) {
                hidden.push(t);
              }
            }
          }
          return hidden;
        }
        get sourceName() {
          return this.tokenSource.sourceName;
        }
        getText(interval) {
          if (interval === void 0) {
            interval = Interval_1.Interval.of(0, this.size - 1);
          } else if (!(interval instanceof Interval_1.Interval)) {
            interval = interval.sourceInterval;
          }
          let start = interval.a;
          let stop = interval.b;
          if (start < 0 || stop < 0) {
            return "";
          }
          this.fill();
          if (stop >= this.tokens.length) {
            stop = this.tokens.length - 1;
          }
          let buf = "";
          for (let i = start; i <= stop; i++) {
            let t = this.tokens[i];
            if (t.type === Token_1.Token.EOF) {
              break;
            }
            buf += t.text;
          }
          return buf.toString();
        }
        getTextFromRange(start, stop) {
          if (this.isToken(start) && this.isToken(stop)) {
            return this.getText(Interval_1.Interval.of(start.tokenIndex, stop.tokenIndex));
          }
          return "";
        }
        /** Get all tokens from lexer until EOF. */
        fill() {
          this.lazyInit();
          const blockSize = 1e3;
          while (true) {
            let fetched = this.fetch(blockSize);
            if (fetched < blockSize) {
              return;
            }
          }
        }
        // TODO: Figure out a way to make this more flexible?
        isWritableToken(t) {
          return t instanceof CommonToken_1.CommonToken;
        }
        // TODO: Figure out a way to make this more flexible?
        isToken(t) {
          return t instanceof CommonToken_1.CommonToken;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], BufferedTokenStream.prototype, "_tokenSource", void 0);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "tokenSource", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "index", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "mark", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "release", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "seek", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "consume", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "get", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "LA", null);
      __decorate([
        Decorators_1.NotNull,
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "LT", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "sourceName", null);
      __decorate([
        Decorators_1.NotNull,
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "getText", null);
      __decorate([
        Decorators_1.NotNull,
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "getTextFromRange", null);
      BufferedTokenStream = __decorate([
        __param(0, Decorators_1.NotNull)
      ], BufferedTokenStream);
      exports.BufferedTokenStream = BufferedTokenStream;
    }
  });

  // node_modules/antlr4ts/CommonTokenStream.js
  var require_CommonTokenStream = __commonJS({
    "node_modules/antlr4ts/CommonTokenStream.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommonTokenStream = void 0;
      var BufferedTokenStream_1 = require_BufferedTokenStream();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var CommonTokenStream2 = class CommonTokenStream extends BufferedTokenStream_1.BufferedTokenStream {
        /**
         * Constructs a new {@link CommonTokenStream} using the specified token
         * source and filtering tokens to the specified channel. Only tokens whose
         * {@link Token#getChannel} matches `channel` or have the
         * `Token.type` equal to {@link Token#EOF} will be returned by the
         * token stream lookahead methods.
         *
         * @param tokenSource The token source.
         * @param channel The channel to use for filtering tokens.
         */
        constructor(tokenSource, channel = Token_1.Token.DEFAULT_CHANNEL) {
          super(tokenSource);
          this.channel = channel;
        }
        adjustSeekIndex(i) {
          return this.nextTokenOnChannel(i, this.channel);
        }
        tryLB(k) {
          if (this.p - k < 0) {
            return void 0;
          }
          let i = this.p;
          let n = 1;
          while (n <= k && i > 0) {
            i = this.previousTokenOnChannel(i - 1, this.channel);
            n++;
          }
          if (i < 0) {
            return void 0;
          }
          return this.tokens[i];
        }
        tryLT(k) {
          this.lazyInit();
          if (k === 0) {
            throw new RangeError("0 is not a valid lookahead index");
          }
          if (k < 0) {
            return this.tryLB(-k);
          }
          let i = this.p;
          let n = 1;
          while (n < k) {
            if (this.sync(i + 1)) {
              i = this.nextTokenOnChannel(i + 1, this.channel);
            }
            n++;
          }
          return this.tokens[i];
        }
        /** Count EOF just once. */
        getNumberOfOnChannelTokens() {
          let n = 0;
          this.fill();
          for (let t of this.tokens) {
            if (t.channel === this.channel) {
              n++;
            }
            if (t.type === Token_1.Token.EOF) {
              break;
            }
          }
          return n;
        }
      };
      __decorate([
        Decorators_1.Override
      ], CommonTokenStream2.prototype, "adjustSeekIndex", null);
      __decorate([
        Decorators_1.Override
      ], CommonTokenStream2.prototype, "tryLB", null);
      __decorate([
        Decorators_1.Override
      ], CommonTokenStream2.prototype, "tryLT", null);
      CommonTokenStream2 = __decorate([
        __param(0, Decorators_1.NotNull)
      ], CommonTokenStream2);
      exports.CommonTokenStream = CommonTokenStream2;
    }
  });

  // node_modules/antlr4ts/ListTokenSource.js
  var require_ListTokenSource = __commonJS({
    "node_modules/antlr4ts/ListTokenSource.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ListTokenSource = void 0;
      var CommonTokenFactory_1 = require_CommonTokenFactory();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var ListTokenSource = class ListTokenSource {
        /**
         * Constructs a new {@link ListTokenSource} instance from the specified
         * collection of {@link Token} objects and source name.
         *
         * @param tokens The collection of {@link Token} objects to provide as a
         * {@link TokenSource}.
         * @param sourceName The name of the {@link TokenSource}. If this value is
         * `undefined`, {@link #getSourceName} will attempt to infer the name from
         * the next {@link Token} (or the previous token if the end of the input has
         * been reached).
         *
         * @exception NullPointerException if `tokens` is `undefined`
         */
        constructor(tokens, sourceName) {
          this.i = 0;
          this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
          if (tokens == null) {
            throw new Error("tokens cannot be null");
          }
          this.tokens = tokens;
          this._sourceName = sourceName;
        }
        /**
         * {@inheritDoc}
         */
        get charPositionInLine() {
          if (this.i < this.tokens.length) {
            return this.tokens[this.i].charPositionInLine;
          } else if (this.eofToken != null) {
            return this.eofToken.charPositionInLine;
          } else if (this.tokens.length > 0) {
            let lastToken = this.tokens[this.tokens.length - 1];
            let tokenText = lastToken.text;
            if (tokenText != null) {
              let lastNewLine = tokenText.lastIndexOf("\n");
              if (lastNewLine >= 0) {
                return tokenText.length - lastNewLine - 1;
              }
            }
            return lastToken.charPositionInLine + lastToken.stopIndex - lastToken.startIndex + 1;
          }
          return 0;
        }
        /**
         * {@inheritDoc}
         */
        nextToken() {
          if (this.i >= this.tokens.length) {
            if (this.eofToken == null) {
              let start = -1;
              if (this.tokens.length > 0) {
                let previousStop = this.tokens[this.tokens.length - 1].stopIndex;
                if (previousStop !== -1) {
                  start = previousStop + 1;
                }
              }
              let stop = Math.max(-1, start - 1);
              this.eofToken = this._factory.create({ source: this, stream: this.inputStream }, Token_1.Token.EOF, "EOF", Token_1.Token.DEFAULT_CHANNEL, start, stop, this.line, this.charPositionInLine);
            }
            return this.eofToken;
          }
          let t = this.tokens[this.i];
          if (this.i === this.tokens.length - 1 && t.type === Token_1.Token.EOF) {
            this.eofToken = t;
          }
          this.i++;
          return t;
        }
        /**
         * {@inheritDoc}
         */
        get line() {
          if (this.i < this.tokens.length) {
            return this.tokens[this.i].line;
          } else if (this.eofToken != null) {
            return this.eofToken.line;
          } else if (this.tokens.length > 0) {
            let lastToken = this.tokens[this.tokens.length - 1];
            let line = lastToken.line;
            let tokenText = lastToken.text;
            if (tokenText != null) {
              for (let i = 0; i < tokenText.length; i++) {
                if (tokenText.charAt(i) === "\n") {
                  line++;
                }
              }
            }
            return line;
          }
          return 1;
        }
        /**
         * {@inheritDoc}
         */
        get inputStream() {
          if (this.i < this.tokens.length) {
            return this.tokens[this.i].inputStream;
          } else if (this.eofToken != null) {
            return this.eofToken.inputStream;
          } else if (this.tokens.length > 0) {
            return this.tokens[this.tokens.length - 1].inputStream;
          }
          return void 0;
        }
        /**
         * {@inheritDoc}
         */
        get sourceName() {
          if (this._sourceName) {
            return this._sourceName;
          }
          let inputStream = this.inputStream;
          if (inputStream != null) {
            return inputStream.sourceName;
          }
          return "List";
        }
        /**
         * {@inheritDoc}
         */
        // @Override
        set tokenFactory(factory) {
          this._factory = factory;
        }
        /**
         * {@inheritDoc}
         */
        get tokenFactory() {
          return this._factory;
        }
      };
      __decorate([
        Decorators_1.Override
      ], ListTokenSource.prototype, "charPositionInLine", null);
      __decorate([
        Decorators_1.Override
      ], ListTokenSource.prototype, "nextToken", null);
      __decorate([
        Decorators_1.Override
      ], ListTokenSource.prototype, "line", null);
      __decorate([
        Decorators_1.Override
      ], ListTokenSource.prototype, "inputStream", null);
      __decorate([
        Decorators_1.Override
      ], ListTokenSource.prototype, "sourceName", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], ListTokenSource.prototype, "tokenFactory", null);
      ListTokenSource = __decorate([
        __param(0, Decorators_1.NotNull)
      ], ListTokenSource);
      exports.ListTokenSource = ListTokenSource;
    }
  });

  // node_modules/antlr4ts/misc/MultiMap.js
  var require_MultiMap = __commonJS({
    "node_modules/antlr4ts/misc/MultiMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MultiMap = void 0;
      var MultiMap = class extends Map {
        constructor() {
          super();
        }
        map(key, value) {
          let elementsForKey = super.get(key);
          if (!elementsForKey) {
            elementsForKey = [];
            super.set(key, elementsForKey);
          }
          elementsForKey.push(value);
        }
        getPairs() {
          let pairs = [];
          this.forEach((values, key) => {
            values.forEach((v) => {
              pairs.push([key, v]);
            });
          });
          return pairs;
        }
      };
      exports.MultiMap = MultiMap;
    }
  });

  // node_modules/antlr4ts/misc/ParseCancellationException.js
  var require_ParseCancellationException = __commonJS({
    "node_modules/antlr4ts/misc/ParseCancellationException.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParseCancellationException = void 0;
      var ParseCancellationException = class extends Error {
        constructor(cause) {
          super(cause.message);
          this.cause = cause;
          this.stack = cause.stack;
        }
        getCause() {
          return this.cause;
        }
      };
      exports.ParseCancellationException = ParseCancellationException;
    }
  });

  // node_modules/antlr4ts/InterpreterRuleContext.js
  var require_InterpreterRuleContext = __commonJS({
    "node_modules/antlr4ts/InterpreterRuleContext.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InterpreterRuleContext = void 0;
      var Decorators_1 = require_Decorators();
      var ParserRuleContext_1 = require_ParserRuleContext();
      var InterpreterRuleContext = class extends ParserRuleContext_1.ParserRuleContext {
        constructor(ruleIndex, parent, invokingStateNumber) {
          if (invokingStateNumber !== void 0) {
            super(parent, invokingStateNumber);
          } else {
            super();
          }
          this._ruleIndex = ruleIndex;
        }
        get ruleIndex() {
          return this._ruleIndex;
        }
      };
      __decorate([
        Decorators_1.Override
      ], InterpreterRuleContext.prototype, "ruleIndex", null);
      exports.InterpreterRuleContext = InterpreterRuleContext;
    }
  });

  // node_modules/antlr4ts/ParserInterpreter.js
  var require_ParserInterpreter = __commonJS({
    "node_modules/antlr4ts/ParserInterpreter.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParserInterpreter = void 0;
      var ATNState_1 = require_ATNState();
      var ATNStateType_1 = require_ATNStateType();
      var BitSet_1 = require_BitSet();
      var FailedPredicateException_1 = require_FailedPredicateException();
      var InputMismatchException_1 = require_InputMismatchException();
      var InterpreterRuleContext_1 = require_InterpreterRuleContext();
      var LoopEndState_1 = require_LoopEndState();
      var Decorators_1 = require_Decorators();
      var Decorators_2 = require_Decorators();
      var Parser_1 = require_Parser();
      var ParserATNSimulator_1 = require_ParserATNSimulator();
      var RecognitionException_1 = require_RecognitionException();
      var StarLoopEntryState_1 = require_StarLoopEntryState();
      var Token_1 = require_Token();
      var ParserInterpreter = class ParserInterpreter2 extends Parser_1.Parser {
        constructor(grammarFileName, vocabulary, ruleNames, atn, input) {
          super(grammarFileName instanceof ParserInterpreter2 ? grammarFileName.inputStream : input);
          this._parentContextStack = [];
          this.overrideDecision = -1;
          this.overrideDecisionInputIndex = -1;
          this.overrideDecisionAlt = -1;
          this.overrideDecisionReached = false;
          this._overrideDecisionRoot = void 0;
          if (grammarFileName instanceof ParserInterpreter2) {
            let old = grammarFileName;
            this._grammarFileName = old._grammarFileName;
            this._atn = old._atn;
            this.pushRecursionContextStates = old.pushRecursionContextStates;
            this._ruleNames = old._ruleNames;
            this._vocabulary = old._vocabulary;
            this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this._atn, this);
          } else {
            vocabulary = vocabulary;
            ruleNames = ruleNames;
            atn = atn;
            this._grammarFileName = grammarFileName;
            this._atn = atn;
            this._ruleNames = ruleNames.slice(0);
            this._vocabulary = vocabulary;
            this.pushRecursionContextStates = new BitSet_1.BitSet(atn.states.length);
            for (let state of atn.states) {
              if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
                continue;
              }
              if (state.precedenceRuleDecision) {
                this.pushRecursionContextStates.set(state.stateNumber);
              }
            }
            this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(atn, this);
          }
        }
        reset(resetInput) {
          if (resetInput === void 0) {
            super.reset();
          } else {
            super.reset(resetInput);
          }
          this.overrideDecisionReached = false;
          this._overrideDecisionRoot = void 0;
        }
        get atn() {
          return this._atn;
        }
        get vocabulary() {
          return this._vocabulary;
        }
        get ruleNames() {
          return this._ruleNames;
        }
        get grammarFileName() {
          return this._grammarFileName;
        }
        /** Begin parsing at startRuleIndex */
        parse(startRuleIndex) {
          let startRuleStartState = this._atn.ruleToStartState[startRuleIndex];
          this._rootContext = this.createInterpreterRuleContext(void 0, ATNState_1.ATNState.INVALID_STATE_NUMBER, startRuleIndex);
          if (startRuleStartState.isPrecedenceRule) {
            this.enterRecursionRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);
          } else {
            this.enterRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex);
          }
          while (true) {
            let p = this.atnState;
            switch (p.stateType) {
              case ATNStateType_1.ATNStateType.RULE_STOP:
                if (this._ctx.isEmpty) {
                  if (startRuleStartState.isPrecedenceRule) {
                    let result = this._ctx;
                    let parentContext = this._parentContextStack.pop();
                    this.unrollRecursionContexts(parentContext[0]);
                    return result;
                  } else {
                    this.exitRule();
                    return this._rootContext;
                  }
                }
                this.visitRuleStopState(p);
                break;
              default:
                try {
                  this.visitState(p);
                } catch (e) {
                  if (e instanceof RecognitionException_1.RecognitionException) {
                    this.state = this._atn.ruleToStopState[p.ruleIndex].stateNumber;
                    this.context.exception = e;
                    this.errorHandler.reportError(this, e);
                    this.recover(e);
                  } else {
                    throw e;
                  }
                }
                break;
            }
          }
        }
        enterRecursionRule(localctx, state, ruleIndex, precedence) {
          this._parentContextStack.push([this._ctx, localctx.invokingState]);
          super.enterRecursionRule(localctx, state, ruleIndex, precedence);
        }
        get atnState() {
          return this._atn.states[this.state];
        }
        visitState(p) {
          let predictedAlt = 1;
          if (p.numberOfTransitions > 1) {
            predictedAlt = this.visitDecisionState(p);
          }
          let transition = p.transition(predictedAlt - 1);
          switch (transition.serializationType) {
            case 1:
              if (this.pushRecursionContextStates.get(p.stateNumber) && !(transition.target instanceof LoopEndState_1.LoopEndState)) {
                let parentContext = this._parentContextStack[this._parentContextStack.length - 1];
                let localctx = this.createInterpreterRuleContext(parentContext[0], parentContext[1], this._ctx.ruleIndex);
                this.pushNewRecursionContext(localctx, this._atn.ruleToStartState[p.ruleIndex].stateNumber, this._ctx.ruleIndex);
              }
              break;
            case 5:
              this.match(transition._label);
              break;
            case 2:
            case 7:
            case 8:
              if (!transition.matches(this._input.LA(1), Token_1.Token.MIN_USER_TOKEN_TYPE, 65535)) {
                this.recoverInline();
              }
              this.matchWildcard();
              break;
            case 9:
              this.matchWildcard();
              break;
            case 3:
              let ruleStartState = transition.target;
              let ruleIndex = ruleStartState.ruleIndex;
              let newctx = this.createInterpreterRuleContext(this._ctx, p.stateNumber, ruleIndex);
              if (ruleStartState.isPrecedenceRule) {
                this.enterRecursionRule(newctx, ruleStartState.stateNumber, ruleIndex, transition.precedence);
              } else {
                this.enterRule(newctx, transition.target.stateNumber, ruleIndex);
              }
              break;
            case 4:
              let predicateTransition = transition;
              if (!this.sempred(this._ctx, predicateTransition.ruleIndex, predicateTransition.predIndex)) {
                throw new FailedPredicateException_1.FailedPredicateException(this);
              }
              break;
            case 6:
              let actionTransition = transition;
              this.action(this._ctx, actionTransition.ruleIndex, actionTransition.actionIndex);
              break;
            case 10:
              if (!this.precpred(this._ctx, transition.precedence)) {
                let precedence = transition.precedence;
                throw new FailedPredicateException_1.FailedPredicateException(this, `precpred(_ctx, ${precedence})`);
              }
              break;
            default:
              throw new Error("UnsupportedOperationException: Unrecognized ATN transition type.");
          }
          this.state = transition.target.stateNumber;
        }
        /** Method visitDecisionState() is called when the interpreter reaches
         *  a decision state (instance of DecisionState). It gives an opportunity
         *  for subclasses to track interesting things.
         */
        visitDecisionState(p) {
          let predictedAlt;
          this.errorHandler.sync(this);
          let decision = p.decision;
          if (decision === this.overrideDecision && this._input.index === this.overrideDecisionInputIndex && !this.overrideDecisionReached) {
            predictedAlt = this.overrideDecisionAlt;
            this.overrideDecisionReached = true;
          } else {
            predictedAlt = this.interpreter.adaptivePredict(this._input, decision, this._ctx);
          }
          return predictedAlt;
        }
        /** Provide simple "factory" for InterpreterRuleContext's.
         *  @since 4.5.1
         */
        createInterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {
          return new InterpreterRuleContext_1.InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);
        }
        visitRuleStopState(p) {
          let ruleStartState = this._atn.ruleToStartState[p.ruleIndex];
          if (ruleStartState.isPrecedenceRule) {
            let parentContext = this._parentContextStack.pop();
            this.unrollRecursionContexts(parentContext[0]);
            this.state = parentContext[1];
          } else {
            this.exitRule();
          }
          let ruleTransition = this._atn.states[this.state].transition(0);
          this.state = ruleTransition.followState.stateNumber;
        }
        /** Override this parser interpreters normal decision-making process
         *  at a particular decision and input token index. Instead of
         *  allowing the adaptive prediction mechanism to choose the
         *  first alternative within a block that leads to a successful parse,
         *  force it to take the alternative, 1..n for n alternatives.
         *
         *  As an implementation limitation right now, you can only specify one
         *  override. This is sufficient to allow construction of different
         *  parse trees for ambiguous input. It means re-parsing the entire input
         *  in general because you're never sure where an ambiguous sequence would
         *  live in the various parse trees. For example, in one interpretation,
         *  an ambiguous input sequence would be matched completely in expression
         *  but in another it could match all the way back to the root.
         *
         *  s : e '!'? ;
         *  e : ID
         *    | ID '!'
         *    ;
         *
         *  Here, x! can be matched as (s (e ID) !) or (s (e ID !)). In the first
         *  case, the ambiguous sequence is fully contained only by the root.
         *  In the second case, the ambiguous sequences fully contained within just
         *  e, as in: (e ID !).
         *
         *  Rather than trying to optimize this and make
         *  some intelligent decisions for optimization purposes, I settled on
         *  just re-parsing the whole input and then using
         *  {link Trees#getRootOfSubtreeEnclosingRegion} to find the minimal
         *  subtree that contains the ambiguous sequence. I originally tried to
         *  record the call stack at the point the parser detected and ambiguity but
         *  left recursive rules create a parse tree stack that does not reflect
         *  the actual call stack. That impedance mismatch was enough to make
         *  it it challenging to restart the parser at a deeply nested rule
         *  invocation.
         *
         *  Only parser interpreters can override decisions so as to avoid inserting
         *  override checking code in the critical ALL(*) prediction execution path.
         *
         *  @since 4.5
         */
        addDecisionOverride(decision, tokenIndex, forcedAlt) {
          this.overrideDecision = decision;
          this.overrideDecisionInputIndex = tokenIndex;
          this.overrideDecisionAlt = forcedAlt;
        }
        get overrideDecisionRoot() {
          return this._overrideDecisionRoot;
        }
        /** Rely on the error handler for this parser but, if no tokens are consumed
         *  to recover, add an error node. Otherwise, nothing is seen in the parse
         *  tree.
         */
        recover(e) {
          let i = this._input.index;
          this.errorHandler.recover(this, e);
          if (this._input.index === i) {
            let tok = e.getOffendingToken();
            if (!tok) {
              throw new Error("Expected exception to have an offending token");
            }
            let source = tok.tokenSource;
            let stream = source !== void 0 ? source.inputStream : void 0;
            let sourcePair = { source, stream };
            if (e instanceof InputMismatchException_1.InputMismatchException) {
              let expectedTokens = e.expectedTokens;
              if (expectedTokens === void 0) {
                throw new Error("Expected the exception to provide expected tokens");
              }
              let expectedTokenType = Token_1.Token.INVALID_TYPE;
              if (!expectedTokens.isNil) {
                expectedTokenType = expectedTokens.minElement;
              }
              let errToken = this.tokenFactory.create(
                sourcePair,
                expectedTokenType,
                tok.text,
                Token_1.Token.DEFAULT_CHANNEL,
                -1,
                -1,
                // invalid start/stop
                tok.line,
                tok.charPositionInLine
              );
              this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
            } else {
              let source2 = tok.tokenSource;
              let errToken = this.tokenFactory.create(
                sourcePair,
                Token_1.Token.INVALID_TYPE,
                tok.text,
                Token_1.Token.DEFAULT_CHANNEL,
                -1,
                -1,
                // invalid start/stop
                tok.line,
                tok.charPositionInLine
              );
              this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
            }
          }
        }
        recoverInline() {
          return this._errHandler.recoverInline(this);
        }
        /** Return the root of the parse, which can be useful if the parser
         *  bails out. You still can access the top node. Note that,
         *  because of the way left recursive rules add children, it's possible
         *  that the root will not have any children if the start rule immediately
         *  called and left recursive rule that fails.
         *
         * @since 4.5.1
         */
        get rootContext() {
          return this._rootContext;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ParserInterpreter.prototype, "_vocabulary", void 0);
      __decorate([
        Decorators_2.Override
      ], ParserInterpreter.prototype, "reset", null);
      __decorate([
        Decorators_2.Override
      ], ParserInterpreter.prototype, "atn", null);
      __decorate([
        Decorators_2.Override
      ], ParserInterpreter.prototype, "vocabulary", null);
      __decorate([
        Decorators_2.Override
      ], ParserInterpreter.prototype, "ruleNames", null);
      __decorate([
        Decorators_2.Override
      ], ParserInterpreter.prototype, "grammarFileName", null);
      __decorate([
        Decorators_2.Override
      ], ParserInterpreter.prototype, "enterRecursionRule", null);
      ParserInterpreter = __decorate([
        __param(1, Decorators_1.NotNull)
      ], ParserInterpreter);
      exports.ParserInterpreter = ParserInterpreter;
    }
  });

  // node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js
  var require_ParseTreeMatch = __commonJS({
    "node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParseTreeMatch = void 0;
      var Decorators_1 = require_Decorators();
      var ParseTreeMatch = class ParseTreeMatch {
        /**
         * Constructs a new instance of {@link ParseTreeMatch} from the specified
         * parse tree and pattern.
         *
         * @param tree The parse tree to match against the pattern.
         * @param pattern The parse tree pattern.
         * @param labels A mapping from label names to collections of
         * {@link ParseTree} objects located by the tree pattern matching process.
         * @param mismatchedNode The first node which failed to match the tree
         * pattern during the matching process.
         *
         * @throws {@link Error} if `tree` is not defined
         * @throws {@link Error} if `pattern` is not defined
         * @throws {@link Error} if `labels` is not defined
         */
        constructor(tree, pattern, labels, mismatchedNode) {
          if (!tree) {
            throw new Error("tree cannot be null");
          }
          if (!pattern) {
            throw new Error("pattern cannot be null");
          }
          if (!labels) {
            throw new Error("labels cannot be null");
          }
          this._tree = tree;
          this._pattern = pattern;
          this._labels = labels;
          this._mismatchedNode = mismatchedNode;
        }
        /**
         * Get the last node associated with a specific `label`.
         *
         * For example, for pattern `<id:ID>`, `get("id")` returns the
         * node matched for that `ID`. If more than one node
         * matched the specified label, only the last is returned. If there is
         * no node associated with the label, this returns `undefined`.
         *
         * Pattern tags like `<ID>` and `<expr>` without labels are
         * considered to be labeled with `ID` and `expr`, respectively.
         *
         * @param label The label to check.
         *
         * @returns The last {@link ParseTree} to match a tag with the specified
         * label, or `undefined` if no parse tree matched a tag with the label.
         */
        get(label) {
          let parseTrees = this._labels.get(label);
          if (!parseTrees || parseTrees.length === 0) {
            return void 0;
          }
          return parseTrees[parseTrees.length - 1];
        }
        /**
         * Return all nodes matching a rule or token tag with the specified label.
         *
         * If the `label` is the name of a parser rule or token in the
         * grammar, the resulting list will contain both the parse trees matching
         * rule or tags explicitly labeled with the label and the complete set of
         * parse trees matching the labeled and unlabeled tags in the pattern for
         * the parser rule or token. For example, if `label` is `"foo"`,
         * the result will contain *all* of the following.
         *
         * * Parse tree nodes matching tags of the form `<foo:anyRuleName>` and
         *   `<foo:AnyTokenName>`.
         * * Parse tree nodes matching tags of the form `<anyLabel:foo>`.
         * * Parse tree nodes matching tags of the form `<foo>`.
         *
         * @param label The label.
         *
         * @returns A collection of all {@link ParseTree} nodes matching tags with
         * the specified `label`. If no nodes matched the label, an empty list
         * is returned.
         */
        getAll(label) {
          const nodes = this._labels.get(label);
          if (!nodes) {
            return [];
          }
          return nodes;
        }
        /**
         * Return a mapping from label &rarr; [list of nodes].
         *
         * The map includes special entries corresponding to the names of rules and
         * tokens referenced in tags in the original pattern. For additional
         * information, see the description of {@link #getAll(String)}.
         *
         * @returns A mapping from labels to parse tree nodes. If the parse tree
         * pattern did not contain any rule or token tags, this map will be empty.
         */
        get labels() {
          return this._labels;
        }
        /**
         * Get the node at which we first detected a mismatch.
         *
         * @returns the node at which we first detected a mismatch, or `undefined`
         * if the match was successful.
         */
        get mismatchedNode() {
          return this._mismatchedNode;
        }
        /**
         * Gets a value indicating whether the match operation succeeded.
         *
         * @returns `true` if the match operation succeeded; otherwise,
         * `false`.
         */
        get succeeded() {
          return !this._mismatchedNode;
        }
        /**
         * Get the tree pattern we are matching against.
         *
         * @returns The tree pattern we are matching against.
         */
        get pattern() {
          return this._pattern;
        }
        /**
         * Get the parse tree we are trying to match to a pattern.
         *
         * @returns The {@link ParseTree} we are trying to match to a pattern.
         */
        get tree() {
          return this._tree;
        }
        /**
         * {@inheritDoc}
         */
        toString() {
          return `Match ${this.succeeded ? "succeeded" : "failed"}; found ${this.labels.size} labels`;
        }
      };
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], ParseTreeMatch.prototype, "getAll", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreeMatch.prototype, "labels", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreeMatch.prototype, "pattern", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreeMatch.prototype, "tree", null);
      __decorate([
        Decorators_1.Override
      ], ParseTreeMatch.prototype, "toString", null);
      ParseTreeMatch = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ParseTreeMatch);
      exports.ParseTreeMatch = ParseTreeMatch;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathLexer.js
  var require_XPathLexer = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathLexer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathLexer = void 0;
      var ATNDeserializer_1 = require_ATNDeserializer();
      var Lexer_1 = require_Lexer();
      var LexerATNSimulator_1 = require_LexerATNSimulator();
      var VocabularyImpl_1 = require_VocabularyImpl();
      var Utils3 = require_Utils();
      var XPathLexer = class _XPathLexer extends Lexer_1.Lexer {
        // tslint:enable:no-trailing-whitespace
        constructor(input) {
          super(input);
          this._interp = new LexerATNSimulator_1.LexerATNSimulator(_XPathLexer._ATN, this);
        }
        // @Override
        // @NotNull
        get vocabulary() {
          return _XPathLexer.VOCABULARY;
        }
        // @Override
        get grammarFileName() {
          return "XPathLexer.g4";
        }
        // @Override
        get ruleNames() {
          return _XPathLexer.ruleNames;
        }
        // @Override
        get serializedATN() {
          return _XPathLexer._serializedATN;
        }
        // @Override
        get channelNames() {
          return _XPathLexer.channelNames;
        }
        // @Override
        get modeNames() {
          return _XPathLexer.modeNames;
        }
        // @Override
        action(_localctx, ruleIndex, actionIndex) {
          switch (ruleIndex) {
            case 4:
              this.ID_action(_localctx, actionIndex);
              break;
          }
        }
        ID_action(_localctx, actionIndex) {
          switch (actionIndex) {
            case 0:
              let text = this.text;
              if (text.charAt(0) === text.charAt(0).toUpperCase()) {
                this.type = _XPathLexer.TOKEN_REF;
              } else {
                this.type = _XPathLexer.RULE_REF;
              }
              break;
          }
        }
        static get _ATN() {
          if (!_XPathLexer.__ATN) {
            _XPathLexer.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils3.toCharArray(_XPathLexer._serializedATN));
          }
          return _XPathLexer.__ATN;
        }
      };
      exports.XPathLexer = XPathLexer;
      XPathLexer.TOKEN_REF = 1;
      XPathLexer.RULE_REF = 2;
      XPathLexer.ANYWHERE = 3;
      XPathLexer.ROOT = 4;
      XPathLexer.WILDCARD = 5;
      XPathLexer.BANG = 6;
      XPathLexer.ID = 7;
      XPathLexer.STRING = 8;
      XPathLexer.channelNames = [
        "DEFAULT_TOKEN_CHANNEL",
        "HIDDEN"
      ];
      XPathLexer.modeNames = [
        "DEFAULT_MODE"
      ];
      XPathLexer.ruleNames = [
        "ANYWHERE",
        "ROOT",
        "WILDCARD",
        "BANG",
        "ID",
        "NameChar",
        "NameStartChar",
        "STRING"
      ];
      XPathLexer._LITERAL_NAMES = [
        void 0,
        void 0,
        void 0,
        "'//'",
        "'/'",
        "'*'",
        "'!'"
      ];
      XPathLexer._SYMBOLIC_NAMES = [
        void 0,
        "TOKEN_REF",
        "RULE_REF",
        "ANYWHERE",
        "ROOT",
        "WILDCARD",
        "BANG",
        "ID",
        "STRING"
      ];
      XPathLexer.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(XPathLexer._LITERAL_NAMES, XPathLexer._SYMBOLIC_NAMES, []);
      XPathLexer._serializedATNSegments = 2;
      XPathLexer._serializedATNSegment0 = '\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\n2\b					\x07	\x07\b	\b			\x07\n\f"\v\x07\x07\b\b		\x07	,\n	\f		/\v			-\n\x07\x07	\b\v	\r\n\u02B6\n2;C\\aac|\x81\xA1\xAC\xAC\xAF\xAF\xB7\xB7\xBC\xBC\xC2\xD8\xDA\xF8\xFA\u02C3\u02C8\u02D3\u02E2\u02E6\u02EE\u02EE\u02F0\u02F0\u0302\u0376\u0378\u0379\u037C\u037F\u0381\u0381\u0388\u0388\u038A\u038C\u038E\u038E\u0390\u03A3\u03A5\u03F7\u03F9\u0483\u0485\u0489\u048C\u0531\u0533\u0558\u055B\u055B\u0563\u0589\u0593\u05BF\u05C1\u05C1\u05C3\u05C4\u05C6\u05C7\u05C9\u05C9\u05D2\u05EC\u05F2\u05F4\u0602\u0607\u0612\u061C\u061E\u061E\u0622\u066B\u0670\u06D5\u06D7\u06DF\u06E1\u06EA\u06EC\u06FE\u0701\u0701\u0711\u074C\u074F\u07B3\u07C2\u07F7\u07FC\u07FC\u0802\u082F\u0842\u085D\u08A2\u08B6\u08B8\u08BF\u08D6\u0965\u0968\u0971\u0973\u0985\u0987\u098E\u0991\u0992\u0995\u09AA\u09AC\u09B2\u09B4\u09B4\u09B8\u09BB\u09BE\u09C6\u09C9\u09CA\u09CD\u09D0\u09D9\u09D9\u09DE\u09DF\u09E1\u09E5\u09E8\u09F3\u0A03\u0A05\u0A07\u0A0C\u0A11\u0A12\u0A15\u0A2A\u0A2C\u0A32\u0A34\u0A35\u0A37\u0A38\u0A3A\u0A3B\u0A3E\u0A3E\u0A40\u0A44\u0A49\u0A4A\u0A4D\u0A4F\u0A53\u0A53\u0A5B\u0A5E\u0A60\u0A60\u0A68\u0A77\u0A83\u0A85\u0A87\u0A8F\u0A91\u0A93\u0A95\u0AAA\u0AAC\u0AB2\u0AB4\u0AB5\u0AB7\u0ABB\u0ABE\u0AC7\u0AC9\u0ACB\u0ACD\u0ACF\u0AD2\u0AD2\u0AE2\u0AE5\u0AE8\u0AF1\u0AFB\u0AFB\u0B03\u0B05\u0B07\u0B0E\u0B11\u0B12\u0B15\u0B2A\u0B2C\u0B32\u0B34\u0B35\u0B37\u0B3B\u0B3E\u0B46\u0B49\u0B4A\u0B4D\u0B4F\u0B58\u0B59\u0B5E\u0B5F\u0B61\u0B65\u0B68\u0B71\u0B73\u0B73\u0B84\u0B85\u0B87\u0B8C\u0B90\u0B92\u0B94\u0B97\u0B9B\u0B9C\u0B9E\u0B9E\u0BA0\u0BA1\u0BA5\u0BA6\u0BAA\u0BAC\u0BB0\u0BBB\u0BC0\u0BC4\u0BC8\u0BCA\u0BCC\u0BCF\u0BD2\u0BD2\u0BD9\u0BD9\u0BE8\u0BF1\u0C02\u0C05\u0C07\u0C0E\u0C10\u0C12\u0C14\u0C2A\u0C2C\u0C3B\u0C3F\u0C46\u0C48\u0C4A\u0C4C\u0C4F\u0C57\u0C58\u0C5A\u0C5C\u0C62\u0C65\u0C68\u0C71\u0C82\u0C85\u0C87\u0C8E\u0C90\u0C92\u0C94\u0CAA\u0CAC\u0CB5\u0CB7\u0CBB\u0CBE\u0CC6\u0CC8\u0CCA\u0CCC\u0CCF\u0CD7\u0CD8\u0CE0\u0CE0\u0CE2\u0CE5\u0CE8\u0CF1\u0CF3\u0CF4\u0D03\u0D05\u0D07\u0D0E\u0D10\u0D12\u0D14\u0D3C\u0D3F\u0D46\u0D48\u0D4A\u0D4C\u0D50\u0D56\u0D59\u0D61\u0D65\u0D68\u0D71\u0D7C\u0D81\u0D84\u0D85\u0D87\u0D98\u0D9C\u0DB3\u0DB5\u0DBD\u0DBF\u0DBF\u0DC2\u0DC8\u0DCC\u0DCC\u0DD1\u0DD6\u0DD8\u0DD8\u0DDA\u0DE1\u0DE8\u0DF1\u0DF4\u0DF5\u0E03\u0E3C\u0E42\u0E50\u0E52\u0E5B\u0E83\u0E84\u0E86\u0E86\u0E89\u0E8A\u0E8C\u0E8C\u0E8F\u0E8F\u0E96\u0E99\u0E9B\u0EA1\u0EA3\u0EA5\u0EA7\u0EA7\u0EA9\u0EA9\u0EAC\u0EAD\u0EAF\u0EBB\u0EBD\u0EBF\u0EC2\u0EC6\u0EC8\u0EC8\u0ECA\u0ECF\u0ED2\u0EDB\u0EDE\u0EE1\u0F02\u0F02\u0F1A\u0F1B\u0F22\u0F2B\u0F37\u0F37\u0F39\u0F39\u0F3B\u0F3B\u0F40\u0F49\u0F4B\u0F6E\u0F73\u0F86\u0F88\u0F99\u0F9B\u0FBE\u0FC8\u0FC8\u1002\u104B\u1052\u109F\u10A2\u10C7\u10C9\u10C9\u10CF\u10CF\u10D2\u10FC\u10FE\u124A\u124C\u124F\u1252\u1258\u125A\u125A\u125C\u125F\u1262\u128A\u128C\u128F\u1292\u12B2\u12B4\u12B7\u12BA\u12C0\u12C2\u12C2\u12C4\u12C7\u12CA\u12D8\u12DA\u1312\u1314\u1317\u131A\u135C\u135F\u1361\u1382\u1391\u13A2\u13F7\u13FA\u13FF\u1403\u166E\u1671\u1681\u1683\u169C\u16A2\u16EC\u16F0\u16FA\u1702\u170E\u1710\u1716\u1722\u1736\u1742\u1755\u1762\u176E\u1770\u1772\u1774\u1775\u1782\u17D5\u17D9\u17D9\u17DE\u17DF\u17E2\u17EB\u180D\u1810\u1812\u181B\u1822\u1879\u1882\u18AC\u18B2\u18F7\u1902\u1920\u1922\u192D\u1932\u193D\u1948\u196F\u1972\u1976\u1982\u19AD\u19B2\u19CB\u19D2\u19DB\u1A02\u1A1D\u1A22\u1A60\u1A62\u1A7E\u1A81\u1A8B\u1A92\u1A9B\u1AA9\u1AA9\u1AB2\u1ABF\u1B02\u1B4D\u1B52\u1B5B\u1B6D\u1B75\u1B82\u1BF5\u1C02\u1C39\u1C42\u1C4B\u1C4F\u1C7F\u1C82\u1C8A\u1CD2\u1CD4\u1CD6\u1CF8\u1CFA\u1CFB\u1D02\u1DF7\u1DFD\u1F17\u1F1A\u1F1F\u1F22\u1F47\u1F4A\u1F4F\u1F52\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F5F\u1F61\u1F7F\u1F82\u1FB6\u1FB8\u1FBE\u1FC0\u1FC0\u1FC4\u1FC6\u1FC8\u1FCE\u1FD2\u1FD5\u1FD8\u1FDD\u1FE2\u1FEE\u1FF4\u1FF6\u1FF8\u1FFE\u200D\u2011\u202C\u2030\u2041\u2042\u2056\u2056\u2062\u2066\u2068\u2071\u2073\u2073\u2081\u2081\u2092\u209E\u20D2\u20DE\u20E3\u20E3\u20E7\u20F2\u2104\u2104\u2109\u2109\u210C\u2115\u2117\u2117\u211B\u211F\u2126\u2126\u2128\u2128\u212A\u212A\u212C\u212F\u2131\u213B\u213E\u2141\u2147\u214B\u2150\u2150\u2162\u218A\u2C02\u2C30\u2C32\u2C60\u2C62\u2CE6\u2CED\u2CF5\u2D02\u2D27\u2D29\u2D29\u2D2F\u2D2F\u2D32\u2D69\u2D71\u2D71\u2D81\u2D98\u2DA2\u2DA8\u2DAA\u2DB0\u2DB2\u2DB8\u2DBA\u2DC0\u2DC2\u2DC8\u2DCA\u2DD0\u2DD2\u2DD8\u2DDA\u2DE0\u2DE2\u2E01\u2E31\u2E31\u3007\u3009\u3023\u3031\u3033\u3037\u303A\u303E\u3043\u3098\u309B\u309C\u309F\u30A1\u30A3\u30FC\u30FE\u3101\u3107\u312F\u3133\u3190\u31A2\u31BC\u31F2\u3201\u3402\u4DB7\u4E02\u9FD7\uA002\uA48E\uA4D2\uA4FF\uA502\uA60E\uA612\uA62D\uA642\uA671\uA676\uA67F\uA681\uA6F3\uA719\uA721\uA724\uA78A\uA78D\uA7B0\uA7B2\uA7B9\uA7F9\uA829\uA842\uA875\uA882\uA8C7\uA8D2\uA8DB\uA8E2\uA8F9\uA8FD\uA8FD\uA8FF\uA8FF\uA902\uA92F\uA932\uA955\uA962\uA97E\uA982\uA9C2\uA9D1\uA9DB\uA9E2\uAA00\uAA02\uAA38\uAA42\uAA4F\uAA52\uAA5B\uAA62\uAA78\uAA7C\uAAC4\uAADD\uAADF\uAAE2\uAAF1\uAAF4\uAAF8\uAB03\uAB08\uAB0B\uAB10\uAB13\uAB18\uAB22\uAB28\uAB2A\uAB30\uAB32\uAB5C\uAB5E\uAB67\uAB72\uABEC\uABEE\uABEF\uABF2\uABFB\uAC02\uD7A5\uD7B2\uD7C8\uD7CD\uD7FD\uF902\uFA6F\uFA72\uFADB\uFB02\uFB08\uFB15\uFB19\uFB1F\uFB2A\uFB2C\uFB38\uFB3A\uFB3E\uFB40\uFB40\uFB42\uFB43\uFB45\uFB46\uFB48\uFBB3\uFBD5\uFD3F\uFD52\uFD91\uFD94\uFDC9\uFDF2\uFDFD\uFE02\uFE11\uFE22\uFE31\uFE35\uFE36\uFE4F\uFE51\uFE72\uFE76\uFE78\uFEFE\uFF01\uFF01\uFF12\uFF1B\uFF23\uFF3C\uFF41\uFF41\uFF43\uFF5C\uFF68\uFFC0\uFFC4\uFFC9\uFFCC\uFFD1\uFFD4\uFFD9\uFFDC\uFFDE\uFFFB\uFFFD\r(*<>?AOR_\x82\xFC\u0142\u0176\u01FF\u01FF\u0282\u029E\u02A2\u02D2\u02E2\u02E2\u0302\u0321\u0332\u034C\u0352\u037C\u0382\u039F\u03A2\u03C5\u03CA\u03D1\u03D3\u03D7\u0402\u049F\u04A2\u04AB\u04B2\u04D5\u04DA\u04FD\u0502\u0529\u0532\u0565\u0602\u0738\u0742\u0757\u0762\u0769\u0802\u0807\u080A\u080A\u080C\u0837\u0839\u083A\u083E\u083E\u0841\u0857\u0862\u0878\u0882\u08A0\u08E2\u08F4\u08F6\u08F7\u0902\u0917\u0922\u093B\u0982\u09B9\u09C0\u09C1\u0A02\u0A05\u0A07\u0A08\u0A0E\u0A15\u0A17\u0A19\u0A1B\u0A35\u0A3A\u0A3C\u0A41\u0A41\u0A62\u0A7E\u0A82\u0A9E\u0AC2\u0AC9\u0ACB\u0AE8\u0B02\u0B37\u0B42\u0B57\u0B62\u0B74\u0B82\u0B93\u0C02\u0C4A\u0C82\u0CB4\u0CC2\u0CF4\u1002\u1048\u1068\u1071\u1081\u10BC\u10BF\u10BF\u10D2\u10EA\u10F2\u10FB\u1102\u1136\u1138\u1141\u1152\u1175\u1178\u1178\u1182\u11C6\u11CC\u11CE\u11D2\u11DC\u11DE\u11DE\u1202\u1213\u1215\u1239\u1240\u1240\u1282\u1288\u128A\u128A\u128C\u128F\u1291\u129F\u12A1\u12AA\u12B2\u12EC\u12F2\u12FB\u1302\u1305\u1307\u130E\u1311\u1312\u1315\u132A\u132C\u1332\u1334\u1335\u1337\u133B\u133E\u1346\u1349\u134A\u134D\u134F\u1352\u1352\u1359\u1359\u135F\u1365\u1368\u136E\u1372\u1376\u1402\u144C\u1452\u145B\u1482\u14C7\u14C9\u14C9\u14D2\u14DB\u1582\u15B7\u15BA\u15C2\u15DA\u15DF\u1602\u1642\u1646\u1646\u1652\u165B\u1682\u16B9\u16C2\u16CB\u1702\u171B\u171F\u172D\u1732\u173B\u18A2\u18EB\u1901\u1901\u1AC2\u1AFA\u1C02\u1C0A\u1C0C\u1C38\u1C3A\u1C42\u1C52\u1C5B\u1C74\u1C91\u1C94\u1CA9\u1CAB\u1CB8\u2002\u239B\u2402\u2470\u2482\u2545\u3002\u3430\u4402\u4648\u6802\u6A3A\u6A42\u6A60\u6A62\u6A6B\u6AD2\u6AEF\u6AF2\u6AF6\u6B02\u6B38\u6B42\u6B45\u6B52\u6B5B\u6B65\u6B79\u6B7F\u6B91\u6F02\u6F46\u6F52\u6F80\u6F91\u6FA1\u6FE2\u6FE2\u7002\u87EE\u8802\u8AF4\uB002\uB003\uBC02\uBC6C\uBC72\uBC7E\uBC82\uBC8A\uBC92\uBC9B\uBC9F\uBCA0\uBCA2\uBCA5\uD167\uD16B\uD16F\uD184\uD187\uD18D\uD1AC\uD1AF\uD244\uD246\uD402\uD456\uD458\uD49E\uD4A0\uD4A1\uD4A4\uD4A4\uD4A7\uD4A8\uD4AB\uD4AE\uD4B0\uD4BB\uD4BD\uD4BD\uD4BF\uD4C5\uD4C7\uD507\uD509\uD50C\uD50F\uD516\uD518\uD51E\uD520\uD53B\uD53D\uD540\uD542\uD546\uD548\uD548\uD54C\uD552\uD554\uD6A7\uD6AA\uD6C2\uD6C4\uD6DC\uD6DE\uD6FC\uD6FE\uD716\uD718\uD736\uD738\uD750\uD752\uD770\uD772\uD78A\uD78C\uD7AA\uD7AC\uD7C4\uD7C6\uD7CD\uD7D0\uD801\uDA02\uDA38\uDA3D\uDA6E\uDA77\uDA77\uDA86\uDA86\uDA9D\uDAA1\uDAA3\uDAB1\uE002\uE008\uE00A\uE01A\uE01D\uE023\uE025\uE026\uE028\uE02C\uE802\uE8C6\uE8D2\uE8D8\uE902\uE94C\uE952\uE95B\uEE02\uEE05\uEE07\uEE21\uEE23\uEE24\uEE26\uEE26\uEE29\uEE29\uEE2B\uEE34\uEE36\uEE39\uEE3B\uEE3B\uEE3D\uEE3D\uEE44\uEE44\uEE49\uEE49\uEE4B\uEE4B\uEE4D\uEE4D\uEE4F\uEE51\uEE53\uEE54\uEE56\uEE56\uEE59\uEE59\uEE5B\uEE5B\uEE5D\uEE5D\uEE5F\uEE5F\uEE61\uEE61\uEE63\uEE64\uEE66\uEE66\uEE69\uEE6C\uEE6E\uEE74\uEE76\uEE79\uEE7B\uEE7E\uEE80\uEE80\uEE82\uEE8B\uEE8D\uEE9D\uEEA3\uEEA5\uEEA7\uEEAB\uEEAD\uEEBD\uA6D8\uA702\uB736\uB742\uB81F\uB822\uCEA3\uF802\uFA1F"\x81\u0102\u01F1\u0240C\\c|\xAC\xAC\xB7\xB7\xBC\xBC\xC2\xD8\xDA\xF8\xFA\u02C3\u02C8\u02D3\u02E2\u02E6\u02EE\u02EE\u02F0\u02F0\u0372\u0376\u0378\u0379\u037C\u037F\u0381\u0381\u0388\u0388\u038A\u038C\u038E\u038E\u0390\u03A3\u03A5\u03F7\u03F9\u0483\u048C\u0531\u0533\u0558\u055B\u055B\u0563\u0589\u05D2\u05EC\u05F2\u05F4\u0622\u064C\u0670\u0671\u0673\u06D5\u06D7\u06D7\u06E7\u06E8\u06F0\u06F1\u06FC\u06FE\u0701\u0701\u0712\u0712\u0714\u0731\u074F\u07A7\u07B3\u07B3\u07CC\u07EC\u07F6\u07F7\u07FC\u07FC\u0802\u0817\u081C\u081C\u0826\u0826\u082A\u082A\u0842\u085A\u08A2\u08B6\u08B8\u08BF\u0906\u093B\u093F\u093F\u0952\u0952\u095A\u0963\u0973\u0982\u0987\u098E\u0991\u0992\u0995\u09AA\u09AC\u09B2\u09B4\u09B4\u09B8\u09BB\u09BF\u09BF\u09D0\u09D0\u09DE\u09DF\u09E1\u09E3\u09F2\u09F3\u0A07\u0A0C\u0A11\u0A12\u0A15\u0A2A\u0A2C\u0A32\u0A34\u0A35\u0A37\u0A38\u0A3A\u0A3B\u0A5B\u0A5E\u0A60\u0A60\u0A74\u0A76\u0A87\u0A8F\u0A91\u0A93\u0A95\u0AAA\u0AAC\u0AB2\u0AB4\u0AB5\u0AB7\u0ABB\u0ABF\u0ABF\u0AD2\u0AD2\u0AE2\u0AE3\u0AFB\u0AFB\u0B07\u0B0E\u0B11\u0B12\u0B15\u0B2A\u0B2C\u0B32\u0B34\u0B35\u0B37\u0B3B\u0B3F\u0B3F\u0B5E\u0B5F\u0B61\u0B63\u0B73\u0B73\u0B85\u0B85\u0B87\u0B8C\u0B90\u0B92\u0B94\u0B97\u0B9B\u0B9C\u0B9E\u0B9E\u0BA0\u0BA1\u0BA5\u0BA6\u0BAA\u0BAC\u0BB0\u0BBB\u0BD2\u0BD2\u0C07\u0C0E\u0C10\u0C12\u0C14\u0C2A\u0C2C\u0C3B\u0C3F\u0C3F\u0C5A\u0C5C\u0C62\u0C63\u0C82\u0C82\u0C87\u0C8E\u0C90\u0C92\u0C94\u0CAA\u0CAC\u0CB5\u0CB7\u0CBB\u0CBF\u0CBF\u0CE0\u0CE0\u0CE2\u0CE3\u0CF3\u0CF4\u0D07\u0D0E\u0D10\u0D12\u0D14\u0D3C\u0D3F\u0D3F\u0D50\u0D50\u0D56\u0D58\u0D61\u0D63\u0D7C\u0D81\u0D87\u0D98\u0D9C\u0DB3\u0DB5\u0DBD\u0DBF\u0DBF\u0DC2\u0DC8\u0E03\u0E32\u0E34\u0E35\u0E42\u0E48\u0E83\u0E84\u0E86\u0E86\u0E89\u0E8A\u0E8C\u0E8C\u0E8F\u0E8F\u0E96\u0E99\u0E9B\u0EA1\u0EA3\u0EA5\u0EA7\u0EA7\u0EA9\u0EA9\u0EAC\u0EAD\u0EAF\u0EB2\u0EB4\u0EB5\u0EBF\u0EBF\u0EC2\u0EC6\u0EC8\u0EC8\u0EDE\u0EE1\u0F02\u0F02\u0F42\u0F49\u0F4B\u0F6E\u0F8A\u0F8E\u1002\u102C\u1041\u1041\u1052\u1057\u105C\u105F\u1063\u1063\u1067\u1068\u1070\u1072\u1077\u1083\u1090\u1090\u10A2\u10C7\u10C9\u10C9\u10CF\u10CF\u10D2\u10FC\u10FE\u124A\u124C\u124F\u1252\u1258\u125A\u125A\u125C\u125F\u1262\u128A\u128C\u128F\u1292\u12B2\u12B4\u12B7\u12BA\u12C0\u12C2\u12C2\u12C4\u12C7\u12CA\u12D8\u12DA\u1312\u1314\u1317\u131A\u135C\u1382\u1391\u13A2\u13F7\u13FA\u13FF\u1403\u166E\u1671\u1681\u1683\u169C\u16A2\u16EC\u16F0\u16FA\u1702\u170E\u1710\u1713\u1722\u1733\u1742\u1753\u1762\u176E\u1770\u1772\u1782\u17B5\u17D9\u17D9\u17DE\u17DE\u1822\u1879\u1882\u1886\u1889\u18AA\u18AC\u18AC\u18B2\u18F7\u1902\u1920\u1952\u196F\u1972\u1976\u1982\u19AD\u19B2\u19CB\u1A02\u1A18\u1A22\u1A56\u1AA9\u1AA9\u1B07\u1B35\u1B47\u1B4D\u1B85\u1BA2\u1BB0\u1BB1\u1BBC\u1BE7\u1C02\u1C25\u1C4F\u1C51\u1C5C\u1C7F\u1C82\u1C8A\u1CEB\u1CEE\u1CF0\u1CF3\u1CF7\u1CF8\u1D02\u1DC1\u1E02\u1F17\u1F1A\u1F1F\u1F22\u1F47\u1F4A\u1F4F\u1F52\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F5F\u1F61\u1F7F\u1F82\u1FB6\u1FB8\u1FBE\u1FC0\u1FC0\u1FC4\u1FC6\u1FC8\u1FCE\u1FD2\u1FD5\u1FD8\u1FDD\u1FE2\u1FEE\u1FF4\u1FF6\u1FF8\u1FFE\u2073\u2073\u2081\u2081\u2092\u209E\u2104\u2104\u2109\u2109\u210C\u2115\u2117\u2117\u211B\u211F\u2126\u2126\u2128\u2128\u212A\u212A\u212C\u212F\u2131\u213B\u213E\u2141\u2147\u214B\u2150\u2150\u2162\u218A\u2C02\u2C30\u2C32\u2C60\u2C62\u2CE6\u2CED\u2CF0\u2CF4\u2CF5\u2D02\u2D27\u2D29\u2D29\u2D2F\u2D2F\u2D32\u2D69\u2D71\u2D71\u2D82\u2D98\u2DA2\u2DA8\u2DAA\u2DB0\u2DB2\u2DB8\u2DBA\u2DC0\u2DC2\u2DC8\u2DCA\u2DD0\u2DD2\u2DD8\u2DDA\u2DE0\u2E31\u2E31\u3007\u3009\u3023\u302B\u3033\u3037\u303A\u303E\u3043\u3098\u309F\u30A1\u30A3\u30FC\u30FE\u3101\u3107\u312F\u3133\u3190\u31A2\u31BC\u31F2\u3201\u3402\u4DB7\u4E02\u9FD7\uA002\uA48E\uA4D2\uA4FF\uA502\uA60E\uA612\uA621\uA62C\uA62D\uA642\uA670\uA681\uA69F\uA6A2\uA6F1\uA719\uA721\uA724\uA78A\uA78D\uA7B0\uA7B2\uA7B9\uA7F9\uA803\uA805\uA807\uA809\uA80C\uA80E\uA824\uA842\uA875\uA884\uA8B5\uA8F4\uA8F9\uA8FD\uA8FD\uA8FF\uA8FF\uA90C\uA927\uA932\uA948\uA962\uA97E\uA986\uA9B4\uA9D1\uA9D1\uA9E2\uA9E6\uA9E8\uA9F1\uA9FC\uAA00\uAA02\uAA2A\uAA42\uAA44\uAA46\uAA4D\uAA62\uAA78\uAA7C\uAA7C\uAA80\uAAB1\uAAB3\uAAB3\uAAB7\uAAB8\uAABB\uAABF\uAAC2\uAAC2\uAAC4\uAAC4\uAADD\uAADF\uAAE2\uAAEC\uAAF4\uAAF6\uAB03\uAB08\uAB0B\uAB10\uAB13\uAB18\uAB22\uAB28\uAB2A\uAB30\uAB32\uAB5C\uAB5E\uAB67\uAB72\uABE4\uAC02\uD7A5\uD7B2\uD7C8\uD7CD\uD7FD\uF902\uFA6F\uFA72\uFADB\uFB02\uFB08\uFB15\uFB19\uFB1F\uFB1F\uFB21\uFB2A\uFB2C\uFB38\uFB3A\uFB3E\uFB40\uFB40\uFB42\uFB43\uFB45\uFB46\uFB48\uFBB3\uFBD5\uFD3F\uFD52\uFD91\uFD94\uFDC9\uFDF2\uFDFD\uFE72\uFE76\uFE78\uFEFE\uFF23\uFF3C\uFF43\uFF5C\uFF68\uFFC0\uFFC4\uFFC9\uFFCC\uFFD1\uFFD4\uFFD9\uFFDC\uFFDE\r(*<>?AOR_\x82\xFC\u0142\u0176\u0282\u029E\u02A2\u02D2\u0302\u0321\u0332\u034C\u0352\u0377\u0382\u039F\u03A2\u03C5\u03CA\u03D1\u03D3\u03D7\u0402\u049F\u04B2\u04D5\u04DA\u04FD\u0502\u0529\u0532\u0565\u0602\u0738\u0742\u0757\u0762\u0769\u0802\u0807\u080A\u080A\u080C\u0837\u0839\u083A\u083E\u083E\u0841\u0857\u0862\u0878\u0882\u08A0\u08E2\u08F4\u08F6\u08F7\u0902\u0917\u0922\u093B\u0982\u09B9\u09C0\u09C1\u0A02\u0A02\u0A12\u0A15\u0A17\u0A19\u0A1B\u0A35\u0A62\u0A7E\u0A82\u0A9E\u0AC2\u0AC9\u0ACB\u0AE6\u0B02\u0B37\u0B42\u0B57\u0B62\u0B74\u0B82\u0B93\u0C02\u0C4A\u0C82\u0CB4\u0CC2\u0CF4\u1005\u1039\u1085\u10B1\u10D2\u10EA\u1105\u1128\u1152\u1174\u1178\u1178\u1185\u11B4\u11C3\u11C6\u11DC\u11DC\u11DE\u11DE\u1202\u1213\u1215\u122D\u1282\u1288\u128A\u128A\u128C\u128F\u1291\u129F\u12A1\u12AA\u12B2\u12E0\u1307\u130E\u1311\u1312\u1315\u132A\u132C\u1332\u1334\u1335\u1337\u133B\u133F\u133F\u1352\u1352\u135F\u1363\u1402\u1436\u1449\u144C\u1482\u14B1\u14C6\u14C7\u14C9\u14C9\u1582\u15B0\u15DA\u15DD\u1602\u1631\u1646\u1646\u1682\u16AC\u1702\u171B\u18A2\u18E1\u1901\u1901\u1AC2\u1AFA\u1C02\u1C0A\u1C0C\u1C30\u1C42\u1C42\u1C74\u1C91\u2002\u239B\u2402\u2470\u2482\u2545\u3002\u3430\u4402\u4648\u6802\u6A3A\u6A42\u6A60\u6AD2\u6AEF\u6B02\u6B31\u6B42\u6B45\u6B65\u6B79\u6B7F\u6B91\u6F02\u6F46\u6F52\u6F52\u6F95\u6FA1\u6FE2\u6FE2\u7002\u87EE\u8802\u8AF4\uB002\uB003\uBC02\uBC6C\uBC72\uBC7E\uBC82\uBC8A\uBC92\uBC9B\uD402\uD456\uD458\uD49E\uD4A0\uD4A1\uD4A4\uD4A4\uD4A7\uD4A8\uD4AB\uD4AE\uD4B0\uD4BB\uD4BD\uD4BD\uD4BF\uD4C5\uD4C7\uD507\uD509\uD50C\uD50F\uD516\uD518\uD51E\uD520\uD53B\uD53D\uD540\uD542\uD546\uD548\uD548';
      XPathLexer._serializedATNSegment1 = `\uD54C\uD552\uD554\uD6A7\uD6AA\uD6C2\uD6C4\uD6DC\uD6DE\uD6FC\uD6FE\uD716\uD718\uD736\uD738\uD750\uD752\uD770\uD772\uD78A\uD78C\uD7AA\uD7AC\uD7C4\uD7C6\uD7CD\uE802\uE8C6\uE902\uE945\uEE02\uEE05\uEE07\uEE21\uEE23\uEE24\uEE26\uEE26\uEE29\uEE29\uEE2B\uEE34\uEE36\uEE39\uEE3B\uEE3B\uEE3D\uEE3D\uEE44\uEE44\uEE49\uEE49\uEE4B\uEE4B\uEE4D\uEE4D\uEE4F\uEE51\uEE53\uEE54\uEE56\uEE56\uEE59\uEE59\uEE5B\uEE5B\uEE5D\uEE5D\uEE5F\uEE5F\uEE61\uEE61\uEE63\uEE64\uEE66\uEE66\uEE69\uEE6C\uEE6E\uEE74\uEE76\uEE79\uEE7B\uEE7E\uEE80\uEE80\uEE82\uEE8B\uEE8D\uEE9D\uEEA3\uEEA5\uEEA7\uEEAB\uEEAD\uEEBD\uA6D8\uA702\uB736\uB742\uB81F\uB822\uCEA3\uF802\uFA1F1\x07	\v\x07	\v\r%')\x071\x071\x071\x07,\b\x1B\x07#\x1B
 \b\r\x07"  !!#" #$\b$\f%&	&'(	()-\x07)*,\v+*,/-.-+.0/-01\x07)1 -`;
      XPathLexer._serializedATN = Utils3.join([
        XPathLexer._serializedATNSegment0,
        XPathLexer._serializedATNSegment1
      ], "");
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js
  var require_XPathLexerErrorListener = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathLexerErrorListener = void 0;
      var Decorators_1 = require_Decorators();
      var XPathLexerErrorListener = class {
        syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
        }
      };
      __decorate([
        Decorators_1.Override
      ], XPathLexerErrorListener.prototype, "syntaxError", null);
      exports.XPathLexerErrorListener = XPathLexerErrorListener;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathElement.js
  var require_XPathElement = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathElement.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathElement = void 0;
      var Decorators_1 = require_Decorators();
      var XPathElement = class {
        /** Construct element like `/ID` or `ID` or `/*` etc...
         *  op is null if just node
         */
        constructor(nodeName) {
          this.nodeName = nodeName;
          this.invert = false;
        }
        toString() {
          let inv = this.invert ? "!" : "";
          let className = Object.constructor.name;
          return className + "[" + inv + this.nodeName + "]";
        }
      };
      __decorate([
        Decorators_1.Override
      ], XPathElement.prototype, "toString", null);
      exports.XPathElement = XPathElement;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js
  var require_XPathRuleAnywhereElement = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathRuleAnywhereElement = void 0;
      var Decorators_1 = require_Decorators();
      var Trees_1 = require_Trees();
      var XPathElement_1 = require_XPathElement();
      var XPathRuleAnywhereElement = class extends XPathElement_1.XPathElement {
        constructor(ruleName, ruleIndex) {
          super(ruleName);
          this.ruleIndex = ruleIndex;
        }
        evaluate(t) {
          return Trees_1.Trees.findAllRuleNodes(t, this.ruleIndex);
        }
      };
      __decorate([
        Decorators_1.Override
      ], XPathRuleAnywhereElement.prototype, "evaluate", null);
      exports.XPathRuleAnywhereElement = XPathRuleAnywhereElement;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathRuleElement.js
  var require_XPathRuleElement = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathRuleElement.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathRuleElement = void 0;
      var ParserRuleContext_1 = require_ParserRuleContext();
      var Decorators_1 = require_Decorators();
      var Trees_1 = require_Trees();
      var XPathElement_1 = require_XPathElement();
      var XPathRuleElement = class extends XPathElement_1.XPathElement {
        constructor(ruleName, ruleIndex) {
          super(ruleName);
          this.ruleIndex = ruleIndex;
        }
        evaluate(t) {
          let nodes = [];
          for (let c of Trees_1.Trees.getChildren(t)) {
            if (c instanceof ParserRuleContext_1.ParserRuleContext) {
              if (c.ruleIndex === this.ruleIndex && !this.invert || c.ruleIndex !== this.ruleIndex && this.invert) {
                nodes.push(c);
              }
            }
          }
          return nodes;
        }
      };
      __decorate([
        Decorators_1.Override
      ], XPathRuleElement.prototype, "evaluate", null);
      exports.XPathRuleElement = XPathRuleElement;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js
  var require_XPathTokenAnywhereElement = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathTokenAnywhereElement = void 0;
      var Decorators_1 = require_Decorators();
      var Trees_1 = require_Trees();
      var XPathElement_1 = require_XPathElement();
      var XPathTokenAnywhereElement = class extends XPathElement_1.XPathElement {
        constructor(tokenName, tokenType) {
          super(tokenName);
          this.tokenType = tokenType;
        }
        evaluate(t) {
          return Trees_1.Trees.findAllTokenNodes(t, this.tokenType);
        }
      };
      __decorate([
        Decorators_1.Override
      ], XPathTokenAnywhereElement.prototype, "evaluate", null);
      exports.XPathTokenAnywhereElement = XPathTokenAnywhereElement;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathTokenElement.js
  var require_XPathTokenElement = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathTokenElement.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathTokenElement = void 0;
      var Decorators_1 = require_Decorators();
      var TerminalNode_1 = require_TerminalNode();
      var Trees_1 = require_Trees();
      var XPathElement_1 = require_XPathElement();
      var XPathTokenElement = class extends XPathElement_1.XPathElement {
        constructor(tokenName, tokenType) {
          super(tokenName);
          this.tokenType = tokenType;
        }
        evaluate(t) {
          let nodes = [];
          for (let c of Trees_1.Trees.getChildren(t)) {
            if (c instanceof TerminalNode_1.TerminalNode) {
              if (c.symbol.type === this.tokenType && !this.invert || c.symbol.type !== this.tokenType && this.invert) {
                nodes.push(c);
              }
            }
          }
          return nodes;
        }
      };
      __decorate([
        Decorators_1.Override
      ], XPathTokenElement.prototype, "evaluate", null);
      exports.XPathTokenElement = XPathTokenElement;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js
  var require_XPathWildcardAnywhereElement = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathWildcardAnywhereElement = void 0;
      var Decorators_1 = require_Decorators();
      var Trees_1 = require_Trees();
      var XPath_1 = require_XPath();
      var XPathElement_1 = require_XPathElement();
      var XPathWildcardAnywhereElement = class extends XPathElement_1.XPathElement {
        constructor() {
          super(XPath_1.XPath.WILDCARD);
        }
        evaluate(t) {
          if (this.invert) {
            return [];
          }
          return Trees_1.Trees.getDescendants(t);
        }
      };
      __decorate([
        Decorators_1.Override
      ], XPathWildcardAnywhereElement.prototype, "evaluate", null);
      exports.XPathWildcardAnywhereElement = XPathWildcardAnywhereElement;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js
  var require_XPathWildcardElement = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathWildcardElement = void 0;
      var Decorators_1 = require_Decorators();
      var Trees_1 = require_Trees();
      var XPath_1 = require_XPath();
      var XPathElement_1 = require_XPathElement();
      var XPathWildcardElement = class extends XPathElement_1.XPathElement {
        constructor() {
          super(XPath_1.XPath.WILDCARD);
        }
        evaluate(t) {
          let kids = [];
          if (this.invert) {
            return kids;
          }
          for (let c of Trees_1.Trees.getChildren(t)) {
            kids.push(c);
          }
          return kids;
        }
      };
      __decorate([
        Decorators_1.Override
      ], XPathWildcardElement.prototype, "evaluate", null);
      exports.XPathWildcardElement = XPathWildcardElement;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPath.js
  var require_XPath = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPath.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPath = void 0;
      var CharStreams_1 = require_CharStreams();
      var CommonTokenStream_1 = require_CommonTokenStream();
      var LexerNoViableAltException_1 = require_LexerNoViableAltException();
      var ParserRuleContext_1 = require_ParserRuleContext();
      var Token_1 = require_Token();
      var XPathLexer_1 = require_XPathLexer();
      var XPathLexerErrorListener_1 = require_XPathLexerErrorListener();
      var XPathRuleAnywhereElement_1 = require_XPathRuleAnywhereElement();
      var XPathRuleElement_1 = require_XPathRuleElement();
      var XPathTokenAnywhereElement_1 = require_XPathTokenAnywhereElement();
      var XPathTokenElement_1 = require_XPathTokenElement();
      var XPathWildcardAnywhereElement_1 = require_XPathWildcardAnywhereElement();
      var XPathWildcardElement_1 = require_XPathWildcardElement();
      var XPath = class _XPath {
        constructor(parser, path) {
          this.parser = parser;
          this.path = path;
          this.elements = this.split(path);
        }
        // TODO: check for invalid token/rule names, bad syntax
        split(path) {
          let lexer = new XPathLexer_1.XPathLexer(CharStreams_1.CharStreams.fromString(path));
          lexer.recover = (e) => {
            throw e;
          };
          lexer.removeErrorListeners();
          lexer.addErrorListener(new XPathLexerErrorListener_1.XPathLexerErrorListener());
          let tokenStream = new CommonTokenStream_1.CommonTokenStream(lexer);
          try {
            tokenStream.fill();
          } catch (e) {
            if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
              let pos = lexer.charPositionInLine;
              let msg = "Invalid tokens or characters at index " + pos + " in path '" + path + "' -- " + e.message;
              throw new RangeError(msg);
            }
            throw e;
          }
          let tokens = tokenStream.getTokens();
          let elements = [];
          let n = tokens.length;
          let i = 0;
          loop: while (i < n) {
            let el = tokens[i];
            let next;
            switch (el.type) {
              case XPathLexer_1.XPathLexer.ROOT:
              case XPathLexer_1.XPathLexer.ANYWHERE:
                let anywhere = el.type === XPathLexer_1.XPathLexer.ANYWHERE;
                i++;
                next = tokens[i];
                let invert = next.type === XPathLexer_1.XPathLexer.BANG;
                if (invert) {
                  i++;
                  next = tokens[i];
                }
                let pathElement = this.getXPathElement(next, anywhere);
                pathElement.invert = invert;
                elements.push(pathElement);
                i++;
                break;
              case XPathLexer_1.XPathLexer.TOKEN_REF:
              case XPathLexer_1.XPathLexer.RULE_REF:
              case XPathLexer_1.XPathLexer.WILDCARD:
                elements.push(this.getXPathElement(el, false));
                i++;
                break;
              case Token_1.Token.EOF:
                break loop;
              default:
                throw new Error("Unknowth path element " + el);
            }
          }
          return elements;
        }
        /**
         * Convert word like `*` or `ID` or `expr` to a path
         * element. `anywhere` is `true` if `//` precedes the
         * word.
         */
        getXPathElement(wordToken, anywhere) {
          if (wordToken.type === Token_1.Token.EOF) {
            throw new Error("Missing path element at end of path");
          }
          let word = wordToken.text;
          if (word == null) {
            throw new Error("Expected wordToken to have text content.");
          }
          let ttype = this.parser.getTokenType(word);
          let ruleIndex = this.parser.getRuleIndex(word);
          switch (wordToken.type) {
            case XPathLexer_1.XPathLexer.WILDCARD:
              return anywhere ? new XPathWildcardAnywhereElement_1.XPathWildcardAnywhereElement() : new XPathWildcardElement_1.XPathWildcardElement();
            case XPathLexer_1.XPathLexer.TOKEN_REF:
            case XPathLexer_1.XPathLexer.STRING:
              if (ttype === Token_1.Token.INVALID_TYPE) {
                throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid token name");
              }
              return anywhere ? new XPathTokenAnywhereElement_1.XPathTokenAnywhereElement(word, ttype) : new XPathTokenElement_1.XPathTokenElement(word, ttype);
            default:
              if (ruleIndex === -1) {
                throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid rule name");
              }
              return anywhere ? new XPathRuleAnywhereElement_1.XPathRuleAnywhereElement(word, ruleIndex) : new XPathRuleElement_1.XPathRuleElement(word, ruleIndex);
          }
        }
        static findAll(tree, xpath, parser) {
          let p = new _XPath(parser, xpath);
          return p.evaluate(tree);
        }
        /**
         * Return a list of all nodes starting at `t` as root that satisfy the
         * path. The root `/` is relative to the node passed to {@link evaluate}.
         */
        evaluate(t) {
          let dummyRoot = new ParserRuleContext_1.ParserRuleContext();
          dummyRoot.addChild(t);
          let work = /* @__PURE__ */ new Set([dummyRoot]);
          let i = 0;
          while (i < this.elements.length) {
            let next = /* @__PURE__ */ new Set();
            for (let node of work) {
              if (node.childCount > 0) {
                let matching = this.elements[i].evaluate(node);
                matching.forEach(next.add, next);
              }
            }
            i++;
            work = next;
          }
          return work;
        }
      };
      exports.XPath = XPath;
      XPath.WILDCARD = "*";
      XPath.NOT = "!";
    }
  });

  // node_modules/antlr4ts/tree/pattern/ParseTreePattern.js
  var require_ParseTreePattern = __commonJS({
    "node_modules/antlr4ts/tree/pattern/ParseTreePattern.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParseTreePattern = void 0;
      var Decorators_1 = require_Decorators();
      var XPath_1 = require_XPath();
      var ParseTreePattern = class ParseTreePattern {
        /**
         * Construct a new instance of the {@link ParseTreePattern} class.
         *
         * @param matcher The {@link ParseTreePatternMatcher} which created this
         * tree pattern.
         * @param pattern The tree pattern in concrete syntax form.
         * @param patternRuleIndex The parser rule which serves as the root of the
         * tree pattern.
         * @param patternTree The tree pattern in {@link ParseTree} form.
         */
        constructor(matcher, pattern, patternRuleIndex, patternTree) {
          this._matcher = matcher;
          this._patternRuleIndex = patternRuleIndex;
          this._pattern = pattern;
          this._patternTree = patternTree;
        }
        /**
         * Match a specific parse tree against this tree pattern.
         *
         * @param tree The parse tree to match against this tree pattern.
         * @returns A {@link ParseTreeMatch} object describing the result of the
         * match operation. The `ParseTreeMatch.succeeded` method can be
         * used to determine whether or not the match was successful.
         */
        match(tree) {
          return this._matcher.match(tree, this);
        }
        /**
         * Determine whether or not a parse tree matches this tree pattern.
         *
         * @param tree The parse tree to match against this tree pattern.
         * @returns `true` if `tree` is a match for the current tree
         * pattern; otherwise, `false`.
         */
        matches(tree) {
          return this._matcher.match(tree, this).succeeded;
        }
        /**
         * Find all nodes using XPath and then try to match those subtrees against
         * this tree pattern.
         *
         * @param tree The {@link ParseTree} to match against this pattern.
         * @param xpath An expression matching the nodes
         *
         * @returns A collection of {@link ParseTreeMatch} objects describing the
         * successful matches. Unsuccessful matches are omitted from the result,
         * regardless of the reason for the failure.
         */
        findAll(tree, xpath) {
          let subtrees = XPath_1.XPath.findAll(tree, xpath, this._matcher.parser);
          let matches = [];
          for (let t of subtrees) {
            let match = this.match(t);
            if (match.succeeded) {
              matches.push(match);
            }
          }
          return matches;
        }
        /**
         * Get the {@link ParseTreePatternMatcher} which created this tree pattern.
         *
         * @returns The {@link ParseTreePatternMatcher} which created this tree
         * pattern.
         */
        get matcher() {
          return this._matcher;
        }
        /**
         * Get the tree pattern in concrete syntax form.
         *
         * @returns The tree pattern in concrete syntax form.
         */
        get pattern() {
          return this._pattern;
        }
        /**
         * Get the parser rule which serves as the outermost rule for the tree
         * pattern.
         *
         * @returns The parser rule which serves as the outermost rule for the tree
         * pattern.
         */
        get patternRuleIndex() {
          return this._patternRuleIndex;
        }
        /**
         * Get the tree pattern as a {@link ParseTree}. The rule and token tags from
         * the pattern are present in the parse tree as terminal nodes with a symbol
         * of type {@link RuleTagToken} or {@link TokenTagToken}.
         *
         * @returns The tree pattern as a {@link ParseTree}.
         */
        get patternTree() {
          return this._patternTree;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ParseTreePattern.prototype, "_pattern", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreePattern.prototype, "_patternTree", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreePattern.prototype, "_matcher", void 0);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], ParseTreePattern.prototype, "match", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParseTreePattern.prototype, "matches", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParseTreePattern.prototype, "findAll", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreePattern.prototype, "matcher", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreePattern.prototype, "pattern", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreePattern.prototype, "patternTree", null);
      ParseTreePattern = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(3, Decorators_1.NotNull)
      ], ParseTreePattern);
      exports.ParseTreePattern = ParseTreePattern;
    }
  });

  // node_modules/antlr4ts/tree/pattern/RuleTagToken.js
  var require_RuleTagToken = __commonJS({
    "node_modules/antlr4ts/tree/pattern/RuleTagToken.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleTagToken = void 0;
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var RuleTagToken = class RuleTagToken {
        /**
         * Constructs a new instance of {@link RuleTagToken} with the specified rule
         * name, bypass token type, and label.
         *
         * @param ruleName The name of the parser rule this rule tag matches.
         * @param bypassTokenType The bypass token type assigned to the parser rule.
         * @param label The label associated with the rule tag, or `undefined` if
         * the rule tag is unlabeled.
         *
         * @exception IllegalArgumentException if `ruleName` is not defined
         * or empty.
         */
        constructor(ruleName, bypassTokenType, label) {
          if (ruleName == null || ruleName.length === 0) {
            throw new Error("ruleName cannot be null or empty.");
          }
          this._ruleName = ruleName;
          this.bypassTokenType = bypassTokenType;
          this._label = label;
        }
        /**
         * Gets the name of the rule associated with this rule tag.
         *
         * @returns The name of the parser rule associated with this rule tag.
         */
        get ruleName() {
          return this._ruleName;
        }
        /**
         * Gets the label associated with the rule tag.
         *
         * @returns The name of the label associated with the rule tag, or
         * `undefined` if this is an unlabeled rule tag.
         */
        get label() {
          return this._label;
        }
        /**
         * {@inheritDoc}
         *
         * Rule tag tokens are always placed on the {@link #DEFAULT_CHANNEL}.
         */
        get channel() {
          return Token_1.Token.DEFAULT_CHANNEL;
        }
        /**
         * {@inheritDoc}
         *
         * This method returns the rule tag formatted with `<` and `>`
         * delimiters.
         */
        get text() {
          if (this._label != null) {
            return "<" + this._label + ":" + this._ruleName + ">";
          }
          return "<" + this._ruleName + ">";
        }
        /**
         * {@inheritDoc}
         *
         * Rule tag tokens have types assigned according to the rule bypass
         * transitions created during ATN deserialization.
         */
        get type() {
          return this.bypassTokenType;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link RuleTagToken} always returns 0.
         */
        get line() {
          return 0;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link RuleTagToken} always returns -1.
         */
        get charPositionInLine() {
          return -1;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link RuleTagToken} always returns -1.
         */
        get tokenIndex() {
          return -1;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link RuleTagToken} always returns -1.
         */
        get startIndex() {
          return -1;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link RuleTagToken} always returns -1.
         */
        get stopIndex() {
          return -1;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link RuleTagToken} always returns `undefined`.
         */
        get tokenSource() {
          return void 0;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link RuleTagToken} always returns `undefined`.
         */
        get inputStream() {
          return void 0;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link RuleTagToken} returns a string of the form
         * `ruleName:bypassTokenType`.
         */
        toString() {
          return this._ruleName + ":" + this.bypassTokenType;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], RuleTagToken.prototype, "ruleName", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "channel", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "text", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "type", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "line", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "charPositionInLine", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "tokenIndex", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "startIndex", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "stopIndex", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "tokenSource", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "inputStream", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "toString", null);
      RuleTagToken = __decorate([
        __param(0, Decorators_1.NotNull)
      ], RuleTagToken);
      exports.RuleTagToken = RuleTagToken;
    }
  });

  // node_modules/antlr4ts/tree/pattern/Chunk.js
  var require_Chunk = __commonJS({
    "node_modules/antlr4ts/tree/pattern/Chunk.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Chunk = void 0;
      var Chunk = class {
      };
      exports.Chunk = Chunk;
    }
  });

  // node_modules/antlr4ts/tree/pattern/TagChunk.js
  var require_TagChunk = __commonJS({
    "node_modules/antlr4ts/tree/pattern/TagChunk.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TagChunk = void 0;
      var Chunk_1 = require_Chunk();
      var Decorators_1 = require_Decorators();
      var TagChunk = class extends Chunk_1.Chunk {
        /**
         * Construct a new instance of {@link TagChunk} using the specified label
         * and tag.
         *
         * @param label The label for the tag. If this is `undefined`, the
         * {@link TagChunk} represents an unlabeled tag.
         * @param tag The tag, which should be the name of a parser rule or token
         * type.
         *
         * @exception IllegalArgumentException if `tag` is not defined or
         * empty.
         */
        constructor(tag, label) {
          super();
          if (tag == null || tag.length === 0) {
            throw new Error("tag cannot be null or empty");
          }
          this._tag = tag;
          this._label = label;
        }
        /**
         * Get the tag for this chunk.
         *
         * @returns The tag for the chunk.
         */
        get tag() {
          return this._tag;
        }
        /**
         * Get the label, if any, assigned to this chunk.
         *
         * @returns The label assigned to this chunk, or `undefined` if no label is
         * assigned to the chunk.
         */
        get label() {
          return this._label;
        }
        /**
         * This method returns a text representation of the tag chunk. Labeled tags
         * are returned in the form `label:tag`, and unlabeled tags are
         * returned as just the tag name.
         */
        toString() {
          if (this._label != null) {
            return this._label + ":" + this._tag;
          }
          return this._tag;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], TagChunk.prototype, "tag", null);
      __decorate([
        Decorators_1.Override
      ], TagChunk.prototype, "toString", null);
      exports.TagChunk = TagChunk;
    }
  });

  // node_modules/antlr4ts/tree/pattern/TextChunk.js
  var require_TextChunk = __commonJS({
    "node_modules/antlr4ts/tree/pattern/TextChunk.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TextChunk = void 0;
      var Chunk_1 = require_Chunk();
      var Decorators_1 = require_Decorators();
      var TextChunk = class TextChunk extends Chunk_1.Chunk {
        /**
         * Constructs a new instance of {@link TextChunk} with the specified text.
         *
         * @param text The text of this chunk.
         * @exception IllegalArgumentException if `text` is not defined.
         */
        constructor(text) {
          super();
          if (text == null) {
            throw new Error("text cannot be null");
          }
          this._text = text;
        }
        /**
         * Gets the raw text of this chunk.
         *
         * @returns The text of the chunk.
         */
        get text() {
          return this._text;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link TextChunk} returns the result of
         * `text` in single quotes.
         */
        toString() {
          return "'" + this._text + "'";
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], TextChunk.prototype, "_text", void 0);
      __decorate([
        Decorators_1.NotNull
      ], TextChunk.prototype, "text", null);
      __decorate([
        Decorators_1.Override
      ], TextChunk.prototype, "toString", null);
      TextChunk = __decorate([
        __param(0, Decorators_1.NotNull)
      ], TextChunk);
      exports.TextChunk = TextChunk;
    }
  });

  // node_modules/antlr4ts/tree/pattern/TokenTagToken.js
  var require_TokenTagToken = __commonJS({
    "node_modules/antlr4ts/tree/pattern/TokenTagToken.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TokenTagToken = void 0;
      var CommonToken_1 = require_CommonToken();
      var Decorators_1 = require_Decorators();
      var TokenTagToken = class TokenTagToken extends CommonToken_1.CommonToken {
        /**
         * Constructs a new instance of {@link TokenTagToken} with the specified
         * token name, type, and label.
         *
         * @param tokenName The token name.
         * @param type The token type.
         * @param label The label associated with the token tag, or `undefined` if
         * the token tag is unlabeled.
         */
        constructor(tokenName, type, label) {
          super(type);
          this._tokenName = tokenName;
          this._label = label;
        }
        /**
         * Gets the token name.
         * @returns The token name.
         */
        get tokenName() {
          return this._tokenName;
        }
        /**
         * Gets the label associated with the rule tag.
         *
         * @returns The name of the label associated with the rule tag, or
         * `undefined` if this is an unlabeled rule tag.
         */
        get label() {
          return this._label;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link TokenTagToken} returns the token tag
         * formatted with `<` and `>` delimiters.
         */
        get text() {
          if (this._label != null) {
            return "<" + this._label + ":" + this._tokenName + ">";
          }
          return "<" + this._tokenName + ">";
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link TokenTagToken} returns a string of the form
         * `tokenName:type`.
         */
        toString() {
          return this._tokenName + ":" + this.type;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], TokenTagToken.prototype, "_tokenName", void 0);
      __decorate([
        Decorators_1.NotNull
      ], TokenTagToken.prototype, "tokenName", null);
      __decorate([
        Decorators_1.Override
      ], TokenTagToken.prototype, "text", null);
      __decorate([
        Decorators_1.Override
      ], TokenTagToken.prototype, "toString", null);
      TokenTagToken = __decorate([
        __param(0, Decorators_1.NotNull)
      ], TokenTagToken);
      exports.TokenTagToken = TokenTagToken;
    }
  });

  // node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js
  var require_ParseTreePatternMatcher = __commonJS({
    "node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParseTreePatternMatcher = void 0;
      var BailErrorStrategy_1 = require_BailErrorStrategy();
      var CharStreams_1 = require_CharStreams();
      var CommonTokenStream_1 = require_CommonTokenStream();
      var ListTokenSource_1 = require_ListTokenSource();
      var MultiMap_1 = require_MultiMap();
      var Decorators_1 = require_Decorators();
      var ParseCancellationException_1 = require_ParseCancellationException();
      var ParserInterpreter_1 = require_ParserInterpreter();
      var ParserRuleContext_1 = require_ParserRuleContext();
      var ParseTreeMatch_1 = require_ParseTreeMatch();
      var ParseTreePattern_1 = require_ParseTreePattern();
      var RecognitionException_1 = require_RecognitionException();
      var RuleNode_1 = require_RuleNode();
      var RuleTagToken_1 = require_RuleTagToken();
      var TagChunk_1 = require_TagChunk();
      var TerminalNode_1 = require_TerminalNode();
      var TextChunk_1 = require_TextChunk();
      var Token_1 = require_Token();
      var TokenTagToken_1 = require_TokenTagToken();
      var ParseTreePatternMatcher = class _ParseTreePatternMatcher {
        /**
         * Constructs a {@link ParseTreePatternMatcher} or from a {@link Lexer} and
         * {@link Parser} object. The lexer input stream is altered for tokenizing
         * the tree patterns. The parser is used as a convenient mechanism to get
         * the grammar name, plus token, rule names.
         */
        constructor(lexer, parser) {
          this.start = "<";
          this.stop = ">";
          this.escape = "\\";
          this.escapeRE = /\\/g;
          this._lexer = lexer;
          this._parser = parser;
        }
        /**
         * Set the delimiters used for marking rule and token tags within concrete
         * syntax used by the tree pattern parser.
         *
         * @param start The start delimiter.
         * @param stop The stop delimiter.
         * @param escapeLeft The escape sequence to use for escaping a start or stop delimiter.
         *
         * @throws {@link Error} if `start` is not defined or empty.
         * @throws {@link Error} if `stop` is not defined or empty.
         */
        setDelimiters(start, stop, escapeLeft) {
          if (!start) {
            throw new Error("start cannot be null or empty");
          }
          if (!stop) {
            throw new Error("stop cannot be null or empty");
          }
          this.start = start;
          this.stop = stop;
          this.escape = escapeLeft;
          this.escapeRE = new RegExp(escapeLeft.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g");
        }
        matches(tree, pattern, patternRuleIndex = 0) {
          if (typeof pattern === "string") {
            let p = this.compile(pattern, patternRuleIndex);
            return this.matches(tree, p);
          } else {
            let labels = new MultiMap_1.MultiMap();
            let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
            return !mismatchedNode;
          }
        }
        // Implementation of match
        match(tree, pattern, patternRuleIndex = 0) {
          if (typeof pattern === "string") {
            let p = this.compile(pattern, patternRuleIndex);
            return this.match(tree, p);
          } else {
            let labels = new MultiMap_1.MultiMap();
            let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
            return new ParseTreeMatch_1.ParseTreeMatch(tree, pattern, labels, mismatchedNode);
          }
        }
        /**
         * For repeated use of a tree pattern, compile it to a
         * {@link ParseTreePattern} using this method.
         */
        compile(pattern, patternRuleIndex) {
          let tokenList = this.tokenize(pattern);
          let tokenSrc = new ListTokenSource_1.ListTokenSource(tokenList);
          let tokens = new CommonTokenStream_1.CommonTokenStream(tokenSrc);
          const parser = this._parser;
          let parserInterp = new ParserInterpreter_1.ParserInterpreter(parser.grammarFileName, parser.vocabulary, parser.ruleNames, parser.getATNWithBypassAlts(), tokens);
          let tree;
          try {
            parserInterp.errorHandler = new BailErrorStrategy_1.BailErrorStrategy();
            tree = parserInterp.parse(patternRuleIndex);
          } catch (e) {
            if (e instanceof ParseCancellationException_1.ParseCancellationException) {
              throw e.getCause();
            } else if (e instanceof RecognitionException_1.RecognitionException) {
              throw e;
            } else if (e instanceof Error) {
              throw new _ParseTreePatternMatcher.CannotInvokeStartRule(e);
            } else {
              throw e;
            }
          }
          if (tokens.LA(1) !== Token_1.Token.EOF) {
            throw new _ParseTreePatternMatcher.StartRuleDoesNotConsumeFullPattern();
          }
          return new ParseTreePattern_1.ParseTreePattern(this, pattern, patternRuleIndex, tree);
        }
        /**
         * Used to convert the tree pattern string into a series of tokens. The
         * input stream is reset.
         */
        get lexer() {
          return this._lexer;
        }
        /**
         * Used to collect to the grammar file name, token names, rule names for
         * used to parse the pattern into a parse tree.
         */
        get parser() {
          return this._parser;
        }
        // ---- SUPPORT CODE ----
        /**
         * Recursively walk `tree` against `patternTree`, filling
         * `match.`{@link ParseTreeMatch#labels labels}.
         *
         * @returns the first node encountered in `tree` which does not match
         * a corresponding node in `patternTree`, or `undefined` if the match
         * was successful. The specific node returned depends on the matching
         * algorithm used by the implementation, and may be overridden.
         */
        matchImpl(tree, patternTree, labels) {
          if (!tree) {
            throw new TypeError("tree cannot be null");
          }
          if (!patternTree) {
            throw new TypeError("patternTree cannot be null");
          }
          if (tree instanceof TerminalNode_1.TerminalNode && patternTree instanceof TerminalNode_1.TerminalNode) {
            let mismatchedNode;
            if (tree.symbol.type === patternTree.symbol.type) {
              if (patternTree.symbol instanceof TokenTagToken_1.TokenTagToken) {
                let tokenTagToken = patternTree.symbol;
                labels.map(tokenTagToken.tokenName, tree);
                const l = tokenTagToken.label;
                if (l) {
                  labels.map(l, tree);
                }
              } else if (tree.text === patternTree.text) {
              } else {
                if (!mismatchedNode) {
                  mismatchedNode = tree;
                }
              }
            } else {
              if (!mismatchedNode) {
                mismatchedNode = tree;
              }
            }
            return mismatchedNode;
          }
          if (tree instanceof ParserRuleContext_1.ParserRuleContext && patternTree instanceof ParserRuleContext_1.ParserRuleContext) {
            let mismatchedNode;
            let ruleTagToken = this.getRuleTagToken(patternTree);
            if (ruleTagToken) {
              let m;
              if (tree.ruleContext.ruleIndex === patternTree.ruleContext.ruleIndex) {
                labels.map(ruleTagToken.ruleName, tree);
                const l = ruleTagToken.label;
                if (l) {
                  labels.map(l, tree);
                }
              } else {
                if (!mismatchedNode) {
                  mismatchedNode = tree;
                }
              }
              return mismatchedNode;
            }
            if (tree.childCount !== patternTree.childCount) {
              if (!mismatchedNode) {
                mismatchedNode = tree;
              }
              return mismatchedNode;
            }
            let n = tree.childCount;
            for (let i = 0; i < n; i++) {
              let childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);
              if (childMatch) {
                return childMatch;
              }
            }
            return mismatchedNode;
          }
          return tree;
        }
        /** Is `t` `(expr <expr>)` subtree? */
        getRuleTagToken(t) {
          if (t instanceof RuleNode_1.RuleNode) {
            if (t.childCount === 1 && t.getChild(0) instanceof TerminalNode_1.TerminalNode) {
              let c = t.getChild(0);
              if (c.symbol instanceof RuleTagToken_1.RuleTagToken) {
                return c.symbol;
              }
            }
          }
          return void 0;
        }
        tokenize(pattern) {
          let chunks = this.split(pattern);
          let tokens = [];
          for (let chunk of chunks) {
            if (chunk instanceof TagChunk_1.TagChunk) {
              let tagChunk = chunk;
              const firstChar = tagChunk.tag.substr(0, 1);
              if (firstChar === firstChar.toUpperCase()) {
                let ttype = this._parser.getTokenType(tagChunk.tag);
                if (ttype === Token_1.Token.INVALID_TYPE) {
                  throw new Error("Unknown token " + tagChunk.tag + " in pattern: " + pattern);
                }
                let t = new TokenTagToken_1.TokenTagToken(tagChunk.tag, ttype, tagChunk.label);
                tokens.push(t);
              } else if (firstChar === firstChar.toLowerCase()) {
                let ruleIndex = this._parser.getRuleIndex(tagChunk.tag);
                if (ruleIndex === -1) {
                  throw new Error("Unknown rule " + tagChunk.tag + " in pattern: " + pattern);
                }
                let ruleImaginaryTokenType = this._parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];
                tokens.push(new RuleTagToken_1.RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));
              } else {
                throw new Error("invalid tag: " + tagChunk.tag + " in pattern: " + pattern);
              }
            } else {
              let textChunk = chunk;
              this._lexer.inputStream = CharStreams_1.CharStreams.fromString(textChunk.text);
              let t = this._lexer.nextToken();
              while (t.type !== Token_1.Token.EOF) {
                tokens.push(t);
                t = this._lexer.nextToken();
              }
            }
          }
          return tokens;
        }
        /** Split `<ID> = <e:expr> ;` into 4 chunks for tokenizing by {@link #tokenize}. */
        split(pattern) {
          let p = 0;
          let n = pattern.length;
          let chunks = [];
          let buf;
          let starts = [];
          let stops = [];
          while (p < n) {
            if (p === pattern.indexOf(this.escape + this.start, p)) {
              p += this.escape.length + this.start.length;
            } else if (p === pattern.indexOf(this.escape + this.stop, p)) {
              p += this.escape.length + this.stop.length;
            } else if (p === pattern.indexOf(this.start, p)) {
              starts.push(p);
              p += this.start.length;
            } else if (p === pattern.indexOf(this.stop, p)) {
              stops.push(p);
              p += this.stop.length;
            } else {
              p++;
            }
          }
          if (starts.length > stops.length) {
            throw new Error("unterminated tag in pattern: " + pattern);
          }
          if (starts.length < stops.length) {
            throw new Error("missing start tag in pattern: " + pattern);
          }
          let ntags = starts.length;
          for (let i = 0; i < ntags; i++) {
            if (starts[i] >= stops[i]) {
              throw new Error("tag delimiters out of order in pattern: " + pattern);
            }
          }
          if (ntags === 0) {
            let text = pattern.substring(0, n);
            chunks.push(new TextChunk_1.TextChunk(text));
          }
          if (ntags > 0 && starts[0] > 0) {
            let text = pattern.substring(0, starts[0]);
            chunks.push(new TextChunk_1.TextChunk(text));
          }
          for (let i = 0; i < ntags; i++) {
            let tag = pattern.substring(starts[i] + this.start.length, stops[i]);
            let ruleOrToken = tag;
            let label;
            let colon = tag.indexOf(":");
            if (colon >= 0) {
              label = tag.substring(0, colon);
              ruleOrToken = tag.substring(colon + 1, tag.length);
            }
            chunks.push(new TagChunk_1.TagChunk(ruleOrToken, label));
            if (i + 1 < ntags) {
              let text = pattern.substring(stops[i] + this.stop.length, starts[i + 1]);
              chunks.push(new TextChunk_1.TextChunk(text));
            }
          }
          if (ntags > 0) {
            let afterLastTag = stops[ntags - 1] + this.stop.length;
            if (afterLastTag < n) {
              let text = pattern.substring(afterLastTag, n);
              chunks.push(new TextChunk_1.TextChunk(text));
            }
          }
          for (let i = 0; i < chunks.length; i++) {
            let c = chunks[i];
            if (c instanceof TextChunk_1.TextChunk) {
              let unescaped = c.text.replace(this.escapeRE, "");
              if (unescaped.length < c.text.length) {
                chunks[i] = new TextChunk_1.TextChunk(unescaped);
              }
            }
          }
          return chunks;
        }
      };
      __decorate([
        Decorators_1.NotNull,
        __param(1, Decorators_1.NotNull)
      ], ParseTreePatternMatcher.prototype, "match", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreePatternMatcher.prototype, "lexer", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreePatternMatcher.prototype, "parser", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ParseTreePatternMatcher.prototype, "matchImpl", null);
      exports.ParseTreePatternMatcher = ParseTreePatternMatcher;
      (function(ParseTreePatternMatcher2) {
        class CannotInvokeStartRule extends Error {
          constructor(error) {
            super(`CannotInvokeStartRule: ${error}`);
            this.error = error;
          }
        }
        ParseTreePatternMatcher2.CannotInvokeStartRule = CannotInvokeStartRule;
        class StartRuleDoesNotConsumeFullPattern extends Error {
          constructor() {
            super("StartRuleDoesNotConsumeFullPattern");
          }
        }
        ParseTreePatternMatcher2.StartRuleDoesNotConsumeFullPattern = StartRuleDoesNotConsumeFullPattern;
      })(ParseTreePatternMatcher = exports.ParseTreePatternMatcher || (exports.ParseTreePatternMatcher = {}));
    }
  });

  // node_modules/antlr4ts/atn/DecisionEventInfo.js
  var require_DecisionEventInfo = __commonJS({
    "node_modules/antlr4ts/atn/DecisionEventInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DecisionEventInfo = void 0;
      var Decorators_1 = require_Decorators();
      var DecisionEventInfo = class DecisionEventInfo {
        constructor(decision, state, input, startIndex, stopIndex, fullCtx) {
          this.decision = decision;
          this.fullCtx = fullCtx;
          this.stopIndex = stopIndex;
          this.input = input;
          this.startIndex = startIndex;
          this.state = state;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], DecisionEventInfo.prototype, "input", void 0);
      DecisionEventInfo = __decorate([
        __param(2, Decorators_1.NotNull)
      ], DecisionEventInfo);
      exports.DecisionEventInfo = DecisionEventInfo;
    }
  });

  // node_modules/antlr4ts/atn/AmbiguityInfo.js
  var require_AmbiguityInfo = __commonJS({
    "node_modules/antlr4ts/atn/AmbiguityInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AmbiguityInfo = void 0;
      var DecisionEventInfo_1 = require_DecisionEventInfo();
      var Decorators_1 = require_Decorators();
      var AmbiguityInfo = class AmbiguityInfo extends DecisionEventInfo_1.DecisionEventInfo {
        /**
         * Constructs a new instance of the {@link AmbiguityInfo} class with the
         * specified detailed ambiguity information.
         *
         * @param decision The decision number
         * @param state The final simulator state identifying the ambiguous
         * alternatives for the current input
         * @param ambigAlts The set of alternatives in the decision that lead to a valid parse.
         *                  The predicted alt is the min(ambigAlts)
         * @param input The input token stream
         * @param startIndex The start index for the current prediction
         * @param stopIndex The index at which the ambiguity was identified during
         * prediction
         */
        constructor(decision, state, ambigAlts, input, startIndex, stopIndex) {
          super(decision, state, input, startIndex, stopIndex, state.useContext);
          this.ambigAlts = ambigAlts;
        }
        /**
         * Gets the set of alternatives in the decision that lead to a valid parse.
         *
         * @since 4.5
         */
        get ambiguousAlternatives() {
          return this.ambigAlts;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], AmbiguityInfo.prototype, "ambigAlts", void 0);
      __decorate([
        Decorators_1.NotNull
      ], AmbiguityInfo.prototype, "ambiguousAlternatives", null);
      AmbiguityInfo = __decorate([
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull),
        __param(3, Decorators_1.NotNull)
      ], AmbiguityInfo);
      exports.AmbiguityInfo = AmbiguityInfo;
    }
  });

  // node_modules/antlr4ts/atn/ContextSensitivityInfo.js
  var require_ContextSensitivityInfo = __commonJS({
    "node_modules/antlr4ts/atn/ContextSensitivityInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ContextSensitivityInfo = void 0;
      var DecisionEventInfo_1 = require_DecisionEventInfo();
      var Decorators_1 = require_Decorators();
      var ContextSensitivityInfo = class ContextSensitivityInfo extends DecisionEventInfo_1.DecisionEventInfo {
        /**
         * Constructs a new instance of the {@link ContextSensitivityInfo} class
         * with the specified detailed context sensitivity information.
         *
         * @param decision The decision number
         * @param state The final simulator state containing the unique
         * alternative identified by full-context prediction
         * @param input The input token stream
         * @param startIndex The start index for the current prediction
         * @param stopIndex The index at which the context sensitivity was
         * identified during full-context prediction
         */
        constructor(decision, state, input, startIndex, stopIndex) {
          super(decision, state, input, startIndex, stopIndex, true);
        }
      };
      ContextSensitivityInfo = __decorate([
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ContextSensitivityInfo);
      exports.ContextSensitivityInfo = ContextSensitivityInfo;
    }
  });

  // node_modules/antlr4ts/atn/DecisionInfo.js
  var require_DecisionInfo = __commonJS({
    "node_modules/antlr4ts/atn/DecisionInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DecisionInfo = void 0;
      var Decorators_1 = require_Decorators();
      var DecisionInfo = class {
        /**
         * Constructs a new instance of the {@link DecisionInfo} class to contain
         * statistics for a particular decision.
         *
         * @param decision The decision number
         */
        constructor(decision) {
          this.invocations = 0;
          this.timeInPrediction = 0;
          this.SLL_TotalLook = 0;
          this.SLL_MinLook = 0;
          this.SLL_MaxLook = 0;
          this.LL_TotalLook = 0;
          this.LL_MinLook = 0;
          this.LL_MaxLook = 0;
          this.contextSensitivities = [];
          this.errors = [];
          this.ambiguities = [];
          this.predicateEvals = [];
          this.SLL_ATNTransitions = 0;
          this.SLL_DFATransitions = 0;
          this.LL_Fallback = 0;
          this.LL_ATNTransitions = 0;
          this.LL_DFATransitions = 0;
          this.decision = decision;
        }
        toString() {
          return "{decision=" + this.decision + ", contextSensitivities=" + this.contextSensitivities.length + ", errors=" + this.errors.length + ", ambiguities=" + this.ambiguities.length + ", SLL_lookahead=" + this.SLL_TotalLook + ", SLL_ATNTransitions=" + this.SLL_ATNTransitions + ", SLL_DFATransitions=" + this.SLL_DFATransitions + ", LL_Fallback=" + this.LL_Fallback + ", LL_lookahead=" + this.LL_TotalLook + ", LL_ATNTransitions=" + this.LL_ATNTransitions + "}";
        }
      };
      __decorate([
        Decorators_1.Override
      ], DecisionInfo.prototype, "toString", null);
      exports.DecisionInfo = DecisionInfo;
    }
  });

  // node_modules/antlr4ts/atn/ErrorInfo.js
  var require_ErrorInfo = __commonJS({
    "node_modules/antlr4ts/atn/ErrorInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ErrorInfo = void 0;
      var DecisionEventInfo_1 = require_DecisionEventInfo();
      var Decorators_1 = require_Decorators();
      var ErrorInfo = class ErrorInfo extends DecisionEventInfo_1.DecisionEventInfo {
        /**
         * Constructs a new instance of the {@link ErrorInfo} class with the
         * specified detailed syntax error information.
         *
         * @param decision The decision number
         * @param state The final simulator state reached during prediction
         * prior to reaching the {@link ATNSimulator#ERROR} state
         * @param input The input token stream
         * @param startIndex The start index for the current prediction
         * @param stopIndex The index at which the syntax error was identified
         */
        constructor(decision, state, input, startIndex, stopIndex) {
          super(decision, state, input, startIndex, stopIndex, state.useContext);
        }
      };
      ErrorInfo = __decorate([
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ErrorInfo);
      exports.ErrorInfo = ErrorInfo;
    }
  });

  // node_modules/antlr4ts/atn/LookaheadEventInfo.js
  var require_LookaheadEventInfo = __commonJS({
    "node_modules/antlr4ts/atn/LookaheadEventInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LookaheadEventInfo = void 0;
      var DecisionEventInfo_1 = require_DecisionEventInfo();
      var Decorators_1 = require_Decorators();
      var LookaheadEventInfo = class LookaheadEventInfo extends DecisionEventInfo_1.DecisionEventInfo {
        /**
         * Constructs a new instance of the {@link LookaheadEventInfo} class with
         * the specified detailed lookahead information.
         *
         * @param decision The decision number
         * @param state The final simulator state containing the necessary
         * information to determine the result of a prediction, or `undefined` if
         * the final state is not available
         * @param input The input token stream
         * @param startIndex The start index for the current prediction
         * @param stopIndex The index at which the prediction was finally made
         * @param fullCtx `true` if the current lookahead is part of an LL
         * prediction; otherwise, `false` if the current lookahead is part of
         * an SLL prediction
         */
        constructor(decision, state, predictedAlt, input, startIndex, stopIndex, fullCtx) {
          super(decision, state, input, startIndex, stopIndex, fullCtx);
          this.predictedAlt = predictedAlt;
        }
      };
      LookaheadEventInfo = __decorate([
        __param(3, Decorators_1.NotNull)
      ], LookaheadEventInfo);
      exports.LookaheadEventInfo = LookaheadEventInfo;
    }
  });

  // node_modules/antlr4ts/atn/PredicateEvalInfo.js
  var require_PredicateEvalInfo = __commonJS({
    "node_modules/antlr4ts/atn/PredicateEvalInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PredicateEvalInfo = void 0;
      var DecisionEventInfo_1 = require_DecisionEventInfo();
      var Decorators_1 = require_Decorators();
      var PredicateEvalInfo = class PredicateEvalInfo extends DecisionEventInfo_1.DecisionEventInfo {
        /**
         * Constructs a new instance of the {@link PredicateEvalInfo} class with the
         * specified detailed predicate evaluation information.
         *
         * @param state The simulator state
         * @param decision The decision number
         * @param input The input token stream
         * @param startIndex The start index for the current prediction
         * @param stopIndex The index at which the predicate evaluation was
         * triggered. Note that the input stream may be reset to other positions for
         * the actual evaluation of individual predicates.
         * @param semctx The semantic context which was evaluated
         * @param evalResult The results of evaluating the semantic context
         * @param predictedAlt The alternative number for the decision which is
         * guarded by the semantic context `semctx`. See {@link #predictedAlt}
         * for more information.
         *
         * @see ParserATNSimulator#evalSemanticContext(SemanticContext, ParserRuleContext, int)
         * @see SemanticContext#eval(Recognizer, RuleContext)
         */
        constructor(state, decision, input, startIndex, stopIndex, semctx, evalResult, predictedAlt) {
          super(decision, state, input, startIndex, stopIndex, state.useContext);
          this.semctx = semctx;
          this.evalResult = evalResult;
          this.predictedAlt = predictedAlt;
        }
      };
      PredicateEvalInfo = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull),
        __param(5, Decorators_1.NotNull)
      ], PredicateEvalInfo);
      exports.PredicateEvalInfo = PredicateEvalInfo;
    }
  });

  // node_modules/antlr4ts/atn/ProfilingATNSimulator.js
  var require_ProfilingATNSimulator = __commonJS({
    "node_modules/antlr4ts/atn/ProfilingATNSimulator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProfilingATNSimulator = void 0;
      var AmbiguityInfo_1 = require_AmbiguityInfo();
      var ATN_1 = require_ATN();
      var ATNSimulator_1 = require_ATNSimulator();
      var ContextSensitivityInfo_1 = require_ContextSensitivityInfo();
      var DecisionInfo_1 = require_DecisionInfo();
      var ErrorInfo_1 = require_ErrorInfo();
      var Decorators_1 = require_Decorators();
      var LookaheadEventInfo_1 = require_LookaheadEventInfo();
      var ParserATNSimulator_1 = require_ParserATNSimulator();
      var PredicateEvalInfo_1 = require_PredicateEvalInfo();
      var SemanticContext_1 = require_SemanticContext();
      var SimulatorState_1 = require_SimulatorState();
      var ProfilingATNSimulator = class extends ParserATNSimulator_1.ParserATNSimulator {
        constructor(parser) {
          super(parser.interpreter.atn, parser);
          this._startIndex = 0;
          this._sllStopIndex = 0;
          this._llStopIndex = 0;
          this.currentDecision = 0;
          this.conflictingAltResolvedBySLL = 0;
          this.optimize_ll1 = false;
          this.reportAmbiguities = true;
          this.numDecisions = this.atn.decisionToState.length;
          this.decisions = [];
          for (let i = 0; i < this.numDecisions; i++) {
            this.decisions.push(new DecisionInfo_1.DecisionInfo(i));
          }
        }
        adaptivePredict(input, decision, outerContext, useContext) {
          if (useContext !== void 0) {
            return super.adaptivePredict(input, decision, outerContext, useContext);
          }
          try {
            this._input = input;
            this._startIndex = input.index;
            this._sllStopIndex = this._startIndex - 1;
            this._llStopIndex = -1;
            this.currentDecision = decision;
            this.currentState = void 0;
            this.conflictingAltResolvedBySLL = ATN_1.ATN.INVALID_ALT_NUMBER;
            let start = process.hrtime();
            let alt = super.adaptivePredict(input, decision, outerContext);
            let stop = process.hrtime();
            let nanoseconds = (stop[0] - start[0]) * 1e9;
            if (nanoseconds === 0) {
              nanoseconds = stop[1] - start[1];
            } else {
              nanoseconds += 1e9 - start[1] + stop[1];
            }
            this.decisions[decision].timeInPrediction += nanoseconds;
            this.decisions[decision].invocations++;
            let SLL_k = this._sllStopIndex - this._startIndex + 1;
            this.decisions[decision].SLL_TotalLook += SLL_k;
            this.decisions[decision].SLL_MinLook = this.decisions[decision].SLL_MinLook === 0 ? SLL_k : Math.min(this.decisions[decision].SLL_MinLook, SLL_k);
            if (SLL_k > this.decisions[decision].SLL_MaxLook) {
              this.decisions[decision].SLL_MaxLook = SLL_k;
              this.decisions[decision].SLL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._sllStopIndex, false);
            }
            if (this._llStopIndex >= 0) {
              let LL_k = this._llStopIndex - this._startIndex + 1;
              this.decisions[decision].LL_TotalLook += LL_k;
              this.decisions[decision].LL_MinLook = this.decisions[decision].LL_MinLook === 0 ? LL_k : Math.min(this.decisions[decision].LL_MinLook, LL_k);
              if (LL_k > this.decisions[decision].LL_MaxLook) {
                this.decisions[decision].LL_MaxLook = LL_k;
                this.decisions[decision].LL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._llStopIndex, true);
              }
            }
            return alt;
          } finally {
            this._input = void 0;
            this.currentDecision = -1;
          }
        }
        getStartState(dfa, input, outerContext, useContext) {
          let state = super.getStartState(dfa, input, outerContext, useContext);
          this.currentState = state;
          return state;
        }
        computeStartState(dfa, globalContext, useContext) {
          let state = super.computeStartState(dfa, globalContext, useContext);
          this.currentState = state;
          return state;
        }
        computeReachSet(dfa, previous, t, contextCache) {
          if (this._input === void 0) {
            throw new Error("Invalid state");
          }
          let reachState = super.computeReachSet(dfa, previous, t, contextCache);
          if (reachState == null) {
            this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, previous, this._input, this._startIndex, this._input.index));
          }
          this.currentState = reachState;
          return reachState;
        }
        getExistingTargetState(previousD, t) {
          if (this.currentState === void 0 || this._input === void 0) {
            throw new Error("Invalid state");
          }
          if (this.currentState.useContext) {
            this._llStopIndex = this._input.index;
          } else {
            this._sllStopIndex = this._input.index;
          }
          let existingTargetState = super.getExistingTargetState(previousD, t);
          if (existingTargetState != null) {
            this.currentState = new SimulatorState_1.SimulatorState(this.currentState.outerContext, existingTargetState, this.currentState.useContext, this.currentState.remainingOuterContext);
            if (this.currentState.useContext) {
              this.decisions[this.currentDecision].LL_DFATransitions++;
            } else {
              this.decisions[this.currentDecision].SLL_DFATransitions++;
            }
            if (existingTargetState === ATNSimulator_1.ATNSimulator.ERROR) {
              let state = new SimulatorState_1.SimulatorState(this.currentState.outerContext, previousD, this.currentState.useContext, this.currentState.remainingOuterContext);
              this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, state, this._input, this._startIndex, this._input.index));
            }
          }
          return existingTargetState;
        }
        computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
          let targetState = super.computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache);
          if (useContext) {
            this.decisions[this.currentDecision].LL_ATNTransitions++;
          } else {
            this.decisions[this.currentDecision].SLL_ATNTransitions++;
          }
          return targetState;
        }
        evalSemanticContextImpl(pred, parserCallStack, alt) {
          if (this.currentState === void 0 || this._input === void 0) {
            throw new Error("Invalid state");
          }
          let result = super.evalSemanticContextImpl(pred, parserCallStack, alt);
          if (!(pred instanceof SemanticContext_1.SemanticContext.PrecedencePredicate)) {
            let fullContext = this._llStopIndex >= 0;
            let stopIndex = fullContext ? this._llStopIndex : this._sllStopIndex;
            this.decisions[this.currentDecision].predicateEvals.push(new PredicateEvalInfo_1.PredicateEvalInfo(this.currentState, this.currentDecision, this._input, this._startIndex, stopIndex, pred, result, alt));
          }
          return result;
        }
        reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
          if (this._input === void 0) {
            throw new Error("Invalid state");
          }
          if (prediction !== this.conflictingAltResolvedBySLL) {
            this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, acceptState, this._input, startIndex, stopIndex));
          }
          super.reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex);
        }
        reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
          if (conflictingAlts != null) {
            this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);
          } else {
            this.conflictingAltResolvedBySLL = conflictState.s0.configs.getRepresentedAlternatives().nextSetBit(0);
          }
          this.decisions[this.currentDecision].LL_Fallback++;
          super.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex);
        }
        reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
          if (this.currentState === void 0 || this._input === void 0) {
            throw new Error("Invalid state");
          }
          let prediction;
          if (ambigAlts != null) {
            prediction = ambigAlts.nextSetBit(0);
          } else {
            prediction = configs.getRepresentedAlternatives().nextSetBit(0);
          }
          if (this.conflictingAltResolvedBySLL !== ATN_1.ATN.INVALID_ALT_NUMBER && prediction !== this.conflictingAltResolvedBySLL) {
            this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, this.currentState, this._input, startIndex, stopIndex));
          }
          this.decisions[this.currentDecision].ambiguities.push(new AmbiguityInfo_1.AmbiguityInfo(this.currentDecision, this.currentState, ambigAlts, this._input, startIndex, stopIndex));
          super.reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs);
        }
        // ---------------------------------------------------------------------
        getDecisionInfo() {
          return this.decisions;
        }
        getCurrentState() {
          return this.currentState;
        }
      };
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], ProfilingATNSimulator.prototype, "adaptivePredict", null);
      __decorate([
        Decorators_1.Override
      ], ProfilingATNSimulator.prototype, "getStartState", null);
      __decorate([
        Decorators_1.Override
      ], ProfilingATNSimulator.prototype, "computeStartState", null);
      __decorate([
        Decorators_1.Override
      ], ProfilingATNSimulator.prototype, "computeReachSet", null);
      __decorate([
        Decorators_1.Override
      ], ProfilingATNSimulator.prototype, "getExistingTargetState", null);
      __decorate([
        Decorators_1.Override
      ], ProfilingATNSimulator.prototype, "computeTargetState", null);
      __decorate([
        Decorators_1.Override
      ], ProfilingATNSimulator.prototype, "evalSemanticContextImpl", null);
      __decorate([
        Decorators_1.Override
      ], ProfilingATNSimulator.prototype, "reportContextSensitivity", null);
      __decorate([
        Decorators_1.Override
      ], ProfilingATNSimulator.prototype, "reportAttemptingFullContext", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull),
        __param(5, Decorators_1.NotNull),
        __param(6, Decorators_1.NotNull)
      ], ProfilingATNSimulator.prototype, "reportAmbiguity", null);
      exports.ProfilingATNSimulator = ProfilingATNSimulator;
    }
  });

  // node_modules/antlr4ts/Parser.js
  var require_Parser = __commonJS({
    "node_modules/antlr4ts/Parser.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Parser = void 0;
      var Utils3 = require_Utils();
      var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();
      var ATNDeserializer_1 = require_ATNDeserializer();
      var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();
      var ErrorNode_1 = require_ErrorNode();
      var IntegerStack_1 = require_IntegerStack();
      var Lexer_1 = require_Lexer();
      var Decorators_1 = require_Decorators();
      var ParseInfo_1 = require_ParseInfo();
      var ParserATNSimulator_1 = require_ParserATNSimulator();
      var ProxyParserErrorListener_1 = require_ProxyParserErrorListener();
      var Recognizer_1 = require_Recognizer();
      var TerminalNode_1 = require_TerminalNode();
      var Token_1 = require_Token();
      var TraceListener = class {
        constructor(ruleNames, tokenStream) {
          this.ruleNames = ruleNames;
          this.tokenStream = tokenStream;
        }
        enterEveryRule(ctx) {
          console.log("enter   " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
        }
        exitEveryRule(ctx) {
          console.log("exit    " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
        }
        visitErrorNode(node) {
        }
        visitTerminal(node) {
          let parent = node.parent.ruleContext;
          let token = node.symbol;
          console.log("consume " + token + " rule " + this.ruleNames[parent.ruleIndex]);
        }
      };
      __decorate([
        Decorators_1.Override
      ], TraceListener.prototype, "enterEveryRule", null);
      __decorate([
        Decorators_1.Override
      ], TraceListener.prototype, "exitEveryRule", null);
      __decorate([
        Decorators_1.Override
      ], TraceListener.prototype, "visitErrorNode", null);
      __decorate([
        Decorators_1.Override
      ], TraceListener.prototype, "visitTerminal", null);
      var Parser2 = class _Parser extends Recognizer_1.Recognizer {
        constructor(input) {
          super();
          this._errHandler = new DefaultErrorStrategy_1.DefaultErrorStrategy();
          this._precedenceStack = new IntegerStack_1.IntegerStack();
          this._buildParseTrees = true;
          this._parseListeners = [];
          this._syntaxErrors = 0;
          this.matchedEOF = false;
          this._precedenceStack.push(0);
          this.inputStream = input;
        }
        reset(resetInput) {
          if (resetInput === void 0 || resetInput) {
            this.inputStream.seek(0);
          }
          this._errHandler.reset(this);
          this._ctx = void 0;
          this._syntaxErrors = 0;
          this.matchedEOF = false;
          this.isTrace = false;
          this._precedenceStack.clear();
          this._precedenceStack.push(0);
          let interpreter = this.interpreter;
          if (interpreter != null) {
            interpreter.reset();
          }
        }
        /**
         * Match current input symbol against `ttype`. If the symbol type
         * matches, {@link ANTLRErrorStrategy#reportMatch} and {@link #consume} are
         * called to complete the match process.
         *
         * If the symbol type does not match,
         * {@link ANTLRErrorStrategy#recoverInline} is called on the current error
         * strategy to attempt recovery. If {@link #getBuildParseTree} is
         * `true` and the token index of the symbol returned by
         * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to
         * the parse tree by calling {@link #createErrorNode(ParserRuleContext, Token)} then
         * {@link ParserRuleContext#addErrorNode(ErrorNode)}.
         *
         * @param ttype the token type to match
         * @returns the matched symbol
         * @ if the current input symbol did not match
         * `ttype` and the error strategy could not recover from the
         * mismatched symbol
         */
        match(ttype) {
          let t = this.currentToken;
          if (t.type === ttype) {
            if (ttype === Token_1.Token.EOF) {
              this.matchedEOF = true;
            }
            this._errHandler.reportMatch(this);
            this.consume();
          } else {
            t = this._errHandler.recoverInline(this);
            if (this._buildParseTrees && t.tokenIndex === -1) {
              this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
            }
          }
          return t;
        }
        /**
         * Match current input symbol as a wildcard. If the symbol type matches
         * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy#reportMatch}
         * and {@link #consume} are called to complete the match process.
         *
         * If the symbol type does not match,
         * {@link ANTLRErrorStrategy#recoverInline} is called on the current error
         * strategy to attempt recovery. If {@link #getBuildParseTree} is
         * `true` and the token index of the symbol returned by
         * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to
         * the parse tree by calling {@link Parser#createErrorNode(ParserRuleContext, Token)} then
         * {@link ParserRuleContext#addErrorNode(ErrorNode)}.
         *
         * @returns the matched symbol
         * @ if the current input symbol did not match
         * a wildcard and the error strategy could not recover from the mismatched
         * symbol
         */
        matchWildcard() {
          let t = this.currentToken;
          if (t.type > 0) {
            this._errHandler.reportMatch(this);
            this.consume();
          } else {
            t = this._errHandler.recoverInline(this);
            if (this._buildParseTrees && t.tokenIndex === -1) {
              this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
            }
          }
          return t;
        }
        /**
         * Track the {@link ParserRuleContext} objects during the parse and hook
         * them up using the {@link ParserRuleContext#children} list so that it
         * forms a parse tree. The {@link ParserRuleContext} returned from the start
         * rule represents the root of the parse tree.
         *
         * Note that if we are not building parse trees, rule contexts only point
         * upwards. When a rule exits, it returns the context but that gets garbage
         * collected if nobody holds a reference. It points upwards but nobody
         * points at it.
         *
         * When we build parse trees, we are adding all of these contexts to
         * {@link ParserRuleContext#children} list. Contexts are then not candidates
         * for garbage collection.
         */
        set buildParseTree(buildParseTrees) {
          this._buildParseTrees = buildParseTrees;
        }
        /**
         * Gets whether or not a complete parse tree will be constructed while
         * parsing. This property is `true` for a newly constructed parser.
         *
         * @returns `true` if a complete parse tree will be constructed while
         * parsing, otherwise `false`
         */
        get buildParseTree() {
          return this._buildParseTrees;
        }
        getParseListeners() {
          return this._parseListeners;
        }
        /**
         * Registers `listener` to receive events during the parsing process.
         *
         * To support output-preserving grammar transformations (including but not
         * limited to left-recursion removal, automated left-factoring, and
         * optimized code generation), calls to listener methods during the parse
         * may differ substantially from calls made by
         * {@link ParseTreeWalker#DEFAULT} used after the parse is complete. In
         * particular, rule entry and exit events may occur in a different order
         * during the parse than after the parser. In addition, calls to certain
         * rule entry methods may be omitted.
         *
         * With the following specific exceptions, calls to listener events are
         * *deterministic*, i.e. for identical input the calls to listener
         * methods will be the same.
         *
         * * Alterations to the grammar used to generate code may change the
         *   behavior of the listener calls.
         * * Alterations to the command line options passed to ANTLR 4 when
         *   generating the parser may change the behavior of the listener calls.
         * * Changing the version of the ANTLR Tool used to generate the parser
         *   may change the behavior of the listener calls.
         *
         * @param listener the listener to add
         *
         * @throws {@link TypeError} if `listener` is `undefined`
         */
        addParseListener(listener) {
          if (listener == null) {
            throw new TypeError("listener cannot be null");
          }
          this._parseListeners.push(listener);
        }
        /**
         * Remove `listener` from the list of parse listeners.
         *
         * If `listener` is `undefined` or has not been added as a parse
         * listener, this method does nothing.
         *
         * @see #addParseListener
         *
         * @param listener the listener to remove
         */
        removeParseListener(listener) {
          let index = this._parseListeners.findIndex((l) => l === listener);
          if (index !== -1) {
            this._parseListeners.splice(index, 1);
          }
        }
        /**
         * Remove all parse listeners.
         *
         * @see #addParseListener
         */
        removeParseListeners() {
          this._parseListeners.length = 0;
        }
        /**
         * Notify any parse listeners of an enter rule event.
         *
         * @see #addParseListener
         */
        triggerEnterRuleEvent() {
          for (let listener of this._parseListeners) {
            if (listener.enterEveryRule) {
              listener.enterEveryRule(this._ctx);
            }
            this._ctx.enterRule(listener);
          }
        }
        /**
         * Notify any parse listeners of an exit rule event.
         *
         * @see #addParseListener
         */
        triggerExitRuleEvent() {
          for (let i = this._parseListeners.length - 1; i >= 0; i--) {
            let listener = this._parseListeners[i];
            this._ctx.exitRule(listener);
            if (listener.exitEveryRule) {
              listener.exitEveryRule(this._ctx);
            }
          }
        }
        /**
         * Gets the number of syntax errors reported during parsing. This value is
         * incremented each time {@link #notifyErrorListeners} is called.
         *
         * @see #notifyErrorListeners
         */
        get numberOfSyntaxErrors() {
          return this._syntaxErrors;
        }
        get tokenFactory() {
          return this._input.tokenSource.tokenFactory;
        }
        /**
         * The ATN with bypass alternatives is expensive to create so we create it
         * lazily.
         *
         * @ if the current parser does not
         * implement the `serializedATN` property.
         */
        getATNWithBypassAlts() {
          let serializedAtn = this.serializedATN;
          if (serializedAtn == null) {
            throw new Error("The current parser does not support an ATN with bypass alternatives.");
          }
          let result = _Parser.bypassAltsAtnCache.get(serializedAtn);
          if (result == null) {
            let deserializationOptions = new ATNDeserializationOptions_1.ATNDeserializationOptions();
            deserializationOptions.isGenerateRuleBypassTransitions = true;
            result = new ATNDeserializer_1.ATNDeserializer(deserializationOptions).deserialize(Utils3.toCharArray(serializedAtn));
            _Parser.bypassAltsAtnCache.set(serializedAtn, result);
          }
          return result;
        }
        compileParseTreePattern(pattern, patternRuleIndex, lexer) {
          return __awaiter(this, void 0, void 0, function* () {
            if (!lexer) {
              if (this.inputStream) {
                let tokenSource = this.inputStream.tokenSource;
                if (tokenSource instanceof Lexer_1.Lexer) {
                  lexer = tokenSource;
                }
              }
              if (!lexer) {
                throw new Error("Parser can't discover a lexer to use");
              }
            }
            let currentLexer = lexer;
            let m = yield Promise.resolve().then(() => require_ParseTreePatternMatcher());
            let matcher = new m.ParseTreePatternMatcher(currentLexer, this);
            return matcher.compile(pattern, patternRuleIndex);
          });
        }
        get errorHandler() {
          return this._errHandler;
        }
        set errorHandler(handler) {
          this._errHandler = handler;
        }
        get inputStream() {
          return this._input;
        }
        /** Set the token stream and reset the parser. */
        set inputStream(input) {
          this.reset(false);
          this._input = input;
        }
        /** Match needs to return the current input symbol, which gets put
         *  into the label for the associated token ref; e.g., x=ID.
         */
        get currentToken() {
          return this._input.LT(1);
        }
        notifyErrorListeners(msg, offendingToken, e) {
          if (offendingToken === void 0) {
            offendingToken = this.currentToken;
          } else if (offendingToken === null) {
            offendingToken = void 0;
          }
          this._syntaxErrors++;
          let line = -1;
          let charPositionInLine = -1;
          if (offendingToken != null) {
            line = offendingToken.line;
            charPositionInLine = offendingToken.charPositionInLine;
          }
          let listener = this.getErrorListenerDispatch();
          if (listener.syntaxError) {
            listener.syntaxError(this, offendingToken, line, charPositionInLine, msg, e);
          }
        }
        /**
         * Consume and return the [current symbol](`currentToken`).
         *
         * E.g., given the following input with `A` being the current
         * lookahead symbol, this function moves the cursor to `B` and returns
         * `A`.
         *
         * ```
         * A B
         * ^
         * ```
         *
         * If the parser is not in error recovery mode, the consumed symbol is added
         * to the parse tree using {@link ParserRuleContext#addChild(TerminalNode)}, and
         * {@link ParseTreeListener#visitTerminal} is called on any parse listeners.
         * If the parser *is* in error recovery mode, the consumed symbol is
         * added to the parse tree using {@link #createErrorNode(ParserRuleContext, Token)} then
         * {@link ParserRuleContext#addErrorNode(ErrorNode)} and
         * {@link ParseTreeListener#visitErrorNode} is called on any parse
         * listeners.
         */
        consume() {
          let o = this.currentToken;
          if (o.type !== _Parser.EOF) {
            this.inputStream.consume();
          }
          let hasListener = this._parseListeners.length !== 0;
          if (this._buildParseTrees || hasListener) {
            if (this._errHandler.inErrorRecoveryMode(this)) {
              let node = this._ctx.addErrorNode(this.createErrorNode(this._ctx, o));
              if (hasListener) {
                for (let listener of this._parseListeners) {
                  if (listener.visitErrorNode) {
                    listener.visitErrorNode(node);
                  }
                }
              }
            } else {
              let node = this.createTerminalNode(this._ctx, o);
              this._ctx.addChild(node);
              if (hasListener) {
                for (let listener of this._parseListeners) {
                  if (listener.visitTerminal) {
                    listener.visitTerminal(node);
                  }
                }
              }
            }
          }
          return o;
        }
        /**
         * How to create a token leaf node associated with a parent.
         * Typically, the terminal node to create is not a function of the parent.
         *
         * @since 4.7
         */
        createTerminalNode(parent, t) {
          return new TerminalNode_1.TerminalNode(t);
        }
        /**
         * How to create an error node, given a token, associated with a parent.
         * Typically, the error node to create is not a function of the parent.
         *
         * @since 4.7
         */
        createErrorNode(parent, t) {
          return new ErrorNode_1.ErrorNode(t);
        }
        addContextToParseTree() {
          let parent = this._ctx._parent;
          if (parent != null) {
            parent.addChild(this._ctx);
          }
        }
        /**
         * Always called by generated parsers upon entry to a rule. Access field
         * {@link #_ctx} get the current context.
         */
        enterRule(localctx, state, ruleIndex) {
          this.state = state;
          this._ctx = localctx;
          this._ctx._start = this._input.LT(1);
          if (this._buildParseTrees) {
            this.addContextToParseTree();
          }
          this.triggerEnterRuleEvent();
        }
        enterLeftFactoredRule(localctx, state, ruleIndex) {
          this.state = state;
          if (this._buildParseTrees) {
            let factoredContext = this._ctx.getChild(this._ctx.childCount - 1);
            this._ctx.removeLastChild();
            factoredContext._parent = localctx;
            localctx.addChild(factoredContext);
          }
          this._ctx = localctx;
          this._ctx._start = this._input.LT(1);
          if (this._buildParseTrees) {
            this.addContextToParseTree();
          }
          this.triggerEnterRuleEvent();
        }
        exitRule() {
          if (this.matchedEOF) {
            this._ctx._stop = this._input.LT(1);
          } else {
            this._ctx._stop = this._input.tryLT(-1);
          }
          this.triggerExitRuleEvent();
          this.state = this._ctx.invokingState;
          this._ctx = this._ctx._parent;
        }
        enterOuterAlt(localctx, altNum) {
          localctx.altNumber = altNum;
          if (this._buildParseTrees && this._ctx !== localctx) {
            let parent = this._ctx._parent;
            if (parent != null) {
              parent.removeLastChild();
              parent.addChild(localctx);
            }
          }
          this._ctx = localctx;
        }
        /**
         * Get the precedence level for the top-most precedence rule.
         *
         * @returns The precedence level for the top-most precedence rule, or -1 if
         * the parser context is not nested within a precedence rule.
         */
        get precedence() {
          if (this._precedenceStack.isEmpty) {
            return -1;
          }
          return this._precedenceStack.peek();
        }
        enterRecursionRule(localctx, state, ruleIndex, precedence) {
          this.state = state;
          this._precedenceStack.push(precedence);
          this._ctx = localctx;
          this._ctx._start = this._input.LT(1);
          this.triggerEnterRuleEvent();
        }
        /** Like {@link #enterRule} but for recursive rules.
         *  Make the current context the child of the incoming localctx.
         */
        pushNewRecursionContext(localctx, state, ruleIndex) {
          let previous = this._ctx;
          previous._parent = localctx;
          previous.invokingState = state;
          previous._stop = this._input.tryLT(-1);
          this._ctx = localctx;
          this._ctx._start = previous._start;
          if (this._buildParseTrees) {
            this._ctx.addChild(previous);
          }
          this.triggerEnterRuleEvent();
        }
        unrollRecursionContexts(_parentctx) {
          this._precedenceStack.pop();
          this._ctx._stop = this._input.tryLT(-1);
          let retctx = this._ctx;
          if (this._parseListeners.length > 0) {
            while (this._ctx !== _parentctx) {
              this.triggerExitRuleEvent();
              this._ctx = this._ctx._parent;
            }
          } else {
            this._ctx = _parentctx;
          }
          retctx._parent = _parentctx;
          if (this._buildParseTrees && _parentctx != null) {
            _parentctx.addChild(retctx);
          }
        }
        getInvokingContext(ruleIndex) {
          let p = this._ctx;
          while (p && p.ruleIndex !== ruleIndex) {
            p = p._parent;
          }
          return p;
        }
        get context() {
          return this._ctx;
        }
        set context(ctx) {
          this._ctx = ctx;
        }
        precpred(localctx, precedence) {
          return precedence >= this._precedenceStack.peek();
        }
        getErrorListenerDispatch() {
          return new ProxyParserErrorListener_1.ProxyParserErrorListener(this.getErrorListeners());
        }
        inContext(context) {
          return false;
        }
        /**
         * Checks whether or not `symbol` can follow the current state in the
         * ATN. The behavior of this method is equivalent to the following, but is
         * implemented such that the complete context-sensitive follow set does not
         * need to be explicitly constructed.
         *
         * ```
         * return getExpectedTokens().contains(symbol);
         * ```
         *
         * @param symbol the symbol type to check
         * @returns `true` if `symbol` can follow the current state in
         * the ATN, otherwise `false`.
         */
        isExpectedToken(symbol) {
          let atn = this.interpreter.atn;
          let ctx = this._ctx;
          let s = atn.states[this.state];
          let following = atn.nextTokens(s);
          if (following.contains(symbol)) {
            return true;
          }
          if (!following.contains(Token_1.Token.EPSILON)) {
            return false;
          }
          while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
            let invokingState = atn.states[ctx.invokingState];
            let rt = invokingState.transition(0);
            following = atn.nextTokens(rt.followState);
            if (following.contains(symbol)) {
              return true;
            }
            ctx = ctx._parent;
          }
          if (following.contains(Token_1.Token.EPSILON) && symbol === Token_1.Token.EOF) {
            return true;
          }
          return false;
        }
        get isMatchedEOF() {
          return this.matchedEOF;
        }
        /**
         * Computes the set of input symbols which could follow the current parser
         * state and context, as given by {@link #getState} and {@link #getContext},
         * respectively.
         *
         * @see ATN#getExpectedTokens(int, RuleContext)
         */
        getExpectedTokens() {
          return this.atn.getExpectedTokens(this.state, this.context);
        }
        getExpectedTokensWithinCurrentRule() {
          let atn = this.interpreter.atn;
          let s = atn.states[this.state];
          return atn.nextTokens(s);
        }
        /** Get a rule's index (i.e., `RULE_ruleName` field) or -1 if not found. */
        getRuleIndex(ruleName) {
          let ruleIndex = this.getRuleIndexMap().get(ruleName);
          if (ruleIndex != null) {
            return ruleIndex;
          }
          return -1;
        }
        get ruleContext() {
          return this._ctx;
        }
        /** Return List&lt;String&gt; of the rule names in your parser instance
         *  leading up to a call to the current rule.  You could override if
         *  you want more details such as the file/line info of where
         *  in the ATN a rule is invoked.
         *
         *  This is very useful for error messages.
         */
        getRuleInvocationStack(ctx = this._ctx) {
          let p = ctx;
          let ruleNames = this.ruleNames;
          let stack = [];
          while (p != null) {
            let ruleIndex = p.ruleIndex;
            if (ruleIndex < 0) {
              stack.push("n/a");
            } else {
              stack.push(ruleNames[ruleIndex]);
            }
            p = p._parent;
          }
          return stack;
        }
        /** For debugging and other purposes. */
        getDFAStrings() {
          let s = [];
          for (let dfa of this._interp.atn.decisionToDFA) {
            s.push(dfa.toString(this.vocabulary, this.ruleNames));
          }
          return s;
        }
        /** For debugging and other purposes. */
        dumpDFA() {
          let seenOne = false;
          for (let dfa of this._interp.atn.decisionToDFA) {
            if (!dfa.isEmpty) {
              if (seenOne) {
                console.log();
              }
              console.log("Decision " + dfa.decision + ":");
              process.stdout.write(dfa.toString(this.vocabulary, this.ruleNames));
              seenOne = true;
            }
          }
        }
        get sourceName() {
          return this._input.sourceName;
        }
        get parseInfo() {
          return Promise.resolve().then(() => require_ProfilingATNSimulator()).then((m) => {
            let interp = this.interpreter;
            if (interp instanceof m.ProfilingATNSimulator) {
              return new ParseInfo_1.ParseInfo(interp);
            }
            return void 0;
          });
        }
        /**
         * @since 4.3
         */
        setProfile(profile) {
          return __awaiter(this, void 0, void 0, function* () {
            let m = yield Promise.resolve().then(() => require_ProfilingATNSimulator());
            let interp = this.interpreter;
            if (profile) {
              if (!(interp instanceof m.ProfilingATNSimulator)) {
                this.interpreter = new m.ProfilingATNSimulator(this);
              }
            } else if (interp instanceof m.ProfilingATNSimulator) {
              this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this.atn, this);
            }
            this.interpreter.setPredictionMode(interp.getPredictionMode());
          });
        }
        /** During a parse is sometimes useful to listen in on the rule entry and exit
         *  events as well as token matches. This is for quick and dirty debugging.
         */
        set isTrace(trace) {
          if (!trace) {
            if (this._tracer) {
              this.removeParseListener(this._tracer);
              this._tracer = void 0;
            }
          } else {
            if (this._tracer) {
              this.removeParseListener(this._tracer);
            } else {
              this._tracer = new TraceListener(this.ruleNames, this._input);
            }
            this.addParseListener(this._tracer);
          }
        }
        /**
         * Gets whether a {@link TraceListener} is registered as a parse listener
         * for the parser.
         */
        get isTrace() {
          return this._tracer != null;
        }
      };
      Parser2.bypassAltsAtnCache = /* @__PURE__ */ new Map();
      __decorate([
        Decorators_1.NotNull
      ], Parser2.prototype, "_errHandler", void 0);
      __decorate([
        Decorators_1.NotNull
      ], Parser2.prototype, "match", null);
      __decorate([
        Decorators_1.NotNull
      ], Parser2.prototype, "matchWildcard", null);
      __decorate([
        Decorators_1.NotNull
      ], Parser2.prototype, "getParseListeners", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], Parser2.prototype, "addParseListener", null);
      __decorate([
        Decorators_1.NotNull
      ], Parser2.prototype, "getATNWithBypassAlts", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], Parser2.prototype, "errorHandler", null);
      __decorate([
        Decorators_1.Override
      ], Parser2.prototype, "inputStream", null);
      __decorate([
        Decorators_1.NotNull
      ], Parser2.prototype, "currentToken", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], Parser2.prototype, "enterRule", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.Nullable)
      ], Parser2.prototype, "precpred", null);
      __decorate([
        Decorators_1.Override
      ], Parser2.prototype, "getErrorListenerDispatch", null);
      __decorate([
        Decorators_1.NotNull
      ], Parser2.prototype, "getExpectedTokens", null);
      __decorate([
        Decorators_1.NotNull
      ], Parser2.prototype, "getExpectedTokensWithinCurrentRule", null);
      __decorate([
        Decorators_1.Override
      ], Parser2.prototype, "parseInfo", null);
      exports.Parser = Parser2;
    }
  });

  // node_modules/antlr4ts/NoViableAltException.js
  var require_NoViableAltException = __commonJS({
    "node_modules/antlr4ts/NoViableAltException.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NoViableAltException = void 0;
      var Parser_1 = require_Parser();
      var RecognitionException_1 = require_RecognitionException();
      var Decorators_1 = require_Decorators();
      var NoViableAltException2 = class extends RecognitionException_1.RecognitionException {
        constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
          if (recognizer instanceof Parser_1.Parser) {
            if (input === void 0) {
              input = recognizer.inputStream;
            }
            if (startToken === void 0) {
              startToken = recognizer.currentToken;
            }
            if (offendingToken === void 0) {
              offendingToken = recognizer.currentToken;
            }
            if (ctx === void 0) {
              ctx = recognizer.context;
            }
          }
          super(recognizer, input, ctx);
          this._deadEndConfigs = deadEndConfigs;
          this._startToken = startToken;
          this.setOffendingToken(recognizer, offendingToken);
        }
        get startToken() {
          return this._startToken;
        }
        get deadEndConfigs() {
          return this._deadEndConfigs;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], NoViableAltException2.prototype, "_startToken", void 0);
      exports.NoViableAltException = NoViableAltException2;
    }
  });

  // node_modules/antlr4ts/DefaultErrorStrategy.js
  var require_DefaultErrorStrategy = __commonJS({
    "node_modules/antlr4ts/DefaultErrorStrategy.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultErrorStrategy = void 0;
      var ATNState_1 = require_ATNState();
      var ATNStateType_1 = require_ATNStateType();
      var FailedPredicateException_1 = require_FailedPredicateException();
      var InputMismatchException_1 = require_InputMismatchException();
      var IntervalSet_1 = require_IntervalSet();
      var NoViableAltException_1 = require_NoViableAltException();
      var PredictionContext_1 = require_PredictionContext();
      var Token_1 = require_Token();
      var Decorators_1 = require_Decorators();
      var DefaultErrorStrategy = class {
        constructor() {
          this.errorRecoveryMode = false;
          this.lastErrorIndex = -1;
          this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
        }
        /**
         * {@inheritDoc}
         *
         * The default implementation simply calls {@link #endErrorCondition} to
         * ensure that the handler is not in error recovery mode.
         */
        reset(recognizer) {
          this.endErrorCondition(recognizer);
        }
        /**
         * This method is called to enter error recovery mode when a recognition
         * exception is reported.
         *
         * @param recognizer the parser instance
         */
        beginErrorCondition(recognizer) {
          this.errorRecoveryMode = true;
        }
        /**
         * {@inheritDoc}
         */
        inErrorRecoveryMode(recognizer) {
          return this.errorRecoveryMode;
        }
        /**
         * This method is called to leave error recovery mode after recovering from
         * a recognition exception.
         *
         * @param recognizer
         */
        endErrorCondition(recognizer) {
          this.errorRecoveryMode = false;
          this.lastErrorStates = void 0;
          this.lastErrorIndex = -1;
        }
        /**
         * {@inheritDoc}
         *
         * The default implementation simply calls {@link #endErrorCondition}.
         */
        reportMatch(recognizer) {
          this.endErrorCondition(recognizer);
        }
        /**
         * {@inheritDoc}
         *
         * The default implementation returns immediately if the handler is already
         * in error recovery mode. Otherwise, it calls {@link #beginErrorCondition}
         * and dispatches the reporting task based on the runtime type of `e`
         * according to the following table.
         *
         * * {@link NoViableAltException}: Dispatches the call to
         *   {@link #reportNoViableAlternative}
         * * {@link InputMismatchException}: Dispatches the call to
         *   {@link #reportInputMismatch}
         * * {@link FailedPredicateException}: Dispatches the call to
         *   {@link #reportFailedPredicate}
         * * All other types: calls {@link Parser#notifyErrorListeners} to report
         *   the exception
         */
        reportError(recognizer, e) {
          if (this.inErrorRecoveryMode(recognizer)) {
            return;
          }
          this.beginErrorCondition(recognizer);
          if (e instanceof NoViableAltException_1.NoViableAltException) {
            this.reportNoViableAlternative(recognizer, e);
          } else if (e instanceof InputMismatchException_1.InputMismatchException) {
            this.reportInputMismatch(recognizer, e);
          } else if (e instanceof FailedPredicateException_1.FailedPredicateException) {
            this.reportFailedPredicate(recognizer, e);
          } else {
            console.error(`unknown recognition error type: ${e}`);
            this.notifyErrorListeners(recognizer, e.toString(), e);
          }
        }
        notifyErrorListeners(recognizer, message, e) {
          let offendingToken = e.getOffendingToken(recognizer);
          if (offendingToken === void 0) {
            offendingToken = null;
          }
          recognizer.notifyErrorListeners(message, offendingToken, e);
        }
        /**
         * {@inheritDoc}
         *
         * The default implementation resynchronizes the parser by consuming tokens
         * until we find one in the resynchronization set--loosely the set of tokens
         * that can follow the current rule.
         */
        recover(recognizer, e) {
          if (this.lastErrorIndex === recognizer.inputStream.index && this.lastErrorStates && this.lastErrorStates.contains(recognizer.state)) {
            recognizer.consume();
          }
          this.lastErrorIndex = recognizer.inputStream.index;
          if (!this.lastErrorStates) {
            this.lastErrorStates = new IntervalSet_1.IntervalSet();
          }
          this.lastErrorStates.add(recognizer.state);
          let followSet = this.getErrorRecoverySet(recognizer);
          this.consumeUntil(recognizer, followSet);
        }
        /**
         * The default implementation of {@link ANTLRErrorStrategy#sync} makes sure
         * that the current lookahead symbol is consistent with what were expecting
         * at this point in the ATN. You can call this anytime but ANTLR only
         * generates code to check before subrules/loops and each iteration.
         *
         * Implements Jim Idle's magic sync mechanism in closures and optional
         * subrules. E.g.,
         *
         * ```antlr
         * a : sync ( stuff sync )* ;
         * sync : {consume to what can follow sync} ;
         * ```
         *
         * At the start of a sub rule upon error, {@link #sync} performs single
         * token deletion, if possible. If it can't do that, it bails on the current
         * rule and uses the default error recovery, which consumes until the
         * resynchronization set of the current rule.
         *
         * If the sub rule is optional (`(...)?`, `(...)*`, or block
         * with an empty alternative), then the expected set includes what follows
         * the subrule.
         *
         * During loop iteration, it consumes until it sees a token that can start a
         * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
         * stay in the loop as long as possible.
         *
         * **ORIGINS**
         *
         * Previous versions of ANTLR did a poor job of their recovery within loops.
         * A single mismatch token or missing token would force the parser to bail
         * out of the entire rules surrounding the loop. So, for rule
         *
         * ```antlr
         * classDef : 'class' ID '{' member* '}'
         * ```
         *
         * input with an extra token between members would force the parser to
         * consume until it found the next class definition rather than the next
         * member definition of the current class.
         *
         * This functionality cost a little bit of effort because the parser has to
         * compare token set at the start of the loop and at each iteration. If for
         * some reason speed is suffering for you, you can turn off this
         * functionality by simply overriding this method as a blank { }.
         */
        sync(recognizer) {
          let s = recognizer.interpreter.atn.states[recognizer.state];
          if (this.inErrorRecoveryMode(recognizer)) {
            return;
          }
          let tokens = recognizer.inputStream;
          let la = tokens.LA(1);
          let nextTokens = recognizer.atn.nextTokens(s);
          if (nextTokens.contains(la)) {
            this.nextTokensContext = void 0;
            this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
            return;
          }
          if (nextTokens.contains(Token_1.Token.EPSILON)) {
            if (this.nextTokensContext === void 0) {
              this.nextTokensContext = recognizer.context;
              this.nextTokensState = recognizer.state;
            }
            return;
          }
          switch (s.stateType) {
            case ATNStateType_1.ATNStateType.BLOCK_START:
            case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
            case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
            case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
              if (this.singleTokenDeletion(recognizer)) {
                return;
              }
              throw new InputMismatchException_1.InputMismatchException(recognizer);
            case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
            case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
              this.reportUnwantedToken(recognizer);
              let expecting = recognizer.getExpectedTokens();
              let whatFollowsLoopIterationOrRule = expecting.or(this.getErrorRecoverySet(recognizer));
              this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
              break;
            default:
              break;
          }
        }
        /**
         * This is called by {@link #reportError} when the exception is a
         * {@link NoViableAltException}.
         *
         * @see #reportError
         *
         * @param recognizer the parser instance
         * @param e the recognition exception
         */
        reportNoViableAlternative(recognizer, e) {
          let tokens = recognizer.inputStream;
          let input;
          if (tokens) {
            if (e.startToken.type === Token_1.Token.EOF) {
              input = "<EOF>";
            } else {
              input = tokens.getTextFromRange(e.startToken, e.getOffendingToken());
            }
          } else {
            input = "<unknown input>";
          }
          let msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
          this.notifyErrorListeners(recognizer, msg, e);
        }
        /**
         * This is called by {@link #reportError} when the exception is an
         * {@link InputMismatchException}.
         *
         * @see #reportError
         *
         * @param recognizer the parser instance
         * @param e the recognition exception
         */
        reportInputMismatch(recognizer, e) {
          let expected = e.expectedTokens;
          let expectedString = expected ? expected.toStringVocabulary(recognizer.vocabulary) : "";
          let msg = "mismatched input " + this.getTokenErrorDisplay(e.getOffendingToken(recognizer)) + " expecting " + expectedString;
          this.notifyErrorListeners(recognizer, msg, e);
        }
        /**
         * This is called by {@link #reportError} when the exception is a
         * {@link FailedPredicateException}.
         *
         * @see #reportError
         *
         * @param recognizer the parser instance
         * @param e the recognition exception
         */
        reportFailedPredicate(recognizer, e) {
          let ruleName = recognizer.ruleNames[recognizer.context.ruleIndex];
          let msg = "rule " + ruleName + " " + e.message;
          this.notifyErrorListeners(recognizer, msg, e);
        }
        /**
         * This method is called to report a syntax error which requires the removal
         * of a token from the input stream. At the time this method is called, the
         * erroneous symbol is current `LT(1)` symbol and has not yet been
         * removed from the input stream. When this method returns,
         * `recognizer` is in error recovery mode.
         *
         * This method is called when {@link #singleTokenDeletion} identifies
         * single-token deletion as a viable recovery strategy for a mismatched
         * input error.
         *
         * The default implementation simply returns if the handler is already in
         * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to
         * enter error recovery mode, followed by calling
         * {@link Parser#notifyErrorListeners}.
         *
         * @param recognizer the parser instance
         */
        reportUnwantedToken(recognizer) {
          if (this.inErrorRecoveryMode(recognizer)) {
            return;
          }
          this.beginErrorCondition(recognizer);
          let t = recognizer.currentToken;
          let tokenName = this.getTokenErrorDisplay(t);
          let expecting = this.getExpectedTokens(recognizer);
          let msg = "extraneous input " + tokenName + " expecting " + expecting.toStringVocabulary(recognizer.vocabulary);
          recognizer.notifyErrorListeners(msg, t, void 0);
        }
        /**
         * This method is called to report a syntax error which requires the
         * insertion of a missing token into the input stream. At the time this
         * method is called, the missing token has not yet been inserted. When this
         * method returns, `recognizer` is in error recovery mode.
         *
         * This method is called when {@link #singleTokenInsertion} identifies
         * single-token insertion as a viable recovery strategy for a mismatched
         * input error.
         *
         * The default implementation simply returns if the handler is already in
         * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to
         * enter error recovery mode, followed by calling
         * {@link Parser#notifyErrorListeners}.
         *
         * @param recognizer the parser instance
         */
        reportMissingToken(recognizer) {
          if (this.inErrorRecoveryMode(recognizer)) {
            return;
          }
          this.beginErrorCondition(recognizer);
          let t = recognizer.currentToken;
          let expecting = this.getExpectedTokens(recognizer);
          let msg = "missing " + expecting.toStringVocabulary(recognizer.vocabulary) + " at " + this.getTokenErrorDisplay(t);
          recognizer.notifyErrorListeners(msg, t, void 0);
        }
        /**
         * {@inheritDoc}
         *
         * The default implementation attempts to recover from the mismatched input
         * by using single token insertion and deletion as described below. If the
         * recovery attempt fails, this method
         * {@link InputMismatchException}.
         *
         * **EXTRA TOKEN** (single token deletion)
         *
         * `LA(1)` is not what we are looking for. If `LA(2)` has the
         * right token, however, then assume `LA(1)` is some extra spurious
         * token and delete it. Then consume and return the next token (which was
         * the `LA(2)` token) as the successful result of the match operation.
         *
         * This recovery strategy is implemented by {@link #singleTokenDeletion}.
         *
         * **MISSING TOKEN** (single token insertion)
         *
         * If current token (at `LA(1)`) is consistent with what could come
         * after the expected `LA(1)` token, then assume the token is missing
         * and use the parser's {@link TokenFactory} to create it on the fly. The
         * "insertion" is performed by returning the created token as the successful
         * result of the match operation.
         *
         * This recovery strategy is implemented by {@link #singleTokenInsertion}.
         *
         * **EXAMPLE**
         *
         * For example, Input `i=(3;` is clearly missing the `')'`. When
         * the parser returns from the nested call to `expr`, it will have
         * call chain:
         *
         * ```
         * stat  expr  atom
         * ```
         *
         * and it will be trying to match the `')'` at this point in the
         * derivation:
         *
         * ```
         * => ID '=' '(' INT ')' ('+' atom)* ';'
         *                    ^
         * ```
         *
         * The attempt to match `')'` will fail when it sees `';'` and
         * call {@link #recoverInline}. To recover, it sees that `LA(1)==';'`
         * is in the set of tokens that can follow the `')'` token reference
         * in rule `atom`. It can assume that you forgot the `')'`.
         */
        recoverInline(recognizer) {
          let matchedSymbol = this.singleTokenDeletion(recognizer);
          if (matchedSymbol) {
            recognizer.consume();
            return matchedSymbol;
          }
          if (this.singleTokenInsertion(recognizer)) {
            return this.getMissingSymbol(recognizer);
          }
          if (this.nextTokensContext === void 0) {
            throw new InputMismatchException_1.InputMismatchException(recognizer);
          } else {
            throw new InputMismatchException_1.InputMismatchException(recognizer, this.nextTokensState, this.nextTokensContext);
          }
        }
        /**
         * This method implements the single-token insertion inline error recovery
         * strategy. It is called by {@link #recoverInline} if the single-token
         * deletion strategy fails to recover from the mismatched input. If this
         * method returns `true`, `recognizer` will be in error recovery
         * mode.
         *
         * This method determines whether or not single-token insertion is viable by
         * checking if the `LA(1)` input symbol could be successfully matched
         * if it were instead the `LA(2)` symbol. If this method returns
         * `true`, the caller is responsible for creating and inserting a
         * token with the correct type to produce this behavior.
         *
         * @param recognizer the parser instance
         * @returns `true` if single-token insertion is a viable recovery
         * strategy for the current mismatched input, otherwise `false`
         */
        singleTokenInsertion(recognizer) {
          let currentSymbolType = recognizer.inputStream.LA(1);
          let currentState = recognizer.interpreter.atn.states[recognizer.state];
          let next = currentState.transition(0).target;
          let atn = recognizer.interpreter.atn;
          let expectingAtLL2 = atn.nextTokens(next, PredictionContext_1.PredictionContext.fromRuleContext(atn, recognizer.context));
          if (expectingAtLL2.contains(currentSymbolType)) {
            this.reportMissingToken(recognizer);
            return true;
          }
          return false;
        }
        /**
         * This method implements the single-token deletion inline error recovery
         * strategy. It is called by {@link #recoverInline} to attempt to recover
         * from mismatched input. If this method returns `undefined`, the parser and error
         * handler state will not have changed. If this method returns non-`undefined`,
         * `recognizer` will *not* be in error recovery mode since the
         * returned token was a successful match.
         *
         * If the single-token deletion is successful, this method calls
         * {@link #reportUnwantedToken} to report the error, followed by
         * {@link Parser#consume} to actually "delete" the extraneous token. Then,
         * before returning {@link #reportMatch} is called to signal a successful
         * match.
         *
         * @param recognizer the parser instance
         * @returns the successfully matched {@link Token} instance if single-token
         * deletion successfully recovers from the mismatched input, otherwise
         * `undefined`
         */
        singleTokenDeletion(recognizer) {
          let nextTokenType = recognizer.inputStream.LA(2);
          let expecting = this.getExpectedTokens(recognizer);
          if (expecting.contains(nextTokenType)) {
            this.reportUnwantedToken(recognizer);
            recognizer.consume();
            let matchedSymbol = recognizer.currentToken;
            this.reportMatch(recognizer);
            return matchedSymbol;
          }
          return void 0;
        }
        /** Conjure up a missing token during error recovery.
         *
         *  The recognizer attempts to recover from single missing
         *  symbols. But, actions might refer to that missing symbol.
         *  For example, x=ID {f($x);}. The action clearly assumes
         *  that there has been an identifier matched previously and that
         *  $x points at that token. If that token is missing, but
         *  the next token in the stream is what we want we assume that
         *  this token is missing and we keep going. Because we
         *  have to return some token to replace the missing token,
         *  we have to conjure one up. This method gives the user control
         *  over the tokens returned for missing tokens. Mostly,
         *  you will want to create something special for identifier
         *  tokens. For literals such as '{' and ',', the default
         *  action in the parser or tree parser works. It simply creates
         *  a CommonToken of the appropriate type. The text will be the token.
         *  If you change what tokens must be created by the lexer,
         *  override this method to create the appropriate tokens.
         */
        getMissingSymbol(recognizer) {
          let currentSymbol = recognizer.currentToken;
          let expecting = this.getExpectedTokens(recognizer);
          let expectedTokenType = Token_1.Token.INVALID_TYPE;
          if (!expecting.isNil) {
            expectedTokenType = expecting.minElement;
          }
          let tokenText;
          if (expectedTokenType === Token_1.Token.EOF) {
            tokenText = "<missing EOF>";
          } else {
            tokenText = "<missing " + recognizer.vocabulary.getDisplayName(expectedTokenType) + ">";
          }
          let current = currentSymbol;
          let lookback = recognizer.inputStream.tryLT(-1);
          if (current.type === Token_1.Token.EOF && lookback != null) {
            current = lookback;
          }
          return this.constructToken(recognizer.inputStream.tokenSource, expectedTokenType, tokenText, current);
        }
        constructToken(tokenSource, expectedTokenType, tokenText, current) {
          let factory = tokenSource.tokenFactory;
          let x = current.tokenSource;
          let stream = x ? x.inputStream : void 0;
          return factory.create({ source: tokenSource, stream }, expectedTokenType, tokenText, Token_1.Token.DEFAULT_CHANNEL, -1, -1, current.line, current.charPositionInLine);
        }
        getExpectedTokens(recognizer) {
          return recognizer.getExpectedTokens();
        }
        /** How should a token be displayed in an error message? The default
         *  is to display just the text, but during development you might
         *  want to have a lot of information spit out.  Override in that case
         *  to use t.toString() (which, for CommonToken, dumps everything about
         *  the token). This is better than forcing you to override a method in
         *  your token objects because you don't have to go modify your lexer
         *  so that it creates a new Java type.
         */
        getTokenErrorDisplay(t) {
          if (!t) {
            return "<no token>";
          }
          let s = this.getSymbolText(t);
          if (!s) {
            if (this.getSymbolType(t) === Token_1.Token.EOF) {
              s = "<EOF>";
            } else {
              s = `<${this.getSymbolType(t)}>`;
            }
          }
          return this.escapeWSAndQuote(s);
        }
        getSymbolText(symbol) {
          return symbol.text;
        }
        getSymbolType(symbol) {
          return symbol.type;
        }
        escapeWSAndQuote(s) {
          s = s.replace("\n", "\\n");
          s = s.replace("\r", "\\r");
          s = s.replace("	", "\\t");
          return "'" + s + "'";
        }
        /*  Compute the error recovery set for the current rule.  During
         *  rule invocation, the parser pushes the set of tokens that can
         *  follow that rule reference on the stack; this amounts to
         *  computing FIRST of what follows the rule reference in the
         *  enclosing rule. See LinearApproximator.FIRST().
         *  This local follow set only includes tokens
         *  from within the rule; i.e., the FIRST computation done by
         *  ANTLR stops at the end of a rule.
         *
         *  EXAMPLE
         *
         *  When you find a "no viable alt exception", the input is not
         *  consistent with any of the alternatives for rule r.  The best
         *  thing to do is to consume tokens until you see something that
         *  can legally follow a call to r *or* any rule that called r.
         *  You don't want the exact set of viable next tokens because the
         *  input might just be missing a token--you might consume the
         *  rest of the input looking for one of the missing tokens.
         *
         *  Consider grammar:
         *
         *  a : '[' b ']'
         *    | '(' b ')'
         *    ;
         *  b : c '^' INT ;
         *  c : ID
         *    | INT
         *    ;
         *
         *  At each rule invocation, the set of tokens that could follow
         *  that rule is pushed on a stack.  Here are the various
         *  context-sensitive follow sets:
         *
         *  FOLLOW(b1_in_a) = FIRST(']') = ']'
         *  FOLLOW(b2_in_a) = FIRST(')') = ')'
         *  FOLLOW(c_in_b) = FIRST('^') = '^'
         *
         *  Upon erroneous input "[]", the call chain is
         *
         *  a -> b -> c
         *
         *  and, hence, the follow context stack is:
         *
         *  depth     follow set       start of rule execution
         *    0         <EOF>                    a (from main())
         *    1          ']'                     b
         *    2          '^'                     c
         *
         *  Notice that ')' is not included, because b would have to have
         *  been called from a different context in rule a for ')' to be
         *  included.
         *
         *  For error recovery, we cannot consider FOLLOW(c)
         *  (context-sensitive or otherwise).  We need the combined set of
         *  all context-sensitive FOLLOW sets--the set of all tokens that
         *  could follow any reference in the call chain.  We need to
         *  resync to one of those tokens.  Note that FOLLOW(c)='^' and if
         *  we resync'd to that token, we'd consume until EOF.  We need to
         *  sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
         *  In this case, for input "[]", LA(1) is ']' and in the set, so we would
         *  not consume anything. After printing an error, rule c would
         *  return normally.  Rule b would not find the required '^' though.
         *  At this point, it gets a mismatched token error and
         *  exception (since LA(1) is not in the viable following token
         *  set).  The rule exception handler tries to recover, but finds
         *  the same recovery set and doesn't consume anything.  Rule b
         *  exits normally returning to rule a.  Now it finds the ']' (and
         *  with the successful match exits errorRecovery mode).
         *
         *  So, you can see that the parser walks up the call chain looking
         *  for the token that was a member of the recovery set.
         *
         *  Errors are not generated in errorRecovery mode.
         *
         *  ANTLR's error recovery mechanism is based upon original ideas:
         *
         *  "Algorithms + Data Structures = Programs" by Niklaus Wirth
         *
         *  and
         *
         *  "A note on error recovery in recursive descent parsers":
         *  http://portal.acm.org/citation.cfm?id=947902.947905
         *
         *  Later, Josef Grosch had some good ideas:
         *
         *  "Efficient and Comfortable Error Recovery in Recursive Descent
         *  Parsers":
         *  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
         *
         *  Like Grosch I implement context-sensitive FOLLOW sets that are combined
         *  at run-time upon error to avoid overhead during parsing.
         */
        getErrorRecoverySet(recognizer) {
          let atn = recognizer.interpreter.atn;
          let ctx = recognizer.context;
          let recoverSet = new IntervalSet_1.IntervalSet();
          while (ctx && ctx.invokingState >= 0) {
            let invokingState = atn.states[ctx.invokingState];
            let rt = invokingState.transition(0);
            let follow = atn.nextTokens(rt.followState);
            recoverSet.addAll(follow);
            ctx = ctx._parent;
          }
          recoverSet.remove(Token_1.Token.EPSILON);
          return recoverSet;
        }
        /** Consume tokens until one matches the given token set. */
        consumeUntil(recognizer, set) {
          let ttype = recognizer.inputStream.LA(1);
          while (ttype !== Token_1.Token.EOF && !set.contains(ttype)) {
            recognizer.consume();
            ttype = recognizer.inputStream.LA(1);
          }
        }
      };
      __decorate([
        Decorators_1.Override
      ], DefaultErrorStrategy.prototype, "reset", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "beginErrorCondition", null);
      __decorate([
        Decorators_1.Override
      ], DefaultErrorStrategy.prototype, "inErrorRecoveryMode", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "endErrorCondition", null);
      __decorate([
        Decorators_1.Override
      ], DefaultErrorStrategy.prototype, "reportMatch", null);
      __decorate([
        Decorators_1.Override
      ], DefaultErrorStrategy.prototype, "reportError", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "notifyErrorListeners", null);
      __decorate([
        Decorators_1.Override
      ], DefaultErrorStrategy.prototype, "recover", null);
      __decorate([
        Decorators_1.Override
      ], DefaultErrorStrategy.prototype, "sync", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "reportNoViableAlternative", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "reportInputMismatch", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "reportFailedPredicate", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "reportUnwantedToken", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "reportMissingToken", null);
      __decorate([
        Decorators_1.Override
      ], DefaultErrorStrategy.prototype, "recoverInline", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "singleTokenInsertion", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "singleTokenDeletion", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "getMissingSymbol", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "getExpectedTokens", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "getSymbolText", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "getSymbolType", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "escapeWSAndQuote", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "getErrorRecoverySet", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "consumeUntil", null);
      exports.DefaultErrorStrategy = DefaultErrorStrategy;
    }
  });

  // node_modules/antlr4ts/BailErrorStrategy.js
  var require_BailErrorStrategy = __commonJS({
    "node_modules/antlr4ts/BailErrorStrategy.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BailErrorStrategy = void 0;
      var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();
      var InputMismatchException_1 = require_InputMismatchException();
      var Decorators_1 = require_Decorators();
      var ParseCancellationException_1 = require_ParseCancellationException();
      var BailErrorStrategy = class extends DefaultErrorStrategy_1.DefaultErrorStrategy {
        /** Instead of recovering from exception `e`, re-throw it wrapped
         *  in a {@link ParseCancellationException} so it is not caught by the
         *  rule function catches.  Use {@link Exception#getCause()} to get the
         *  original {@link RecognitionException}.
         */
        recover(recognizer, e) {
          for (let context = recognizer.context; context; context = context.parent) {
            context.exception = e;
          }
          throw new ParseCancellationException_1.ParseCancellationException(e);
        }
        /** Make sure we don't attempt to recover inline; if the parser
         *  successfully recovers, it won't throw an exception.
         */
        recoverInline(recognizer) {
          let e = new InputMismatchException_1.InputMismatchException(recognizer);
          for (let context = recognizer.context; context; context = context.parent) {
            context.exception = e;
          }
          throw new ParseCancellationException_1.ParseCancellationException(e);
        }
        /** Make sure we don't attempt to recover from problems in subrules. */
        sync(recognizer) {
        }
      };
      __decorate([
        Decorators_1.Override
      ], BailErrorStrategy.prototype, "recover", null);
      __decorate([
        Decorators_1.Override
      ], BailErrorStrategy.prototype, "recoverInline", null);
      __decorate([
        Decorators_1.Override
      ], BailErrorStrategy.prototype, "sync", null);
      exports.BailErrorStrategy = BailErrorStrategy;
    }
  });

  // node_modules/antlr4ts/CharStream.js
  var require_CharStream = __commonJS({
    "node_modules/antlr4ts/CharStream.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/antlr4ts/Dependents.js
  var require_Dependents = __commonJS({
    "node_modules/antlr4ts/Dependents.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Dependents = void 0;
      var Dependents;
      (function(Dependents2) {
        Dependents2[Dependents2["SELF"] = 0] = "SELF";
        Dependents2[Dependents2["PARENTS"] = 1] = "PARENTS";
        Dependents2[Dependents2["CHILDREN"] = 2] = "CHILDREN";
        Dependents2[Dependents2["ANCESTORS"] = 3] = "ANCESTORS";
        Dependents2[Dependents2["DESCENDANTS"] = 4] = "DESCENDANTS";
        Dependents2[Dependents2["SIBLINGS"] = 5] = "SIBLINGS";
        Dependents2[Dependents2["PRECEEDING_SIBLINGS"] = 6] = "PRECEEDING_SIBLINGS";
        Dependents2[Dependents2["FOLLOWING_SIBLINGS"] = 7] = "FOLLOWING_SIBLINGS";
        Dependents2[Dependents2["PRECEEDING"] = 8] = "PRECEEDING";
        Dependents2[Dependents2["FOLLOWING"] = 9] = "FOLLOWING";
      })(Dependents = exports.Dependents || (exports.Dependents = {}));
    }
  });

  // node_modules/antlr4ts/DiagnosticErrorListener.js
  var require_DiagnosticErrorListener = __commonJS({
    "node_modules/antlr4ts/DiagnosticErrorListener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiagnosticErrorListener = void 0;
      var BitSet_1 = require_BitSet();
      var Decorators_1 = require_Decorators();
      var Interval_1 = require_Interval();
      var DiagnosticErrorListener = class {
        /**
         * Initializes a new instance of {@link DiagnosticErrorListener}, specifying
         * whether all ambiguities or only exact ambiguities are reported.
         *
         * @param exactOnly `true` to report only exact ambiguities, otherwise
         * `false` to report all ambiguities.  Defaults to true.
         */
        constructor(exactOnly = true) {
          this.exactOnly = exactOnly;
          this.exactOnly = exactOnly;
        }
        syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
        }
        reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
          if (this.exactOnly && !exact) {
            return;
          }
          let decision = this.getDecisionDescription(recognizer, dfa);
          let conflictingAlts = this.getConflictingAlts(ambigAlts, configs);
          let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
          let message = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text}'`;
          recognizer.notifyErrorListeners(message);
        }
        reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
          let format = "reportAttemptingFullContext d=%s, input='%s'";
          let decision = this.getDecisionDescription(recognizer, dfa);
          let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
          let message = `reportAttemptingFullContext d=${decision}, input='${text}'`;
          recognizer.notifyErrorListeners(message);
        }
        reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
          let format = "reportContextSensitivity d=%s, input='%s'";
          let decision = this.getDecisionDescription(recognizer, dfa);
          let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
          let message = `reportContextSensitivity d=${decision}, input='${text}'`;
          recognizer.notifyErrorListeners(message);
        }
        getDecisionDescription(recognizer, dfa) {
          let decision = dfa.decision;
          let ruleIndex = dfa.atnStartState.ruleIndex;
          let ruleNames = recognizer.ruleNames;
          if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
            return decision.toString();
          }
          let ruleName = ruleNames[ruleIndex];
          if (!ruleName) {
            return decision.toString();
          }
          return `${decision} (${ruleName})`;
        }
        /**
         * Computes the set of conflicting or ambiguous alternatives from a
         * configuration set, if that information was not already provided by the
         * parser.
         *
         * @param reportedAlts The set of conflicting or ambiguous alternatives, as
         * reported by the parser.
         * @param configs The conflicting or ambiguous configuration set.
         * @returns Returns `reportedAlts` if it is not `undefined`, otherwise
         * returns the set of alternatives represented in `configs`.
         */
        getConflictingAlts(reportedAlts, configs) {
          if (reportedAlts != null) {
            return reportedAlts;
          }
          let result = new BitSet_1.BitSet();
          for (let config of configs) {
            result.set(config.alt);
          }
          return result;
        }
      };
      __decorate([
        Decorators_1.Override
      ], DiagnosticErrorListener.prototype, "syntaxError", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(6, Decorators_1.NotNull)
      ], DiagnosticErrorListener.prototype, "reportAmbiguity", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(5, Decorators_1.NotNull)
      ], DiagnosticErrorListener.prototype, "reportAttemptingFullContext", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(5, Decorators_1.NotNull)
      ], DiagnosticErrorListener.prototype, "reportContextSensitivity", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], DiagnosticErrorListener.prototype, "getDecisionDescription", null);
      __decorate([
        Decorators_1.NotNull,
        __param(1, Decorators_1.NotNull)
      ], DiagnosticErrorListener.prototype, "getConflictingAlts", null);
      exports.DiagnosticErrorListener = DiagnosticErrorListener;
    }
  });

  // node_modules/antlr4ts/LexerInterpreter.js
  var require_LexerInterpreter = __commonJS({
    "node_modules/antlr4ts/LexerInterpreter.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerInterpreter = void 0;
      var Lexer_1 = require_Lexer();
      var LexerATNSimulator_1 = require_LexerATNSimulator();
      var Decorators_1 = require_Decorators();
      var Decorators_2 = require_Decorators();
      var LexerInterpreter = class LexerInterpreter extends Lexer_1.Lexer {
        constructor(grammarFileName, vocabulary, ruleNames, channelNames, modeNames, atn, input) {
          super(input);
          if (atn.grammarType !== 0) {
            throw new Error("IllegalArgumentException: The ATN must be a lexer ATN.");
          }
          this._grammarFileName = grammarFileName;
          this._atn = atn;
          this._ruleNames = ruleNames.slice(0);
          this._channelNames = channelNames.slice(0);
          this._modeNames = modeNames.slice(0);
          this._vocabulary = vocabulary;
          this._interp = new LexerATNSimulator_1.LexerATNSimulator(atn, this);
        }
        get atn() {
          return this._atn;
        }
        get grammarFileName() {
          return this._grammarFileName;
        }
        get ruleNames() {
          return this._ruleNames;
        }
        get channelNames() {
          return this._channelNames;
        }
        get modeNames() {
          return this._modeNames;
        }
        get vocabulary() {
          return this._vocabulary;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], LexerInterpreter.prototype, "_vocabulary", void 0);
      __decorate([
        Decorators_2.Override
      ], LexerInterpreter.prototype, "atn", null);
      __decorate([
        Decorators_2.Override
      ], LexerInterpreter.prototype, "grammarFileName", null);
      __decorate([
        Decorators_2.Override
      ], LexerInterpreter.prototype, "ruleNames", null);
      __decorate([
        Decorators_2.Override
      ], LexerInterpreter.prototype, "channelNames", null);
      __decorate([
        Decorators_2.Override
      ], LexerInterpreter.prototype, "modeNames", null);
      __decorate([
        Decorators_2.Override
      ], LexerInterpreter.prototype, "vocabulary", null);
      LexerInterpreter = __decorate([
        __param(1, Decorators_1.NotNull)
      ], LexerInterpreter);
      exports.LexerInterpreter = LexerInterpreter;
    }
  });

  // node_modules/antlr4ts/ParserErrorListener.js
  var require_ParserErrorListener = __commonJS({
    "node_modules/antlr4ts/ParserErrorListener.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/antlr4ts/RuleContextWithAltNum.js
  var require_RuleContextWithAltNum = __commonJS({
    "node_modules/antlr4ts/RuleContextWithAltNum.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleContextWithAltNum = void 0;
      var ATN_1 = require_ATN();
      var Decorators_1 = require_Decorators();
      var ParserRuleContext_1 = require_ParserRuleContext();
      var RuleContextWithAltNum = class extends ParserRuleContext_1.ParserRuleContext {
        constructor(parent, invokingStateNumber) {
          if (invokingStateNumber !== void 0) {
            super(parent, invokingStateNumber);
          } else {
            super();
          }
          this._altNumber = ATN_1.ATN.INVALID_ALT_NUMBER;
        }
        get altNumber() {
          return this._altNumber;
        }
        // @Override
        set altNumber(altNum) {
          this._altNumber = altNum;
        }
      };
      __decorate([
        Decorators_1.Override
      ], RuleContextWithAltNum.prototype, "altNumber", null);
      exports.RuleContextWithAltNum = RuleContextWithAltNum;
    }
  });

  // node_modules/antlr4ts/RuleDependency.js
  var require_RuleDependency = __commonJS({
    "node_modules/antlr4ts/RuleDependency.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleDependency = void 0;
      function RuleDependency(dependency) {
        return (target, propertyKey, propertyDescriptor) => {
        };
      }
      exports.RuleDependency = RuleDependency;
    }
  });

  // node_modules/antlr4ts/RuleVersion.js
  var require_RuleVersion = __commonJS({
    "node_modules/antlr4ts/RuleVersion.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleVersion = void 0;
      function RuleVersion(version) {
        return (target, propertyKey, propertyDescriptor) => {
        };
      }
      exports.RuleVersion = RuleVersion;
    }
  });

  // node_modules/antlr4ts/TokenFactory.js
  var require_TokenFactory = __commonJS({
    "node_modules/antlr4ts/TokenFactory.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/antlr4ts/TokenSource.js
  var require_TokenSource = __commonJS({
    "node_modules/antlr4ts/TokenSource.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/antlr4ts/TokenStream.js
  var require_TokenStream = __commonJS({
    "node_modules/antlr4ts/TokenStream.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/antlr4ts/TokenStreamRewriter.js
  var require_TokenStreamRewriter = __commonJS({
    "node_modules/antlr4ts/TokenStreamRewriter.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RewriteOperation = exports.TokenStreamRewriter = void 0;
      var Interval_1 = require_Interval();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var TokenStreamRewriter = class _TokenStreamRewriter {
        constructor(tokens) {
          this.tokens = tokens;
          this.programs = /* @__PURE__ */ new Map();
          this.programs.set(_TokenStreamRewriter.DEFAULT_PROGRAM_NAME, []);
          this.lastRewriteTokenIndexes = /* @__PURE__ */ new Map();
        }
        getTokenStream() {
          return this.tokens;
        }
        rollback(instructionIndex, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
          let is = this.programs.get(programName);
          if (is != null) {
            this.programs.set(programName, is.slice(_TokenStreamRewriter.MIN_TOKEN_INDEX, instructionIndex));
          }
        }
        deleteProgram(programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
          this.rollback(_TokenStreamRewriter.MIN_TOKEN_INDEX, programName);
        }
        insertAfter(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
          let index;
          if (typeof tokenOrIndex === "number") {
            index = tokenOrIndex;
          } else {
            index = tokenOrIndex.tokenIndex;
          }
          let rewrites = this.getProgram(programName);
          let op = new InsertAfterOp(this.tokens, index, rewrites.length, text);
          rewrites.push(op);
        }
        insertBefore(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
          let index;
          if (typeof tokenOrIndex === "number") {
            index = tokenOrIndex;
          } else {
            index = tokenOrIndex.tokenIndex;
          }
          let rewrites = this.getProgram(programName);
          let op = new InsertBeforeOp(this.tokens, index, rewrites.length, text);
          rewrites.push(op);
        }
        replaceSingle(index, text) {
          if (typeof index === "number") {
            this.replace(index, index, text);
          } else {
            this.replace(index, index, text);
          }
        }
        replace(from, to, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
          if (typeof from !== "number") {
            from = from.tokenIndex;
          }
          if (typeof to !== "number") {
            to = to.tokenIndex;
          }
          if (from > to || from < 0 || to < 0 || to >= this.tokens.size) {
            throw new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);
          }
          let rewrites = this.getProgram(programName);
          let op = new ReplaceOp(this.tokens, from, to, rewrites.length, text);
          rewrites.push(op);
        }
        delete(from, to, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
          if (to === void 0) {
            to = from;
          }
          if (typeof from === "number") {
            this.replace(from, to, "", programName);
          } else {
            this.replace(from, to, "", programName);
          }
        }
        getLastRewriteTokenIndex(programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
          let I = this.lastRewriteTokenIndexes.get(programName);
          if (I == null) {
            return -1;
          }
          return I;
        }
        setLastRewriteTokenIndex(programName, i) {
          this.lastRewriteTokenIndexes.set(programName, i);
        }
        getProgram(name) {
          let is = this.programs.get(name);
          if (is == null) {
            is = this.initializeProgram(name);
          }
          return is;
        }
        initializeProgram(name) {
          let is = [];
          this.programs.set(name, is);
          return is;
        }
        getText(intervalOrProgram, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
          let interval;
          if (intervalOrProgram instanceof Interval_1.Interval) {
            interval = intervalOrProgram;
          } else {
            interval = Interval_1.Interval.of(0, this.tokens.size - 1);
          }
          if (typeof intervalOrProgram === "string") {
            programName = intervalOrProgram;
          }
          let rewrites = this.programs.get(programName);
          let start = interval.a;
          let stop = interval.b;
          if (stop > this.tokens.size - 1) {
            stop = this.tokens.size - 1;
          }
          if (start < 0) {
            start = 0;
          }
          if (rewrites == null || rewrites.length === 0) {
            return this.tokens.getText(interval);
          }
          let buf = [];
          let indexToOp = this.reduceToSingleOperationPerIndex(rewrites);
          let i = start;
          while (i <= stop && i < this.tokens.size) {
            let op = indexToOp.get(i);
            indexToOp.delete(i);
            let t = this.tokens.get(i);
            if (op == null) {
              if (t.type !== Token_1.Token.EOF) {
                buf.push(String(t.text));
              }
              i++;
            } else {
              i = op.execute(buf);
            }
          }
          if (stop === this.tokens.size - 1) {
            for (let op of indexToOp.values()) {
              if (op.index >= this.tokens.size - 1) {
                buf.push(op.text.toString());
              }
            }
          }
          return buf.join("");
        }
        /** We need to combine operations and report invalid operations (like
         *  overlapping replaces that are not completed nested). Inserts to
         *  same index need to be combined etc...  Here are the cases:
         *
         *  I.i.u I.j.v								leave alone, nonoverlapping
         *  I.i.u I.i.v								combine: Iivu
         *
         *  R.i-j.u R.x-y.v	| i-j in x-y			delete first R
         *  R.i-j.u R.i-j.v							delete first R
         *  R.i-j.u R.x-y.v	| x-y in i-j			ERROR
         *  R.i-j.u R.x-y.v	| boundaries overlap	ERROR
         *
         *  Delete special case of replace (text==undefined):
         *  D.i-j.u D.x-y.v	| boundaries overlap	combine to max(min)..max(right)
         *
         *  I.i.u R.x-y.v | i in (x+1)-y			delete I (since insert before
         * 											we're not deleting i)
         *  I.i.u R.x-y.v | i not in (x+1)-y		leave alone, nonoverlapping
         *  R.x-y.v I.i.u | i in x-y				ERROR
         *  R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
         *  R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
         *
         *  I.i.u = insert u before op @ index i
         *  R.x-y.u = replace x-y indexed tokens with u
         *
         *  First we need to examine replaces. For any replace op:
         *
         * 		1. wipe out any insertions before op within that range.
         * 		2. Drop any replace op before that is contained completely within
         * 	 that range.
         * 		3. Throw exception upon boundary overlap with any previous replace.
         *
         *  Then we can deal with inserts:
         *
         * 		1. for any inserts to same index, combine even if not adjacent.
         * 		2. for any prior replace with same left boundary, combine this
         * 	 insert with replace and delete this replace.
         * 		3. throw exception if index in same range as previous replace
         *
         *  Don't actually delete; make op undefined in list. Easier to walk list.
         *  Later we can throw as we add to index &rarr; op map.
         *
         *  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
         *  inserted stuff would be before the replace range. But, if you
         *  add tokens in front of a method body '{' and then delete the method
         *  body, I think the stuff before the '{' you added should disappear too.
         *
         *  Return a map from token index to operation.
         */
        reduceToSingleOperationPerIndex(rewrites) {
          for (let i = 0; i < rewrites.length; i++) {
            let op = rewrites[i];
            if (op == null) {
              continue;
            }
            if (!(op instanceof ReplaceOp)) {
              continue;
            }
            let rop = op;
            let inserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
            for (let iop of inserts) {
              if (iop.index === rop.index) {
                rewrites[iop.instructionIndex] = void 0;
                rop.text = iop.text.toString() + (rop.text != null ? rop.text.toString() : "");
              } else if (iop.index > rop.index && iop.index <= rop.lastIndex) {
                rewrites[iop.instructionIndex] = void 0;
              }
            }
            let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
            for (let prevRop of prevReplaces) {
              if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {
                rewrites[prevRop.instructionIndex] = void 0;
                continue;
              }
              let disjoint = prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;
              if (prevRop.text == null && rop.text == null && !disjoint) {
                rewrites[prevRop.instructionIndex] = void 0;
                rop.index = Math.min(prevRop.index, rop.index);
                rop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);
              } else if (!disjoint) {
                throw new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);
              }
            }
          }
          for (let i = 0; i < rewrites.length; i++) {
            let op = rewrites[i];
            if (op == null) {
              continue;
            }
            if (!(op instanceof InsertBeforeOp)) {
              continue;
            }
            let iop = op;
            let prevInserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
            for (let prevIop of prevInserts) {
              if (prevIop.index === iop.index) {
                if (prevIop instanceof InsertAfterOp) {
                  iop.text = this.catOpText(prevIop.text, iop.text);
                  rewrites[prevIop.instructionIndex] = void 0;
                } else if (prevIop instanceof InsertBeforeOp) {
                  iop.text = this.catOpText(iop.text, prevIop.text);
                  rewrites[prevIop.instructionIndex] = void 0;
                }
              }
            }
            let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
            for (let rop of prevReplaces) {
              if (iop.index === rop.index) {
                rop.text = this.catOpText(iop.text, rop.text);
                rewrites[i] = void 0;
                continue;
              }
              if (iop.index >= rop.index && iop.index <= rop.lastIndex) {
                throw new Error(`insert op ${iop} within boundaries of previous ${rop}`);
              }
            }
          }
          let m = /* @__PURE__ */ new Map();
          for (let op of rewrites) {
            if (op == null) {
              continue;
            }
            if (m.get(op.index) != null) {
              throw new Error("should only be one op per index");
            }
            m.set(op.index, op);
          }
          return m;
        }
        catOpText(a, b) {
          let x = "";
          let y = "";
          if (a != null) {
            x = a.toString();
          }
          if (b != null) {
            y = b.toString();
          }
          return x + y;
        }
        /** Get all operations before an index of a particular kind */
        getKindOfOps(rewrites, kind, before) {
          let ops = [];
          for (let i = 0; i < before && i < rewrites.length; i++) {
            let op = rewrites[i];
            if (op == null) {
              continue;
            }
            if (op instanceof kind) {
              ops.push(op);
            }
          }
          return ops;
        }
      };
      exports.TokenStreamRewriter = TokenStreamRewriter;
      TokenStreamRewriter.DEFAULT_PROGRAM_NAME = "default";
      TokenStreamRewriter.PROGRAM_INIT_SIZE = 100;
      TokenStreamRewriter.MIN_TOKEN_INDEX = 0;
      var RewriteOperation = class {
        constructor(tokens, index, instructionIndex, text) {
          this.tokens = tokens;
          this.instructionIndex = instructionIndex;
          this.index = index;
          this.text = text === void 0 ? "" : text;
        }
        /** Execute the rewrite operation by possibly adding to the buffer.
         *  Return the index of the next token to operate on.
         */
        execute(buf) {
          return this.index;
        }
        toString() {
          let opName = this.constructor.name;
          let $index = opName.indexOf("$");
          opName = opName.substring($index + 1, opName.length);
          return "<" + opName + "@" + this.tokens.get(this.index) + ':"' + this.text + '">';
        }
      };
      __decorate([
        Decorators_1.Override
      ], RewriteOperation.prototype, "toString", null);
      exports.RewriteOperation = RewriteOperation;
      var InsertBeforeOp = class extends RewriteOperation {
        constructor(tokens, index, instructionIndex, text) {
          super(tokens, index, instructionIndex, text);
        }
        execute(buf) {
          buf.push(this.text.toString());
          if (this.tokens.get(this.index).type !== Token_1.Token.EOF) {
            buf.push(String(this.tokens.get(this.index).text));
          }
          return this.index + 1;
        }
      };
      __decorate([
        Decorators_1.Override
      ], InsertBeforeOp.prototype, "execute", null);
      var InsertAfterOp = class extends InsertBeforeOp {
        constructor(tokens, index, instructionIndex, text) {
          super(tokens, index + 1, instructionIndex, text);
        }
      };
      var ReplaceOp = class extends RewriteOperation {
        constructor(tokens, from, to, instructionIndex, text) {
          super(tokens, from, instructionIndex, text);
          this.lastIndex = to;
        }
        execute(buf) {
          if (this.text != null) {
            buf.push(this.text.toString());
          }
          return this.lastIndex + 1;
        }
        toString() {
          if (this.text == null) {
            return "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">";
          }
          return "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ':"' + this.text + '">';
        }
      };
      __decorate([
        Decorators_1.Override
      ], ReplaceOp.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], ReplaceOp.prototype, "toString", null);
    }
  });

  // node_modules/antlr4ts/Vocabulary.js
  var require_Vocabulary = __commonJS({
    "node_modules/antlr4ts/Vocabulary.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/antlr4ts/WritableToken.js
  var require_WritableToken = __commonJS({
    "node_modules/antlr4ts/WritableToken.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/antlr4ts/index.js
  var require_antlr4ts = __commonJS({
    "node_modules/antlr4ts/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_ANTLRErrorListener(), exports);
      __exportStar(require_ANTLRErrorStrategy(), exports);
      __exportStar(require_ANTLRInputStream(), exports);
      __exportStar(require_BailErrorStrategy(), exports);
      __exportStar(require_BufferedTokenStream(), exports);
      __exportStar(require_CharStream(), exports);
      __exportStar(require_CharStreams(), exports);
      __exportStar(require_CodePointBuffer(), exports);
      __exportStar(require_CodePointCharStream(), exports);
      __exportStar(require_CommonToken(), exports);
      __exportStar(require_CommonTokenFactory(), exports);
      __exportStar(require_CommonTokenStream(), exports);
      __exportStar(require_ConsoleErrorListener(), exports);
      __exportStar(require_DefaultErrorStrategy(), exports);
      __exportStar(require_Dependents(), exports);
      __exportStar(require_DiagnosticErrorListener(), exports);
      __exportStar(require_FailedPredicateException(), exports);
      __exportStar(require_InputMismatchException(), exports);
      __exportStar(require_InterpreterRuleContext(), exports);
      __exportStar(require_IntStream(), exports);
      __exportStar(require_Lexer(), exports);
      __exportStar(require_LexerInterpreter(), exports);
      __exportStar(require_LexerNoViableAltException(), exports);
      __exportStar(require_ListTokenSource(), exports);
      __exportStar(require_NoViableAltException(), exports);
      __exportStar(require_Parser(), exports);
      __exportStar(require_ParserErrorListener(), exports);
      __exportStar(require_ParserInterpreter(), exports);
      __exportStar(require_ParserRuleContext(), exports);
      __exportStar(require_ProxyErrorListener(), exports);
      __exportStar(require_ProxyParserErrorListener(), exports);
      __exportStar(require_RecognitionException(), exports);
      __exportStar(require_Recognizer(), exports);
      __exportStar(require_RuleContext(), exports);
      __exportStar(require_RuleContextWithAltNum(), exports);
      __exportStar(require_RuleDependency(), exports);
      __exportStar(require_RuleVersion(), exports);
      __exportStar(require_Token(), exports);
      __exportStar(require_TokenFactory(), exports);
      __exportStar(require_TokenSource(), exports);
      __exportStar(require_TokenStream(), exports);
      __exportStar(require_TokenStreamRewriter(), exports);
      __exportStar(require_Vocabulary(), exports);
      __exportStar(require_VocabularyImpl(), exports);
      __exportStar(require_WritableToken(), exports);
    }
  });

  // node_modules/antlr4ts/tree/ParseTree.js
  var require_ParseTree = __commonJS({
    "node_modules/antlr4ts/tree/ParseTree.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // source/gcs.ts
  var TARGET_PATH = "/api/v1/vault/mapview/gcs";
  function normalizeUrl(url) {
    try {
      return new URL(url, location.origin);
    } catch {
      return null;
    }
  }
  function injectGcsListener(listener) {
    const origOpen = XMLHttpRequest.prototype.open;
    const origSend = XMLHttpRequest.prototype.send;
    const isTargetSymbol = /* @__PURE__ */ Symbol("_isTarget");
    const urlObjSymbol = /* @__PURE__ */ Symbol("_urlObj");
    XMLHttpRequest.prototype.open = function(method, url, ...rest) {
      const urlObj = normalizeUrl(url);
      this[isTargetSymbol] = method === "GET" && urlObj?.pathname === TARGET_PATH;
      this[urlObjSymbol] = urlObj;
      return origOpen.call(this, method, url, ...rest);
    };
    XMLHttpRequest.prototype.send = function(...args) {
      if (this[isTargetSymbol]) {
        this.addEventListener("load", function() {
          try {
            const ct = this.getResponseHeader("content-type") || "";
            if (!ct.includes("application/json")) return;
            listener(this[urlObjSymbol], this.responseText);
          } catch (e) {
            console.warn("[GCS LOGGER] Parse failed", e);
          }
        });
      }
      return origSend.apply(this, args);
    };
  }

  // source/geometry.ts
  function toLatLngLiteral(latLng) {
    return { lat: latLng.lat(), lng: latLng.lng() };
  }
  function distance({ lat: lat1, lng: lng1 }, { lat: lat2, lng: lng2 }) {
    const R = 6371e3;
    const rLat1 = lat1 * Math.PI / 180;
    const rLat2 = lat2 * Math.PI / 180;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = Math.sin(dLat / 2) ** 2 + Math.cos(rLat1) * Math.cos(rLat2) * Math.sin(dLng / 2) ** 2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }
  function padBounds(bounds, ratio) {
    const sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), swLat = sw.lat(), swLng = sw.lng(), neLat = ne.lat(), neLng = ne.lng();
    const height = Math.abs(swLat - neLat) * ratio;
    const width = Math.abs(swLng - neLng) * ratio;
    return new google.maps.LatLngBounds(
      { lat: swLat - height, lng: swLng - width },
      { lat: neLat + height, lng: neLng + width }
    );
  }
  function parseCoordinates(coordinatesText) {
    const tokens = coordinatesText.split(",");
    const result = [];
    for (let i = 1; i < tokens.length; i += 2) {
      result.push({ lat: Number(tokens[i - 1]), lng: Number(tokens[i]) });
    }
    if (result.length === 0) {
      throw new Error();
    }
    return result;
  }
  function coordinatesToString(coords) {
    return coords.map((ll) => `${ll.lat},${ll.lng}`).join(",");
  }

  // source/bounds.ts
  function fromSwNeLatLng(swLat, swLng, neLat, neLng) {
    return {
      sw: { lat: swLat, lng: swLng },
      ne: { lat: neLat, lng: neLng }
    };
  }
  function contains(bounds, point) {
    const { lat, lng } = point;
    const { sw, ne } = bounds;
    const isInLat = lat >= sw.lat && lat <= ne.lat;
    if (!isInLat) return false;
    if (sw.lng <= ne.lng) {
      return lng >= sw.lng && lng <= ne.lng;
    } else {
      return lng >= sw.lng || lng <= ne.lng;
    }
  }
  function containsBounds(outer, inner) {
    return contains(outer, inner.sw) && contains(outer, inner.ne);
  }
  function fromClass(object) {
    const sw = object.getSouthWest();
    const ne = object.getNorthEast();
    return fromSwNeLatLng(sw.lat(), sw.lng(), ne.lat(), ne.lng());
  }

  // source/standard-extensions.ts
  function id(value) {
    return value;
  }
  function ignore(..._) {
  }
  function withTag(value) {
    return value;
  }
  async function awaitElement(get, options) {
    let currentInterval = 100;
    const maxInterval = 500;
    for (; ; ) {
      const ref = get();
      if (ref) return ref;
      await sleep(Math.min(currentInterval *= 2, maxInterval), options);
    }
  }
  function sleep(ms, options) {
    return new Promise((resolve, reject) => {
      const signal = options?.signal;
      if (signal?.aborted) return reject(signal.reason);
      const handle = setTimeout(() => {
        cleanup();
        resolve();
      }, ms);
      function onAbort() {
        cleanup();
        queueMicrotask(
          () => reject(signal == null ? newAbortError() : signal.reason)
        );
      }
      function cleanup() {
        clearTimeout(handle);
        signal?.removeEventListener("abort", onAbort);
      }
      signal?.addEventListener("abort", onAbort);
    });
  }
  function raise(templateStringsArray, ...substitutions) {
    throw new Error(String.raw(templateStringsArray, ...substitutions));
  }
  var AbortError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "AbortError";
    }
  };
  function newAbortError(message = "The operation was aborted.") {
    if (typeof DOMException === "function") {
      return new DOMException(message, "AbortError");
    } else {
      return new AbortError(message);
    }
  }
  function isAbortError(e) {
    return e != null && typeof e === "object" && "name" in e && e.name === "AbortError";
  }
  function createAsyncCancelScope(onError) {
    let activeController;
    return (process2) => {
      activeController?.abort(newAbortError());
      activeController = new AbortController();
      process2(activeController.signal).catch((e) => {
        if (isAbortError(e)) return;
        onError(e);
      });
    };
  }
  function cached(f) {
    let hasValue = false;
    let value;
    return () => {
      if (!hasValue) {
        hasValue = true;
        value = f();
      }
      return value;
    };
  }
  function memoizeWith(getKey, f) {
    const memo = /* @__PURE__ */ new Map();
    return (...x) => {
      const k = getKey(...x);
      let r = memo.get(k);
      if (r === void 0) {
        r = f(k, ...x);
        memo.set(k, r);
      }
      return r;
    };
  }
  function waitAnimationFrame(signal) {
    return new Promise((resolve, reject) => {
      if (signal.aborted) return reject(signal.reason);
      const cleanup = () => {
        cancelAnimationFrame(handle);
        signal.removeEventListener("abort", cleanup);
      };
      const handle = requestAnimationFrame((time) => {
        cleanup();
        resolve(time);
      });
      signal.addEventListener("abort", cleanup, { once: true });
    });
  }
  function wrapCancellable(task, cancelTask) {
    let id2 = 1;
    return async (signal, ...args) => {
      const requestId = id2++;
      const onAbort = () => {
        cancelTask(requestId).catch(ignore);
      };
      if (signal.aborted) {
        onAbort();
        throw new DOMException("Aborted", "AbortError");
      }
      signal.addEventListener("abort", onAbort, { once: true });
      try {
        return await task(requestId, ...args);
      } finally {
        signal.removeEventListener("abort", onAbort);
      }
    };
  }

  // source/typed-idb.ts
  function defineDatabase(database, schema) {
    for (const [storeName, storeSchema] of Object.entries(schema)) {
      const store = database.createObjectStore(storeName, {
        keyPath: storeSchema.key.slice()
      });
      for (const [indexName, options] of Object.entries(
        storeSchema.indexes
      )) {
        store.createIndex(indexName, options.key, options);
      }
    }
  }
  function openDatabase(databaseName2, databaseVersion2, databaseSchema2) {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(databaseName2, databaseVersion2);
      request.addEventListener(
        "upgradeneeded",
        () => defineDatabase(request.result, databaseSchema2)
      );
      request.addEventListener(
        "blocked",
        () => reject(new Error("database blocked"))
      );
      request.addEventListener("error", () => reject(request.error));
      request.addEventListener(
        "success",
        () => resolve(withTag(request.result))
      );
    });
  }
  var IterateValuesRequest = class {
    constructor(source, query, action) {
      this.source = source;
      this.query = query;
      this.action = action;
    }
  };
  function enterTransactionScope(database, {
    mode,
    signal
  }, scope, ...storeNames) {
    return new Promise((resolve, reject) => {
      if (signal?.aborted) {
        reject(newAbortError());
        return;
      }
      let hasResult = false;
      let result;
      const transaction = database.transaction(storeNames, mode);
      const onAbort = signal ? () => {
        if (!hasResult) {
          transaction.abort();
        }
      } : ignore;
      transaction.addEventListener("complete", () => {
        signal?.removeEventListener("abort", onAbort);
        if (hasResult) {
          resolve(result);
        } else {
          reject(new Error(`internal error`));
        }
      });
      transaction.addEventListener("error", (e) => {
        signal?.removeEventListener("abort", onAbort);
        reject(e.target.error);
      });
      signal?.addEventListener("abort", onAbort);
      const stores = {};
      for (const name of storeNames) {
        stores[name] = withTag(transaction.objectStore(name));
      }
      const iterator = scope(
        stores
      );
      let stateKind;
      let request_request;
      let waitRequests_results;
      let waitRequests_requests;
      let openCursor_request;
      let openCursor_action;
      function onResolved() {
        let r;
        switch (stateKind) {
          case void 0:
            r = iterator.next();
            break;
          case "Request": {
            const result2 = request_request.result;
            stateKind = void 0;
            request_request = void 0;
            r = iterator.next(result2);
            break;
          }
          case "WaitRequests": {
            const results = waitRequests_results;
            const requests = waitRequests_requests;
            const result2 = requests[results.length].result;
            results.push(result2);
            if (results.length !== requests.length) return;
            stateKind = void 0;
            waitRequests_requests = void 0;
            waitRequests_results = void 0;
            r = iterator.next(results);
            break;
          }
          case "OpenCursor": {
            const cursor = openCursor_request.result;
            if (cursor === null || openCursor_action(cursor.value) === "break") {
              stateKind = void 0;
              openCursor_request = void 0;
              openCursor_action = void 0;
              r = iterator.next(void 0);
            } else {
              cursor.continue();
              return;
            }
            break;
          }
          default: {
            reject(new Error(`Invalid resolving kind: ${stateKind}`));
            return;
          }
        }
        if (r.done) {
          hasResult = true;
          result = r.value;
          return;
        }
        const yieldValue = r.value;
        if (yieldValue instanceof IDBRequest) {
          stateKind = "Request";
          request_request = yieldValue;
          yieldValue.onsuccess = onResolved;
          return;
        }
        if (yieldValue instanceof IterateValuesRequest) {
          stateKind = "OpenCursor";
          openCursor_request = yieldValue.source.openCursor(
            yieldValue.query
          );
          openCursor_action = yieldValue.action;
          openCursor_request.onsuccess = onResolved;
          return;
        }
        stateKind = "WaitRequests";
        waitRequests_requests = yieldValue;
        waitRequests_results = [];
        for (const request of yieldValue) {
          request.onsuccess = onResolved;
        }
        return;
      }
      onResolved();
    });
  }
  function getIndex(store, indexName) {
    return withTag(store.index(indexName));
  }
  function* iterateValuesOfIndex(index, query, action) {
    yield new IterateValuesRequest(index, query, action);
    return;
  }

  // source/s2.ts
  function exposeS2Module(exports) {
    "use strict";
    var S22 = exports.S2 = {
      L: {}
    };
    S22.L.LatLng = function(rawLat, rawLng, noWrap) {
      var lat = parseFloat(rawLat, 10);
      var lng = parseFloat(rawLng, 10);
      if (isNaN(lat) || isNaN(lng)) {
        throw new Error(
          "Invalid LatLng object: (" + rawLat + ", " + rawLng + ")"
        );
      }
      if (noWrap !== true) {
        lat = Math.max(Math.min(lat, 90), -90);
        lng = (lng + 180) % 360 + (lng < -180 || lng === 180 ? 180 : -180);
      }
      return {
        lat,
        lng
      };
    };
    S22.L.LatLng.DEG_TO_RAD = Math.PI / 180;
    S22.L.LatLng.RAD_TO_DEG = 180 / Math.PI;
    S22.LatLngToXYZ = function(latLng) {
      var d2r = S22.L.LatLng.DEG_TO_RAD;
      var phi = latLng.lat * d2r;
      var theta = latLng.lng * d2r;
      var cosphi = Math.cos(phi);
      return [
        Math.cos(theta) * cosphi,
        Math.sin(theta) * cosphi,
        Math.sin(phi)
      ];
    };
    S22.XYZToLatLng = function(xyz) {
      var r2d = S22.L.LatLng.RAD_TO_DEG;
      var lat = Math.atan2(
        xyz[2],
        Math.sqrt(xyz[0] * xyz[0] + xyz[1] * xyz[1])
      );
      var lng = Math.atan2(xyz[1], xyz[0]);
      return S22.L.LatLng(lat * r2d, lng * r2d);
    };
    var largestAbsComponent = function(xyz) {
      var temp = [Math.abs(xyz[0]), Math.abs(xyz[1]), Math.abs(xyz[2])];
      if (temp[0] > temp[1]) {
        if (temp[0] > temp[2]) {
          return 0;
        } else {
          return 2;
        }
      } else {
        if (temp[1] > temp[2]) {
          return 1;
        } else {
          return 2;
        }
      }
    };
    var faceXYZToUV = function(face, xyz) {
      var u, v;
      switch (face) {
        case 0:
          u = xyz[1] / xyz[0];
          v = xyz[2] / xyz[0];
          break;
        case 1:
          u = -xyz[0] / xyz[1];
          v = xyz[2] / xyz[1];
          break;
        case 2:
          u = -xyz[0] / xyz[2];
          v = -xyz[1] / xyz[2];
          break;
        case 3:
          u = xyz[2] / xyz[0];
          v = xyz[1] / xyz[0];
          break;
        case 4:
          u = xyz[2] / xyz[1];
          v = -xyz[0] / xyz[1];
          break;
        case 5:
          u = -xyz[1] / xyz[2];
          v = -xyz[0] / xyz[2];
          break;
        default:
          throw {
            error: "Invalid face"
          };
      }
      return [u, v];
    };
    S22.XYZToFaceUV = function(xyz) {
      var face = largestAbsComponent(xyz);
      if (xyz[face] < 0) {
        face += 3;
      }
      var uv = faceXYZToUV(face, xyz);
      return [face, uv];
    };
    S22.FaceUVToXYZ = function(face, uv) {
      var u = uv[0];
      var v = uv[1];
      switch (face) {
        case 0:
          return [1, u, v];
        case 1:
          return [-u, 1, v];
        case 2:
          return [-u, -v, 1];
        case 3:
          return [-1, -v, -u];
        case 4:
          return [v, -1, -u];
        case 5:
          return [v, u, -1];
        default:
          throw {
            error: "Invalid face"
          };
      }
    };
    var singleSTtoUV = function(st) {
      if (st >= 0.5) {
        return 1 / 3 * (4 * st * st - 1);
      } else {
        return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
      }
    };
    S22.STToUV = function(st) {
      return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];
    };
    var singleUVtoST = function(uv) {
      if (uv >= 0) {
        return 0.5 * Math.sqrt(1 + 3 * uv);
      } else {
        return 1 - 0.5 * Math.sqrt(1 - 3 * uv);
      }
    };
    S22.UVToST = function(uv) {
      return [singleUVtoST(uv[0]), singleUVtoST(uv[1])];
    };
    S22.STToIJ = function(st, order) {
      var maxSize = 1 << order;
      var singleSTtoIJ = function(st2) {
        var ij = Math.floor(st2 * maxSize);
        return Math.max(0, Math.min(maxSize - 1, ij));
      };
      return [singleSTtoIJ(st[0]), singleSTtoIJ(st[1])];
    };
    S22.IJToST = function(ij, order, offsets) {
      var maxSize = 1 << order;
      return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
    };
    var rotateAndFlipQuadrant = function(n, point, rx, ry) {
      var newX, newY;
      if (ry == 0) {
        if (rx == 1) {
          point.x = n - 1 - point.x;
          point.y = n - 1 - point.y;
        }
        var x = point.x;
        point.x = point.y;
        point.y = x;
      }
    };
    var pointToHilbertQuadList = function(x, y, order, face) {
      var hilbertMap = {
        a: [
          [0, "d"],
          [1, "a"],
          [3, "b"],
          [2, "a"]
        ],
        b: [
          [2, "b"],
          [1, "b"],
          [3, "a"],
          [0, "c"]
        ],
        c: [
          [2, "c"],
          [3, "d"],
          [1, "c"],
          [0, "b"]
        ],
        d: [
          [0, "a"],
          [3, "c"],
          [1, "d"],
          [2, "d"]
        ]
      };
      if ("number" !== typeof face) {
        console.warn(
          new Error(
            "called pointToHilbertQuadList without face value, defaulting to '0'"
          ).stack
        );
      }
      var currentSquare = face % 2 ? "d" : "a";
      var positions = [];
      for (var i = order - 1; i >= 0; i--) {
        var mask = 1 << i;
        var quad_x = x & mask ? 1 : 0;
        var quad_y = y & mask ? 1 : 0;
        var t = hilbertMap[currentSquare][quad_x * 2 + quad_y];
        positions.push(t[0]);
        currentSquare = t[1];
      }
      return positions;
    };
    S22.S2Cell = function() {
    };
    S22.S2Cell.FromHilbertQuadKey = function(hilbertQuadkey) {
      var parts = hilbertQuadkey.split("/");
      var face = parseInt(parts[0]);
      var position = parts[1];
      var maxLevel = position.length;
      var point = {
        x: 0,
        y: 0
      };
      var i;
      var level;
      var bit;
      var rx, ry;
      var val;
      for (i = maxLevel - 1; i >= 0; i--) {
        level = maxLevel - i;
        bit = position[i];
        rx = 0;
        ry = 0;
        if (bit === "1") {
          ry = 1;
        } else if (bit === "2") {
          rx = 1;
          ry = 1;
        } else if (bit === "3") {
          rx = 1;
        }
        val = Math.pow(2, level - 1);
        rotateAndFlipQuadrant(val, point, rx, ry);
        point.x += val * rx;
        point.y += val * ry;
      }
      if (face % 2 === 1) {
        var t = point.x;
        point.x = point.y;
        point.y = t;
      }
      return S22.S2Cell.FromFaceIJ(parseInt(face), [point.x, point.y], level);
    };
    S22.S2Cell.FromLatLng = function(latLng, level) {
      if (!latLng.lat && latLng.lat !== 0 || !latLng.lng && latLng.lng !== 0) {
        throw new Error(
          "Pass { lat: lat, lng: lng } to S2.S2Cell.FromLatLng"
        );
      }
      var xyz = S22.LatLngToXYZ(latLng);
      var faceuv = S22.XYZToFaceUV(xyz);
      var st = S22.UVToST(faceuv[1]);
      var ij = S22.STToIJ(st, level);
      return S22.S2Cell.FromFaceIJ(faceuv[0], ij, level);
    };
    S22.S2Cell.FromFaceIJ = function(face, ij, level) {
      var cell = new S22.S2Cell();
      cell.face = face;
      cell.ij = ij;
      cell.level = level;
      return cell;
    };
    S22.S2Cell.prototype.toString = function() {
      return "F" + this.face + "ij[" + this.ij[0] + "," + this.ij[1] + "]@" + this.level;
    };
    S22.S2Cell.prototype.getLatLng = function() {
      var st = S22.IJToST(this.ij, this.level, [0.5, 0.5]);
      var uv = S22.STToUV(st);
      var xyz = S22.FaceUVToXYZ(this.face, uv);
      return S22.XYZToLatLng(xyz);
    };
    S22.S2Cell.prototype.getCornerLatLngs = function() {
      var result = [];
      var offsets = [
        [0, 0],
        [0, 1],
        [1, 1],
        [1, 0]
      ];
      for (var i = 0; i < 4; i++) {
        var st = S22.IJToST(this.ij, this.level, offsets[i]);
        var uv = S22.STToUV(st);
        var xyz = S22.FaceUVToXYZ(this.face, uv);
        result.push(S22.XYZToLatLng(xyz));
      }
      return result;
    };
    S22.S2Cell.prototype.getFaceAndQuads = function() {
      var quads = pointToHilbertQuadList(
        this.ij[0],
        this.ij[1],
        this.level,
        this.face
      );
      return [this.face, quads];
    };
    S22.S2Cell.prototype.toHilbertQuadkey = function() {
      var quads = pointToHilbertQuadList(
        this.ij[0],
        this.ij[1],
        this.level,
        this.face
      );
      return this.face.toString(10) + "/" + quads.join("");
    };
    S22.latLngToNeighborKeys = S22.S2Cell.latLngToNeighborKeys = function(lat, lng, level) {
      return S22.S2Cell.FromLatLng(
        {
          lat,
          lng
        },
        level
      ).getNeighbors().map(function(cell) {
        return cell.toHilbertQuadkey();
      });
    };
    S22.S2Cell.prototype.getNeighbors = function() {
      var fromFaceIJWrap = function(face2, ij, level2) {
        var maxSize = 1 << level2;
        if (ij[0] >= 0 && ij[1] >= 0 && ij[0] < maxSize && ij[1] < maxSize) {
          return S22.S2Cell.FromFaceIJ(face2, ij, level2);
        } else {
          var st = S22.IJToST(ij, level2, [0.5, 0.5]);
          var uv = S22.STToUV(st);
          var xyz = S22.FaceUVToXYZ(face2, uv);
          var faceuv = S22.XYZToFaceUV(xyz);
          face2 = faceuv[0];
          uv = faceuv[1];
          st = S22.UVToST(uv);
          ij = S22.STToIJ(st, level2);
          return S22.S2Cell.FromFaceIJ(face2, ij, level2);
        }
      };
      var face = this.face;
      var i = this.ij[0];
      var j = this.ij[1];
      var level = this.level;
      return [
        fromFaceIJWrap(face, [i - 1, j], level),
        fromFaceIJWrap(face, [i, j - 1], level),
        fromFaceIJWrap(face, [i + 1, j], level),
        fromFaceIJWrap(face, [i, j + 1], level)
      ];
    };
    S22.FACE_BITS = 3;
    S22.MAX_LEVEL = 30;
    S22.POS_BITS = 2 * S22.MAX_LEVEL + 1;
    S22.facePosLevelToId = S22.S2Cell.facePosLevelToId = S22.fromFacePosLevel = function(faceN, posS, levelN) {
      var Long = exports.dcodeIO && exports.dcodeIO.Long;
      var faceB;
      var posB;
      var bin;
      if (!levelN) {
        levelN = posS.length;
      }
      if (posS.length > levelN) {
        posS = posS.substr(0, levelN);
      }
      faceB = Long.fromString(faceN.toString(10), true, 10).toString(
        2
      );
      while (faceB.length < S22.FACE_BITS) {
        faceB = "0" + faceB;
      }
      posB = Long.fromString(posS, true, 4).toString(2);
      while (posB.length < 2 * levelN) {
        posB = "0" + posB;
      }
      bin = faceB + posB;
      bin += "1";
      while (bin.length < S22.FACE_BITS + S22.POS_BITS) {
        bin += "0";
      }
      return Long.fromString(bin, true, 2).toString(10);
    };
    S22.keyToId = S22.S2Cell.keyToId = S22.toId = S22.toCellId = S22.fromKey = function(key) {
      var parts = key.split("/");
      return S22.fromFacePosLevel(parts[0], parts[1], parts[1].length);
    };
    S22.idToKey = S22.S2Cell.idToKey = S22.S2Cell.toKey = S22.toKey = S22.fromId = S22.fromCellId = S22.S2Cell.toHilbertQuadkey = S22.toHilbertQuadkey = function(idS) {
      var Long = exports.dcodeIO && exports.dcodeIO.Long;
      var bin = Long.fromString(idS, true, 10).toString(2);
      while (bin.length < S22.FACE_BITS + S22.POS_BITS) {
        bin = "0" + bin;
      }
      var lsbIndex = bin.lastIndexOf("1");
      var faceB = bin.substring(0, 3);
      var posB = bin.substring(3, lsbIndex);
      var levelN = posB.length / 2;
      var faceS = Long.fromString(faceB, true, 2).toString(10);
      var posS = Long.fromString(posB, true, 2).toString(4);
      while (posS.length < levelN) {
        posS = "0" + posS;
      }
      return faceS + "/" + posS;
    };
    S22.keyToLatLng = S22.S2Cell.keyToLatLng = function(key) {
      var cell2 = S22.S2Cell.FromHilbertQuadKey(key);
      return cell2.getLatLng();
    };
    S22.idToLatLng = S22.S2Cell.idToLatLng = function(id2) {
      var key = S22.idToKey(id2);
      return S22.keyToLatLng(key);
    };
    S22.S2Cell.latLngToKey = S22.latLngToKey = S22.latLngToQuadkey = function(lat, lng, level) {
      if (isNaN(level) || level < 1 || level > 30) {
        throw new Error(
          "'level' is not a number between 1 and 30 (but it should be)"
        );
      }
      return S22.S2Cell.FromLatLng(
        {
          lat,
          lng
        },
        level
      ).toHilbertQuadkey();
    };
    S22.stepKey = function(key, num) {
      var Long = exports.dcodeIO && exports.dcodeIO.Long;
      var parts = key.split("/");
      var faceS = parts[0];
      var posS = parts[1];
      var level = parts[1].length;
      var posL = Long.fromString(posS, true, 4);
      var otherL;
      if (num > 0) {
        otherL = posL.add(Math.abs(num));
      } else if (num < 0) {
        otherL = posL.subtract(Math.abs(num));
      }
      var otherS = otherL.toString(4);
      if ("0" === otherS) {
        console.warning(
          new Error("face/position wrapping is not yet supported")
        );
      }
      while (otherS.length < level) {
        otherS = "0" + otherS;
      }
      return faceS + "/" + otherS;
    };
    S22.S2Cell.prevKey = S22.prevKey = function(key) {
      return S22.stepKey(key, -1);
    };
    S22.S2Cell.nextKey = S22.nextKey = function(key) {
      return S22.stepKey(key, 1);
    };
    return S22;
  }
  var S2 = exposeS2Module(
    typeof module !== "undefined" && module.exports ? module.exports : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : void 0
  );

  // source/typed-s2cell.ts
  function createCellFromCoordinates(latLng, level) {
    return S2.S2Cell.FromLatLng(latLng, level);
  }
  function getCellId(latLng, level) {
    return createCellFromCoordinates(latLng, level).toString();
  }
  var indexes = Object.freeze(["0", "1", "2", "3"]);
  var buffer64 = new BigUint64Array(1);
  var view32 = new Uint32Array(buffer64.buffer);

  // source/async-queue.ts
  function createAsyncQueue(consume, handleAsyncError2, { batchSize = 10 } = {}) {
    const queue = [];
    let processing = false;
    let scheduled = false;
    function push(item) {
      queue.push(item);
      schedule();
    }
    function schedule() {
      if (scheduled) return;
      scheduled = true;
      queueMicrotask(() => {
        scheduled = false;
        void flush().catch(handleAsyncError2);
      });
    }
    async function flush() {
      if (processing) return;
      if (queue.length === 0) return;
      processing = true;
      const batch = queue.splice(0, batchSize);
      try {
        await consume(batch);
      } finally {
        processing = false;
        if (queue.length) {
          schedule();
        }
      }
    }
    function close() {
      queue.length = 0;
    }
    return { push, close };
  }

  // source/environments.ts
  function isWebWorker() {
    return typeof window === "undefined" && typeof self !== "undefined";
  }

  // source/dom-extensions.ts
  function createSchedulerByAnimationFrame(signal, thresholdMs) {
    let startTime = performance.now();
    let lastHandle = null;
    signal.addEventListener(
      "abort",
      () => {
        if (lastHandle != null) {
          cancelAnimationFrame(lastHandle);
          lastHandle = null;
        }
      },
      { once: true }
    );
    return {
      get isYieldRequested() {
        if (navigator.scheduling?.isInputPending?.()) {
          return true;
        }
        const now = performance.now();
        return now - startTime >= thresholdMs;
      },
      yield() {
        if (!this.isYieldRequested) return null;
        return new Promise((resolve) => {
          lastHandle = requestAnimationFrame(() => {
            startTime = performance.now();
            resolve();
          });
        });
      }
    };
  }
  function createWorkerScheduler() {
    return {
      isYieldRequested: false,
      yield() {
        return null;
      }
    };
  }
  function createScheduler(signal, thresholdMs = 10) {
    if (isWebWorker()) return createWorkerScheduler();
    return createSchedulerByAnimationFrame(signal, thresholdMs);
  }
  function styleSetter(cssText12) {
    let done2 = false;
    return () => {
      if (!done2) {
        done2 = true;
        const sheet = new CSSStyleSheet();
        sheet.replaceSync(cssText12);
        document.adoptedStyleSheets.push(sheet);
      }
    };
  }

  // source/typed-event-target.ts
  function createTypedEventTarget() {
    return new EventTarget();
  }
  function createTypedCustomEvent(type, detail) {
    return new CustomEvent(type, { detail });
  }

  // source/poi-records.ts
  var databaseSchema = {
    pois: {
      recordType: id,
      key: "guid",
      indexes: {
        coordinates: {
          key: ["lat", "lng"]
        },
        cellIds: {
          key: "cellIds",
          multiEntry: true
        }
      }
    },
    cells: {
      recordType: id,
      key: "cellId",
      indexes: {
        ancestorIds: {
          key: "ancestorIds",
          multiEntry: true
        }
      }
    }
  };
  var poisSymbol = /* @__PURE__ */ Symbol("_pois");
  var cellsSymbol = /* @__PURE__ */ Symbol("_cells");
  var coordinatesIndexSymbol = /* @__PURE__ */ Symbol("_coordinatesIndex");
  var cellIdsIndexSymbol = /* @__PURE__ */ Symbol("_cellIdsIndex");
  var ancestorIdsIndexSymbol = /* @__PURE__ */ Symbol("_ancestorIdsIndexSymbol");
  function iteratePoisInCell(store, cellId, action) {
    return iterateValuesOfIndex(store[cellIdsIndexSymbol], cellId, action);
  }
  function iterateCellsInCell14(store, cellId, action) {
    return iterateValuesOfIndex(
      store[ancestorIdsIndexSymbol],
      cellId,
      action
    );
  }
  var databaseName = "poi-records-e232930d-7282-4c02-aeef-bb9508576d2e";
  var databaseVersion = 1;
  var databaseSymbol = /* @__PURE__ */ Symbol("_database");
  async function openRecords() {
    return {
      [databaseSymbol]: await openDatabase(
        databaseName,
        databaseVersion,
        databaseSchema
      )
    };
  }
  function enterTransactionScope2(records, mode, options, scope) {
    return enterTransactionScope(
      records[databaseSymbol],
      { mode, signal: options?.signal },
      ({ pois, cells }) => {
        const store = {
          [poisSymbol]: pois,
          [cellsSymbol]: cells,
          [coordinatesIndexSymbol]: getIndex(pois, "coordinates"),
          [cellIdsIndexSymbol]: getIndex(pois, "cellIds"),
          [ancestorIdsIndexSymbol]: getIndex(cells, "ancestorIds")
        };
        return scope(store);
      },
      "pois",
      "cells"
    );
  }
  function setEntry(map, key, value) {
    map.set(key, value);
    return value;
  }
  function createEmptyCell14Statistics(cell) {
    return {
      cell,
      id: cell.toString(),
      pois: /* @__PURE__ */ new Map(),
      corner: cell.getCornerLatLngs(),
      center: cell.getLatLng(),
      cell17s: /* @__PURE__ */ new Map(),
      cell16s: /* @__PURE__ */ new Map(),
      kindToPois: /* @__PURE__ */ new Map()
    };
  }
  function updateCellStatisticsByCell(cells, cell, lastFetchDate) {
    const key = cell.toString();
    const stat = cells.get(key) ?? setEntry(cells, key, {
      cell,
      center: cell.getLatLng(),
      kindToCount: /* @__PURE__ */ new Map(),
      lastFetchDate
    });
    stat.lastFetchDate ||= lastFetchDate;
    return stat;
  }
  function updateCellStatisticsByPoi(cells, poi, level) {
    const cell = createCellFromCoordinates(poi, level);
    const { kindToCount } = updateCellStatisticsByCell(cells, cell, void 0);
    for (const { entity } of poi.data.gmo) {
      const count = kindToCount.get(entity) ?? 0;
      kindToCount.set(entity, count + 1);
    }
  }
  function isGymOrPokestop(g) {
    return g.entity === "GYM" || g.entity === "POKESTOP";
  }
  function addToKindToPois(cell14, entity, poi) {
    const pois = cell14.kindToPois.get(entity) ?? setEntry(cell14.kindToPois, entity, []);
    pois.push(poi);
  }
  async function getCell14Stats(records, cell, signal) {
    const cellId = cell.toString();
    let cell14;
    const collectPois = (poi) => {
      cell14 ??= createEmptyCell14Statistics(cell);
      const coordinateKey = `(${poi.lat}, ${poi.lng})`;
      if (cell14.pois.get(coordinateKey) != null) return "continue";
      cell14.pois.set(coordinateKey, poi);
      const { gmo } = poi.data;
      for (const { entity } of gmo) {
        addToKindToPois(cell14, entity, poi);
      }
      if (gmo.length === 0) {
        addToKindToPois(cell14, "", poi);
      }
      if (gmo.some(isGymOrPokestop)) {
        updateCellStatisticsByPoi(cell14.cell16s, poi, 16);
        updateCellStatisticsByPoi(cell14.cell17s, poi, 17);
      }
    };
    const collectCells = (childCell) => {
      if (childCell.level !== 17) {
        return "continue";
      }
      cell14 ??= createEmptyCell14Statistics(cell);
      const cell17 = createCellFromCoordinates(
        { lat: childCell.centerLat, lng: childCell.centerLng },
        17
      );
      updateCellStatisticsByCell(
        cell14.cell17s,
        cell17,
        childCell.lastFetchDate
      );
    };
    await enterTransactionScope2(
      records,
      "readonly",
      { signal },
      function* (store) {
        yield* iteratePoisInCell(store, cellId, collectPois);
        yield* iterateCellsInCell14(store, cellId, collectCells);
      }
    );
    return cell14;
  }

  // source/poi-records-overlay-view.ts
  var TILE_SIZE = 256;
  var PI = Math.PI;
  var RAD_PER_DEG = PI / 180;
  var X_FACTOR = TILE_SIZE / 360;
  var Y_FACTOR = TILE_SIZE / (2 * PI);
  var OFFSET = TILE_SIZE / 2;
  var Point_x = 0;
  var Point_y = Point_x + 1;
  var Point_size = Point_y + 1;
  var cellBaseZIndex = 3100;
  var poiBaseZIndex = cellBaseZIndex + 100;
  var poiLabelBaseZIndex = poiBaseZIndex + 100;
  var statLabelBaseZIndex = poiLabelBaseZIndex + 100;
  var cell17EmptyOptions = Object.freeze({
    strokeColor: "rgba(253, 255, 114, 0.4)",
    strokeWeight: 1,
    fillColor: "#0000002d",
    clickable: false,
    zIndex: cellBaseZIndex + 1
  });
  var cell17PokestopOptions = Object.freeze({
    ...cell17EmptyOptions,
    fillColor: "rgba(0, 191, 255, 0.4)",
    strokeColor: "rgba(0, 191, 255, 0.6)",
    zIndex: cellBaseZIndex
  });
  var cell17GymOptions = Object.freeze({
    ...cell17PokestopOptions,
    fillColor: "rgba(255, 0, 13, 0.4)",
    strokeColor: "rgba(255, 0, 13, 0.6)"
  });
  var cell14Options = Object.freeze({
    strokeColor: "#c54545b7",
    strokeWeight: 2,
    fillColor: "transparent",
    clickable: false,
    zIndex: cellBaseZIndex + 2
  });
  var cell14Options1 = Object.freeze({
    ...cell14Options,
    fillColor: "#dd767625"
  });
  var cell14Options2 = Object.freeze({
    ...cell14Options,
    fillColor: "#d3b71738"
  });
  var wayspotOptions = Object.freeze({
    markerSize: 8,
    borderColor: "#ff6600",
    borderWidth: 2,
    fillColor: "#ff660080",
    zIndex: poiBaseZIndex
  });
  var gymOptions = Object.freeze({
    ...wayspotOptions,
    borderColor: "#ffffff",
    fillColor: "#ff2450"
  });
  var pokestopOptions = Object.freeze({
    ...wayspotOptions,
    borderColor: "#0000cd",
    fillColor: "#00bfff"
  });
  var powerspotOptions = Object.freeze({
    ...wayspotOptions,
    borderColor: "#e762d3",
    fillColor: "#f195eb"
  });
  var wayspotLabelOptions = {
    font: `11px "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif`,
    strokeColor: "rgb(0, 0, 0)",
    fillColor: "#FFFFBB",
    strokeWeight: 2,
    lineJoin: "round",
    shadowBlur: 1
  };
  var gymLabelOptions = Object.freeze({
    ...wayspotLabelOptions,
    font: `bold ` + wayspotLabelOptions.font,
    strokeColor: "#ffffffd5",
    fillColor: "#9c1933"
  });
  var powerspotLabelOptions = Object.freeze({
    ...wayspotLabelOptions,
    strokeColor: "#e762d3"
  });
  function initCanvas(ctx, port) {
    const { canvas } = ctx;
    const { width, height, devicePixelRatio } = port;
    const canvasWidth = width * devicePixelRatio;
    const canvasHeight = height * devicePixelRatio;
    if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
    }
    ctx.scale(devicePixelRatio, devicePixelRatio);
    ctx.clearRect(0, 0, width, height);
  }

  // inline-worker:__inline-worker
  function inlineWorker(scriptText) {
    let blob = new Blob([scriptText], { type: "text/javascript" });
    let url = URL.createObjectURL(blob);
    let worker = new Worker(url);
    URL.revokeObjectURL(url);
    return worker;
  }

  // source/poi-records-overlay.worker.ts?worker
  function Worker2() {
    return inlineWorker('var Be=Object.defineProperty,Ae=Object.defineProperties;var Ve=Object.getOwnPropertyDescriptors;var z=Object.getOwnPropertySymbols;var Fe=Object.prototype.hasOwnProperty,qe=Object.prototype.propertyIsEnumerable;var q=(t,e)=>(e=Symbol[t])?e:Symbol.for("Symbol."+t),We=t=>{throw TypeError(t)};var $=(t,e,o)=>e in t?Be(t,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[e]=o,v=(t,e)=>{for(var o in e||(e={}))Fe.call(e,o)&&$(t,o,e[o]);if(z)for(var o of z(e))qe.call(e,o)&&$(t,o,e[o]);return t},C=(t,e)=>Ae(t,Ve(e));var _e=function(t,e){this[0]=t,this[1]=e};var W=t=>{var e=t[q("asyncIterator")],o=!1,i,s={};return e==null?(e=t[q("iterator")](),i=c=>s[c]=u=>e[c](u)):(e=e.call(t),i=c=>s[c]=u=>{if(o){if(o=!1,c==="throw")throw u;return u}return o=!0,{done:!1,value:new _e(new Promise(d=>{var n=e[c](u);n instanceof Object||We("Object expected"),d(n)}),1)}}),s[q("iterator")]=()=>s,i("next"),"throw"in e?i("throw"):s.throw=c=>{throw c},"return"in e&&i("return"),s};function ee(t=128){let e=new Map;function o(n,r){return n<<16|r&65535}function i(n,r){let a=n.centerX-n.width/2,l=n.centerX+n.width/2,f=n.centerY-n.height/2,m=n.centerY+n.height/2,p=Math.floor(a/t),T=Math.floor(l/t),y=Math.floor(f/t),g=Math.floor(m/t);for(let S=p;S<=T;S++)for(let h=y;h<=g;h++)r.push(o(S,h))}let s=[];function c(n){i(n,s);try{for(let r of s){let a=e.get(r);a||(a=[],e.set(r,a)),a.push(n)}}finally{s.length=0}}let u=new Set;function d(n){i(n,s);try{for(let r of s){let a=e.get(r);if(a)for(let l of a)u.add(l)}for(let r of u){if(n.key===r.key)continue;let a=Math.abs(n.centerX-r.centerX),l=(n.width+r.width)/2;if(a>=l)continue;let f=Math.abs(n.centerY-r.centerY),m=(n.height+r.height)/2;if(!(f>=m))return!0}}finally{u.clear(),s.length=0}return!1}return{addBox:c,check:d}}function te(){return{sw:{lat:1/0,lng:1/0},ne:{lat:-1/0,lng:-1/0}}}function ne(t){return{lat:(t.sw.lat+t.ne.lat)/2,lng:(t.sw.lng+t.ne.lng)/2}}function re(t,e){return{sw:{lat:Math.min(t.sw.lat,e.lat),lng:Math.min(t.sw.lng,e.lng)},ne:{lat:Math.max(t.ne.lat,e.lat),lng:Math.max(t.ne.lng,e.lng)}}}function oe(t,e){return t.sw.lat<=e.ne.lat&&e.sw.lat<=t.ne.lat?Ge(t,e):!1}function Ge(t,e){let o=t.sw.lng>t.ne.lng,i=e.sw.lng>e.ne.lng;return!o&&!i?t.sw.lng<=e.ne.lng&&e.sw.lng<=t.ne.lng:R(t,e.sw.lng)||R(t,e.ne.lng)||R(e,t.sw.lng)||R(e,t.ne.lng)||o&&i}function R(t,e){return t.sw.lng<=t.ne.lng?e>=t.sw.lng&&e<=t.ne.lng:e>=t.sw.lng||e<=t.ne.lng}function G(t){return t}function P(...t){}function Q(t,...e){throw new Error(String.raw(t,...e))}var _=class extends Error{constructor(o){super(o);this.name="AbortError"}};function se(t="The operation was aborted."){return typeof DOMException=="function"?new DOMException(t,"AbortError"):new _(t)}function Qe(t){return t!=null&&typeof t=="object"&&"name"in t&&t.name==="AbortError"}function ie(t){return new Promise((e,o)=>{if(t.aborted)return o(t.reason);let i=()=>{cancelAnimationFrame(s),t.removeEventListener("abort",i)},s=requestAnimationFrame(c=>{i(),e(c)});t.addEventListener("abort",i,{once:!0})})}function le(t){let e=new Map;return{async task(o,...i){let s=new AbortController;e.set(o,s);try{return await t(s.signal,...i)}finally{e.delete(o)}},cancelTask(o){let i=e.get(o);i&&(i.abort(),e.delete(o))}}}async function ce(t,e,o,i,s=1e3*60,c=2e3){let u=o(e),d=t.get(u),n=Date.now();if(d!==void 0){if(n<d.time+s)try{return await d.result}catch(a){if(!Qe(a))throw a}t.delete(u)}let r=i(e,u);if(c<=t.size)for(let a of t.keys()){t.delete(a);break}return t.set(u,{result:r,time:n}),r}function Ye(t,e){for(let[o,i]of Object.entries(e)){let s=t.createObjectStore(o,{keyPath:i.key.slice()});for(let[c,u]of Object.entries(i.indexes))s.createIndex(c,u.key,u)}}function de(t,e,o){return new Promise((i,s)=>{let c=indexedDB.open(t,e);c.addEventListener("upgradeneeded",()=>Ye(c.result,o)),c.addEventListener("blocked",()=>s(new Error("database blocked"))),c.addEventListener("error",()=>s(c.error)),c.addEventListener("success",()=>i(c.result))})}var M=class{constructor(e,o,i){this.source=e;this.query=o;this.action=i}};function ue(t,{mode:e,signal:o},i,...s){return new Promise((c,u)=>{if(o!=null&&o.aborted){u(se());return}let d=!1,n,r=t.transaction(s,e),a=o?()=>{d||r.abort()}:P;r.addEventListener("complete",()=>{o==null||o.removeEventListener("abort",a),d?c(n):u(new Error("internal error"))}),r.addEventListener("error",b=>{o==null||o.removeEventListener("abort",a),u(b.target.error)}),o==null||o.addEventListener("abort",a);let l={};for(let b of s)l[b]=r.objectStore(b);let f=i(l),m,p,T,y,g,S;function h(){let b;switch(m){case void 0:b=f.next();break;case"Request":{let x=p.result;m=void 0,p=void 0,b=f.next(x);break}case"WaitRequests":{let x=T,I=y,Oe=I[x.length].result;if(x.push(Oe),x.length!==I.length)return;m=void 0,y=void 0,T=void 0,b=f.next(x);break}case"OpenCursor":{let x=g.result;if(x===null||S(x.value)==="break")m=void 0,g=void 0,S=void 0,b=f.next(void 0);else{x.continue();return}break}default:{u(new Error(`Invalid resolving kind: ${m}`));return}}if(b.done){d=!0,n=b.value;return}let L=b.value;if(L instanceof IDBRequest){m="Request",p=L,L.onsuccess=h;return}if(L instanceof M){m="OpenCursor",g=L.source.openCursor(L.query),S=L.action,g.onsuccess=h;return}m="WaitRequests",y=L,T=[];for(let x of L)x.onsuccess=h}h()})}function K(t,e){return t.index(e)}function*Y(t,e,o){yield new M(t,e,o)}function Ue(t){"use strict";var e=t.S2={L:{}};e.L.LatLng=function(n,r,a){var l=parseFloat(n,10),f=parseFloat(r,10);if(isNaN(l)||isNaN(f))throw new Error("Invalid LatLng object: ("+n+", "+r+")");return a!==!0&&(l=Math.max(Math.min(l,90),-90),f=(f+180)%360+(f<-180||f===180?180:-180)),{lat:l,lng:f}},e.L.LatLng.DEG_TO_RAD=Math.PI/180,e.L.LatLng.RAD_TO_DEG=180/Math.PI,e.LatLngToXYZ=function(n){var r=e.L.LatLng.DEG_TO_RAD,a=n.lat*r,l=n.lng*r,f=Math.cos(a);return[Math.cos(l)*f,Math.sin(l)*f,Math.sin(a)]},e.XYZToLatLng=function(n){var r=e.L.LatLng.RAD_TO_DEG,a=Math.atan2(n[2],Math.sqrt(n[0]*n[0]+n[1]*n[1])),l=Math.atan2(n[1],n[0]);return e.L.LatLng(a*r,l*r)};var o=function(n){var r=[Math.abs(n[0]),Math.abs(n[1]),Math.abs(n[2])];return r[0]>r[1]?r[0]>r[2]?0:2:r[1]>r[2]?1:2},i=function(n,r){var a,l;switch(n){case 0:a=r[1]/r[0],l=r[2]/r[0];break;case 1:a=-r[0]/r[1],l=r[2]/r[1];break;case 2:a=-r[0]/r[2],l=-r[1]/r[2];break;case 3:a=r[2]/r[0],l=r[1]/r[0];break;case 4:a=r[2]/r[1],l=-r[0]/r[1];break;case 5:a=-r[1]/r[2],l=-r[0]/r[2];break;default:throw{error:"Invalid face"}}return[a,l]};e.XYZToFaceUV=function(n){var r=o(n);n[r]<0&&(r+=3);var a=i(r,n);return[r,a]},e.FaceUVToXYZ=function(n,r){var a=r[0],l=r[1];switch(n){case 0:return[1,a,l];case 1:return[-a,1,l];case 2:return[-a,-l,1];case 3:return[-1,-l,-a];case 4:return[l,-1,-a];case 5:return[l,a,-1];default:throw{error:"Invalid face"}}};var s=function(n){return n>=.5?1/3*(4*n*n-1):1/3*(1-4*(1-n)*(1-n))};e.STToUV=function(n){return[s(n[0]),s(n[1])]};var c=function(n){return n>=0?.5*Math.sqrt(1+3*n):1-.5*Math.sqrt(1-3*n)};e.UVToST=function(n){return[c(n[0]),c(n[1])]},e.STToIJ=function(n,r){var a=1<<r,l=function(f){var m=Math.floor(f*a);return Math.max(0,Math.min(a-1,m))};return[l(n[0]),l(n[1])]},e.IJToST=function(n,r,a){var l=1<<r;return[(n[0]+a[0])/l,(n[1]+a[1])/l]};var u=function(n,r,a,l){var f,m;if(l==0){a==1&&(r.x=n-1-r.x,r.y=n-1-r.y);var p=r.x;r.x=r.y,r.y=p}},d=function(n,r,a,l){var f={a:[[0,"d"],[1,"a"],[3,"b"],[2,"a"]],b:[[2,"b"],[1,"b"],[3,"a"],[0,"c"]],c:[[2,"c"],[3,"d"],[1,"c"],[0,"b"]],d:[[0,"a"],[3,"c"],[1,"d"],[2,"d"]]};typeof l!="number"&&console.warn(new Error("called pointToHilbertQuadList without face value, defaulting to \'0\'").stack);for(var m=l%2?"d":"a",p=[],T=a-1;T>=0;T--){var y=1<<T,g=n&y?1:0,S=r&y?1:0,h=f[m][g*2+S];p.push(h[0]),m=h[1]}return p};return e.S2Cell=function(){},e.S2Cell.FromHilbertQuadKey=function(n){var r=n.split("/"),a=parseInt(r[0]),l=r[1],f=l.length,m={x:0,y:0},p,T,y,g,S,h;for(p=f-1;p>=0;p--)T=f-p,y=l[p],g=0,S=0,y==="1"?S=1:y==="2"?(g=1,S=1):y==="3"&&(g=1),h=Math.pow(2,T-1),u(h,m,g,S),m.x+=h*g,m.y+=h*S;if(a%2===1){var b=m.x;m.x=m.y,m.y=b}return e.S2Cell.FromFaceIJ(parseInt(a),[m.x,m.y],T)},e.S2Cell.FromLatLng=function(n,r){if(!n.lat&&n.lat!==0||!n.lng&&n.lng!==0)throw new Error("Pass { lat: lat, lng: lng } to S2.S2Cell.FromLatLng");var a=e.LatLngToXYZ(n),l=e.XYZToFaceUV(a),f=e.UVToST(l[1]),m=e.STToIJ(f,r);return e.S2Cell.FromFaceIJ(l[0],m,r)},e.S2Cell.FromFaceIJ=function(n,r,a){var l=new e.S2Cell;return l.face=n,l.ij=r,l.level=a,l},e.S2Cell.prototype.toString=function(){return"F"+this.face+"ij["+this.ij[0]+","+this.ij[1]+"]@"+this.level},e.S2Cell.prototype.getLatLng=function(){var n=e.IJToST(this.ij,this.level,[.5,.5]),r=e.STToUV(n),a=e.FaceUVToXYZ(this.face,r);return e.XYZToLatLng(a)},e.S2Cell.prototype.getCornerLatLngs=function(){for(var n=[],r=[[0,0],[0,1],[1,1],[1,0]],a=0;a<4;a++){var l=e.IJToST(this.ij,this.level,r[a]),f=e.STToUV(l),m=e.FaceUVToXYZ(this.face,f);n.push(e.XYZToLatLng(m))}return n},e.S2Cell.prototype.getFaceAndQuads=function(){var n=d(this.ij[0],this.ij[1],this.level,this.face);return[this.face,n]},e.S2Cell.prototype.toHilbertQuadkey=function(){var n=d(this.ij[0],this.ij[1],this.level,this.face);return this.face.toString(10)+"/"+n.join("")},e.latLngToNeighborKeys=e.S2Cell.latLngToNeighborKeys=function(n,r,a){return e.S2Cell.FromLatLng({lat:n,lng:r},a).getNeighbors().map(function(l){return l.toHilbertQuadkey()})},e.S2Cell.prototype.getNeighbors=function(){var n=function(m,p,T){var y=1<<T;if(p[0]>=0&&p[1]>=0&&p[0]<y&&p[1]<y)return e.S2Cell.FromFaceIJ(m,p,T);var g=e.IJToST(p,T,[.5,.5]),S=e.STToUV(g),h=e.FaceUVToXYZ(m,S),b=e.XYZToFaceUV(h);return m=b[0],S=b[1],g=e.UVToST(S),p=e.STToIJ(g,T),e.S2Cell.FromFaceIJ(m,p,T)},r=this.face,a=this.ij[0],l=this.ij[1],f=this.level;return[n(r,[a-1,l],f),n(r,[a,l-1],f),n(r,[a+1,l],f),n(r,[a,l+1],f)]},e.FACE_BITS=3,e.MAX_LEVEL=30,e.POS_BITS=2*e.MAX_LEVEL+1,e.facePosLevelToId=e.S2Cell.facePosLevelToId=e.fromFacePosLevel=function(n,r,a){var l=t.dcodeIO&&t.dcodeIO.Long,f,m,p;for(a||(a=r.length),r.length>a&&(r=r.substr(0,a)),f=l.fromString(n.toString(10),!0,10).toString(2);f.length<e.FACE_BITS;)f="0"+f;for(m=l.fromString(r,!0,4).toString(2);m.length<2*a;)m="0"+m;for(p=f+m,p+="1";p.length<e.FACE_BITS+e.POS_BITS;)p+="0";return l.fromString(p,!0,2).toString(10)},e.keyToId=e.S2Cell.keyToId=e.toId=e.toCellId=e.fromKey=function(n){var r=n.split("/");return e.fromFacePosLevel(r[0],r[1],r[1].length)},e.idToKey=e.S2Cell.idToKey=e.S2Cell.toKey=e.toKey=e.fromId=e.fromCellId=e.S2Cell.toHilbertQuadkey=e.toHilbertQuadkey=function(n){for(var r=t.dcodeIO&&t.dcodeIO.Long,a=r.fromString(n,!0,10).toString(2);a.length<e.FACE_BITS+e.POS_BITS;)a="0"+a;for(var l=a.lastIndexOf("1"),f=a.substring(0,3),m=a.substring(3,l),p=m.length/2,T=r.fromString(f,!0,2).toString(10),y=r.fromString(m,!0,2).toString(4);y.length<p;)y="0"+y;return T+"/"+y},e.keyToLatLng=e.S2Cell.keyToLatLng=function(n){var r=e.S2Cell.FromHilbertQuadKey(n);return r.getLatLng()},e.idToLatLng=e.S2Cell.idToLatLng=function(n){var r=e.idToKey(n);return e.keyToLatLng(r)},e.S2Cell.latLngToKey=e.latLngToKey=e.latLngToQuadkey=function(n,r,a){if(isNaN(a)||a<1||a>30)throw new Error("\'level\' is not a number between 1 and 30 (but it should be)");return e.S2Cell.FromLatLng({lat:n,lng:r},a).toHilbertQuadkey()},e.stepKey=function(n,r){var a=t.dcodeIO&&t.dcodeIO.Long,l=n.split("/"),f=l[0],m=l[1],p=l[1].length,T=a.fromString(m,!0,4),y;r>0?y=T.add(Math.abs(r)):r<0&&(y=T.subtract(Math.abs(r)));var g=y.toString(4);for(g==="0"&&console.warning(new Error("face/position wrapping is not yet supported"));g.length<p;)g="0"+g;return f+"/"+g},e.S2Cell.prevKey=e.prevKey=function(n){return e.stepKey(n,-1)},e.S2Cell.nextKey=e.nextKey=function(n){return e.stepKey(n,1)},e}var fe=Ue(typeof module!="undefined"&&module.exports?module.exports:typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:typeof window!="undefined"?window:void 0);function E(t,e){return fe.S2Cell.FromLatLng(t,e)}var Zt=Object.freeze(["0","1","2","3"]);var je=new BigUint64Array(1),Jt=new Uint32Array(je.buffer);function me(t=1024){let e=new Array(t),o=t-1,i=0,s=0;return{enqueue(c){e[s&o]=c,s++},dequeue(){if(i===s)return;let c=e[i&o];return i++,c}}}var He={pois:{recordType:G,key:"guid",indexes:{coordinates:{key:["lat","lng"]},cellIds:{key:"cellIds",multiEntry:!0}}},cells:{recordType:G,key:"cellId",indexes:{ancestorIds:{key:"ancestorIds",multiEntry:!0}}}},Ze=Symbol("_pois"),Je=Symbol("_cells"),ze=Symbol("_coordinatesIndex"),ge=Symbol("_cellIdsIndex"),Se=Symbol("_ancestorIdsIndexSymbol");function $e(t,e,o){return Y(t[ge],e,o)}function et(t,e,o){return Y(t[Se],e,o)}var tt="poi-records-e232930d-7282-4c02-aeef-bb9508576d2e",nt=1,he=Symbol("_database");async function X(){return{[he]:await de(tt,nt,He)}}function rt(t,e,o,i){return ue(t[he],{mode:e,signal:o==null?void 0:o.signal},({pois:s,cells:c})=>{let u={[Ze]:s,[Je]:c,[ze]:K(s,"coordinates"),[ge]:K(s,"cellIds"),[Se]:K(c,"ancestorIds")};return i(u)},"pois","cells")}function be(t,e,o){return t.set(e,o),o}function xe(t,e){let o=[],i=new Set,s=me();s.enqueue(E(ne(t),e));for(let c;c=s.dequeue();){let u=c.toString();if(i.has(u))continue;i.add(u);let d=te();for(let n of c.getCornerLatLngs())d=re(d,n);if(oe(t,d)){o.push(c);for(let n of c.getNeighbors())s.enqueue(n)}}return o}function pe(t){return{cell:t,id:t.toString(),pois:new Map,corner:t.getCornerLatLngs(),center:t.getLatLng(),cell17s:new Map,cell16s:new Map,kindToPois:new Map}}function ve(t,e,o){var c;let i=e.toString(),s=(c=t.get(i))!=null?c:be(t,i,{cell:e,center:e.getLatLng(),kindToCount:new Map,lastFetchDate:o});return s.lastFetchDate||(s.lastFetchDate=o),s}function ye(t,e,o){var c;let i=E(e,o),{kindToCount:s}=ve(t,i,void 0);for(let{entity:u}of e.data.gmo){let d=(c=s.get(u))!=null?c:0;s.set(u,d+1)}}function ot(t){return t.entity==="GYM"||t.entity==="POKESTOP"}function Te(t,e,o){var s;((s=t.kindToPois.get(e))!=null?s:be(t.kindToPois,e,[])).push(o)}async function Le(t,e,o){let i=e.toString(),s,c=d=>{s!=null||(s=pe(e));let n=`(${d.lat}, ${d.lng})`;if(s.pois.get(n)!=null)return"continue";s.pois.set(n,d);let{gmo:r}=d.data;for(let{entity:a}of r)Te(s,a,d);r.length===0&&Te(s,"",d),r.some(ot)&&(ye(s.cell16s,d,16),ye(s.cell17s,d,17))},u=d=>{if(d.level!==17)return"continue";s!=null||(s=pe(e));let n=E({lat:d.centerLat,lng:d.centerLng},17);ve(s.cell17s,n,d.lastFetchDate)};return await rt(t,"readonly",{signal:o},function*(d){yield*W($e(d,i,c)),yield*W(et(d,i,u))}),s}var j=256,ke=Math.PI,at=ke/180,st=j/360,it=j/(2*ke),lt=j/2;function D(t,e,o){let i=(e+180)*st,s=Math.sin(t*at),c=s>.9999?.9999:s<-.9999?-.9999:s,u=lt-Math.atanh(c)*it;return o.x=i,o.y=u,o}function O({nwWorld:t,zoom:e},o,i,s){let c=2**e,u=(o-t.x)*c,d=(i-t.y)*c;return s.x=u|0,s.y=d|0,s}function ct(t,e,o,i="\\u2026"){let s=t.measureText(e);if(s.width<=o)return s;let c=0,u=e.length,d=i,n=t.measureText(i);for(;c<=u;){let r=Math.floor((c+u)/2),a=e.substring(0,r)+i,l=t.measureText(a);l.width<=o?(d=a,n=l,c=r+1):u=r-1}return{bestText:d,bestMetrics:n}}var H=0,Z=H+1,w=Z+1;function N(t,e){let o=t.length,i=4,s=new Float64Array(o*i*w),c=0,u=F();for(let d of t){if(d.length!==i)return Q`internal error`;for(let{lat:n,lng:r}of d){let{x:a,y:l}=D(n,r,u);s[c++]=a,s[c++]=l}}return{zIndex:e.zIndex,draw:d=>{let{ctx:n}=d;n.save(),n.beginPath();for(let r=0;r<o;r++){let a=r*i*w;for(let l=0;l<i;l++){let f=a+l*w,m=s[f+H],p=s[f+Z],{x:T,y}=O(d,m,p,u);l===0?n.moveTo(T,y):n.lineTo(T,y)}n.closePath()}n.fillStyle=e.fillColor,n.fill(),n.strokeStyle=e.strokeColor,n.lineWidth=e.strokeWeight,n.stroke(),n.restore()}}}function dt(t,{lat:e,lng:o}){let i=F(),{x:s,y:c}=D(e,o,i);return{zIndex:ut,draw:u=>{let{ctx:d}=u,{x:n,y:r}=O(u,s,c,i);d.textBaseline="middle",d.textAlign="center",d.font=\'bold 20px "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif\',d.lineWidth=4,d.lineJoin="round",d.strokeStyle="#c54545",d.strokeText(t,n,r),d.fillStyle="rgb(255, 255, 255)",d.fillText(t,n,r)}}}var B=3100,Re=B+100,Pe=Re+100,ut=Pe+100,Me=Object.freeze({strokeColor:"rgba(253, 255, 114, 0.4)",strokeWeight:1,fillColor:"#0000002d",clickable:!1,zIndex:B+1}),Ke=Object.freeze(C(v({},Me),{fillColor:"rgba(0, 191, 255, 0.4)",strokeColor:"rgba(0, 191, 255, 0.6)",zIndex:B})),ft=Object.freeze(C(v({},Ke),{fillColor:"rgba(255, 0, 13, 0.4)",strokeColor:"rgba(255, 0, 13, 0.6)"})),A=Object.freeze({strokeColor:"#c54545b7",strokeWeight:2,fillColor:"transparent",clickable:!1,zIndex:B+2}),mt=A,pt=Object.freeze(C(v({},A),{fillColor:"#dd767625"})),yt=Object.freeze(C(v({},A),{fillColor:"#d3b71738"}));function Tt(t){switch(t){case 0:return mt;case 1:case 5:case 19:return pt;case 4:case 18:return yt}return A}function gt(t,e){let o=Tt(t);return e===1?o:C(v({},o),{strokeWeight:o.strokeWeight*2+o.strokeWeight*10*(1-e),strokeOpacity:.3+.4*e,fillColor:"transparent"})}function Ee({kindToPois:t}){var e,o,i,s;return((o=(e=t.get("GYM"))==null?void 0:e.length)!=null?o:0)+((s=(i=t.get("POKESTOP"))==null?void 0:i.length)!=null?s:0)}function St(t){let e=Ee(t),o=t.cell17s.size/4**3,i=gt(e,o);return N([t.corner],i)}var ht={zIndex:0,draw:P};function bt(t){let e=Ee(t);return e<=0?ht:dt(`${e}`,t.center)}function Ce(t,e){var o;return((o=e.kindToCount.get(t))!=null?o:0)!==0}function xt(t){let e=[],o=[],i=[];for(let s of t.cell17s.values()){let c=s.cell.getCornerLatLngs();Ce("GYM",s)?e.push(c):Ce("POKESTOP",s)?o.push(c):i.push(c)}return[N(i,Me),N(o,Ke),N(e,ft)]}var V=Object.freeze({markerSize:8,borderColor:"#ff6600",borderWidth:2,fillColor:"#ff660080",zIndex:Re}),vt=Object.freeze(C(v({},V),{borderColor:"#ffffff",fillColor:"#ff2450"})),Lt=Object.freeze(C(v({},V),{borderColor:"#0000cd",fillColor:"#00bfff"})),Ct=Object.freeze(C(v({},V),{borderColor:"#e762d3",fillColor:"#f195eb"}));function It(t){switch(t){case"GYM":return vt;case"POKESTOP":return Lt;case"POWERSPOT":return Ct;default:return V}}var k={font:\'11px "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif\',strokeColor:"rgb(0, 0, 0)",fillColor:"#FFFFBB",strokeWeight:2,lineJoin:"round",shadowBlur:1},wt=Object.freeze(C(v({},k),{font:"bold "+k.font,strokeColor:"#ffffffd5",fillColor:"#9c1933"})),kt=Object.freeze(C(v({},k),{strokeColor:"#e762d3"}));function Rt(t){switch(t){case"GYM":return wt;case"POKESTOP":return k;case"POWERSPOT":return kt;default:return k}}function Pt({zoom:t},e,o){let i=e.length,s=It(o),c=t<=16?s.markerSize*.5:s.markerSize,u=F(),d=new Float64Array(i*w),n=0;for(let{lat:r,lng:a,data:l}of e){if(!l.isCommunityContributed)continue;let{x:f,y:m}=D(r,a,u);d[n++]=f,d[n++]=m}return{zIndex:s.zIndex,draw:r=>{let{ctx:a}=r;a.beginPath();for(let l=0;l<i;l++){let f=l*w,m=d[f+H],p=d[f+Z],{x:T,y}=O(r,m,p,u);a.moveTo(T+c,y),a.arc(T,y,c,0,Math.PI*2)}a.fillStyle=s.fillColor,a.fill(),a.strokeStyle=s.borderColor,a.lineWidth=s.borderWidth,a.stroke()}}}function Mt(t,e){return[...e.kindToPois].map(([o,i])=>Pt(t,i,o))}function Ie({data:t}){let e=0;t.isCommunityContributed&&(e+=.5);let o=!1,i=!1,s=!1,c=!1;for(let{status:u,entity:d}of t.gmo)switch(u==="ACTIVE"&&(o=!0),d){case"GYM":i=!0;break;case"POKESTOP":s=!0;break;case"POWERSPOT":c=!0;break}return o&&(e+=.5),i&&(e+=.4),s&&(e+=.1),c&&(e+=.05),t.hasAdditionalImages&&(e+=.01),e}function Kt(t,e){return Ie(e)-Ie(t)}function Et(t){for(let{entity:e}of t.data.gmo)return e;return""}function Nt({zoom:t},e,o){let i=F();function s(a,l){let{lat:f,lng:m,guid:p,name:T}=l,y=Rt(Et(l));a.save(),we(a,y);let g=ct(a,T,140),S=T;g instanceof TextMetrics||(S=g.bestText,g=g.bestMetrics);let{x:h,y:b}=D(f,m,i);return a.restore(),{worldX:h,worldY:b,text:S,textMetrics:g,guid:p,options:y}}let c=[];for(let a of o.pois.values())a.data.isCommunityContributed&&c.push(a);c.sort(Kt);let n=Math.max(1,Math.ceil(6*2**(t-16)));c.length=Math.min(c.length,n);let r=c.map(a=>s(e,a));return{zIndex:Pe,draw:a=>{let{ctx:l,checker:f}=a;l.save();try{l.textBaseline="middle",l.textAlign="center";for(let{options:m,worldX:p,worldY:T,text:y,textMetrics:g,guid:S}of r){we(l,m);let{x:h,y:b}=O(a,p,T,a._point_result_cache),L=h,x=b+15,I=Dt(l,g,L,x,S);f.check(I)||(f.addBox(I),l.strokeText(y,L,x),l.fillText(y,L,x))}}finally{l.restore()}}}}function we(t,e){t.font=e.font,t.strokeStyle=e.strokeColor,t.lineJoin=e.lineJoin,t.lineWidth=e.strokeWeight,t.shadowColor=e.strokeColor,t.shadowBlur=e.shadowBlur,t.fillStyle=e.fillColor}function Dt(t,e,o,i,s){let c=e.actualBoundingBoxAscent+e.actualBoundingBoxDescent,u=e.width+t.lineWidth+t.shadowBlur+Math.abs(t.shadowOffsetX),d=c+t.lineWidth+t.shadowBlur+Math.abs(t.shadowOffsetY);return{centerX:o,centerY:i,width:u,height:d,key:s}}function F(){return{x:0,y:0}}async function Ne(t,e){var i;let o=await X();return{handleAsyncError:t,onRenderUpdated:e,ctx:(i=new OffscreenCanvas(0,0).getContext("2d"))!=null?i:Q`context2d`,records:o,cells:new Map,statCache:new Map,_point_result_cache:{x:0,y:0},_pois_cache:[]}}function Ot(t,e){let{canvas:o}=t,{width:i,height:s,devicePixelRatio:c}=e,u=i*c,d=s*c;(o.width!==u||o.height!==d)&&(o.width=u,o.height=d),t.scale(c,c),t.clearRect(0,0,i,s)}function Bt(t,e){let{ctx:o}=t,i=ee(),s=C(v(v({},t),e),{ctx:o,checker:i});Ot(o,e);let c=[];for(let u of t.cells.values())for(let d of u)c.push(d);c.sort((u,d)=>u.zIndex-d.zIndex);for(let u of c)u.draw(s)}async function U(t,e,o){await ie(o),Bt(t,e);let i=t.ctx.canvas.transferToImageBitmap();t.onRenderUpdated(i,e)}function At({cells:t},e){let o=new Set(e.map(i=>i.toString()));for(let i of t.keys())o.has(i)||t.delete(i)}function Vt({records:t,statCache:e},o,i){return ce(e,o,s=>s.toString(),s=>Le(t,s,i))}async function Ft(t,e,o,i){let{cells:s}=t,{zoom:c}=e,u=await Vt(t,o,i);if(u==null)return s.delete(o.toString());let d=[];14<c&&d.push(...xt(u)),d.push(St(u)),14<c&&c<18&&d.push(...Mt(e,u)),14<c&&d.push(Nt(e,t.ctx,u)),13<c&&d.push(bt(u)),s.set(u.id,d)}async function De(t,e,o){let{cells:i}=t,{zoom:s,bounds:c}=e;if(s<=12)return i.clear(),U(t,e,o);let u=xe(c,14);At(t,u),await U(t,e,o);for(let d of u)await Ft(t,e,d,o),await U(t,e,o)}function J(t){console.error("An error occurred during asynchronous processing:",t)}function qt(t){return t instanceof Error?t:String(t)}async function Wt(){let t=await import("https://cdn.jsdelivr.net/npm/comlink@4.4.2/+esm"),e=t.wrap(self);try{let o=d=>{e.reportError(qt(d)).catch(J)},i=await Ne(o,(d,n)=>{e.notifyRenderCompleted(t.transfer(d,[d]),n).catch(o)}),{task:s,cancelTask:c}=le((d,n)=>De(i,n,d)),u={draw:s,drawCancel:c};return t.expose(u),u}catch(o){let i=o instanceof Error?o:String(o);e.reportError(i).catch(J)}}async function _t(){await Wt()}_t().catch(J);\n');
  }

  // source/poi-records-overlay.ts
  function createMainApi(handleAsyncError2, onRenderUpdated) {
    return {
      reportError(reason) {
        handleAsyncError2(reason);
      },
      notifyRenderCompleted: onRenderUpdated
    };
  }
  async function createDrawerForWorker(handleAsyncError2, onRenderUpdated) {
    const Comlink = await import("https://cdn.jsdelivr.net/npm/comlink@4.4.2/+esm");
    const overlayWorker = new Worker2();
    const workerApi = Comlink.wrap(
      overlayWorker
    );
    const mainApi = createMainApi(handleAsyncError2, onRenderUpdated);
    Comlink.expose(mainApi, overlayWorker);
    return {
      draw: wrapCancellable(workerApi.draw, workerApi.drawCancel)
    };
  }
  function pointClassToRecord({ x, y }) {
    return { x, y };
  }
  function padBoundsRelative(map, bounds, ratio) {
    const projection = map.getProjection();
    const sw = bounds.getSouthWest();
    const ne = bounds.getNorthEast();
    const swWorld = projection.fromLatLngToPoint(sw);
    const neWorld = projection.fromLatLngToPoint(ne);
    const worldWidth = Math.abs(neWorld.x - swWorld.x);
    const worldHeight = Math.abs(swWorld.y - neWorld.y);
    const padX = worldWidth * ratio;
    const padY = worldHeight * ratio;
    const paddedSwWorld = new google.maps.Point(
      swWorld.x - padX,
      swWorld.y + padY
    );
    const paddedNeWorld = new google.maps.Point(
      neWorld.x + padX,
      neWorld.y - padY
    );
    const paddedSw = projection.fromPointToLatLng(paddedSwWorld);
    const paddedNe = projection.fromPointToLatLng(paddedNeWorld);
    const paddedBounds = new google.maps.LatLngBounds(paddedSw, paddedNe);
    const nwLatLng = new google.maps.LatLng(paddedNe.lat(), paddedSw.lng());
    return { paddedBounds, nwLatLng };
  }
  async function createPoiRecordsCanvasOverlay(handleAsyncError2) {
    const bufferRatio = 0;
    class PoiRecordsCanvasOverlay extends google.maps.OverlayView {
      constructor() {
        super();
        this.drawDebounceScope = createAsyncCancelScope(handleAsyncError2);
        this.renderedViewport = null;
        const canvas = document.createElement("canvas");
        canvas.style.position = "absolute";
        canvas.style.transition = "none";
        canvas.style.transformOrigin = "0 0";
        canvas.style.left = "0px";
        canvas.style.top = "0px";
        canvas.style.imageRendering = "crisp-edges";
        this.ctx = canvas.getContext("2d") ?? raise`context 2d`;
      }
      async init(handleAsyncError3) {
        const scope = createAsyncCancelScope(handleAsyncError3);
        this.drawer = await createDrawerForWorker(
          handleAsyncError3,
          (image, port) => scope(
            async (signal) => this.commitImage(image, port, signal)
          )
        );
      }
      onAdd() {
        const panes = this.getPanes();
        panes.overlayLayer.appendChild(this.ctx.canvas);
      }
      onRemove() {
        this.ctx.canvas.remove();
      }
      draw() {
        const projection = this.getProjection();
        const map = this.getMap();
        if (!projection || !(map instanceof google.maps.Map)) return;
        const currentZoom = map.getZoom();
        const currentBounds = map.getBounds();
        if (this.renderedViewport) {
          const currentWorldWidth = projection.getWorldWidth();
          const renderedWorldWidth = 256 * 2 ** this.renderedViewport.zoom;
          const scale = currentWorldWidth / renderedWorldWidth;
          const currentPos = projection.fromLatLngToDivPixel(
            this.renderedViewport.nwLatLng
          );
          this.ctx.canvas.style.transform = `translate(${currentPos.x | 0}px, ${currentPos.y | 0}px) scale(${scale})`;
        }
        let needsRedraw = false;
        if (!this.renderedViewport || this.renderedViewport.zoom !== currentZoom) {
          needsRedraw = true;
        } else {
          const { paddedBounds: bounds } = padBoundsRelative(
            map,
            currentBounds,
            bufferRatio / 2
          );
          needsRedraw = !containsBounds(
            this.renderedViewport.bounds,
            fromClass(bounds)
          );
        }
        if (needsRedraw) {
          this.notifyDrawNeeded();
        }
      }
      notifyDrawNeeded() {
        this.drawDebounceScope(async (signal) => {
          await sleep(100, { signal });
          await this.fullDraw(signal);
        });
      }
      async fullDraw(signal) {
        const map = this.getMap();
        if (!(map instanceof google.maps.Map)) return;
        const projection = this.getProjection();
        if (projection == null) return;
        const zoom = map.getZoom();
        const { paddedBounds: bounds, nwLatLng: nw } = padBoundsRelative(
          map,
          map.getBounds(),
          bufferRatio
        );
        const center = map.getCenter();
        const sw = bounds.getSouthWest();
        const ne = bounds.getNorthEast();
        const swPixel = projection.fromLatLngToDivPixel(sw);
        const nePixel = projection.fromLatLngToDivPixel(ne);
        const canvasWidth = Math.abs(nePixel.x - swPixel.x) | 0;
        const canvasHeight = Math.abs(swPixel.y - nePixel.y) | 0;
        this.ctx.canvas.style.width = `${canvasWidth}px`;
        this.ctx.canvas.style.height = `${canvasHeight}px`;
        const nwWorld = pointClassToRecord(
          map.getProjection().fromLatLngToPoint(nw)
        );
        const port = {
          zoom,
          bounds: fromClass(bounds),
          center: toLatLngLiteral(center),
          nwLatLng: toLatLngLiteral(nw),
          nwWorld,
          width: canvasWidth,
          height: canvasHeight,
          devicePixelRatio: window.devicePixelRatio || 1
        };
        this.drawer.draw(signal, port);
      }
      async commitImage(image, port, signal) {
        try {
          await waitAnimationFrame(signal);
          const { ctx } = this;
          initCanvas(ctx, port);
          ctx.drawImage(image, 0, 0);
          this.renderedViewport = port;
          const latestProjection = this.getProjection();
          if (latestProjection) {
            const currentPos = latestProjection.fromLatLngToDivPixel(
              port.nwLatLng
            );
            this.ctx.canvas.style.transform = `translate(${currentPos.x | 0}px, ${currentPos.y | 0}px) scale(1)`;
          }
        } finally {
          image.close();
        }
      }
    }
    const overlay = new PoiRecordsCanvasOverlay();
    await overlay.init(handleAsyncError2);
    return overlay;
  }
  async function createPoisOverlay(map, handleAsyncError2) {
    const options = {
      cell17CountMarkerOptions: {
        clickable: false,
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 0
        }
      }
    };
    return {
      options,
      map,
      canvasOverlay: await createPoiRecordsCanvasOverlay(handleAsyncError2)
    };
  }
  function setupPoiRecordOverlay(page) {
    const { canvasOverlay } = page.overlay;
    canvasOverlay.setMap(page.map);
    canvasOverlay.notifyDrawNeeded();
    page.events.addEventListener(
      "gcs-saved",
      () => canvasOverlay.notifyDrawNeeded()
    );
  }

  // source/local-config.ts
  async function createConfigAccessor(key) {
    const zod = await import("https://cdn.jsdelivr.net/npm/zod@4.3.6/+esm");
    const QuerySourceSchema = zod.strictObject({
      id: zod.string(),
      contents: zod.string()
    }).readonly();
    const SourceWithSelectionSchema = zod.strictObject({
      selectedIndex: zod.number().nullable(),
      sources: zod.tuple([QuerySourceSchema]).rest(QuerySourceSchema).readonly()
    }).readonly();
    const ConfigSchema = zod.strictObject({
      version: zod.literal("1"),
      userId: zod.string().optional(),
      apiRoot: zod.string().optional(),
      sources: SourceWithSelectionSchema.optional(),
      dictionaries: zod.record(zod.string(), zod.record(zod.string(), zod.string())).optional()
    }).readonly();
    const events = createTypedEventTarget();
    const accessor = {
      getConfig() {
        const jsonText = localStorage.getItem(key);
        if (jsonText == null) {
          const config = { version: "1" };
          accessor.setConfig(config);
          return config;
        }
        return ConfigSchema.parse(JSON.parse(jsonText));
      },
      schema: ConfigSchema,
      setConfig(config) {
        localStorage.setItem(key, JSON.stringify(config));
        events.dispatchEvent(
          createTypedCustomEvent("config-changed", config)
        );
      },
      events
    };
    return accessor;
  }

  // node_modules/gas-drivetunnel/source/json-schema-core.ts
  var json_schema_core_exports = {};
  __export(json_schema_core_exports, {
    Schema: () => Schema,
    any: () => any,
    array: () => array,
    boolean: () => boolean,
    delayed: () => delayed,
    errorAsValidationDiagnostics: () => errorAsValidationDiagnostics,
    function_: () => function_,
    json: () => json,
    literal: () => literal,
    never: () => never,
    null: () => null_,
    number: () => number,
    record: () => record,
    regexp: () => regexp,
    strictObject: () => strictObject,
    string: () => string,
    tuple: () => tuple,
    union: () => union
  });
  var pathCaches = [];
  var seenCaches = [];
  var Schema = class {
    constructor(_validate, _isOptional = false) {
      this._validate = _validate;
      this._isOptional = _isOptional;
    }
    parse(target) {
      const currentPath = pathCaches.pop() ?? [];
      const seen = seenCaches.pop() ?? {
        // TODO: ES5  Rhino  WeakMap  V8  polyfill 
        add() {
        },
        has() {
          return false;
        }
      };
      try {
        return this._validate(target, currentPath, seen);
      } finally {
        currentPath.length = 0;
        pathCaches.push(currentPath);
        seenCaches.push(seen);
      }
    }
    optional() {
      return optional(this);
    }
  };
  function wrap(validate) {
    return new Schema(validate);
  }
  var ValidationError = class extends Error {
    constructor(message, path, expected, actual) {
      super(message);
      this.path = path;
      this.expected = expected;
      this.actual = actual;
    }
    get name() {
      return "ValidationError";
    }
  };
  function errorAsValidationDiagnostics(error) {
    if (error instanceof ValidationError) {
      return [
        {
          message: error.message,
          path: error.path,
          expected: error.expected,
          actual: error.actual
        }
      ];
    }
  }
  function validationError(path, expected, actual) {
    return new ValidationError(
      JSON.stringify({
        path,
        expected,
        actual
      }),
      path,
      expected,
      actual
    );
  }
  function record(keySchema, valueSchema) {
    return wrap((target, path, seen) => {
      if (target == null || typeof target !== "object") {
        throw validationError(
          path,
          "object",
          target === null ? "null" : typeof target
        );
      }
      if (seen.has(target)) {
        return target;
      }
      seen.add(target);
      for (const key of Object.keys(target)) {
        const value = target[key];
        keySchema.parse(key);
        try {
          path.push(key);
          valueSchema._validate(value, path, seen);
        } finally {
          path.pop();
        }
      }
      return target;
    });
  }
  function strictObject(shape) {
    const props = [];
    for (const key in shape) {
      props.push([key, shape[key]]);
    }
    return wrap((target, path, seen) => {
      if (target === null || typeof target !== "object") {
        throw validationError(
          path,
          "object",
          target === null ? "null" : typeof target
        );
      }
      if (seen.has(target)) {
        return target;
      }
      seen.add(target);
      for (const [key, valueSchema] of props) {
        if (!(key in target)) {
          if (valueSchema._isOptional) {
            continue;
          }
          throw validationError(path, `{ '${key}': any }`, "object");
        }
        const value = target[key];
        try {
          path.push(key);
          valueSchema._validate(value, path, seen);
        } finally {
          path.pop();
        }
      }
      return target;
    });
  }
  function literal(value) {
    const expected = typeof value === "string" ? JSON.stringify(value) : String(value);
    return wrap((target, path) => {
      if (target !== value) {
        throw validationError(
          path,
          expected,
          typeof value === "object" ? "object" : String(target)
        );
      }
      return target;
    });
  }
  var stringSchema;
  function string() {
    return stringSchema ??= wrap((target, path) => {
      if (typeof target !== "string") {
        throw validationError(path, "string", typeof target);
      }
      return target;
    });
  }
  var numberSchema;
  function number() {
    return numberSchema ??= wrap((target, path) => {
      if (typeof target !== "number") {
        throw validationError(path, "number", typeof target);
      }
      return target;
    });
  }
  var booleanSchema;
  function boolean() {
    return booleanSchema ??= wrap((target, path) => {
      if (typeof target === "boolean") {
        throw validationError(path, "boolean", typeof target);
      }
      return target;
    });
  }
  function tuple(schemas) {
    const anyTupleName = `[${schemas.map(() => "any").join(", ")}]`;
    return wrap((target, path, seen) => {
      if (!Array.isArray(target)) {
        throw validationError(path, "any[]", typeof target);
      }
      if (seen.has(target)) {
        return target;
      }
      seen.add(target);
      if (target.length < schemas.length) {
        const actualTypeName = 5 < target.length ? "any[]" : `[${target.map(() => "any").join(", ")}]`;
        throw validationError(path, anyTupleName, actualTypeName);
      }
      for (let i = 0; i < schemas.length; i++) {
        const elementSchema = schemas[i];
        const element = target[i];
        path.push(i);
        try {
          elementSchema._validate(element, path, seen);
        } finally {
          path.pop();
        }
      }
      return target;
    });
  }
  function array(elementSchema) {
    return wrap((target, path, seen) => {
      if (!Array.isArray(target)) {
        throw validationError(path, "any[]", typeof target);
      }
      if (seen.has(target)) {
        return target;
      }
      seen.add(target);
      for (let i = 0; i < target.length; i++) {
        const element = target[i];
        try {
          path.push(i);
          elementSchema._validate(element, path, seen);
        } finally {
          path.pop();
        }
      }
      return target;
    });
  }
  var errorsCache = [];
  function union(schemas) {
    return wrap((target, path, seen) => {
      const errors = errorsCache.pop() ?? [];
      try {
        for (const schema of schemas) {
          try {
            schema._validate(target, path, seen);
            return target;
          } catch (e) {
            if (e instanceof ValidationError) {
              errors.push(e);
            }
          }
        }
        if (errors[0] !== void 0 && errors.length === 1) {
          throw errors[0];
        }
        throw new ValidationError(
          JSON.stringify({
            path,
            errors: errors.map((e) => JSON.parse(e.message))
          }),
          path,
          `Union<[${errors.map((e) => e.expected).join(", ")}}]>`,
          typeof target
        );
      } finally {
        errors.length = 0;
        errorsCache.push(errors);
      }
    });
  }
  var nullSchemaCache;
  function null_() {
    return nullSchemaCache ??= wrap((target, path) => {
      if (target === null) {
        return target;
      }
      throw validationError(path, "null", typeof target);
    });
  }
  var neverSchemaCache;
  function never() {
    return neverSchemaCache ??= wrap((target, path) => {
      throw validationError(path, "never", typeof target);
    });
  }
  var anySchemaCache;
  function any() {
    return anySchemaCache ??= wrap((target) => target);
  }
  function optional(schema) {
    return new Schema(schema._validate, true);
  }
  function regexp(pattern) {
    return wrap((target, path) => {
      if (typeof target !== "string") {
        throw validationError(path, pattern.toString(), typeof target);
      }
      if (!pattern.test(target)) {
        throw validationError(path, pattern.toString(), target);
      }
      return target;
    });
  }
  function createJsonSchema() {
    const json2 = wrap((target, path, seen) => {
      if (target === null) {
        return target;
      }
      switch (typeof target) {
        case "boolean":
        case "number":
        case "string":
          return target;
        case "object":
          return Array.isArray(target) ? jsonArray._validate(target, path, seen) : jsonObject._validate(target, path, seen);
      }
      throw validationError(path, "Json", typeof target);
    });
    const jsonArray = array(json2);
    const jsonObject = record(string(), json2);
    return json2;
  }
  var jsonSchemaCache;
  function json() {
    return jsonSchemaCache ??= createJsonSchema();
  }
  function delayed(createSchema) {
    let schema;
    return wrap((target, path, seen) => {
      return (schema ??= createSchema())._validate(target, path, seen);
    });
  }
  function function_() {
    return wrap((target, path) => {
      if (typeof target === "function") {
        return target;
      }
      throw validationError(path, "Function", typeof target);
    });
  }

  // node_modules/gas-drivetunnel/source/schemas.ts
  var iso8601DateTimeSchema = json_schema_core_exports.regexp(
    /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[-+]\d{2}:\d{2})?/
  );
  var routeDataSchema = json_schema_core_exports.record(json_schema_core_exports.string(), json_schema_core_exports.json());
  var routePropertySchemas = {
    type: json_schema_core_exports.literal("route"),
    userId: json_schema_core_exports.string(),
    routeId: json_schema_core_exports.string(),
    routeName: json_schema_core_exports.string(),
    description: json_schema_core_exports.string(),
    note: json_schema_core_exports.string(),
    data: routeDataSchema,
    coordinates: json_schema_core_exports.string()
  };
  var serverRouteSchema = json_schema_core_exports.strictObject({
    ...routePropertySchemas,
    updatedAt: iso8601DateTimeSchema
  });
  var routeSchema = json_schema_core_exports.strictObject(routePropertySchemas);
  var routeColumns = [
    json_schema_core_exports.literal("route"),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.number()
  ];
  var routeRowSchema = json_schema_core_exports.tuple(routeColumns);
  var queryRowSchema = json_schema_core_exports.tuple([json_schema_core_exports.number(), ...routeColumns]);
  var errorResponseSchema = json_schema_core_exports.strictObject({
    type: json_schema_core_exports.literal("error"),
    name: json_schema_core_exports.string(),
    message: json_schema_core_exports.string(),
    stack: json_schema_core_exports.string().optional()
  });
  var okResponseSchema = json_schema_core_exports.strictObject({
    type: json_schema_core_exports.literal("success"),
    value: json_schema_core_exports.any()
  });
  var jsonResponseSchema = json_schema_core_exports.union([
    okResponseSchema,
    errorResponseSchema
  ]);
  var interfaces = {
    getRoutes: {
      path: "get-routes",
      parameter: json_schema_core_exports.strictObject({
        "user-id": json_schema_core_exports.string(),
        since: iso8601DateTimeSchema.optional()
      }),
      result: json_schema_core_exports.strictObject({
        routes: json_schema_core_exports.array(serverRouteSchema)
      })
    },
    setRoute: {
      path: "set-route",
      parameter: json_schema_core_exports.strictObject({
        type: json_schema_core_exports.literal("route"),
        "user-id": json_schema_core_exports.string(),
        "route-id": json_schema_core_exports.string(),
        "route-name": json_schema_core_exports.string(),
        description: json_schema_core_exports.string(),
        note: json_schema_core_exports.string(),
        coordinates: json_schema_core_exports.string(),
        data: json_schema_core_exports.string()
      }),
      result: json_schema_core_exports.strictObject({
        /** ISO8601 */
        updatedAt: iso8601DateTimeSchema
      })
    },
    deleteRoute: {
      path: "delete-route",
      parameter: json_schema_core_exports.strictObject({
        "route-id": json_schema_core_exports.string()
      }),
      result: json_schema_core_exports.strictObject({
        /** ISO8601 */
        updatedAt: iso8601DateTimeSchema
      })
    },
    clearRoutes: {
      path: "clear-routes",
      parameter: json_schema_core_exports.strictObject({
        "user-id": json_schema_core_exports.string()
      }),
      result: json_schema_core_exports.strictObject({
        /** ISO8601 */
        updatedAt: iso8601DateTimeSchema
      })
    }
  };
  var requestPathSchema = json_schema_core_exports.union([
    json_schema_core_exports.literal(interfaces.getRoutes.path),
    json_schema_core_exports.literal(interfaces.setRoute.path),
    json_schema_core_exports.literal(interfaces.deleteRoute.path),
    json_schema_core_exports.literal(interfaces.clearRoutes.path)
  ]);

  // source/remote.ts
  async function fetchJsonp(url, options = {}) {
    const { data, jsonp = "callback", signal } = options;
    return new Promise((resolve, reject) => {
      if (signal?.aborted) {
        reject(newAbortError());
        return;
      }
      const script = document.createElement("script");
      const callbackName = `__fetchJsonp_cb_${Date.now()}_${Math.random().toString(36).slice(2)}`;
      let finished = false;
      const cleanup = () => {
        if (finished) return;
        finished = true;
        delete window[callbackName];
        script.remove();
        signal?.removeEventListener("abort", onAbort);
      };
      const onAbort = () => {
        cleanup();
        reject(newAbortError());
      };
      signal?.addEventListener("abort", onAbort);
      window[callbackName] = (data2) => {
        cleanup();
        resolve(data2);
      };
      const u = new URL(url, window.location.href);
      if (data) {
        for (const [key, value] of Object.entries(data)) {
          if (value == null) continue;
          u.searchParams.append(key, String(value));
        }
      }
      u.searchParams.append(jsonp, callbackName);
      script.onerror = () => {
        cleanup();
        reject(new Error("JSONP request failed"));
      };
      script.src = u.toString();
      script.async = true;
      document.head.appendChild(script);
    });
  }
  var RemoteError = class extends Error {
    constructor(response) {
      super();
      this.response = response;
    }
    get name() {
      return "RemoteError";
    }
  };
  async function fetchGet(schema, parameters, options) {
    const rootUrl = options.rootUrl;
    const method = "GET";
    const url = `${rootUrl}/${schema.path}`;
    console.debug(
      `-> ${JSON.stringify([method, url, JSON.stringify(parameters)])}`
    );
    const responseData = await fetchJsonp(url, {
      jsonp: "jsonp-callback",
      data: parameters,
      signal: options.signal
    });
    console.debug(`<- ${JSON.stringify([method, url, responseData])}`);
    const result = jsonResponseSchema.parse(responseData);
    const { type } = result;
    switch (type) {
      case "success": {
        return schema.result.parse(result.value);
      }
      case "error": {
        throw new RemoteError(result);
      }
      default: {
        throw new Error(`unknown response type: ${type}`);
      }
    }
  }
  async function getDrafts(parameter, options) {
    return await fetchGet(interfaces.getRoutes, parameter, options);
  }
  function createRemote(handleAsyncError2, intervalMs) {
    const events = createTypedEventTarget();
    const queue = createAsyncQueue(
      async (commands) => {
        const map = /* @__PURE__ */ new Map();
        for (const command of commands) {
          const id2 = command.parameter["route-id"];
          map.set(id2, command);
        }
        events.dispatchEvent(
          createTypedCustomEvent("fetch-start", void 0)
        );
        try {
          for (const command of map.values()) {
            const { type, parameter, rootUrl } = command;
            switch (type) {
              case "set":
                await fetchGet(interfaces.setRoute, parameter, {
                  rootUrl
                });
                break;
              case "delete":
                await fetchGet(interfaces.deleteRoute, parameter, {
                  rootUrl
                });
                break;
            }
            await sleep(intervalMs);
          }
        } finally {
          events.dispatchEvent(
            createTypedCustomEvent("fetch-end", void 0)
          );
        }
      },
      handleAsyncError2,
      { batchSize: 100 }
    );
    return {
      events,
      set(parameter, rootUrl) {
        queue.push({ type: "set", parameter, rootUrl });
      },
      delete(parameter, rootUrl) {
        queue.push({ type: "delete", parameter, rootUrl });
      }
    };
  }

  // source/drafts-overlay.module.css
  var cssText = ".label-6adc694ea38ca16a7e81027d243b7c13b1c6aa05 {\n    --text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923: #000;\n\n    max-width: 12em;\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n\n    text-shadow:\n        1px 1px var(--text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923),\n        1px -1px var(--text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923),\n        -1px 1px var(--text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923),\n        -1px -1px var(--text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923),\n        0 0 5px var(--text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923);\n}\n";
  var drafts_overlay_default = {
    label: "label-6adc694ea38ca16a7e81027d243b7c13b1c6aa05"
  };

  // source/drafts-canvas-overlay.ts
  function getPixelsPerMeter(center, projection) {
    const offsetLatLng = google.maps.geometry.spherical.computeOffset(
      center,
      1,
      0
    );
    const p1 = projection.fromLatLngToDivPixel(center);
    const p2 = projection.fromLatLngToDivPixel(offsetLatLng);
    return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
  }
  function createCanvasOverlay(drafts, config, selectedDraftId) {
    class CanvasOverlay extends google.maps.OverlayView {
      constructor(config2, drafts2, selectedDraftId2) {
        super();
        this.config = config2;
        this.drafts = drafts2;
        this.selectedDraftId = selectedDraftId2;
        this.canvas = null;
      }
      // Overlay 
      onAdd() {
        this.canvas = document.createElement("canvas");
        this.canvas.style.position = "absolute";
        this.canvas.style.pointerEvents = "none";
        const panes = this.getPanes();
        panes.markerLayer.appendChild(this.canvas);
      }
      onRemove() {
        if (this.canvas?.parentNode) {
          this.canvas.parentNode.removeChild(this.canvas);
          this.canvas = null;
        }
      }
      // 
      draw() {
        const projection = this.getProjection();
        const map = this.getMap();
        const canvas = this.canvas;
        if (!(map instanceof google.maps.Map) || !canvas) return;
        const bounds = map.getBounds();
        const sw = projection.fromLatLngToDivPixel(bounds.getSouthWest());
        const ne = projection.fromLatLngToDivPixel(bounds.getNorthEast());
        canvas.style.left = sw.x + "px";
        canvas.style.top = ne.y + "px";
        canvas.width = ne.x - sw.x;
        canvas.height = sw.y - ne.y;
        const deviceX = sw.x;
        const deviceY = ne.y;
        const ctx = canvas.getContext("2d");
        if (!ctx) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!isNeedDetail(map, this.config)) {
          renderDrafts(
            ctx,
            this.drafts,
            this.config.draftMarker,
            projection,
            deviceX,
            deviceY
          );
        }
        const selected = this.drafts.get(this.selectedDraftId.contents);
        const config2 = this.config.selected;
        if (selected) {
          drawSelectedViews(
            selected,
            projection,
            ctx,
            config2,
            deviceX,
            deviceY
          );
        }
      }
    }
    return new CanvasOverlay(config, drafts, selectedDraftId);
  }
  function drawSelectedViews(selected, projection, ctx, config, deviceX, deviceY) {
    const center = selected.draft.coordinates[0];
    const pixelsPerMeter = getPixelsPerMeter(center, projection);
    for (const circleKey in config.circles) {
      const circleConfig = config.circles[circleKey];
      renderCircle(
        ctx,
        center,
        circleConfig,
        projection,
        pixelsPerMeter,
        deviceX,
        deviceY
      );
    }
    for (const key in config.cell) {
      const cellConfig = config.cell[key];
      const level = Number(key);
      const path = createCellFromCoordinates(
        center,
        level
      ).getCornerLatLngs();
      renderPolygon(ctx, path, cellConfig, projection, deviceX, deviceY);
    }
  }
  function renderPolygon(ctx, path, config, projection, deviceX, deviceY) {
    const {
      strokeWeight,
      strokeColor,
      dashLength,
      dashRatio,
      fill: needFill,
      fillColor
    } = config;
    const hasPath = 2 <= path.length;
    const needStroke = 0 < strokeWeight;
    if (!hasPath || !needStroke && !needFill) return;
    setPath(ctx, path, projection, deviceX, deviceY);
    if (needFill) {
      ctx.fillStyle = fillColor;
      ctx.fill();
    }
    if (needStroke) {
      const unitLength = dashLength * (1 + 1 / dashRatio);
      const dashPx = unitLength * (dashRatio / (dashRatio + 1));
      const gapPx = unitLength - dashPx;
      ctx.setLineDash([dashPx, gapPx]);
      ctx.lineWidth = strokeWeight;
      ctx.strokeStyle = strokeColor;
      ctx.lineCap = "round";
      ctx.stroke();
    }
  }
  function setPath(ctx, path, projection, deviceX, deviceY) {
    const start = path[0];
    if (start == null) return;
    ctx.beginPath();
    const { x, y } = projection.fromLatLngToDivPixel(start);
    const canvasX = x - deviceX;
    const canvasY = y - deviceY;
    ctx.moveTo(canvasX, canvasY);
    for (let i = 1; i < path.length; i++) {
      const position = path[i];
      const { x: x2, y: y2 } = projection.fromLatLngToDivPixel(position);
      const canvasX2 = x2 - deviceX;
      const canvasY2 = y2 - deviceY;
      ctx.lineTo(canvasX2, canvasY2);
    }
    ctx.closePath();
  }
  function renderDrafts(ctx, drafts, config, projection, deviceX, deviceY) {
    const strokeStyle = config.strokeColor;
    const fillStyle = config.fillColor;
    const radius = config.scale;
    const lineWidth = config.strokeWeight;
    for (const draft of drafts.values()) {
      const position = draft.draft.coordinates[0];
      const pixel = projection.fromLatLngToDivPixel(position);
      const x = pixel.x - deviceX;
      const y = pixel.y - deviceY;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fillStyle = fillStyle;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x, y, radius + 2, 0, 2 * Math.PI);
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = strokeStyle;
      ctx.stroke();
    }
  }
  function renderCircle(ctx, center, config, projection, pixelsPerMeter, deviceX, deviceY) {
    const {
      strokeColor,
      radius: radiusMeters,
      strokeWeight,
      dashRatio,
      dashLength
    } = config;
    const radius = radiusMeters * pixelsPerMeter;
    const { x, y } = projection.fromLatLngToDivPixel(center);
    const centerX = x - deviceX;
    const centerY = y - deviceY;
    const circumference = 2 * Math.PI * radius;
    const targetUnitLength = dashLength * (1 + 1 / dashRatio);
    const numberOfUnits = Math.max(
      1,
      Math.round(circumference / targetUnitLength)
    );
    const actualUnitLength = circumference / numberOfUnits;
    const dashPx = actualUnitLength * (dashRatio / (dashRatio + 1));
    const gapPx = actualUnitLength - dashPx;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.setLineDash([dashPx, gapPx]);
    ctx.lineWidth = strokeWeight;
    ctx.strokeStyle = strokeColor;
    ctx.lineCap = "round";
    ctx.stroke();
  }

  // source/drafts-overlay.ts
  function createDefaultViewConfig() {
    const cell = {
      strokeColor: "rgba(240, 252, 249, 0.7)",
      strokeWeight: 4,
      dashLength: 30,
      dashRatio: 2,
      fillColor: "",
      fill: false
    };
    const cell17 = {
      strokeColor: "",
      strokeWeight: 0,
      dashLength: 30,
      dashRatio: 2,
      fillColor: "rgba(240, 252, 249, 0.4)",
      fill: true
    };
    const selectedCircleBase = {
      radius: 20,
      strokeColor: "rgb(240, 252, 249)",
      strokeWeight: 2,
      dashLength: 30,
      dashRatio: 3
    };
    return {
      minDetailZoom: 16,
      baseZIndex: 3100,
      draftMarker: {
        scale: 9,
        fillColor: "#00ffb380",
        strokeColor: "#ffffff80",
        strokeWeight: 2,
        label: {
          fillColor: "#FFFFBB",
          fontSize: "11px",
          className: drafts_overlay_default.label
        }
      },
      selected: {
        circles: {
          submissionTooClose: {
            ...selectedCircleBase,
            radius: 2,
            strokeWeight: 1,
            dashLength: 30,
            dashRatio: 5
          },
          tooClose: selectedCircleBase,
          powerSpotTooClose: {
            ...selectedCircleBase,
            radius: 40,
            strokeColor: "rgb(247, 158, 255)",
            strokeWeight: 1
          },
          pogoTouchable: {
            ...selectedCircleBase,
            radius: 80,
            strokeColor: "rgb(160, 201, 255)",
            strokeWeight: 1
          },
          submissionDistance: {
            ...selectedCircleBase,
            radius: 10 * 1e3,
            strokeColor: "rgb(231, 18, 196)",
            strokeWeight: 5,
            dashLength: 50
          }
        },
        cell: {
          14: cell,
          16: cell,
          17: cell17
        }
      }
    };
  }
  function createOptionsCache(config) {
    return {
      draftMarkerOptions: {
        zIndex: config.baseZIndex,
        icon: {
          ...config.draftMarker,
          labelOrigin: new google.maps.Point(0, 2),
          path: 0,
          fillOpacity: 1,
          strokeOpacity: 1
        }
      },
      draftMarkerLabel: {
        ...config.draftMarker.label,
        text: "",
        color: config.draftMarker.label.fillColor
      }
    };
  }
  function notifyDraftListUpdated(overlay) {
    overlay.asyncRouteListUpdateScope(async (_signal) => {
      const drafts = [];
      for (const v of overlay.drafts.values()) {
        drafts.push(v.draft);
      }
      overlay.events.dispatchEvent(
        createTypedCustomEvent("drafts-updated", drafts)
      );
    });
  }
  function getPosition(draft) {
    return draft.coordinates[0];
  }
  function includesIn(bounds, draft) {
    return bounds.contains(getPosition(draft));
  }
  function addDraft(overlay, draft) {
    overlay.drafts.set(draft.id, {
      draft,
      mapView: createMapView(overlay, draft)
    });
  }
  function deleteDraftCore(overlay, draftId) {
    const draftWithView = overlay.drafts.get(draftId);
    if (draftWithView) {
      draftWithView.mapView.marker.setMap(null);
      overlay.drafts.delete(draftId);
      if (overlay.selectedDraftId.contents === draftId) {
        overlay.selectedDraftId.contents = null;
        updateSelectedView(overlay);
      }
      notifyDraftListUpdated(overlay);
    }
  }
  function updateSelectedView(overlay) {
    overlay.draftsCanvasOverlay.draw();
  }
  function createMapView(overlay, draft) {
    const label = {
      ...overlay.cachedOptions.draftMarkerLabel,
      text: draft.name
    };
    const marker = new google.maps.Marker(
      overlay.cachedOptions.draftMarkerOptions
    );
    marker.setPosition(getPosition(draft));
    marker.setLabel(label);
    marker.addListener("click", () => {
      overlay.select(draft.id);
    });
    marker.addListener("dragend", () => {
      const newPosition = marker.getPosition();
      if (newPosition == null) return;
      draft.coordinates = [
        { lat: newPosition.lat(), lng: newPosition.lng() }
      ];
      overlay.updateDraftCoordinates(draft);
      overlay.events.dispatchEvent(
        createTypedCustomEvent("draft-updated", draft.id)
      );
    });
    return {
      label,
      marker
    };
  }
  function isNeedDetail(map, config) {
    return config.minDetailZoom <= (map.getZoom() ?? 0);
  }
  function updateMapView(overlay, { mapView, draft }) {
    const needDetail = isNeedDetail(overlay.map, overlay.config);
    const hasDetail = mapView.marker.getMap() != null;
    if (needDetail !== hasDetail) {
      if (needDetail) {
        mapView.marker.setMap(overlay.map);
      } else {
        mapView.marker.setLabel(null);
      }
    }
    mapView.marker.setDraggable(overlay.selectedDraftId.contents === draft.id);
  }
  function deleteDetailView(overlay, view) {
    overlay.addedMapViews.delete(view);
    view.marker.setMap(null);
  }
  async function renderDraftsInMap(overlay, scheduler) {
    const { drafts, map } = overlay;
    const bounds = map.getBounds();
    if (bounds == null) return;
    const needDetail = isNeedDetail(overlay.map, overlay.config);
    if (!needDetail) {
      for (const oldView of overlay.addedMapViews) {
        deleteDetailView(overlay, oldView);
      }
      return;
    }
    const viewToDrafts = /* @__PURE__ */ new Map();
    const visibleBounds = padBounds(bounds, 0.2);
    for (const view of drafts.values()) {
      if (includesIn(visibleBounds, view.draft)) {
        viewToDrafts.set(view.mapView, view);
      }
    }
    for (const view of viewToDrafts.values()) {
      await scheduler.yield();
      updateMapView(overlay, view);
    }
    for (const oldView of overlay.addedMapViews) {
      await scheduler.yield();
      if (viewToDrafts.has(oldView)) {
        viewToDrafts.delete(oldView);
      } else {
        deleteDetailView(overlay, oldView);
      }
    }
    for (const view of viewToDrafts.keys()) {
      await scheduler.yield();
      view.marker.setMap(overlay.map);
      overlay.addedMapViews.add(view);
    }
  }
  function notifyMapRangeChanged(overlay) {
    overlay.asyncRenderDraftsInMapScope(async (signal) => {
      await sleep(100, { signal });
      const scheduler = createScheduler(signal);
      return await renderDraftsInMap(overlay, scheduler);
    });
  }
  function createDraftsOverlay(map, asyncErrorHandler) {
    const config = createDefaultViewConfig();
    const drafts = /* @__PURE__ */ new Map();
    const selectedDraftId = { contents: null };
    const draftsCanvasOverlay = createCanvasOverlay(
      drafts,
      config,
      selectedDraftId
    );
    return {
      events: createTypedEventTarget(),
      config,
      cachedOptions: createOptionsCache(config),
      map,
      drafts,
      selectedDraftId,
      draftsCanvasOverlay,
      addedMapViews: /* @__PURE__ */ new Set(),
      asyncRouteListUpdateScope: createAsyncCancelScope(asyncErrorHandler),
      asyncRenderDraftsInMapScope: createAsyncCancelScope(asyncErrorHandler),
      updateDraftTitle(draft) {
        const draftWithView = this.drafts.get(draft.id);
        if (draftWithView) {
          draftWithView.draft.name = draft.name;
          draftWithView.mapView.marker.setLabel({
            ...draftWithView.mapView.label,
            text: draft.name
          });
          notifyMapRangeChanged(this);
        }
      },
      updateDraftCoordinates(draft) {
        const draftWithView = this.drafts.get(draft.id);
        if (draftWithView) {
          draftWithView.draft.coordinates = draft.coordinates;
          draftWithView.mapView.marker.setPosition(getPosition(draft));
          if (this.selectedDraftId.contents === draft.id) {
            updateSelectedView(this);
          }
          notifyMapRangeChanged(this);
        }
      },
      async addDrafts(drafts2, scheduler) {
        for (const draft of drafts2) {
          await scheduler.yield();
          addDraft(this, draft);
        }
        notifyDraftListUpdated(this);
        notifyMapRangeChanged(this);
      },
      addDraft(draft) {
        addDraft(this, draft);
        notifyDraftListUpdated(this);
        notifyMapRangeChanged(this);
      },
      deleteDraft(draftId) {
        deleteDraftCore(this, draftId);
        notifyMapRangeChanged(this);
      },
      select(draftId) {
        const draft = this.drafts.get(draftId)?.draft;
        if (draft == null) return;
        this.selectedDraftId.contents = draft.id;
        updateSelectedView(this);
        this.events.dispatchEvent(
          createTypedCustomEvent("selection-changed", draft.id)
        );
        notifyMapRangeChanged(this);
      }
    };
  }
  var setStyle = styleSetter(cssText);
  async function setupDraftsOverlay(overlay, local, scheduler) {
    setStyle();
    overlay.draftsCanvasOverlay.setMap(overlay.map);
    overlay.map.addListener("idle", () => notifyMapRangeChanged(overlay));
    notifyMapRangeChanged(overlay);
    const { userId, apiRoot } = local.getConfig();
    if (userId && apiRoot) {
      const { routes } = await getDrafts(
        {
          "user-id": userId
        },
        { rootUrl: apiRoot }
      );
      const drafts = routes.map((route) => ({
        ...route,
        coordinates: parseCoordinates(route.coordinates),
        id: route.routeId,
        name: route.routeName
      }));
      await overlay.addDrafts(drafts, scheduler);
    }
  }

  // source/poi-records.worker.ts?worker
  function Worker3() {
    return inlineWorker('var xe=Object.defineProperty,Le=Object.defineProperties;var Ie=Object.getOwnPropertyDescriptors;var _=Object.getOwnPropertySymbols;var Ce=Object.prototype.hasOwnProperty,we=Object.prototype.propertyIsEnumerable;var M=(t,e)=>(e=Symbol[t])?e:Symbol.for("Symbol."+t),Re=t=>{throw TypeError(t)};var U=(t,e,o)=>e in t?xe(t,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[e]=o,W=(t,e)=>{for(var o in e||(e={}))Ce.call(e,o)&&U(t,o,e[o]);if(_)for(var o of _(e))we.call(e,o)&&U(t,o,e[o]);return t},j=(t,e)=>Le(t,Ie(e));var ke=function(t,e){this[0]=t,this[1]=e};var L=t=>{var e=t[M("asyncIterator")],o=!1,s,c={};return e==null?(e=t[M("iterator")](),s=i=>c[i]=d=>e[i](d)):(e=e.call(t),s=i=>c[i]=d=>{if(o){if(o=!1,i==="throw")throw d;return d}return o=!0,{done:!1,value:new ke(new Promise(u=>{var n=e[i](d);n instanceof Object||Re("Object expected"),u(n)}),1)}}),c[M("iterator")]=()=>c,s("next"),"throw"in e?s("throw"):c.throw=i=>{throw i},"return"in e&&s("return"),c};function Y(t,e,{batchSize:o=10}={}){let s=[],c=!1,i=!1;function d(a){s.push(a),u()}function u(){i||(i=!0,queueMicrotask(()=>{i=!1,n().catch(e)}))}async function n(){if(c||s.length===0)return;c=!0;let a=s.splice(0,o);try{await t(a)}finally{c=!1,s.length&&u()}}function r(){s.length=0}return{push:d,close:r}}function X(){return typeof window=="undefined"&&typeof self!="undefined"}function Ee(t,e){let o=performance.now(),s=null;return t.addEventListener("abort",()=>{s!=null&&(cancelAnimationFrame(s),s=null)},{once:!0}),{get isYieldRequested(){var i,d;return(d=(i=navigator.scheduling)==null?void 0:i.isInputPending)!=null&&d.call(i)?!0:performance.now()-o>=e},yield(){return this.isYieldRequested?new Promise(c=>{s=requestAnimationFrame(()=>{o=performance.now(),c()})}):null}}}function Ne(){return{isYieldRequested:!1,yield(){return null}}}function H(t,e=10){return X()?Ne():Ee(t,e)}function J(){return{sw:{lat:1/0,lng:1/0},ne:{lat:-1/0,lng:-1/0}}}function Ke(t,e,o,s){return{sw:{lat:t,lng:e},ne:{lat:o,lng:s}}}function Z(t,e){return Ke(t.lat,t.lng,e.lat,e.lng)}function $(t){return{lat:(t.sw.lat+t.ne.lat)/2,lng:(t.sw.lng+t.ne.lng)/2}}function z(t,e){return{sw:{lat:Math.min(t.sw.lat,e.lat),lng:Math.min(t.sw.lng,e.lng)},ne:{lat:Math.max(t.ne.lat,e.lat),lng:Math.max(t.ne.lng,e.lng)}}}function ee(t,e){return t.sw.lat<=e.ne.lat&&e.sw.lat<=t.ne.lat?De(t,e):!1}function De(t,e){let o=t.sw.lng>t.ne.lng,s=e.sw.lng>e.ne.lng;return!o&&!s?t.sw.lng<=e.ne.lng&&e.sw.lng<=t.ne.lng:w(t,e.sw.lng)||w(t,e.ne.lng)||w(e,t.sw.lng)||w(e,t.ne.lng)||o&&s}function w(t,e){return t.sw.lng<=t.ne.lng?e>=t.sw.lng&&e<=t.ne.lng:e>=t.sw.lng||e<=t.ne.lng}function I(t){return t}function ne(...t){}var P=class extends Error{constructor(o){super(o);this.name="AbortError"}};function re(t="The operation was aborted."){return typeof DOMException=="function"?new DOMException(t,"AbortError"):new P(t)}function Pe(t,e){for(let[o,s]of Object.entries(e)){let c=t.createObjectStore(o,{keyPath:s.key.slice()});for(let[i,d]of Object.entries(s.indexes))c.createIndex(i,d.key,d)}}function oe(t,e,o){return new Promise((s,c)=>{let i=indexedDB.open(t,e);i.addEventListener("upgradeneeded",()=>Pe(i.result,o)),i.addEventListener("blocked",()=>c(new Error("database blocked"))),i.addEventListener("error",()=>c(i.error)),i.addEventListener("success",()=>s(i.result))})}var A=class{constructor(e,o,s){this.source=e;this.query=o;this.action=s}};function ae(t,{mode:e,signal:o},s,...c){return new Promise((i,d)=>{if(o!=null&&o.aborted){d(re());return}let u=!1,n,r=t.transaction(c,e),a=o?()=>{u||r.abort()}:ne;r.addEventListener("complete",()=>{o==null||o.removeEventListener("abort",a),u?i(n):d(new Error("internal error"))}),r.addEventListener("error",g=>{o==null||o.removeEventListener("abort",a),d(g.target.error)}),o==null||o.addEventListener("abort",a);let l={};for(let g of c)l[g]=r.objectStore(g);let p=s(l),m,T,y,f,S,h;function v(){let g;switch(m){case void 0:g=p.next();break;case"Request":{let b=T.result;m=void 0,T=void 0,g=p.next(b);break}case"WaitRequests":{let b=y,Q=f,be=Q[b.length].result;if(b.push(be),b.length!==Q.length)return;m=void 0,f=void 0,y=void 0,g=p.next(b);break}case"OpenCursor":{let b=S.result;if(b===null||h(b.value)==="break")m=void 0,S=void 0,h=void 0,g=p.next(void 0);else{b.continue();return}break}default:{d(new Error(`Invalid resolving kind: ${m}`));return}}if(g.done){u=!0,n=g.value;return}let x=g.value;if(x instanceof IDBRequest){m="Request",T=x,x.onsuccess=v;return}if(x instanceof A){m="OpenCursor",S=x.source.openCursor(x.query),h=x.action,S.onsuccess=v;return}m="WaitRequests",f=x,y=[];for(let b of x)b.onsuccess=v}v()})}function R(t,e){return t.index(e)}function Ae(t,e){let o=[];for(let s of e)o.push(t.get(s));return o}function*se(t,e){let o=Ae(t,e);return o.length===0?[]:yield o}function*ie(t,e,o){return yield t.getAll(e,o)}function*B(t,e){let o;for(let s of e)o=t.put(s);o!=null&&(yield o)}function*le(t,e){let o;for(let s of e)o=t.delete(s);o!=null&&(yield o)}function Fe(t){"use strict";var e=t.S2={L:{}};e.L.LatLng=function(n,r,a){var l=parseFloat(n,10),p=parseFloat(r,10);if(isNaN(l)||isNaN(p))throw new Error("Invalid LatLng object: ("+n+", "+r+")");return a!==!0&&(l=Math.max(Math.min(l,90),-90),p=(p+180)%360+(p<-180||p===180?180:-180)),{lat:l,lng:p}},e.L.LatLng.DEG_TO_RAD=Math.PI/180,e.L.LatLng.RAD_TO_DEG=180/Math.PI,e.LatLngToXYZ=function(n){var r=e.L.LatLng.DEG_TO_RAD,a=n.lat*r,l=n.lng*r,p=Math.cos(a);return[Math.cos(l)*p,Math.sin(l)*p,Math.sin(a)]},e.XYZToLatLng=function(n){var r=e.L.LatLng.RAD_TO_DEG,a=Math.atan2(n[2],Math.sqrt(n[0]*n[0]+n[1]*n[1])),l=Math.atan2(n[1],n[0]);return e.L.LatLng(a*r,l*r)};var o=function(n){var r=[Math.abs(n[0]),Math.abs(n[1]),Math.abs(n[2])];return r[0]>r[1]?r[0]>r[2]?0:2:r[1]>r[2]?1:2},s=function(n,r){var a,l;switch(n){case 0:a=r[1]/r[0],l=r[2]/r[0];break;case 1:a=-r[0]/r[1],l=r[2]/r[1];break;case 2:a=-r[0]/r[2],l=-r[1]/r[2];break;case 3:a=r[2]/r[0],l=r[1]/r[0];break;case 4:a=r[2]/r[1],l=-r[0]/r[1];break;case 5:a=-r[1]/r[2],l=-r[0]/r[2];break;default:throw{error:"Invalid face"}}return[a,l]};e.XYZToFaceUV=function(n){var r=o(n);n[r]<0&&(r+=3);var a=s(r,n);return[r,a]},e.FaceUVToXYZ=function(n,r){var a=r[0],l=r[1];switch(n){case 0:return[1,a,l];case 1:return[-a,1,l];case 2:return[-a,-l,1];case 3:return[-1,-l,-a];case 4:return[l,-1,-a];case 5:return[l,a,-1];default:throw{error:"Invalid face"}}};var c=function(n){return n>=.5?1/3*(4*n*n-1):1/3*(1-4*(1-n)*(1-n))};e.STToUV=function(n){return[c(n[0]),c(n[1])]};var i=function(n){return n>=0?.5*Math.sqrt(1+3*n):1-.5*Math.sqrt(1-3*n)};e.UVToST=function(n){return[i(n[0]),i(n[1])]},e.STToIJ=function(n,r){var a=1<<r,l=function(p){var m=Math.floor(p*a);return Math.max(0,Math.min(a-1,m))};return[l(n[0]),l(n[1])]},e.IJToST=function(n,r,a){var l=1<<r;return[(n[0]+a[0])/l,(n[1]+a[1])/l]};var d=function(n,r,a,l){var p,m;if(l==0){a==1&&(r.x=n-1-r.x,r.y=n-1-r.y);var T=r.x;r.x=r.y,r.y=T}},u=function(n,r,a,l){var p={a:[[0,"d"],[1,"a"],[3,"b"],[2,"a"]],b:[[2,"b"],[1,"b"],[3,"a"],[0,"c"]],c:[[2,"c"],[3,"d"],[1,"c"],[0,"b"]],d:[[0,"a"],[3,"c"],[1,"d"],[2,"d"]]};typeof l!="number"&&console.warn(new Error("called pointToHilbertQuadList without face value, defaulting to \'0\'").stack);for(var m=l%2?"d":"a",T=[],y=a-1;y>=0;y--){var f=1<<y,S=n&f?1:0,h=r&f?1:0,v=p[m][S*2+h];T.push(v[0]),m=v[1]}return T};return e.S2Cell=function(){},e.S2Cell.FromHilbertQuadKey=function(n){var r=n.split("/"),a=parseInt(r[0]),l=r[1],p=l.length,m={x:0,y:0},T,y,f,S,h,v;for(T=p-1;T>=0;T--)y=p-T,f=l[T],S=0,h=0,f==="1"?h=1:f==="2"?(S=1,h=1):f==="3"&&(S=1),v=Math.pow(2,y-1),d(v,m,S,h),m.x+=v*S,m.y+=v*h;if(a%2===1){var g=m.x;m.x=m.y,m.y=g}return e.S2Cell.FromFaceIJ(parseInt(a),[m.x,m.y],y)},e.S2Cell.FromLatLng=function(n,r){if(!n.lat&&n.lat!==0||!n.lng&&n.lng!==0)throw new Error("Pass { lat: lat, lng: lng } to S2.S2Cell.FromLatLng");var a=e.LatLngToXYZ(n),l=e.XYZToFaceUV(a),p=e.UVToST(l[1]),m=e.STToIJ(p,r);return e.S2Cell.FromFaceIJ(l[0],m,r)},e.S2Cell.FromFaceIJ=function(n,r,a){var l=new e.S2Cell;return l.face=n,l.ij=r,l.level=a,l},e.S2Cell.prototype.toString=function(){return"F"+this.face+"ij["+this.ij[0]+","+this.ij[1]+"]@"+this.level},e.S2Cell.prototype.getLatLng=function(){var n=e.IJToST(this.ij,this.level,[.5,.5]),r=e.STToUV(n),a=e.FaceUVToXYZ(this.face,r);return e.XYZToLatLng(a)},e.S2Cell.prototype.getCornerLatLngs=function(){for(var n=[],r=[[0,0],[0,1],[1,1],[1,0]],a=0;a<4;a++){var l=e.IJToST(this.ij,this.level,r[a]),p=e.STToUV(l),m=e.FaceUVToXYZ(this.face,p);n.push(e.XYZToLatLng(m))}return n},e.S2Cell.prototype.getFaceAndQuads=function(){var n=u(this.ij[0],this.ij[1],this.level,this.face);return[this.face,n]},e.S2Cell.prototype.toHilbertQuadkey=function(){var n=u(this.ij[0],this.ij[1],this.level,this.face);return this.face.toString(10)+"/"+n.join("")},e.latLngToNeighborKeys=e.S2Cell.latLngToNeighborKeys=function(n,r,a){return e.S2Cell.FromLatLng({lat:n,lng:r},a).getNeighbors().map(function(l){return l.toHilbertQuadkey()})},e.S2Cell.prototype.getNeighbors=function(){var n=function(m,T,y){var f=1<<y;if(T[0]>=0&&T[1]>=0&&T[0]<f&&T[1]<f)return e.S2Cell.FromFaceIJ(m,T,y);var S=e.IJToST(T,y,[.5,.5]),h=e.STToUV(S),v=e.FaceUVToXYZ(m,h),g=e.XYZToFaceUV(v);return m=g[0],h=g[1],S=e.UVToST(h),T=e.STToIJ(S,y),e.S2Cell.FromFaceIJ(m,T,y)},r=this.face,a=this.ij[0],l=this.ij[1],p=this.level;return[n(r,[a-1,l],p),n(r,[a,l-1],p),n(r,[a+1,l],p),n(r,[a,l+1],p)]},e.FACE_BITS=3,e.MAX_LEVEL=30,e.POS_BITS=2*e.MAX_LEVEL+1,e.facePosLevelToId=e.S2Cell.facePosLevelToId=e.fromFacePosLevel=function(n,r,a){var l=t.dcodeIO&&t.dcodeIO.Long,p,m,T;for(a||(a=r.length),r.length>a&&(r=r.substr(0,a)),p=l.fromString(n.toString(10),!0,10).toString(2);p.length<e.FACE_BITS;)p="0"+p;for(m=l.fromString(r,!0,4).toString(2);m.length<2*a;)m="0"+m;for(T=p+m,T+="1";T.length<e.FACE_BITS+e.POS_BITS;)T+="0";return l.fromString(T,!0,2).toString(10)},e.keyToId=e.S2Cell.keyToId=e.toId=e.toCellId=e.fromKey=function(n){var r=n.split("/");return e.fromFacePosLevel(r[0],r[1],r[1].length)},e.idToKey=e.S2Cell.idToKey=e.S2Cell.toKey=e.toKey=e.fromId=e.fromCellId=e.S2Cell.toHilbertQuadkey=e.toHilbertQuadkey=function(n){for(var r=t.dcodeIO&&t.dcodeIO.Long,a=r.fromString(n,!0,10).toString(2);a.length<e.FACE_BITS+e.POS_BITS;)a="0"+a;for(var l=a.lastIndexOf("1"),p=a.substring(0,3),m=a.substring(3,l),T=m.length/2,y=r.fromString(p,!0,2).toString(10),f=r.fromString(m,!0,2).toString(4);f.length<T;)f="0"+f;return y+"/"+f},e.keyToLatLng=e.S2Cell.keyToLatLng=function(n){var r=e.S2Cell.FromHilbertQuadKey(n);return r.getLatLng()},e.idToLatLng=e.S2Cell.idToLatLng=function(n){var r=e.idToKey(n);return e.keyToLatLng(r)},e.S2Cell.latLngToKey=e.latLngToKey=e.latLngToQuadkey=function(n,r,a){if(isNaN(a)||a<1||a>30)throw new Error("\'level\' is not a number between 1 and 30 (but it should be)");return e.S2Cell.FromLatLng({lat:n,lng:r},a).toHilbertQuadkey()},e.stepKey=function(n,r){var a=t.dcodeIO&&t.dcodeIO.Long,l=n.split("/"),p=l[0],m=l[1],T=l[1].length,y=a.fromString(m,!0,4),f;r>0?f=y.add(Math.abs(r)):r<0&&(f=y.subtract(Math.abs(r)));var S=f.toString(4);for(S==="0"&&console.warning(new Error("face/position wrapping is not yet supported"));S.length<T;)S="0"+S;return p+"/"+S},e.S2Cell.prevKey=e.prevKey=function(n){return e.stepKey(n,-1)},e.S2Cell.nextKey=e.nextKey=function(n){return e.stepKey(n,1)},e}var C=Fe(typeof module!="undefined"&&module.exports?module.exports:typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:typeof window!="undefined"?window:void 0);function F(t,e){return C.S2Cell.FromLatLng(t,e)}function Ge(t){return C.S2Cell.FromHilbertQuadKey(t)}function N(t,e){return F(t,e).toString()}var qe=Object.freeze(["0","1","2","3"]);function K(t){let e=t.level;if(C.MAX_LEVEL<=e)throw new Error("Cannot get children for a cell at MAX_LEVEL (30).");let o=t.toHilbertQuadkey(),s=[];for(let c of qe){let i=o+c;s.push(Ge(i))}return s}function ce(t){let e=t.padEnd(16,"0"),o=BigInt(`0x${e}`),s=Ve(o);return C.S2Cell.FromHilbertQuadKey(s)}var G=new BigUint64Array(1),E=new Uint32Array(G.buffer);function Oe(t){G[0]=t;let e=E[0],o=E[1];return e!==0?31-Math.clz32(e&-e):o!==0?32+(31-Math.clz32(o&-o)):64}var k=[];function Ve(t){G[0]=t;let e=E[0],o=E[1],s=o>>>29,c=Qe(t);k.length=0,k.push(s,"/");for(let i=1;i<=c;i++){let d=61-2*i,u;d>=32?u=o>>>d-32&3:d===31?u=(o&1)<<1|e>>>31:u=e>>>d&3,k.push(u)}return k.join("")}function Qe(t){let e=Oe(t);if(e>60||(e&1)!==0)throw new Error("Invalid S2CellID");return 60-e>>1}function de(t=1024){let e=new Array(t),o=t-1,s=0,c=0;return{enqueue(i){e[c&o]=i,c++},dequeue(){if(s===c)return;let i=e[s&o];return s++,i}}}var _e={pois:{recordType:I,key:"guid",indexes:{coordinates:{key:["lat","lng"]},cellIds:{key:"cellIds",multiEntry:!0}}},cells:{recordType:I,key:"cellId",indexes:{ancestorIds:{key:"ancestorIds",multiEntry:!0}}}},D=Symbol("_pois"),ue=Symbol("_cells"),Ue=Symbol("_coordinatesIndex"),me=Symbol("_cellIdsIndex"),We=Symbol("_ancestorIdsIndexSymbol");var je="poi-records-e232930d-7282-4c02-aeef-bb9508576d2e",Ye=1,pe=Symbol("_database");async function Te(){return{[pe]:await oe(je,Ye,_e)}}function Xe(t,e,o,s){return ae(t[pe],{mode:e,signal:o==null?void 0:o.signal},({pois:c,cells:i})=>{let d={[D]:c,[ue]:i,[Ue]:R(c,"coordinates"),[me]:R(c,"cellIds"),[We]:R(i,"ancestorIds")};return s(d)},"pois","cells")}function He(t,e){let o=[],s=new Set,c=de();c.enqueue(F($(t),e));for(let i;i=c.dequeue();){let d=i.toString();if(s.has(d))continue;s.add(d);let u=J();for(let n of i.getCornerLatLngs())u=z(u,n);if(ee(t,u)){o.push(i);for(let n of i.getNeighbors())c.enqueue(n)}}return o}function Je(t,e,o,s){let c=o.latE6/1e6,i=o.lngE6/1e6,d=o.title,u={lat:c,lng:i},n=[N(u,14),N(u,15)],r=t!=null?t:{guid:e,lat:c,lng:i,name:d,data:o,cellIds:n,firstFetchDate:s,lastFetchDate:s};return j(W({},r),{name:d!==""?d:r.name,lat:c,lng:i,data:o,cellIds:n,lastFetchDate:s})}async function fe(t,e,o,s,c){let i=new Map;for(let d of o)for(let u of He(d,q)){let n=u.toString();e.has(n)||i.set(n,{cell:u})}await Xe(t,"readwrite",{signal:c},function*(d){yield*L(Ze(d,e)),yield*L($e(e,d,s)),yield*L(ze(d,e,i,s))})}function*Ze(t,e){let o=[];for(let[s,{pois:c}]of e){let i=new Set;for(let u of c)i.add(u.poiId);let d=yield*L(ie(t[me],s));for(let{guid:u}of d)i.has(u)||o.push(u)}yield*L(le(t[D],o))}function*$e(t,e,o){let s=[],c=[];for(let{pois:u}of t.values())for(let n of u)s.push(n.poiId),c.push(n);let d=(yield*L(se(e[D],s))).map((u,n)=>{let r=c[n];return Je(u,r.poiId,r,o)});yield*L(B(e[D],d))}function*ze(t,e,o,s){let c=[];for(let{cell:i}of[...e.values(),...o.values()])for(let d of K(i))for(let u of K(d))for(let n of K(u)){let r=n.getLatLng();c.push({cellId:n.toString(),centerLat:r.lat,centerLng:r.lng,level:n.level,ancestorIds:[N(r,14)],firstFetchDate:s,lastFetchDate:s})}yield*L(B(t[ue],c))}function ye(){return new EventTarget}function Se(t,e){return new CustomEvent(t,{detail:e})}function et(t){let e={};return t.searchParams.forEach((o,s)=>{e[s]=o}),e}async function tt(t,e,{cells:o,bounds:s},c){await fe(t,o,s,Date.now(),c),e.dispatchEvent(Se("gcs-saved",void 0))}var q=14;async function nt(t,e,o){let s=new Map,c=[];for(let{queries:i,responseText:d}of e){await o.yield();let u=t.parseGcsResponse(d);if(u.captcha||!u.result.success)continue;let n=t.parseGcsQueries(i);c.push(Z(n.sw,n.ne));for(let{metadata:r,pois:a}of u.result.data){if(r.s2CellLevel!==q)continue;let l=ce(r.s2CellId),p=l.toString();s.set(p,{pois:a,cell:l})}}return{cells:s,bounds:c}}async function ge(t,e,o){let s=await Te(),c=Y(async i=>{let{signal:d}=new AbortController,u=H(d),n=await nt(t,i,u);await tt(s,e,n,d)},o);return(i,d)=>{c.push({queries:et(i),responseText:d})}}function O(t,e){return t}var rt=[O("config-changed",I),O("gcs-received",I),O("gcs-saved",I)],he=rt;async function ve(){let t=await import("https://cdn.jsdelivr.net/npm/zod@4.3.6/+esm"),e=t.enum(["DETAILED"]),o=t.enum(["GYM","POKESTOP","POWERSPOT"]),s=t.enum(["HOLOHOLO"]),c=t.enum(["ACTIVE","INACTIVE"]),i=/^\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)\\s*\\)$/,d=t.string().transform((T,y)=>{let f=i.exec(T);return f?{lat:Number(f[1]),lng:Number(f[2])}:(y.addIssue({code:"invalid_format",message:"Invalid point format. Expected `(${number},${number})",format:"custom",pattern:i.source,input:T}),t.NEVER)}),u=t.object({ne:d,sw:d}),n=t.object({s2CellLevel:t.number(),s2CellId:t.string(),generatedTimestamp:t.string(),count:t.number(),format:e}),r=t.object({gameBrand:s,entity:o,status:c}),a=t.object({poiId:t.string(),latE6:t.number(),lngE6:t.number(),title:t.string(),description:t.string(),address:t.string(),categoryTags:t.array(t.unknown()),mainImage:t.string(),hasAdditionalImages:t.boolean(),gmo:t.array(r),isCommunityContributed:t.boolean()}),l=t.object({metadata:n,pois:t.array(a),clusters:t.array(t.unknown())}),p=t.object({success:t.boolean(),data:t.array(l),cellsQueried:t.number(),cellsLoaded:t.number(),snapshot:t.string(),cellLevel:t.number()}),m=t.object({result:p,message:t.unknown(),code:t.string(),errorsWithIcon:t.unknown(),fieldErrors:t.unknown(),errorDetails:t.unknown(),version:t.string(),captcha:t.boolean()});return{FormatSchema:e,EntityKindSchema:o,GameBrandSchema:s,StatusSchema:c,MetadataSchema:n,GmoSchema:r,PoiSchema:a,DatumSchema:l,ResultSchema:p,GcsQueriesSchema:u,GcsResponseSchema:m,parseGcsResponse(T){return m.parse(JSON.parse(T))},parseGcsQueries(T){return u.parse(T)}}}function V(t){console.error("An error occurred during asynchronous processing:",t)}async function ot(){let t=await import("https://cdn.jsdelivr.net/npm/comlink@4.4.2/+esm"),e=t.wrap(self),o=await ve(),s=ye(),c=u=>{e.dispatchEvent(u.type,u.detail).catch(V)};he.forEach(u=>s.addEventListener(u,c));let i=await ge(o,s,V),d={onGcsReceived(u,n){i(new URL(u),n)}};t.expose(d)}ot().catch(V);\n');
  }

  // source/drafts-view/dialog.module.css
  var cssText2 = '.dialog-59a53fe03e3575e542ce8529fd0df0730794d761 {\n    --initial-height-495e116479cd0a7f6c7e692d6f9bdccbce49be36: min(300px, 50%);\n    --initial-width-34ea83cc4f4c691432fc64a891f4be0f53ecd5fa: min(400px, 80%);\n    --border-radius-e5129cde634ebedc5b44d3c50a36d58b65129a1e: 6px;\n\n    position: fixed;\n    top: var(--drag-top-737ad0c0838ca0307f6d25b24cebb7846196db72, calc(100% - var(--initial-height-495e116479cd0a7f6c7e692d6f9bdccbce49be36)));\n    left: var(--drag-left-0481d18ee27dc8bdf676134913f1eab609bbb7f7, calc(100% - var(--initial-width-34ea83cc4f4c691432fc64a891f4be0f53ecd5fa)));\n    height: var(--initial-height-495e116479cd0a7f6c7e692d6f9bdccbce49be36);\n    width: var(--initial-width-34ea83cc4f4c691432fc64a891f4be0f53ecd5fa);\n\n    --foreground-color-58da031e86887b92a1feaf5e8052dd5c83e23b4d: var(--external-foreground-color-5de188c61cf6701393a6300181cad2c723ea246c, #717171);\n    --background-color-b3200fc721c2f9f2b2d7b295b0ef23343df6f092: var(\n        --external-background-color-bb20739c0fcb55a95dfe902adb5bd01a0380425f,\n        rgba(247, 251, 255, 0.8)\n    );\n\n    color: var(--foreground-color-58da031e86887b92a1feaf5e8052dd5c83e23b4d);\n    background: var(--background-color-b3200fc721c2f9f2b2d7b295b0ef23343df6f092);\n    backdrop-filter: blur(6px);\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);\n    z-index: 10000;\n    border-radius: var(--border-radius-e5129cde634ebedc5b44d3c50a36d58b65129a1e);\n\n    overflow: auto;\n    resize: both;\n    display: flex;\n    flex-direction: column;\n}\n\n.dialog-59a53fe03e3575e542ce8529fd0df0730794d761.maximized-153d4ccb93d0dc13d48f201dd533f39d0bbc8ced {\n    /* resize: both \u306B\u3088\u3063\u3066\u30D6\u30E9\u30A6\u30B6\u306B\u3088\u3063\u3066\u8A2D\u5B9A\u3055\u308C\u305F\u30A4\u30F3\u30E9\u30A4\u30F3\u30B9\u30BF\u30A4\u30EB\u3092\u4E0A\u66F8\u304D\u3059\u308B\u305F\u3081 */\n    width: 100% !important;\n    height: 100% !important;\n    left: 0;\n    top: 0;\n    resize: none;\n}\n\n.dialog-59a53fe03e3575e542ce8529fd0df0730794d761.minimized-b1fe5ca90f7af0d447dd92c120b85309a6bffdfe {\n    resize: none;\n\n    /* resize: both \u306B\u3088\u3063\u3066\u30D6\u30E9\u30A6\u30B6\u306B\u3088\u3063\u3066\u8A2D\u5B9A\u3055\u308C\u305F\u30A4\u30F3\u30E9\u30A4\u30F3\u30B9\u30BF\u30A4\u30EB\u3092\u4E0A\u66F8\u304D\u3059\u308B\u305F\u3081 */\n    width: auto !important;\n    height: auto !important;\n}\n\n.titlebar-77f4f2a0b714f05efd6878ddb3f8362533a260f1 {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    align-content: center;\n    user-select: none;\n    touch-action: none;\n\n    padding: 2px 4px;\n\n    background-color: #e5e7eb;\n    border-radius: var(--border-radius-e5129cde634ebedc5b44d3c50a36d58b65129a1e) var(--border-radius-e5129cde634ebedc5b44d3c50a36d58b65129a1e) 0 0;\n}\n\n.titlebar-icon-412b1d35c34f2f49f26bd6a3dc81001c27e0fe4b {\n    width: 16px;\n    height: 16px;\n    margin-right: 8px;\n}\n\n.titlebar-title-140e5b86835d843d6f9a7c022dae1a3bf76fd116 {\n    display: flex;\n    justify-content: center;\n    flex-grow: 1;\n\n    cursor: move;\n}\n\n.titlebar-right-controls-b99876a673652ed87e84d15f17ba6f9b394c2846 {\n    display: flex;\n    align-items: center;\n}\n\n.titlebar-button-2acc5baf768eb39ffacca5d5359121c9ce7ee90f {\n    color: var(--foreground-color-58da031e86887b92a1feaf5e8052dd5c83e23b4d);\n    background: none;\n    border: none;\n    cursor: pointer;\n    padding: 0 12px;\n}\n\n.titlebar-button-2acc5baf768eb39ffacca5d5359121c9ce7ee90f::before {\n    color: var(--foreground-color-58da031e86887b92a1feaf5e8052dd5c83e23b4d);\n}\n\n.maximize-toggle-button-7fa903373c55bc3db348e90f211001c4f117f7d1::before {\n    content: "\u25A1";\n}\n\n.maximized-153d4ccb93d0dc13d48f201dd533f39d0bbc8ced .maximize-toggle-button-7fa903373c55bc3db348e90f211001c4f117f7d1::before {\n    content: "\u2750";\n}\n\n.minimize-toggle-button-bca3fbdc7dd23b6c26035e7111aeb869dd28182e::before {\n    content: "\uFF3F";\n}\n\n.minimized-b1fe5ca90f7af0d447dd92c120b85309a6bffdfe .minimize-toggle-button-bca3fbdc7dd23b6c26035e7111aeb869dd28182e::before {\n    content: "\u2750";\n}\n\n.minimized-b1fe5ca90f7af0d447dd92c120b85309a6bffdfe .titlebar-button-2acc5baf768eb39ffacca5d5359121c9ce7ee90f:not(.minimize-toggle-button-bca3fbdc7dd23b6c26035e7111aeb869dd28182e) {\n    display: none;\n}\n\n.inner-container-606dc1192fb95b445129198ee621c32f887ea204 {\n    flex-grow: 1;\n    overflow: auto;\n}\n\n.minimized-b1fe5ca90f7af0d447dd92c120b85309a6bffdfe .inner-container-606dc1192fb95b445129198ee621c32f887ea204 {\n    display: none;\n}\n';
  var variables = {
    "--initial-height": "--initial-height-495e116479cd0a7f6c7e692d6f9bdccbce49be36",
    "--initial-width": "--initial-width-34ea83cc4f4c691432fc64a891f4be0f53ecd5fa",
    "--border-radius": "--border-radius-e5129cde634ebedc5b44d3c50a36d58b65129a1e",
    "--drag-top": "--drag-top-737ad0c0838ca0307f6d25b24cebb7846196db72",
    "--drag-left": "--drag-left-0481d18ee27dc8bdf676134913f1eab609bbb7f7",
    "--foreground-color": "--foreground-color-58da031e86887b92a1feaf5e8052dd5c83e23b4d",
    "--external-foreground-color": "--external-foreground-color-5de188c61cf6701393a6300181cad2c723ea246c",
    "--background-color": "--background-color-b3200fc721c2f9f2b2d7b295b0ef23343df6f092",
    "--external-background-color": "--external-background-color-bb20739c0fcb55a95dfe902adb5bd01a0380425f"
  };
  var dialog_default = {
    dialog: "dialog-59a53fe03e3575e542ce8529fd0df0730794d761",
    maximized: "maximized-153d4ccb93d0dc13d48f201dd533f39d0bbc8ced",
    minimized: "minimized-b1fe5ca90f7af0d447dd92c120b85309a6bffdfe",
    titlebar: "titlebar-77f4f2a0b714f05efd6878ddb3f8362533a260f1",
    "titlebar-icon": "titlebar-icon-412b1d35c34f2f49f26bd6a3dc81001c27e0fe4b",
    "titlebar-title": "titlebar-title-140e5b86835d843d6f9a7c022dae1a3bf76fd116",
    "titlebar-right-controls": "titlebar-right-controls-b99876a673652ed87e84d15f17ba6f9b394c2846",
    "titlebar-button": "titlebar-button-2acc5baf768eb39ffacca5d5359121c9ce7ee90f",
    "maximize-toggle-button": "maximize-toggle-button-7fa903373c55bc3db348e90f211001c4f117f7d1",
    "minimize-toggle-button": "minimize-toggle-button-bca3fbdc7dd23b6c26035e7111aeb869dd28182e",
    "inner-container": "inner-container-606dc1192fb95b445129198ee621c32f887ea204"
  };

  // source/document-jsx/jsx-runtime.ts
  function jsxs(name, properties, _option) {
    if (name === Fragment) {
      return createFragment(
        properties.children
      );
    }
    const element = document.createElement(name);
    for (const [key, value] of Object.entries(properties ?? {})) {
      if (key === "children") continue;
      if (key.startsWith("on") && typeof value === "function") {
        const eventName = key.substring(2).toLowerCase();
        element.addEventListener(eventName, value);
        continue;
      }
      if (key === "style" && typeof value === "function") {
        value(element.style);
        continue;
      }
      if (key === "classList" && value) {
        const classes = Array.isArray(value) ? value : [value];
        for (const c of classes) {
          if (typeof c === "string" && c) {
            element.classList.add(c);
          }
        }
        continue;
      }
      if (value !== void 0 && value !== null) {
        element.setAttribute(key, String(value));
      }
    }
    const children = properties?.children;
    if (children) {
      if (Array.isArray(children)) {
        for (const child of children) {
          if (!child) continue;
          element.append(child);
        }
      } else {
        element.append(children);
      }
    }
    return element;
  }
  var jsx = jsxs;
  var Fragment = /* @__PURE__ */ Symbol("Fragment");
  function createFragment(children) {
    const fragment = document.createDocumentFragment();
    if (children != null) {
      if (Array.isArray(children)) {
        for (const child of children) {
          fragment.appendChild(child);
        }
      } else {
        fragment.appendChild(children);
      }
    }
    return fragment;
  }

  // source/drafts-view/dialog.tsx
  function makeDraggable(element, handleElement = element, options) {
    let offsetX = 0, offsetY = 0;
    function setPosition(left, top) {
      const rect = element.getBoundingClientRect();
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      left = Math.max(0, Math.min(left, windowWidth - rect.width));
      top = Math.max(0, Math.min(top, windowHeight - rect.height));
      if (options?.propertyNames) {
        const { left: leftName, top: topName } = options.propertyNames;
        element.style.setProperty(leftName, `${left}px`);
        element.style.setProperty(topName, `${top}px`);
      } else {
        element.style.left = `${left}px`;
        element.style.top = `${top}px`;
      }
    }
    const onPointerMove = (e) => {
      setPosition(e.clientX - offsetX, e.clientY - offsetY);
    };
    handleElement.addEventListener("pointerdown", (e) => {
      handleElement.addEventListener("pointermove", onPointerMove);
      handleElement.setPointerCapture(e.pointerId);
      offsetX = e.clientX - element.offsetLeft;
      offsetY = e.clientY - element.offsetTop;
    });
    handleElement.addEventListener("pointerup", (e) => {
      handleElement.removeEventListener("pointermove", onPointerMove);
      handleElement.releasePointerCapture(e.pointerId);
    });
    function adjustSize() {
      const rect = element.getBoundingClientRect();
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      if (rect.width > windowWidth) {
        element.style.width = `${windowWidth}px`;
      }
      if (rect.height > windowHeight) {
        element.style.height = `${windowHeight}px`;
      }
      setPosition(rect.left, rect.top);
    }
    window.addEventListener("resize", adjustSize);
    adjustSize();
  }
  var setStyle2 = styleSetter(cssText2);
  function createDialog(innerElement, options) {
    setStyle2();
    const titleSpan = /* @__PURE__ */ jsx("div", { class: dialog_default["titlebar-title"], children: options?.title ?? "" });
    const dialogElement = /* @__PURE__ */ jsxs("div", { class: dialog_default["dialog"], children: [
      /* @__PURE__ */ jsxs(
        "div",
        {
          class: dialog_default["titlebar"],
          ondblclick: toggleMaximizedState,
          children: [
            titleSpan,
            /* @__PURE__ */ jsxs("div", { class: dialog_default["titlebar-right-controls"], children: [
              /* @__PURE__ */ jsx(
                "button",
                {
                  classList: [
                    dialog_default["titlebar-button"],
                    dialog_default["minimize-toggle-button"]
                  ],
                  title: "minimize",
                  onclick: toggleMinimizedState
                }
              ),
              /* @__PURE__ */ jsx(
                "button",
                {
                  classList: [
                    dialog_default["titlebar-button"],
                    dialog_default["maximize-toggle-button"]
                  ],
                  title: "maximize",
                  onclick: toggleMaximizedState
                }
              ),
              /* @__PURE__ */ jsx(
                "button",
                {
                  class: dialog_default["titlebar-button"],
                  title: "close",
                  onclick: hide,
                  children: "\xD7"
                }
              )
            ] })
          ]
        }
      ),
      /* @__PURE__ */ jsx("div", { class: dialog_default["inner-container"], children: innerElement })
    ] });
    makeDraggable(dialogElement, titleSpan, {
      propertyNames: {
        left: variables["--drag-left"],
        top: variables["--drag-top"]
      }
    });
    function show() {
      document.body.appendChild(dialogElement);
    }
    function hide() {
      document.body.removeChild(dialogElement);
    }
    function toggleMaximizedState() {
      dialogElement.classList.remove(dialog_default["minimized"]);
      dialogElement.classList.toggle(dialog_default["maximized"]);
    }
    function toggleMinimizedState() {
      dialogElement.classList.remove(dialog_default["maximized"]);
      dialogElement.classList.toggle(dialog_default["minimized"]);
    }
    return {
      show,
      hide,
      element: dialogElement,
      setTitle(title) {
        titleSpan.innerHTML = "";
        titleSpan.append(title);
      },
      setForegroundColor(cssColorText) {
        dialogElement.style.setProperty(
          variables["--external-foreground-color"],
          cssColorText
        );
      },
      setBackgroundColor(cssColorText) {
        dialogElement.style.setProperty(
          variables["--external-background-color"],
          cssColorText
        );
      }
    };
  }

  // source/drafts-view/draft-list.module.css
  var cssText3 = ':root {\n    --border-color-40d85bb0a4cd9e18e1675213e27926067e14ec44: #ccc;\n    --selected-background-color-15395d257dc2a9dbc4d35bf4e8636decf66fb580: #2563eb;\n    --selected-text-color-2fafe4abcba384c428e6663a12c8ebcb4becf7c4: #fff;\n    --text-muted-e054f4904a1b966f2001aa63511aed50f1a7eb4b: #666;\n    --background-color-light-f43ca1891bfeb3b68364b309b269e758feb5983e: #f8f9fa;\n    --primary-color-5bcad8b481171789894dde44ae88f0732a00a933: #2563eb;\n    --primary-color-dark-f1398bfd0df9f9d323d5b8be1e96aa7944a782d3: #0056b3;\n}\n\n.container-d616a65ee94eb3e65d06174907e8ea47361d285e {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n}\n\n.input-field-0f1ad47e6e58c954331ca21516ad3a9658f81d2d {\n    border: 1px solid;\n    border-color: rgba(255, 255, 255, 0.514) rgba(255, 255, 255, 0.726) white;\n    background-color: rgba(255, 255, 255, 0.25);\n    outline: none;\n}\n\n.input-field-0f1ad47e6e58c954331ca21516ad3a9658f81d2d:focus {\n    background-color: #ffffff;\n    border-color: #cbd5e1;\n    box-shadow: 0 0 0 3px rgba(203, 213, 225, 0.35);\n}\n\n.input-error-599c6c6df62264a0a1d2659fb5c9b7420f2c5b1a {\n    border: 1px solid red;\n}\n\n.list-container-83113acafdacffc7acf580cacc0ff14397b9275b {\n    flex-grow: 1;\n    overflow-y: auto;\n    border: 1px solid var(--border-color-40d85bb0a4cd9e18e1675213e27926067e14ec44);\n    border-radius: 4px;\n}\n\n.item-37e25f2b2abeb01ef28100917b7d3a0587af5e2f {\n    height: 100%;\n    display: flex;\n    align-items: center;\n    flex-grow: 1;\n    min-width: 0;\n    padding: 4px;\n    border-bottom: 1px solid var(--border-color-40d85bb0a4cd9e18e1675213e27926067e14ec44);\n    cursor: pointer;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n\n.item-37e25f2b2abeb01ef28100917b7d3a0587af5e2f:last-child {\n    border-bottom: none;\n}\n\n.item-37e25f2b2abeb01ef28100917b7d3a0587af5e2f.selected-e87247b5a5cfd84b8e590c984f8df84a31990d3a {\n    background-color: var(--selected-background-color-15395d257dc2a9dbc4d35bf4e8636decf66fb580);\n    color: var(--selected-text-color-2fafe4abcba384c428e6663a12c8ebcb4becf7c4);\n}\n\n.item-37e25f2b2abeb01ef28100917b7d3a0587af5e2f.selected-e87247b5a5cfd84b8e590c984f8df84a31990d3a .item-note-325785ce02e5733f3b97abf9c4719f0032b08735 {\n    color: var(--selected-text-color-2fafe4abcba384c428e6663a12c8ebcb4becf7c4);\n}\n\n.item-name-90a023abd12df4503fcbdd00805349cbd8befdf2 {\n    font-weight: bold;\n    flex-shrink: 0;\n    margin-right: 4px;\n}\n\n.item-note-325785ce02e5733f3b97abf9c4719f0032b08735 {\n    font-size: 0.8em;\n    color: var(--text-muted-e054f4904a1b966f2001aa63511aed50f1a7eb4b);\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.detail-pane-a8d855bbdd738b9c86079022d60a620d9a5a4fb9 {\n    box-shadow: 0px 0px 4px 0px rgba(0, 0, 0, 0.5);\n    border: 1px solid var(--border-color-40d85bb0a4cd9e18e1675213e27926067e14ec44);\n    border-radius: 4px;\n    flex-shrink: 0;\n    padding: 0;\n}\n\n.detail-summary-d29161e7893ffbf485c82b4a3c9d703838e80ce6 {\n    list-style: none;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    cursor: pointer;\n    padding: 16px;\n}\n\n/* Webkit\u30D6\u30E9\u30A6\u30B6\u306E\u30C7\u30D5\u30A9\u30EB\u30C8\u30DE\u30FC\u30AB\u30FC\u3092\u975E\u8868\u793A\u306B\u3059\u308B */\n.detail-summary-d29161e7893ffbf485c82b4a3c9d703838e80ce6::-webkit-details-marker {\n    display: none;\n}\n\n/* \u9589\u3058\u305F\u3068\u304D\u306E\u30A2\u30A4\u30B3\u30F3 */\n.detail-summary-d29161e7893ffbf485c82b4a3c9d703838e80ce6::after {\n    content: "+";\n    font-size: 1.5em;\n    line-height: 1;\n    margin-left: 10px;\n}\n\n/* \u958B\u3044\u305F\u3068\u304D\u306E\u30A2\u30A4\u30B3\u30F3 */\n.detail-pane-a8d855bbdd738b9c86079022d60a620d9a5a4fb9[open] > .detail-summary-d29161e7893ffbf485c82b4a3c9d703838e80ce6::after {\n    content: "\u2212";\n}\n\n.detail-name-3f57af7f77d5d8f8aec7751a1a233375ac2c0598 {\n    flex-grow: 1;\n    font-size: 1.2em;\n    font-weight: bold;\n    margin-bottom: 0;\n}\n\n.detail-description-254fb1e1ae0cdc0f865d95ae463db64d2867ec52,\n.detail-note-733aa354e8cd8b62b720404353736b49ef0cc57d,\n.detail-coordinates-91eda1507122fc7266e8a73f8c592295e4da8bca {\n    margin-bottom: 4px;\n    padding: 0;\n    width: 100%;\n    box-sizing: border-box;\n}\n\n.detail-content-wrapper-d078eaeb8bd5e4f289484bc4bc835c8dd8ade5c0 {\n    padding: 0 16px 16px 16px;\n    display: flex;\n    flex-wrap: wrap;\n    gap: 8px;\n}\n\n.coordinates-container-f262f03ca4b1310e60e0588a145d7845d604051d {\n    display: flex;\n    width: 100%;\n    gap: 4px;\n}\n\n.detail-coordinates-91eda1507122fc7266e8a73f8c592295e4da8bca {\n    flex-grow: 1;\n}\n\n.open-map-button-d0469846eff8ab2c5bbbf8279fe8939e10807acb {\n    padding: 4px;\n    border: none;\n    border-radius: 4px;\n    background-color: var(--primary-color-5bcad8b481171789894dde44ae88f0732a00a933);\n    color: white;\n    cursor: pointer;\n}\n\n.open-map-button-d0469846eff8ab2c5bbbf8279fe8939e10807acb:hover {\n    background-color: var(--primary-color-dark-f1398bfd0df9f9d323d5b8be1e96aa7944a782d3);\n}\n\n.map-button-1746b9bfb3076b8c29a3974dd83457a853c70236,\n.create-button-67f1537ff4fdf26ca6cfb4d6f15c201ad15e5e6d,\n.delete-button-ff6b0a755638b349e9da00f921a2056e31592ac4,\n.template-button-3d054d6b00ab67976c9b50498ca799ae22db71ca,\n.config-button-e520a405714cc54cc83204febea7e8f1e108cd20 {\n    margin-top: 8px;\n    padding: 8px 12px;\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n}\n\n.map-button-1746b9bfb3076b8c29a3974dd83457a853c70236,\n.create-button-67f1537ff4fdf26ca6cfb4d6f15c201ad15e5e6d,\n.template-button-3d054d6b00ab67976c9b50498ca799ae22db71ca,\n.config-button-e520a405714cc54cc83204febea7e8f1e108cd20 {\n    background-color: var(--primary-color-5bcad8b481171789894dde44ae88f0732a00a933);\n}\n\n.map-button-1746b9bfb3076b8c29a3974dd83457a853c70236:hover,\n.create-button-67f1537ff4fdf26ca6cfb4d6f15c201ad15e5e6d:hover,\n.template-button-3d054d6b00ab67976c9b50498ca799ae22db71ca:hover,\n.config-button-e520a405714cc54cc83204febea7e8f1e108cd20:hover {\n    background-color: var(--primary-color-dark-f1398bfd0df9f9d323d5b8be1e96aa7944a782d3);\n}\n\n.delete-button-ff6b0a755638b349e9da00f921a2056e31592ac4 {\n    background-color: #dc3545;\n}\n\n.delete-button-ff6b0a755638b349e9da00f921a2056e31592ac4:hover {\n    background-color: #c82333;\n}\n\n.template-button-3d054d6b00ab67976c9b50498ca799ae22db71ca.is-template-a08083e78a7a21d71d45b82e8a7d612af147b55c {\n    background-color: #28a745;\n}\n\n.template-button-3d054d6b00ab67976c9b50498ca799ae22db71ca.is-template-a08083e78a7a21d71d45b82e8a7d612af147b55c:hover {\n    background-color: #218838;\n}\n\n.input-error-599c6c6df62264a0a1d2659fb5c9b7420f2c5b1a {\n    border: 1px solid red;\n    background-color: #c82333;\n}\n';
  var draft_list_default = {
    container: "container-d616a65ee94eb3e65d06174907e8ea47361d285e",
    "input-field": "input-field-0f1ad47e6e58c954331ca21516ad3a9658f81d2d",
    "input-error": "input-error-599c6c6df62264a0a1d2659fb5c9b7420f2c5b1a",
    "list-container": "list-container-83113acafdacffc7acf580cacc0ff14397b9275b",
    item: "item-37e25f2b2abeb01ef28100917b7d3a0587af5e2f",
    selected: "selected-e87247b5a5cfd84b8e590c984f8df84a31990d3a",
    "item-note": "item-note-325785ce02e5733f3b97abf9c4719f0032b08735",
    "item-name": "item-name-90a023abd12df4503fcbdd00805349cbd8befdf2",
    "detail-pane": "detail-pane-a8d855bbdd738b9c86079022d60a620d9a5a4fb9",
    "detail-summary": "detail-summary-d29161e7893ffbf485c82b4a3c9d703838e80ce6",
    "detail-name": "detail-name-3f57af7f77d5d8f8aec7751a1a233375ac2c0598",
    "detail-description": "detail-description-254fb1e1ae0cdc0f865d95ae463db64d2867ec52",
    "detail-note": "detail-note-733aa354e8cd8b62b720404353736b49ef0cc57d",
    "detail-coordinates": "detail-coordinates-91eda1507122fc7266e8a73f8c592295e4da8bca",
    "detail-content-wrapper": "detail-content-wrapper-d078eaeb8bd5e4f289484bc4bc835c8dd8ade5c0",
    "coordinates-container": "coordinates-container-f262f03ca4b1310e60e0588a145d7845d604051d",
    "open-map-button": "open-map-button-d0469846eff8ab2c5bbbf8279fe8939e10807acb",
    "map-button": "map-button-1746b9bfb3076b8c29a3974dd83457a853c70236",
    "create-button": "create-button-67f1537ff4fdf26ca6cfb4d6f15c201ad15e5e6d",
    "delete-button": "delete-button-ff6b0a755638b349e9da00f921a2056e31592ac4",
    "template-button": "template-button-3d054d6b00ab67976c9b50498ca799ae22db71ca",
    "config-button": "config-button-e520a405714cc54cc83204febea7e8f1e108cd20",
    "is-template": "is-template-a08083e78a7a21d71d45b82e8a7d612af147b55c"
  };

  // source/drafts-view/virtual-list.module.css
  var cssText4 = ".list-window-bcd08fce6b1a595356880a5a598137912e379aee {\n    height: 100%;\n    overflow: auto;\n}\n\n.list-spacer-32059099ba781e882b7ae69bcd971a9b66d151a8 {\n    box-sizing: border-box;\n    height: var(--list-height-601758becf7d7867f70930534784cc2ddcc8fb22);\n    padding-top: var(--list-offset-top-fcb56bf845280fbeb22cda5501878b68a331e405);\n}\n\n.list-fffb82a022c6017f97dfdac45113ef61fa81fe9c {\n    list-style-type: none;\n    margin: 0;\n    padding: 0;\n}\n\n.item-519dd442a3657bdc57c1e482401f339cee8003a2 {\n    height: var(--item-height-c5da2f0d91ae8c90a7f14e92fce1ba40bfd0b3ec);\n}\n";
  var variables2 = {
    "--list-height": "--list-height-601758becf7d7867f70930534784cc2ddcc8fb22",
    "--list-offset-top": "--list-offset-top-fcb56bf845280fbeb22cda5501878b68a331e405",
    "--item-height": "--item-height-c5da2f0d91ae8c90a7f14e92fce1ba40bfd0b3ec"
  };
  var virtual_list_default = {
    "list-window": "list-window-bcd08fce6b1a595356880a5a598137912e379aee",
    "list-spacer": "list-spacer-32059099ba781e882b7ae69bcd971a9b66d151a8",
    list: "list-fffb82a022c6017f97dfdac45113ef61fa81fe9c",
    item: "item-519dd442a3657bdc57c1e482401f339cee8003a2"
  };

  // source/drafts-view/virtual-list.tsx
  var setStyle3 = styleSetter(cssText4);
  function createEmptyElements() {
    return {
      itemHeight: 0,
      count: 0,
      get() {
        return void 0;
      }
    };
  }
  function createVirtualList() {
    setStyle3();
    const list = /* @__PURE__ */ jsx("ul", { class: virtual_list_default["list"] });
    const listSpacer = /* @__PURE__ */ jsx("div", { class: virtual_list_default["list-spacer"], children: list });
    const listWindow = /* @__PURE__ */ jsx("div", { class: virtual_list_default["list-window"], onscroll: update, children: listSpacer });
    let items = createEmptyElements();
    let redrawRequested = true;
    let lastStart = null;
    let lastCount = null;
    function update() {
      const { scrollTop, offsetHeight: windowHeight } = listWindow;
      const { itemHeight, count: itemCount } = items;
      const start = Math.floor(scrollTop / itemHeight);
      const count = Math.min(
        itemCount,
        Math.ceil((scrollTop + windowHeight) / itemHeight)
      ) - start;
      redrawRequested = redrawRequested || lastStart !== start || lastCount !== count;
      lastStart = start;
      lastCount = count;
      if (!redrawRequested) return;
      redrawRequested = false;
      list.innerHTML = "";
      for (let i = 0; i < count; i++) {
        list.append(
          /* @__PURE__ */ jsx("li", { class: virtual_list_default.item, children: items.get(start + i) })
        );
      }
      listWindow.style.setProperty(
        variables2["--item-height"],
        itemHeight + "px"
      );
      listWindow.style.setProperty(
        variables2["--list-height"],
        itemHeight * itemCount + "px"
      );
      listWindow.style.setProperty(
        variables2["--list-offset-top"],
        start * itemHeight + "px"
      );
    }
    function setItems(newItems) {
      items = newItems;
      redrawRequested = true;
      return update();
    }
    new ResizeObserver((entries) => {
      for (const _ of entries) void update();
    }).observe(listWindow);
    return {
      element: listWindow,
      setItems
    };
  }

  // source/draft.ts
  function setDraftIsTemplate(draft, isTemplate) {
    draft.data["isTemplate"] = isTemplate || void 0;
  }
  function getDraftIsTemplate(draft) {
    return draft.data["isTemplate"] === true;
  }
  function pad2(value) {
    return ("00" + value).slice(-2);
  }
  function getIsoTodayString(date) {
    const yyyy = date.getFullYear();
    const mm = pad2(date.getMonth() + 1);
    const dd = pad2(date.getDate());
    return `${yyyy}-${mm}-${dd}`;
  }
  function getIsoTimeString(date) {
    const hours = pad2(date.getHours());
    const minutes = pad2(date.getMinutes());
    const seconds = pad2(date.getSeconds());
    return `${hours}:${minutes}:${seconds}`;
  }
  function getIsoTimeZoneString(date) {
    const offset = -date.getTimezoneOffset();
    const sign = offset >= 0 ? "+" : "-";
    const hours = pad2(offset / 60);
    const minutes = pad2(offset % 60);
    return `${sign}${hours}:${minutes}`;
  }
  function getIsoDateTimeString(date, withTimeZone = false) {
    return `${getIsoTodayString(date)}T${getIsoTimeString(date)}${withTimeZone ? getIsoTimeZoneString(date) : ""}`;
  }
  function resolveStandardVariable(name) {
    switch (name) {
      case "today":
        return getIsoTodayString(/* @__PURE__ */ new Date());
      case "now":
        return getIsoDateTimeString(/* @__PURE__ */ new Date());
      case "nowWithTimeZone":
        return getIsoDateTimeString(/* @__PURE__ */ new Date(), true);
    }
  }
  var interpolationPattern = /\\\(\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)/g;
  function applyTemplate(template, resolve) {
    return template.replace(
      interpolationPattern,
      (interpolation, variableName) => resolve?.(variableName) ?? resolveStandardVariable(variableName) ?? interpolation
    );
  }

  // source/local-config-view/local-config-view.module.css
  var cssText5 = ".container-f1dab241a09bb3df58f56a71a1860677b51f2515 {\n    box-sizing: border-box;\n}\n\n.container-f1dab241a09bb3df58f56a71a1860677b51f2515 {\n    width: 100%;\n    height: 100%;\n    padding: 24px;\n    color: #1f2937;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.form-scroll-2e3ac2fd8bc51e6f171db04ef7d943ff85b90020 {\n    overflow-y: auto;\n    padding-right: 4px;\n    margin-right: -4px;\n    flex: 1 1 auto;\n}\n\n.status-message-c256dff5faa609e9d6ec55dc16d17267529c8bdc {\n    margin-top: auto;\n    font-size: 13px;\n    color: #6b7280;\n    padding-top: 10px;\n    border-radius: 8px;\n    transition:\n        background-color 0.2s ease,\n        color 0.2s ease,\n        border-color 0.2s ease;\n}\n\n.status-message-c256dff5faa609e9d6ec55dc16d17267529c8bdc.success-2e73314ef49e2ec643b73bff4583ac0097498f92 {\n    color: #065f46;\n    background-color: #ecfdf5;\n    border: 1px solid #a7f3d0;\n    padding: 10px 12px;\n}\n\n.status-message-c256dff5faa609e9d6ec55dc16d17267529c8bdc.error-683e02068e71c66e6211aa9a1b8738688ff5ad26 {\n    color: #7f1d1d;\n    background-color: #fef2f2;\n    border: 1px solid #fecaca;\n    padding: 10px 12px;\n}\n";
  var local_config_view_default = {
    container: "container-f1dab241a09bb3df58f56a71a1860677b51f2515",
    "form-scroll": "form-scroll-2e3ac2fd8bc51e6f171db04ef7d943ff85b90020",
    "status-message": "status-message-c256dff5faa609e9d6ec55dc16d17267529c8bdc",
    success: "success-2e73314ef49e2ec643b73bff4583ac0097498f92",
    error: "error-683e02068e71c66e6211aa9a1b8738688ff5ad26"
  };

  // source/local-config-view/item-input.module.css
  var cssText6 = ".form-group-e5a3430126ab0369fd7ee8a6a30580ffad360df7 {\n    width: 100%;\n    margin-bottom: 18px;\n    display: flex;\n    flex-direction: column;\n    flex-shrink: 0;\n}\n\n.form-group-e5a3430126ab0369fd7ee8a6a30580ffad360df7 {\n    width: 100%;\n    margin-bottom: 18px;\n    display: flex;\n    flex-direction: column;\n    flex-shrink: 0;\n}\n\n.label-5d97d2385d3fe4f8201f867470d9a372143c929f {\n    font-size: 13px;\n    font-weight: 500;\n    margin-bottom: 6px;\n    color: #374151;\n}\n\n.input-d67df4267ce56bfa6a39eaade32c4f8c68e12ce0,\n.textarea-f6272e46e885340c7cfafd8e922bfd093e4269d4 {\n    width: 100%;\n    border: 1px solid #e5e7eb;\n    background-color: #ffffff;\n    border-radius: 8px;\n    padding: 10px 12px;\n    font-size: 14px;\n    color: #111827;\n    outline: none;\n    transition:\n        border-color 0.2s ease,\n        box-shadow 0.2s ease;\n}\n\n.input-d67df4267ce56bfa6a39eaade32c4f8c68e12ce0:focus,\n.textarea-f6272e46e885340c7cfafd8e922bfd093e4269d4:focus {\n    border-color: #cbd5e1;\n    box-shadow: 0 0 0 3px rgba(203, 213, 225, 0.35);\n}\n\n.checkbox-40de0e9fd90c64b05aa39b0981eff0ac2c2c3b16 {\n    width: 16px;\n    height: 16px;\n    margin-right: 8px;\n    vertical-align: middle;\n}\n\n.textarea-f6272e46e885340c7cfafd8e922bfd093e4269d4 {\n    min-height: 120px;\n    resize: vertical;\n    line-height: 1.5;\n}\n";
  var item_input_default = {
    "form-group": "form-group-e5a3430126ab0369fd7ee8a6a30580ffad360df7",
    label: "label-5d97d2385d3fe4f8201f867470d9a372143c929f",
    input: "input-d67df4267ce56bfa6a39eaade32c4f8c68e12ce0",
    textarea: "textarea-f6272e46e885340c7cfafd8e922bfd093e4269d4",
    checkbox: "checkbox-40de0e9fd90c64b05aa39b0981eff0ac2c2c3b16"
  };

  // source/local-config-view/item-input-string.tsx
  var setStyle4 = styleSetter(cssText6);
  function createStringItemInput(label) {
    setStyle4();
    const events = createTypedEventTarget();
    const dispatchChanged = () => events.dispatchEvent(createTypedCustomEvent("changed", void 0));
    const input = /* @__PURE__ */ jsx(
      "input",
      {
        type: "text",
        class: item_input_default["input"],
        oninput: dispatchChanged
      }
    );
    const enabledCheckbox = /* @__PURE__ */ jsx(
      "input",
      {
        type: "checkbox",
        class: item_input_default["checkbox"],
        onchange: () => {
          const isChecked = enabledCheckbox.checked;
          input.disabled = !isChecked;
          inputContainer.style.display = isChecked ? "" : "none";
          dispatchChanged();
        }
      }
    );
    const inputContainer = /* @__PURE__ */ jsx("div", { class: item_input_default["form-group"], children: /* @__PURE__ */ jsx("label", { class: item_input_default["label"], children: input }) });
    const element = /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx("div", { class: item_input_default["form-group"], children: /* @__PURE__ */ jsxs("label", { class: item_input_default["label"], children: [
        enabledCheckbox,
        /* @__PURE__ */ jsx("span", { children: label })
      ] }) }),
      inputContainer
    ] });
    function setValue(value) {
      const hasUserId = value !== void 0;
      enabledCheckbox.checked = hasUserId;
      input.disabled = !hasUserId;
      inputContainer.style.display = hasUserId ? "" : "none";
      input.value = hasUserId ? value : "";
    }
    function getValue2() {
      if (enabledCheckbox.checked) {
        return input.value;
      }
    }
    return {
      element,
      events,
      setValue,
      getValue: getValue2
    };
  }

  // source/local-config-view/item-input-json.tsx
  var setStyle5 = styleSetter(cssText6);
  function createJsonItemInput(label) {
    setStyle5();
    const events = createTypedEventTarget();
    const dispatchChange = () => events.dispatchEvent(createTypedCustomEvent("changed", void 0));
    const textarea = /* @__PURE__ */ jsx(
      "textarea",
      {
        class: item_input_default["textarea"],
        oninput: dispatchChange
      }
    );
    const enabledCheckbox = /* @__PURE__ */ jsx(
      "input",
      {
        type: "checkbox",
        class: item_input_default["checkbox"],
        onchange: () => {
          const isChecked = enabledCheckbox.checked;
          textarea.disabled = !isChecked;
          inputContainer.style.display = isChecked ? "" : "none";
          dispatchChange();
        }
      }
    );
    const inputContainer = /* @__PURE__ */ jsx("div", { class: item_input_default["form-group"], children: /* @__PURE__ */ jsx("label", { class: item_input_default["label"], children: textarea }) });
    const element = /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx("div", { class: item_input_default["form-group"], children: /* @__PURE__ */ jsxs("label", { class: item_input_default["label"], children: [
        enabledCheckbox,
        /* @__PURE__ */ jsx("span", { children: label })
      ] }) }),
      inputContainer
    ] });
    function setValue(value) {
      const hasValue = value !== void 0;
      enabledCheckbox.checked = hasValue;
      textarea.disabled = !hasValue;
      inputContainer.style.display = hasValue ? "" : "none";
      textarea.value = hasValue ? JSON.stringify(value, null, 2) : "";
    }
    function getValue2() {
      if (enabledCheckbox.checked) {
        try {
          const parsedJson = JSON.parse(textarea.value);
          return parsedJson;
        } catch {
          throw new Error("Invalid JSON. Please check the syntax.");
        }
      }
    }
    return {
      element,
      events,
      setValue,
      getValue: getValue2
    };
  }

  // source/local-config-view/local-config-view.tsx
  var setStyle6 = styleSetter(cssText5);
  function debounce(f, ms) {
    let timeout;
    const debounced = (...args) => {
      if (timeout !== void 0) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(() => {
        timeout = void 0;
        f(...args);
      }, ms);
    };
    const cancel = () => {
      if (timeout !== void 0) {
        clearTimeout(timeout);
        timeout = void 0;
      }
    };
    return {
      debounced,
      cancel
    };
  }
  function createLocalConfigView(configAccessor) {
    setStyle6();
    const userIdInput = createStringItemInput("User ID");
    const apiRootInput = createStringItemInput("API Root");
    const dictionariesInput = createJsonItemInput("Dictionaries(JSON)");
    const statusMessageElement = /* @__PURE__ */ jsx("div", { class: local_config_view_default["status-message"], children: "Loading configuration..." });
    const element = /* @__PURE__ */ jsxs("div", { class: local_config_view_default["container"], children: [
      /* @__PURE__ */ jsxs("div", { class: local_config_view_default["form-scroll"], children: [
        userIdInput.element,
        apiRootInput.element,
        dictionariesInput.element
      ] }),
      statusMessageElement
    ] });
    const loadConfig = () => {
      const currentConfig = configAccessor.getConfig();
      userIdInput.setValue(currentConfig.userId);
      apiRootInput.setValue(currentConfig.apiRoot);
      dictionariesInput.setValue(currentConfig.dictionaries);
    };
    const { debounced: saveConfig } = debounce(() => {
      statusMessageElement.textContent = "Changes pending...";
      statusMessageElement.className = local_config_view_default["status-message"];
      try {
        let newConfig = configAccessor.getConfig();
        newConfig = { ...newConfig, userId: userIdInput.getValue() };
        newConfig = { ...newConfig, apiRoot: apiRootInput.getValue() };
        newConfig = {
          ...newConfig,
          dictionaries: dictionariesInput.getValue()
        };
        configAccessor.schema.parse(newConfig);
        configAccessor.setConfig(newConfig);
        statusMessageElement.textContent = "Saved successfully!";
        statusMessageElement.classList.add(local_config_view_default.success);
      } catch (error) {
        let errorMessage = "Unknown error";
        if (error instanceof Error) {
          errorMessage = error.message;
        }
        statusMessageElement.textContent = `Error saving configuration: ${errorMessage}`;
        statusMessageElement.classList.add(local_config_view_default.error);
      }
    }, 500);
    userIdInput.events.addEventListener("changed", saveConfig);
    apiRootInput.events.addEventListener("changed", saveConfig);
    dictionariesInput.events.addEventListener("changed", saveConfig);
    loadConfig();
    return {
      element
    };
  }

  // source/drafts-view/query-view/filter-bar.module.css
  var cssText7 = ".wrapper-8bc4a3b3977b2502079737f94abf28c055aa3ed0 {\n    display: flex;\n    align-items: center;\n    border-radius: 14px;\n    box-shadow: 0 4px 14px rgba(0, 0, 0, 0.08);\n    padding: 6px 8px 6px 14px;\n    transition:\n        box-shadow 0.2s ease,\n        transform 0.15s ease;\n}\n\n.wrapper-8bc4a3b3977b2502079737f94abf28c055aa3ed0:focus-within {\n    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);\n    background: #ffffff;\n    transform: translateY(-1px);\n}\n\n.input-a3cd597a7edd16a5b8f98f87bf268700118ebc1b {\n    flex: 1;\n    border: none;\n    outline: none;\n    font-size: 15px;\n    padding: 10px 8px;\n    background: transparent;\n}\n\n.input-a3cd597a7edd16a5b8f98f87bf268700118ebc1b::placeholder {\n    color: #9aa0a6;\n}\n\n.buttons-8a3903d509aa03820963c9f588309b28f2a65315 {\n    display: flex;\n    gap: 6px;\n}\n\n.button-d9b4764b58f22085151b077b4baf95772b011154 {\n    border: none;\n    background: #f1f3f4;\n    border-radius: 10px;\n    padding: 8px 10px;\n    cursor: pointer;\n    font-size: 16px;\n    transition:\n        background 0.2s ease,\n        transform 0.1s ease;\n}\n\n.button-d9b4764b58f22085151b077b4baf95772b011154:hover {\n    background: #e3e6e8;\n}\n\n.button-d9b4764b58f22085151b077b4baf95772b011154:active {\n    transform: scale(0.96);\n}\n\n.clear-button-f08da52c4c717ecbc8c2fa8b108b7ed7028c62a6 {\n    border: none;\n    background: transparent;\n    border-radius: 50%;\n    padding: 4px;\n    margin: 0 4px;\n    cursor: pointer;\n    font-size: 14px;\n    color: #5f6368;\n    line-height: 1;\n    width: 24px;\n    height: 24px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.clear-button-f08da52c4c717ecbc8c2fa8b108b7ed7028c62a6:hover {\n    background: #f1f3f4;\n}\n\n.multi-line-indicator-4862b152d03b535aaca8b17d707c54068055edc2 {\n    margin-left: 5px;\n    font-weight: bold;\n    color: #888;\n}\n\n.hidden-19cdfb0022842aa1f15c1db445435adb67773ce5 {\n    display: none;\n}\n";
  var filter_bar_default = {
    wrapper: "wrapper-8bc4a3b3977b2502079737f94abf28c055aa3ed0",
    input: "input-a3cd597a7edd16a5b8f98f87bf268700118ebc1b",
    buttons: "buttons-8a3903d509aa03820963c9f588309b28f2a65315",
    button: "button-d9b4764b58f22085151b077b4baf95772b011154",
    "clear-button": "clear-button-f08da52c4c717ecbc8c2fa8b108b7ed7028c62a6",
    "multi-line-indicator": "multi-line-indicator-4862b152d03b535aaca8b17d707c54068055edc2",
    hidden: "hidden-19cdfb0022842aa1f15c1db445435adb67773ce5"
  };

  // source/drafts-view/query-view/filter-bar.tsx
  var setStyle7 = styleSetter(cssText7);
  function createFilterBar({ value: initialValue }) {
    setStyle7();
    const events = createTypedEventTarget();
    const input = /* @__PURE__ */ jsx(
      "input",
      {
        type: "text",
        oninput: onInput,
        classList: [filter_bar_default.input],
        placeholder: "\u{1F50D}\u30AD\u30FC\u30EF\u30FC\u30C9\u3067\u7D5E\u308A\u8FBC\u307F\u2026"
      }
    );
    const clearButton = /* @__PURE__ */ jsx(
      "button",
      {
        classList: [filter_bar_default["clear-button"], filter_bar_default.hidden],
        onclick: onClickClear,
        "aria-label": "\u691C\u7D22\u30EF\u30FC\u30C9\u3092\u524A\u9664",
        children: "\u2715"
      }
    );
    const multiLineIndicator = /* @__PURE__ */ jsx(
      "span",
      {
        classList: [filter_bar_default["multi-line-indicator"], filter_bar_default.hidden],
        children: "..."
      }
    );
    const element = /* @__PURE__ */ jsxs("div", { classList: [filter_bar_default.wrapper], children: [
      input,
      clearButton,
      multiLineIndicator,
      /* @__PURE__ */ jsxs("div", { class: filter_bar_default.buttons, children: [
        /* @__PURE__ */ jsx(
          "button",
          {
            class: filter_bar_default.button,
            onclick: () => {
              events.dispatchEvent(
                createTypedCustomEvent(
                  "click-list-button",
                  void 0
                )
              );
            },
            "aria-label": "\u691C\u7D22\u5F0F\u4E00\u89A7",
            children: "\u{1F4C2}"
          }
        ),
        /* @__PURE__ */ jsx(
          "button",
          {
            class: filter_bar_default.button,
            onclick: () => {
              events.dispatchEvent(
                createTypedCustomEvent(
                  "click-edit-button",
                  void 0
                )
              );
            },
            "aria-label": "\u691C\u7D22\u5F0F\u3092\u7DE8\u96C6",
            children: "\u270F"
          }
        )
      ] })
    ] });
    let value = "";
    function getValue2() {
      const index = value.indexOf("\n");
      if (index < 0) return input.value;
      return input.value + "\n" + value.slice(index + 1);
    }
    function setValue(newValue) {
      value = newValue;
      const isMultiLine = newValue.includes("\n");
      if (isMultiLine) {
        multiLineIndicator.classList.remove(filter_bar_default.hidden);
      } else {
        multiLineIndicator.classList.add(filter_bar_default.hidden);
      }
      input.value = newValue.split("\n")[0] ?? "";
      updateClearButtonVisibility();
    }
    function updateClearButtonVisibility() {
      const isMultiLine = value.includes("\n");
      const hasValue = input.value.length > 0;
      if (!isMultiLine && hasValue) {
        clearButton.classList.remove(filter_bar_default.hidden);
      } else {
        clearButton.classList.add(filter_bar_default.hidden);
      }
    }
    function onInput() {
      events.dispatchEvent(
        createTypedCustomEvent("input-changed", void 0)
      );
      updateClearButtonVisibility();
    }
    function onClickClear() {
      setValue("");
      input.focus();
      events.dispatchEvent(
        createTypedCustomEvent("input-changed", void 0)
      );
    }
    setValue(initialValue);
    return { element, events, getValue: getValue2, setValue };
  }

  // source/drafts-view/query-view/source-list.module.css
  var cssText8 = ".wrapper-12ea3675915522e27cfe3356addfb9ac5a8e4fe2 {\r\n    flex: 1;\r\n    display: flex;\r\n    flex-direction: column;\r\n    height: 100%;\r\n}\r\n\r\n.item-6f81a84ee10d38ca107998be1d9a5cf01d0eed91 {\r\n    height: 100%;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: space-between;\r\n    padding: 12px 14px;\r\n    border-radius: 12px;\r\n    cursor: pointer;\r\n    user-select: none;\r\n    transition:\r\n        background 0.15s ease,\r\n        transform 0.05s ease;\r\n    font-size: 14px;\r\n}\r\n\r\n.item-6f81a84ee10d38ca107998be1d9a5cf01d0eed91:hover {\r\n    background: #f1f3f4;\r\n}\r\n\r\n.item-6f81a84ee10d38ca107998be1d9a5cf01d0eed91.active-5cfd7acb0e1f0f2c1ae1509ff7114f29aecf222b {\r\n    background: #e8f0fe;\r\n    font-weight: 600;\r\n}\r\n\r\n.item-6f81a84ee10d38ca107998be1d9a5cf01d0eed91:active {\r\n    transform: scale(0.98);\r\n}\r\n\r\n.item-label-aa6d3639738d866205ef3f6db063315d6b23659f {\r\n    pointer-events: none;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    white-space: nowrap;\r\n}\r\n\r\n.delete-button-04b39470f8b9cde6122641ba127dae02e389ce94 {\r\n    display: none;\r\n    border: none;\r\n    background: #ffdede;\r\n    color: #b00020;\r\n    border-radius: 8px;\r\n    padding: 4px 8px;\r\n    font-size: 12px;\r\n    cursor: pointer;\r\n}\r\n\r\n.item-6f81a84ee10d38ca107998be1d9a5cf01d0eed91.active-5cfd7acb0e1f0f2c1ae1509ff7114f29aecf222b .delete-button-04b39470f8b9cde6122641ba127dae02e389ce94 {\r\n    display: inline-block;\r\n}\r\n\r\n.add-button-a69146193c33e23bae778ebbed5c56d136253b50 {\r\n    margin-top: 10px;\r\n    border: none;\r\n    background: #f1f3f4;\r\n    border-radius: 12px;\r\n    padding: 12px;\r\n    cursor: pointer;\r\n    font-size: 14px;\r\n    transition:\r\n        background 0.2s ease,\r\n        transform 0.1s ease;\r\n    flex-shrink: 0;\r\n}\r\n\r\n.add-button-a69146193c33e23bae778ebbed5c56d136253b50:hover {\r\n    background: #e3e6e8;\r\n}\r\n\r\n.add-button-a69146193c33e23bae778ebbed5c56d136253b50:active {\r\n    transform: scale(0.97);\r\n}\r\n";
  var source_list_default = {
    wrapper: "wrapper-12ea3675915522e27cfe3356addfb9ac5a8e4fe2",
    item: "item-6f81a84ee10d38ca107998be1d9a5cf01d0eed91",
    active: "active-5cfd7acb0e1f0f2c1ae1509ff7114f29aecf222b",
    "item-label": "item-label-aa6d3639738d866205ef3f6db063315d6b23659f",
    "delete-button": "delete-button-04b39470f8b9cde6122641ba127dae02e389ce94",
    "add-button": "add-button-a69146193c33e23bae778ebbed5c56d136253b50"
  };

  // source/drafts-view/query-view/source-list.tsx
  var setStyle8 = styleSetter(cssText8);
  function createSourceList({
    initialList
  }) {
    setStyle8();
    const events = createTypedEventTarget();
    const list = createVirtualList();
    const element = /* @__PURE__ */ jsxs("div", { class: source_list_default.wrapper, children: [
      list.element,
      /* @__PURE__ */ jsx(
        "button",
        {
          class: source_list_default["add-button"],
          onclick: () => events.dispatchEvent(
            createTypedCustomEvent("add", void 0)
          ),
          children: "\uFF0B \u9805\u76EE\u3092\u8FFD\u52A0"
        }
      )
    ] });
    function createListItem(sources, index) {
      const contents = sources.sources[index]?.contents;
      if (contents == null) return;
      const classList = [source_list_default.item];
      if (sources.selectedIndex === index) {
        classList.push(source_list_default.active);
      }
      return /* @__PURE__ */ jsxs(
        "div",
        {
          classList,
          onclick: () => {
            events.dispatchEvent(
              createTypedCustomEvent("select", index)
            );
          },
          children: [
            /* @__PURE__ */ jsx("span", { class: source_list_default["item-label"], children: contents === "" ? "<empty>" : contents }),
            /* @__PURE__ */ jsx(
              "button",
              {
                class: source_list_default["delete-button"],
                onclick: (e) => {
                  events.dispatchEvent(
                    createTypedCustomEvent("delete", index)
                  );
                  e.stopPropagation();
                },
                children: "\u524A\u9664"
              }
            )
          ]
        }
      );
    }
    function setSources(sources) {
      list.setItems({
        itemHeight: 52,
        count: sources.sources.length,
        get(index) {
          return createListItem(sources, index);
        }
      });
    }
    setSources(initialList);
    return {
      element,
      events,
      setSources
    };
  }

  // source/sal/effective.ts
  function* done(x) {
    return x;
  }
  var EffectiveRequest = class {
  };
  var AwaitPromiseRequest = class extends EffectiveRequest {
    constructor(promise) {
      super();
      this.promise = promise;
    }
  };
  function* awaitPromise(promise) {
    return yield new AwaitPromiseRequest(promise);
  }
  var privateGetAbortSignalSymbol = /* @__PURE__ */ Symbol("privateGetAbortSignal");
  function* getCancel() {
    return yield privateGetAbortSignalSymbol;
  }
  async function forceAsPromise(g, signal) {
    let nextInput = void 0;
    let nextResult;
    for (; nextResult = g.next(nextInput), !nextResult.done; ) {
      const nextOutput = nextResult.value;
      if (nextOutput === privateGetAbortSignalSymbol) {
        nextInput = signal;
        continue;
      }
      if (nextOutput instanceof AwaitPromiseRequest) {
        nextInput = await nextOutput.promise;
        continue;
      }
      return raise`unknown effect: ${nextOutput}`;
    }
    return nextResult.value;
  }

  // source/query/standard-queries.ts
  function buildDraftMap(drafts) {
    const cell14s = /* @__PURE__ */ new Map();
    for (const draft of drafts) {
      const p = draft.coordinates[0];
      const cell14 = createCellFromCoordinates(p, 14);
      const cell14Id = cell14.toString();
      let cell17Drafts = cell14s.get(cell14Id)?.cell17Drafts;
      if (cell17Drafts == null) {
        cell14s.set(cell14Id, {
          cell14,
          cell17Drafts: cell17Drafts = /* @__PURE__ */ new Set()
        });
      }
      cell17Drafts.add(getCellId(p, 17));
    }
    return cell14s;
  }
  function hasTermInString(text, term) {
    return text.toLowerCase().includes(term);
  }
  function hasTermInDraft({ name, description, note }, term) {
    return hasTermInString(name, term) || hasTermInString(description, term) || hasTermInString(note, term);
  }
  function queryAsBuilder(query) {
    return {
      isIgnorable: false,
      initialize() {
        return done(query);
      }
    };
  }
  function builderAsValue(builder) {
    return builder;
  }
  function valueAsBuilder(v) {
    return v;
  }
  function stringTermQuery(text) {
    return builderAsValue({
      isIgnorable: false,
      initialize() {
        const term = text.toLocaleLowerCase();
        return done({
          isVisible(d) {
            return done(hasTermInDraft(d, term));
          }
        });
      }
    });
  }
  function any2() {
    return builderAsValue(
      queryAsBuilder({
        isVisible() {
          return done(true);
        }
      })
    );
  }
  function not(b) {
    if (b.isIgnorable) return builderAsValue(b);
    return builderAsValue({
      isIgnorable: false,
      *initialize(e) {
        const q = yield* b.initialize(e);
        return {
          *isVisible(d) {
            return !(yield* q.isVisible(d));
          },
          isAny: false
        };
      }
    });
  }
  function fromString(x) {
    return done(stringTermQuery(String(x)));
  }
  function and(b1, b2) {
    if (b2.isIgnorable) return b1;
    if (b1.isIgnorable) return b2;
    return {
      isIgnorable: false,
      *initialize(e) {
        const q1 = yield* b1.initialize(e);
        const q2 = yield* b2.initialize(e);
        return {
          *isVisible(draft) {
            return (yield* q1.isVisible(draft)) && (yield* q2.isVisible(draft));
          }
        };
      }
    };
  }
  function or(b1, b2) {
    if (b2.isIgnorable) return b1;
    if (b1.isIgnorable) return b2;
    return {
      isIgnorable: false,
      *initialize(e) {
        const q1 = yield* b1.initialize(e);
        const q2 = yield* b2.initialize(e);
        return {
          *isVisible(d) {
            return (yield* q1.isVisible(d)) || (yield* q2.isVisible(d));
          }
        };
      }
    };
  }
  function reachableWith(center, radius) {
    return {
      isIgnorable: false,
      initialize() {
        const p1 = { lat: center[0], lng: center[1] };
        return done({
          isVisible(d) {
            const [p2] = d.coordinates;
            return done(distance(p1, p2) <= radius);
          }
        });
      }
    };
  }
  function builderOfPredicate(predicate) {
    return {
      isIgnorable: false,
      initialize(e) {
        return done({
          isVisible(d) {
            return predicate(e, d);
          }
        });
      }
    };
  }
  function* getFreshCell17(e, d) {
    const minFetchDate = yield* e.getMinFreshDate();
    const stat17 = yield* e.getCell17Stat(d);
    if (stat17 == null || stat17.lastFetchDate == null || stat17.lastFetchDate < minFetchDate) {
      return;
    }
    return stat17;
  }
  function builderOfCellPredicate(predicate) {
    return {
      isIgnorable: false,
      initialize(e) {
        return done({
          *isVisible(d) {
            const stat17 = yield* getFreshCell17(e, d);
            if (stat17 == null) return true;
            const stat14 = yield* e.getCell14Stat(d);
            if (stat14 == null) return true;
            return predicate(stat14, stat17, d);
          }
        });
      }
    };
  }
  function hasPokestopOrGymInCell17() {
    return builderOfPredicate(function* (e, d) {
      const stat17 = yield* getFreshCell17(e, d);
      if (stat17 == null) return true;
      const count = (stat17.kindToCount.get("GYM") ?? 0) + (stat17.kindToCount.get("POKESTOP") ?? 0);
      return 0 < count;
    });
  }
  var gymThresholds = Object.freeze([2, 6, 20]);
  function getGymCount(stopCount) {
    for (let i = 0; i < gymThresholds.length; i++) {
      const threshold = gymThresholds[i];
      if (stopCount < threshold) {
        return i;
      }
    }
    return gymThresholds.length;
  }
  function getPokestopCountForNextGym(current) {
    let next = Infinity;
    for (const threshold of gymThresholds) {
      if (current < threshold) {
        next = threshold;
        break;
      }
    }
    return next - current;
  }
  function stopsForNextGym(expectedCount) {
    return builderOfPredicate(function* (e, d) {
      const stat14 = yield* e.getCell14Stat(d);
      if (stat14 == null) return true;
      const gymCount = stat14.kindToPois.get("GYM")?.length ?? 0;
      const pokestopCount = stat14.kindToPois.get("POKESTOP")?.length ?? 0;
      const stopCount = gymCount + pokestopCount;
      const draftStat14 = yield* e.getCell14DraftStat(d);
      if (draftStat14 == null) return true;
      return (
        // 
        getPokestopCountForNextGym(stopCount) === expectedCount && // 
        expectedCount <= draftStat14.potentialStops && // 
        getGymCount(stopCount) === gymCount
      );
    });
  }
  function cell14Stops(expectedCount) {
    return builderOfCellPredicate((stat14, _stat17) => {
      return stat14.pois.size === expectedCount;
    });
  }
  function binaryBuilder(f) {
    return (x) => {
      return done((y) => {
        const b = f(valueAsBuilder(x), valueAsBuilder(y));
        return done(builderAsValue(b));
      });
    };
  }
  function binaryFunction(f) {
    return (x) => done((y) => done(f(x, y)));
  }
  function createStandardQueries() {
    const all = any2();
    const ignorableAll = builderAsValue({
      isIgnorable: true,
      initialize() {
        return done({
          isVisible() {
            return done(true);
          }
        });
      }
    });
    const seq = binaryBuilder(and);
    const duplicated = builderAsValue(hasPokestopOrGymInCell17());
    const dict = {
      fromVoid(_) {
        return done(all);
      },
      fromMissing(_) {
        return done(ignorableAll);
      },
      fromNumber(x) {
        return done(stringTermQuery(String(x)));
      },
      fromString,
      fromWord: fromString,
      not_(x) {
        return done(not(valueAsBuilder(x)));
      },
      _seq_: seq,
      _and_: seq,
      _or_: binaryBuilder(or),
      reachableWith: binaryFunction((center, distanceMeter) => {
        return builderAsValue(
          reachableWith(
            center,
            distanceMeter
          )
        );
      }),
      duplicated,
      hasStopInCell17: duplicated,
      stopsForNextGym(x) {
        return done(builderAsValue(stopsForNextGym(x)));
      },
      cell14Stops(x) {
        return done(builderAsValue(cell14Stops(x)));
      }
    };
    return new Map(Object.entries(dict));
  }

  // source/sal/evaluator.ts
  var import_antlr4ts = __toESM(require_antlr4ts());

  // source/sal/.antlr-generated/SalLexer.ts
  var import_ATNDeserializer = __toESM(require_ATNDeserializer());
  var import_Lexer = __toESM(require_Lexer());
  var import_LexerATNSimulator = __toESM(require_LexerATNSimulator());
  var import_VocabularyImpl = __toESM(require_VocabularyImpl());
  var Utils = __toESM(require_Utils());
  var SalLexer = class _SalLexer extends import_Lexer.Lexer {
    static {
      this.T__0 = 1;
    }
    static {
      this.T__1 = 2;
    }
    static {
      this.T__2 = 3;
    }
    static {
      this.T__3 = 4;
    }
    static {
      this.T__4 = 5;
    }
    static {
      this.OR = 6;
    }
    static {
      this.AND = 7;
    }
    static {
      this.WHERE = 8;
    }
    static {
      this.FUNCTION = 9;
    }
    static {
      this.PAREN_BEGIN = 10;
    }
    static {
      this.PAREN_END = 11;
    }
    static {
      this.COLON = 12;
    }
    static {
      this.SLASH = 13;
    }
    static {
      this.AT = 14;
    }
    static {
      this.MINUS = 15;
    }
    static {
      this.EQUALS = 16;
    }
    static {
      this.NUMBER = 17;
    }
    static {
      this.STRING = 18;
    }
    static {
      this.WORD = 19;
    }
    static {
      this.LINE_COMMENT = 20;
    }
    static {
      this.BLOCK_COMMENT = 21;
    }
    static {
      this.WS = 22;
    }
    static {
      // tslint:disable:no-trailing-whitespace
      this.channelNames = [
        "DEFAULT_TOKEN_CHANNEL",
        "HIDDEN"
      ];
    }
    static {
      // tslint:disable:no-trailing-whitespace
      this.modeNames = [
        "DEFAULT_MODE"
      ];
    }
    static {
      this.ruleNames = [
        "T__0",
        "T__1",
        "T__2",
        "T__3",
        "T__4",
        "OR",
        "AND",
        "WHERE",
        "FUNCTION",
        "PAREN_BEGIN",
        "PAREN_END",
        "COLON",
        "SLASH",
        "AT",
        "MINUS",
        "EQUALS",
        "NUMBER",
        "STRING",
        "WORD_START",
        "WORD_PART",
        "WORD",
        "LINE_COMMENT",
        "BLOCK_COMMENT",
        "WS"
      ];
    }
    static {
      this._LITERAL_NAMES = [
        void 0,
        "'['",
        "','",
        "']'",
        "'{'",
        "'}'",
        "'or'",
        "'and'",
        "'where'",
        void 0,
        "'('",
        "')'",
        "':'",
        "'/'",
        "'@'",
        "'-'",
        "'='"
      ];
    }
    static {
      this._SYMBOLIC_NAMES = [
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        "OR",
        "AND",
        "WHERE",
        "FUNCTION",
        "PAREN_BEGIN",
        "PAREN_END",
        "COLON",
        "SLASH",
        "AT",
        "MINUS",
        "EQUALS",
        "NUMBER",
        "STRING",
        "WORD",
        "LINE_COMMENT",
        "BLOCK_COMMENT",
        "WS"
      ];
    }
    static {
      this.VOCABULARY = new import_VocabularyImpl.VocabularyImpl(_SalLexer._LITERAL_NAMES, _SalLexer._SYMBOLIC_NAMES, []);
    }
    // @Override
    // @NotNull
    get vocabulary() {
      return _SalLexer.VOCABULARY;
    }
    // tslint:enable:no-trailing-whitespace
    constructor(input) {
      super(input);
      this._interp = new import_LexerATNSimulator.LexerATNSimulator(_SalLexer._ATN, this);
    }
    // @Override
    get grammarFileName() {
      return "Sal.g4";
    }
    // @Override
    get ruleNames() {
      return _SalLexer.ruleNames;
    }
    // @Override
    get serializedATN() {
      return _SalLexer._serializedATN;
    }
    // @Override
    get channelNames() {
      return _SalLexer.channelNames;
    }
    // @Override
    get modeNames() {
      return _SalLexer.modeNames;
    }
    static {
      this._serializedATNSegments = 2;
    }
    static {
      this._serializedATNSegment0 = '\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\xB8\b					\x07	\x07\b	\b			\n	\n\v	\v\f	\f\r	\r												\x07\x07\x07\b\b\b\b						\n\n\n\n\n\n\n\n\n\n\nU\n\n\v\v\f\f\r\rf\ni\n\rjo\n\rps\nw\nz\n\r{~\n\x07\x84\n\f\x87\v\x8F\n\x07\x93\n\f\x96\v\x07\x9C\n\f\x9F\v\x07\xA8\n\f\xAB\v\xB3\n\r\xB4\xA9\x07	\v\x07\r\b	\n\v\f\r\x1B!#%\')+-/1\x072;GGgg$$^^))/0\f\f\u028D"$$)+.1<@BB]]__}}\x7F\x7F\x81\xA2\xAF\xAF\u037A\u037B\u0382\u0385\u038D\u038D\u038F\u038F\u03A4\u03A4\u0532\u0532\u0559\u055A\u0562\u0562\u058A\u058A\u058D\u058E\u0592\u0592\u05CA\u05D1\u05ED\u05F1\u05F7\u0607\u061E\u061F\u06DF\u06DF\u0710\u0711\u074D\u074E\u07B4\u07C1\u07FD\u0801\u0830\u0831\u0841\u0841\u085E\u085F\u0861\u08A1\u08B7\u08B7\u08C0\u08D5\u08E4\u08E4\u0986\u0986\u098F\u0990\u0993\u0994\u09AB\u09AB\u09B3\u09B3\u09B5\u09B7\u09BC\u09BD\u09C7\u09C8\u09CB\u09CC\u09D1\u09D8\u09DA\u09DD\u09E0\u09E0\u09E6\u09E7\u09FE\u0A02\u0A06\u0A06\u0A0D\u0A10\u0A13\u0A14\u0A2B\u0A2B\u0A33\u0A33\u0A36\u0A36\u0A39\u0A39\u0A3C\u0A3D\u0A3F\u0A3F\u0A45\u0A48\u0A4B\u0A4C\u0A50\u0A52\u0A54\u0A5A\u0A5F\u0A5F\u0A61\u0A67\u0A78\u0A82\u0A86\u0A86\u0A90\u0A90\u0A94\u0A94\u0AAB\u0AAB\u0AB3\u0AB3\u0AB6\u0AB6\u0ABC\u0ABD\u0AC8\u0AC8\u0ACC\u0ACC\u0AD0\u0AD1\u0AD3\u0AE1\u0AE6\u0AE7\u0AF4\u0AFA\u0AFC\u0B02\u0B06\u0B06\u0B0F\u0B10\u0B13\u0B14\u0B2B\u0B2B\u0B33\u0B33\u0B36\u0B36\u0B3C\u0B3D\u0B47\u0B48\u0B4B\u0B4C\u0B50\u0B57\u0B5A\u0B5D\u0B60\u0B60\u0B66\u0B67\u0B7A\u0B83\u0B86\u0B86\u0B8D\u0B8F\u0B93\u0B93\u0B98\u0B9A\u0B9D\u0B9D\u0B9F\u0B9F\u0BA2\u0BA4\u0BA7\u0BA9\u0BAD\u0BAF\u0BBC\u0BBF\u0BC5\u0BC7\u0BCB\u0BCB\u0BD0\u0BD1\u0BD3\u0BD8\u0BDA\u0BE7\u0BFD\u0C01\u0C06\u0C06\u0C0F\u0C0F\u0C13\u0C13\u0C2B\u0C2B\u0C3C\u0C3E\u0C47\u0C47\u0C4B\u0C4B\u0C50\u0C56\u0C59\u0C59\u0C5D\u0C61\u0C66\u0C67\u0C72\u0C79\u0C86\u0C86\u0C8F\u0C8F\u0C93\u0C93\u0CAB\u0CAB\u0CB6\u0CB6\u0CBC\u0CBD\u0CC7\u0CC7\u0CCB\u0CCB\u0CD0\u0CD6\u0CD9\u0CDF\u0CE1\u0CE1\u0CE6\u0CE7\u0CF2\u0CF2\u0CF5\u0D02\u0D06\u0D06\u0D0F\u0D0F\u0D13\u0D13\u0D3D\u0D3E\u0D47\u0D47\u0D4B\u0D4B\u0D52\u0D55\u0D66\u0D67\u0D82\u0D83\u0D86\u0D86\u0D99\u0D9B\u0DB4\u0DB4\u0DBE\u0DBE\u0DC0\u0DC1\u0DC9\u0DCB\u0DCD\u0DD0\u0DD7\u0DD7\u0DD9\u0DD9\u0DE2\u0DE7\u0DF2\u0DF3\u0DF7\u0E02\u0E3D\u0E40\u0E5E\u0E82\u0E85\u0E85\u0E87\u0E88\u0E8B\u0E8B\u0E8D\u0E8E\u0E90\u0E95\u0E9A\u0E9A\u0EA2\u0EA2\u0EA6\u0EA6\u0EA8\u0EA8\u0EAA\u0EAB\u0EAE\u0EAE\u0EBC\u0EBC\u0EC0\u0EC1\u0EC7\u0EC7\u0EC9\u0EC9\u0ED0\u0ED1\u0EDC\u0EDD\u0EE2\u0F01\u0F4A\u0F4A\u0F6F\u0F72\u0F9A\u0F9A\u0FBF\u0FBF\u0FCF\u0FCF\u0FDD\u1001\u10C8\u10C8\u10CA\u10CE\u10D0\u10D1\u124B\u124B\u1250\u1251\u1259\u1259\u125B\u125B\u1260\u1261\u128B\u128B\u1290\u1291\u12B3\u12B3\u12B8\u12B9\u12C1\u12C1\u12C3\u12C3\u12C8\u12C9\u12D9\u12D9\u1313\u1313\u1318\u1319\u135D\u135E\u137F\u1381\u139C\u13A1\u13F8\u13F9\u1400\u1401\u1682\u1682\u169F\u16A1\u16FB\u1701\u170F\u170F\u1717\u1721\u1739\u1741\u1756\u1761\u176F\u176F\u1773\u1773\u1776\u1781\u17E0\u17E1\u17EC\u17F1\u17FC\u1801\u1810\u1811\u181C\u1821\u187A\u1881\u18AD\u18B1\u18F8\u1901\u1921\u1921\u192E\u1931\u193E\u1941\u1943\u1945\u1970\u1971\u1977\u1981\u19AE\u19B1\u19CC\u19D1\u19DD\u19DF\u1A1E\u1A1F\u1A61\u1A61\u1A7F\u1A80\u1A8C\u1A91\u1A9C\u1AA1\u1AB0\u1AB1\u1AC1\u1B01\u1B4E\u1B51\u1B7F\u1B81\u1BF6\u1BFD\u1C3A\u1C3C\u1C4C\u1C4E\u1C8B\u1CC1\u1CCA\u1CD1\u1CF9\u1CF9\u1CFC\u1D01\u1DF8\u1DFC\u1F18\u1F19\u1F20\u1F21\u1F48\u1F49\u1F50\u1F51\u1F5A\u1F5A\u1F5C\u1F5C\u1F5E\u1F5E\u1F60\u1F60\u1F80\u1F81\u1FB7\u1FB7\u1FC7\u1FC7\u1FD6\u1FD7\u1FDE\u1FDE\u1FF2\u1FF3\u1FF7\u1FF7\u2001\u2011\u202A\u2031\u2061\u2071\u2074\u2075\u2091\u2091\u209F\u20A1\u20C1\u20D1\u20F3\u2101\u218E\u2191\u2401\u2401\u2429\u2441\u244D\u2461\u2B76\u2B77\u2B98\u2B99\u2BBC\u2BBE\u2BCB\u2BCB\u2BD4\u2BED\u2BF2\u2C01\u2C31\u2C31\u2C61\u2C61\u2CF6\u2CFA\u2D28\u2D28\u2D2A\u2D2E\u2D30\u2D31\u2D6A\u2D70\u2D73\u2D80\u2D99\u2DA1\u2DA9\u2DA9\u2DB1\u2DB1\u2DB9\u2DB9\u2DC1\u2DC1\u2DC9\u2DC9\u2DD1\u2DD1\u2DD9\u2DD9\u2DE1\u2DE1\u2E47\u2E81\u2E9C\u2E9C\u2EF6\u2F01\u2FD8\u2FF1\u2FFE\u3002\u3042\u3042\u3099\u309A\u3102\u3106\u3130\u3132\u3191\u3191\u31BD\u31C1\u31E6\u31F1\u3221\u3221\u3301\u3301\u4DB8\u4DC1\u9FD8\uA001\uA48F\uA491\uA4C9\uA4D1\uA62E\uA641\uA6FA\uA701\uA7B1\uA7B1\uA7BA\uA7F8\uA82E\uA831\uA83C\uA841\uA87A\uA881\uA8C8\uA8CF\uA8DC\uA8E1\uA900\uA901\uA956\uA960\uA97F\uA981\uA9D0\uA9D0\uA9DC\uA9DF\uAA01\uAA01\uAA39\uAA41\uAA50\uAA51\uAA5C\uAA5D\uAAC5\uAADC\uAAF9\uAB02\uAB09\uAB0A\uAB11\uAB12\uAB19\uAB21\uAB29\uAB29\uAB31\uAB31\uAB68\uAB71\uABF0\uABF1\uABFC\uAC01\uD7A6\uD7B1\uD7C9\uD7CC\uD7FE\uF901\uFA70\uFA71\uFADC\uFB01\uFB09\uFB14\uFB1A\uFB1E\uFB39\uFB39\uFB3F\uFB3F\uFB41\uFB41\uFB44\uFB44\uFB47\uFB47\uFBC4\uFBD4\uFD42\uFD51\uFD92\uFD93\uFDCA\uFDF1\uFE00\uFE01\uFE1C\uFE21\uFE55\uFE55\uFE69\uFE69\uFE6E\uFE71\uFE77\uFE77\uFEFF\uFF02\uFFC1\uFFC3\uFFCA\uFFCB\uFFD2\uFFD3\uFFDA\uFFDB\uFFDF\uFFE1\uFFE9\uFFE9\uFFF1\uFFFD\0))==@@PQ`\x81\xFD\u0101\u0105\u0108\u0136\u0138\u0191\u0191\u019E\u01A1\u01A3\u01D1\u0200\u0281\u029F\u02A1\u02D3\u02E1\u02FE\u0301\u0326\u0331\u034D\u0351\u037D\u0381\u03A0\u03A0\u03C6\u03C9\u03D8\u0401\u04A0\u04A1\u04AC\u04B1\u04D6\u04D9\u04FE\u0501\u052A\u0531\u0566\u0570\u0572\u0601\u0739\u0741\u0758\u0761\u076A\u0801\u0808\u0809\u080B\u080B\u0838\u0838\u083B\u083D\u083F\u0840\u0858\u0858\u08A1\u08A8\u08B2\u08E1\u08F5\u08F5\u08F8\u08FC\u091E\u0920\u093C\u0940\u0942\u0981\u09BA\u09BD\u09D2\u09D3\u0A06\u0A06\u0A09\u0A0D\u0A16\u0A16\u0A1A\u0A1A\u0A36\u0A39\u0A3D\u0A40\u0A4A\u0A51\u0A5B\u0A61\u0AA2\u0AC1\u0AE9\u0AEC\u0AF9\u0B01\u0B38\u0B3A\u0B58\u0B59\u0B75\u0B79\u0B94\u0B9A\u0B9F\u0BAA\u0BB2\u0C01\u0C4B\u0C81\u0CB5\u0CC1\u0CF5\u0CFB\u0D02\u0E61\u0E81\u1001\u1050\u1053\u1072\u1080\u10BF\u10BF\u10C4\u10D1\u10EB\u10F1\u10FC\u1101\u1137\u1137\u1146\u1151\u1179\u1181\u11D0\u11D1\u11E2\u11E2\u11F7\u1201\u1214\u1214\u1241\u1281\u1289\u1289\u128B\u128B\u1290\u1290\u12A0\u12A0\u12AC\u12B1\u12ED\u12F1\u12FC\u1301\u1306\u1306\u130F\u1310\u1313\u1314\u132B\u132B\u1333\u1333\u1336\u1336\u133C\u133D\u1347\u1348\u134B\u134C\u1350\u1351\u1353\u1358\u135A\u135E\u1366\u1367\u136F\u1371\u1377\u1401\u145C\u145C\u145E\u145E\u1460\u1481\u14CA\u14D1\u14DC\u1581\u15B8\u15B9\u15E0\u1601\u1647\u1651\u165C\u1661\u166F\u1681\u16BA\u16C1\u16CC\u1701\u171C\u171E\u172E\u1731\u1742\u18A1\u18F5\u1900\u1902\u1AC1\u1AFB\u1C01\u1C0B\u1C0B\u1C39\u1C39\u1C48\u1C51\u1C6F\u1C71\u1C92\u1C93\u1CAA\u1CAA\u1CB9\u2001\u239C\u2401\u2471\u2471\u2477\u2481\u2546\u3001\u3431\u4401\u4649\u6801\u6A3B\u6A41\u6A61\u6A61\u6A6C\u6A6F\u6A72\u6AD1\u6AF0\u6AF1\u6AF8\u6B01\u6B48\u6B51\u6B5C\u6B5C\u6B64\u6B64\u6B7A\u6B7E\u6B92\u6F01\u6F47\u6F51\u6F81\u6F90\u6FA2\u6FE1\u6FE3\u7001\u87EF\u8801\u8AF5\uB001\uB004\uBC01\uBC6D\uBC71\uBC7F\uBC81\uBC8B\uBC91\uBC9C\uBC9D\uBCA2\uD001\uD0F8\uD101\uD129\uD12A\uD175\uD17C\uD1EB\uD201\uD248\uD301\uD359\uD361\uD374\uD401\uD457\uD457\uD49F\uD49F\uD4A2\uD4A3\uD4A5\uD4A6\uD4A9\uD4AA\uD4AF\uD4AF\uD4BC\uD4BC\uD4BE\uD4BE\uD4C6\uD4C6\uD508\uD508\uD50D\uD50E\uD517\uD517\uD51F\uD51F\uD53C\uD53C\uD541\uD541\uD547\uD547\uD549\uD54B\uD553\uD553\uD6A8\uD6A9\uD7CE\uD7CF\uDA8E\uDA9C\uDAA2\uDAA2\uDAB2\uE001\uE009\uE009\uE01B\uE01C\uE024\uE024\uE027\uE027\uE02D\uE801\uE8C7\uE8C8\uE8D9\uE901\uE94D\uE951\uE95C\uE95F\uE962\uEE01\uEE06\uEE06\uEE22\uEE22\uEE25\uEE25\uEE27\uEE28\uEE2A\uEE2A\uEE35\uEE35\uEE3A\uEE3A\uEE3C\uEE3C\uEE3E\uEE43\uEE45\uEE48\uEE4A\uEE4A\uEE4C\uEE4C\uEE4E\uEE4E\uEE52\uEE52\uEE55\uEE55\uEE57\uEE58\uEE5A\uEE5A\uEE5C\uEE5C\uEE5E\uEE5E\uEE60\uEE60\uEE62\uEE62\uEE65\uEE65\uEE67\uEE68\uEE6D\uEE6D\uEE75\uEE75\uEE7A\uEE7A\uEE7F\uEE7F\uEE81\uEE81\uEE8C\uEE8C\uEE9E\uEEA2\uEEA6\uEEA6\uEEAC\uEEAC\uEEBE\uEEF1\uEEF4\uF001\uF02E\uF031\uF096\uF0A1\uF0B1\uF0B2\uF0C2\uF0C2\uF0D2\uF0D2\uF0F8\uF101\uF10F\uF111\uF131\uF131\uF16E\uF171\uF1AF\uF1E7\uF205\uF211\uF23E\uF241\uF24B\uF251\uF254\uF301\uF6D5\uF6E1\uF6EF\uF6F1\uF6F9\uF701\uF776\uF781\uF7D7\uF801\uF80E\uF811\uF84A\uF851\uF85C\uF861\uF88A\uF891\uF8B0\uF911\uF921\uF921\uF92A\uF931\uF933\uF934\uF941\uF941\uF94E\uF951\uF961\uF981\uF994\uF9C1\uF9C3\uA6D9\uA701\uB737\uB741\uB820\uB821\uCEA4\uF801\uFA20\u0101\u01F2\u0284"\x81\xA2\xAF\xAF\u037A\u037B\u0382\u0385\u038D\u038D\u038F\u038F\u03A4\u03A4\u0532\u0532\u0559\u055A\u0562\u0562\u058A\u058A\u058D\u058E\u0592\u0592\u05CA\u05D1\u05ED\u05F1\u05F7\u0607\u061E\u061F\u06DF\u06DF\u0710\u0711\u074D\u074E\u07B4\u07C1\u07FD\u0801\u0830\u0831\u0841\u0841\u085E\u085F\u0861\u08A1\u08B7\u08B7\u08C0\u08D5\u08E4\u08E4\u0986\u0986\u098F\u0990\u0993\u0994\u09AB\u09AB\u09B3\u09B3\u09B5\u09B7\u09BC\u09BD\u09C7\u09C8\u09CB\u09CC\u09D1\u09D8\u09DA\u09DD\u09E0\u09E0\u09E6\u09E7\u09FE\u0A02\u0A06\u0A06\u0A0D\u0A10\u0A13\u0A14\u0A2B\u0A2B\u0A33\u0A33\u0A36\u0A36\u0A39\u0A39\u0A3C\u0A3D\u0A3F\u0A3F\u0A45\u0A48\u0A4B\u0A4C\u0A50\u0A52\u0A54\u0A5A\u0A5F\u0A5F\u0A61\u0A67\u0A78\u0A82\u0A86\u0A86\u0A90\u0A90\u0A94\u0A94\u0AAB\u0AAB\u0AB3\u0AB3\u0AB6\u0AB6\u0ABC\u0ABD\u0AC8\u0AC8\u0ACC\u0ACC\u0AD0\u0AD1\u0AD3\u0AE1\u0AE6\u0AE7\u0AF4\u0AFA\u0AFC\u0B02\u0B06\u0B06\u0B0F\u0B10\u0B13\u0B14\u0B2B\u0B2B\u0B33\u0B33\u0B36\u0B36\u0B3C\u0B3D\u0B47\u0B48\u0B4B\u0B4C\u0B50\u0B57\u0B5A\u0B5D\u0B60\u0B60\u0B66\u0B67\u0B7A\u0B83\u0B86\u0B86\u0B8D\u0B8F\u0B93\u0B93\u0B98\u0B9A\u0B9D\u0B9D\u0B9F\u0B9F\u0BA2\u0BA4\u0BA7\u0BA9\u0BAD\u0BAF\u0BBC\u0BBF\u0BC5\u0BC7\u0BCB\u0BCB\u0BD0\u0BD1\u0BD3\u0BD8\u0BDA\u0BE7\u0BFD\u0C01\u0C06\u0C06\u0C0F\u0C0F\u0C13\u0C13\u0C2B\u0C2B\u0C3C\u0C3E\u0C47\u0C47\u0C4B\u0C4B\u0C50\u0C56\u0C59\u0C59\u0C5D\u0C61\u0C66\u0C67\u0C72\u0C79\u0C86\u0C86\u0C8F\u0C8F\u0C93\u0C93\u0CAB\u0CAB\u0CB6\u0CB6\u0CBC\u0CBD\u0CC7\u0CC7\u0CCB\u0CCB\u0CD0\u0CD6\u0CD9\u0CDF\u0CE1\u0CE1\u0CE6\u0CE7\u0CF2\u0CF2\u0CF5\u0D02\u0D06\u0D06\u0D0F\u0D0F\u0D13\u0D13\u0D3D\u0D3E\u0D47\u0D47\u0D4B\u0D4B\u0D52\u0D55\u0D66\u0D67\u0D82\u0D83\u0D86\u0D86\u0D99\u0D9B\u0DB4\u0DB4\u0DBE\u0DBE\u0DC0\u0DC1\u0DC9\u0DCB\u0DCD\u0DD0\u0DD7\u0DD7\u0DD9\u0DD9\u0DE2\u0DE7\u0DF2\u0DF3\u0DF7\u0E02\u0E3D\u0E40\u0E5E\u0E82\u0E85\u0E85\u0E87\u0E88\u0E8B\u0E8B\u0E8D\u0E8E\u0E90\u0E95\u0E9A\u0E9A\u0EA2\u0EA2\u0EA6\u0EA6\u0EA8\u0EA8\u0EAA\u0EAB\u0EAE\u0EAE\u0EBC\u0EBC\u0EC0\u0EC1\u0EC7\u0EC7\u0EC9\u0EC9\u0ED0\u0ED1\u0EDC\u0EDD\u0EE2\u0F01\u0F4A\u0F4A\u0F6F\u0F72\u0F9A\u0F9A\u0FBF\u0FBF\u0FCF\u0FCF\u0FDD\u1001\u10C8\u10C8\u10CA\u10CE\u10D0\u10D1\u124B\u124B\u1250\u1251\u1259\u1259\u125B\u125B\u1260\u1261\u128B\u128B\u1290\u1291\u12B3\u12B3\u12B8\u12B9\u12C1\u12C1\u12C3\u12C3\u12C8\u12C9\u12D9\u12D9\u1313\u1313\u1318\u1319\u135D\u135E\u137F\u1381\u139C\u13A1\u13F8\u13F9\u1400\u1401\u1682\u1682\u169F\u16A1\u16FB\u1701\u170F\u170F\u1717\u1721\u1739\u1741\u1756\u1761\u176F\u176F\u1773\u1773\u1776\u1781\u17E0\u17E1\u17EC\u17F1\u17FC\u1801\u1810\u1811\u181C\u1821\u187A\u1881\u18AD\u18B1\u18F8\u1901\u1921\u1921\u192E\u1931\u193E\u1941\u1943\u1945\u1970\u1971\u1977\u1981\u19AE\u19B1\u19CC\u19D1\u19DD\u19DF\u1A1E\u1A1F\u1A61\u1A61\u1A7F\u1A80\u1A8C\u1A91\u1A9C\u1AA1\u1AB0\u1AB1\u1AC1\u1B01\u1B4E\u1B51\u1B7F\u1B81\u1BF6\u1BFD\u1C3A\u1C3C\u1C4C\u1C4E\u1C8B\u1CC1\u1CCA\u1CD1\u1CF9\u1CF9\u1CFC\u1D01\u1DF8\u1DFC\u1F18\u1F19\u1F20\u1F21\u1F48\u1F49\u1F50\u1F51\u1F5A\u1F5A\u1F5C\u1F5C\u1F5E\u1F5E\u1F60\u1F60\u1F80\u1F81\u1FB7\u1FB7\u1FC7\u1FC7\u1FD6\u1FD7\u1FDE\u1FDE\u1FF2\u1FF3\u1FF7\u1FF7\u2001\u2011\u202A\u2031\u2061\u2071\u2074\u2075\u2091\u2091\u209F\u20A1\u20C1\u20D1\u20F3\u2101\u218E\u2191\u2401\u2401\u2429\u2441\u244D\u2461\u2B76\u2B77\u2B98\u2B99\u2BBC\u2BBE\u2BCB\u2BCB\u2BD4\u2BED\u2BF2\u2C01\u2C31\u2C31\u2C61\u2C61\u2CF6\u2CFA\u2D28\u2D28\u2D2A\u2D2E\u2D30\u2D31\u2D6A\u2D70\u2D73\u2D80\u2D99\u2DA1\u2DA9\u2DA9\u2DB1\u2DB1\u2DB9\u2DB9\u2DC1\u2DC1\u2DC9\u2DC9\u2DD1\u2DD1\u2DD9\u2DD9\u2DE1\u2DE1\u2E47\u2E81\u2E9C\u2E9C\u2EF6\u2F01\u2FD8\u2FF1\u2FFE\u3002\u3042\u3042\u3099\u309A\u3102\u3106\u3130\u3132\u3191\u3191\u31BD\u31C1\u31E6\u31F1\u3221\u3221\u3301\u3301\u4DB8\u4DC1\u9FD8\uA001\uA48F\uA491\uA4C9\uA4D1\uA62E\uA641\uA6FA\uA701\uA7B1\uA7B1\uA7BA\uA7F8\uA82E\uA831\uA83C\uA841\uA87A\uA881\uA8C8\uA8CF\uA8DC\uA8E1\uA900\uA901\uA956\uA960\uA97F\uA981\uA9D0\uA9D0\uA9DC\uA9DF\uAA01\uAA01\uAA39\uAA41\uAA50\uAA51\uAA5C\uAA5D\uAAC5\uAADC\uAAF9\uAB02\uAB09\uAB0A\uAB11\uAB12\uAB19\uAB21\uAB29\uAB29\uAB31\uAB31\uAB68\uAB71\uABF0\uABF1\uABFC\uAC01\uD7A6\uD7B1\uD7C9\uD7CC\uD7FE\uF901\uFA70\uFA71\uFADC\uFB01\uFB09\uFB14\uFB1A\uFB1E\uFB39\uFB39\uFB3F\uFB3F\uFB41\uFB41\uFB44\uFB44\uFB47\uFB47\uFBC4\uFBD4\uFD42\uFD51\uFD92\uFD93\uFDCA\uFDF1\uFE00\uFE01\uFE1C\uFE21\uFE55\uFE55\uFE69\uFE69\uFE6E\uFE71\uFE77\uFE77\uFEFF\uFF02\uFFC1\uFFC3\uFFCA\uFFCB\uFFD2\uFFD3\uFFDA\uFFDB\uFFDF\uFFE1\uFFE9\uFFE9\uFFF1\uFFFD\0))==@@PQ`\x81\xFD\u0101\u0105\u0108\u0136\u0138\u0191\u0191\u019E\u01A1\u01A3\u01D1\u0200\u0281\u029F\u02A1\u02D3\u02E1\u02FE\u0301\u0326\u0331\u034D\u0351\u037D\u0381\u03A0\u03A0\u03C6\u03C9\u03D8\u0401\u04A0\u04A1\u04AC\u04B1\u04D6\u04D9\u04FE\u0501\u052A\u0531\u0566\u0570\u0572\u0601\u0739\u0741\u0758\u0761\u076A\u0801\u0808\u0809\u080B\u080B\u0838\u0838\u083B\u083D\u083F\u0840\u0858\u0858\u08A1\u08A8\u08B2\u08E1\u08F5\u08F5\u08F8\u08FC\u091E\u0920\u093C\u0940\u0942\u0981\u09BA\u09BD\u09D2\u09D3\u0A06\u0A06\u0A09\u0A0D\u0A16\u0A16\u0A1A\u0A1A\u0A36\u0A39\u0A3D\u0A40\u0A4A\u0A51\u0A5B\u0A61\u0AA2\u0AC1\u0AE9\u0AEC\u0AF9\u0B01\u0B38\u0B3A\u0B58\u0B59\u0B75\u0B79\u0B94\u0B9A\u0B9F\u0BAA\u0BB2\u0C01\u0C4B\u0C81\u0CB5\u0CC1\u0CF5\u0CFB\u0D02\u0E61\u0E81\u1001\u1050\u1053\u1072\u1080\u10BF\u10BF\u10C4\u10D1\u10EB\u10F1\u10FC\u1101\u1137\u1137\u1146\u1151\u1179\u1181\u11D0\u11D1\u11E2\u11E2\u11F7\u1201\u1214\u1214\u1241\u1281\u1289\u1289\u128B\u128B\u1290\u1290\u12A0\u12A0\u12AC\u12B1\u12ED\u12F1\u12FC\u1301\u1306\u1306\u130F\u1310\u1313\u1314\u132B\u132B\u1333\u1333\u1336\u1336\u133C\u133D\u1347\u1348\u134B\u134C\u1350\u1351\u1353';
    }
    static {
      this._serializedATNSegment1 = "\u1358\u135A\u135E\u1366\u1367\u136F\u1371\u1377\u1401\u145C\u145C\u145E\u145E\u1460\u1481\u14CA\u14D1\u14DC\u1581\u15B8\u15B9\u15E0\u1601\u1647\u1651\u165C\u1661\u166F\u1681\u16BA\u16C1\u16CC\u1701\u171C\u171E\u172E\u1731\u1742\u18A1\u18F5\u1900\u1902\u1AC1\u1AFB\u1C01\u1C0B\u1C0B\u1C39\u1C39\u1C48\u1C51\u1C6F\u1C71\u1C92\u1C93\u1CAA\u1CAA\u1CB9\u2001\u239C\u2401\u2471\u2471\u2477\u2481\u2546\u3001\u3431\u4401\u4649\u6801\u6A3B\u6A41\u6A61\u6A61\u6A6C\u6A6F\u6A72\u6AD1\u6AF0\u6AF1\u6AF8\u6B01\u6B48\u6B51\u6B5C\u6B5C\u6B64\u6B64\u6B7A\u6B7E\u6B92\u6F01\u6F47\u6F51\u6F81\u6F90\u6FA2\u6FE1\u6FE3\u7001\u87EF\u8801\u8AF5\uB001\uB004\uBC01\uBC6D\uBC71\uBC7F\uBC81\uBC8B\uBC91\uBC9C\uBC9D\uBCA2\uD001\uD0F8\uD101\uD129\uD12A\uD175\uD17C\uD1EB\uD201\uD248\uD301\uD359\uD361\uD374\uD401\uD457\uD457\uD49F\uD49F\uD4A2\uD4A3\uD4A5\uD4A6\uD4A9\uD4AA\uD4AF\uD4AF\uD4BC\uD4BC\uD4BE\uD4BE\uD4C6\uD4C6\uD508\uD508\uD50D\uD50E\uD517\uD517\uD51F\uD51F\uD53C\uD53C\uD541\uD541\uD547\uD547\uD549\uD54B\uD553\uD553\uD6A8\uD6A9\uD7CE\uD7CF\uDA8E\uDA9C\uDAA2\uDAA2\uDAB2\uE001\uE009\uE009\uE01B\uE01C\uE024\uE024\uE027\uE027\uE02D\uE801\uE8C7\uE8C8\uE8D9\uE901\uE94D\uE951\uE95C\uE95F\uE962\uEE01\uEE06\uEE06\uEE22\uEE22\uEE25\uEE25\uEE27\uEE28\uEE2A\uEE2A\uEE35\uEE35\uEE3A\uEE3A\uEE3C\uEE3C\uEE3E\uEE43\uEE45\uEE48\uEE4A\uEE4A\uEE4C\uEE4C\uEE4E\uEE4E\uEE52\uEE52\uEE55\uEE55\uEE57\uEE58\uEE5A\uEE5A\uEE5C\uEE5C\uEE5E\uEE5E\uEE60\uEE60\uEE62\uEE62\uEE65\uEE65\uEE67\uEE68\uEE6D\uEE6D\uEE75\uEE75\uEE7A\uEE7A\uEE7F\uEE7F\uEE81\uEE81\uEE8C\uEE8C\uEE9E\uEEA2\uEEA6\uEEA6\uEEAC\uEEAC\uEEBE\uEEF1\uEEF4\uF001\uF02E\uF031\uF096\uF0A1\uF0B1\uF0B2\uF0C2\uF0C2\uF0D2\uF0D2\uF0F8\uF101\uF10F\uF111\uF131\uF131\uF16E\uF171\uF1AF\uF1E7\uF205\uF211\uF23E\uF241\uF24B\uF251\uF254\uF301\uF6D5\uF6E1\uF6EF\uF6F1\uF6F9\uF701\uF776\uF781\uF7D7\uF801\uF80E\uF811\uF84A\uF851\uF85C\uF861\uF88A\uF891\uF8B0\uF911\uF921\uF921\uF92A\uF931\uF933\uF934\uF941\uF941\uF94E\uF951\uF961\uF981\uF994\uF9C1\uF9C3\uA6D9\uA701\uB737\uB741\uB820\uB821\uCEA4\uF801\uFA20\u0101\u01F2\xC5\x07	\v\r\x1B!#%+-/135\x077	9\v;\r=@DTVXZ\x1B\\^`!b#e%\x7F'\x8A)\x8E+\x90-\x97/\xA21\xB234\x07]456\x07.678\x07_8\b9:\x07}:\n;<\x07\x7F<\f=>\x07q>?\x07t?@A\x07cAB\x07pBC\x07fCDE\x07yEF\x07jFG\x07gGH\x07tHI\x07gIJK\x07hKL\x07wLM\x07pMN\x07eNO\x07vOP\x07kPQ\x07qQU\x07pRS\x07hSU\x07pTJTRUVW\x07*WXY\x07+YZ[\x07<[\\]\x071]^_\x07B_`a\x07/a bc\x07?c\"df\x07/edeffhgi	hgijjhjkkrln\x070mo	nmoppnpqqsrlrss}tv	uw\x07/vuvwwyxz	yxz{{y{||~}t}~~$\x7F\x85\x07$\x80\x81\x07^\x81\x84\v\x82\x84\n\x83\x80\x83\x82\x84\x87\x85\x83\x85\x86\x86\x88\x87\x85\x88\x89\x07$\x89&\x8A\x8B\n\x07\x8B(\x8C\x8F'\x8D\x8F	\x8E\x8C\x8E\x8D\x8F*\x90\x94'\x91\x93)\x92\x91\x93\x96\x94\x92\x94\x95\x95,\x96\x94\x97\x98\x071\x98\x99\x071\x99\x9D\x9A\x9C\n\x9B\x9A\x9C\x9F\x9D\x9B\x9D\x9E\x9E\xA0\x9F\x9D\xA0\xA1\b\xA1.\xA2\xA3\x071\xA3\xA4\x07,\xA4\xA9\xA5\xA8/\xA6\xA8\v\xA7\xA5\xA7\xA6\xA8\xAB\xA9\xAA\xA9\xA7\xAA\xAC\xAB\xA9\xAC\xAD\x07,\xAD\xAE\x071\xAE\xAF\xAF\xB0\b\xB00\xB1\xB3	\b\xB2\xB1\xB3\xB4\xB4\xB2\xB4\xB5\xB5\xB6\xB6\xB7\b\xB72Tejprv{}\x83\x85\x8E\x94\x9D\xA7\xA9\xB4\b";
    }
    static {
      this._serializedATN = Utils.join(
        [
          _SalLexer._serializedATNSegment0,
          _SalLexer._serializedATNSegment1
        ],
        ""
      );
    }
    static get _ATN() {
      if (!_SalLexer.__ATN) {
        _SalLexer.__ATN = new import_ATNDeserializer.ATNDeserializer().deserialize(Utils.toCharArray(_SalLexer._serializedATN));
      }
      return _SalLexer.__ATN;
    }
  };

  // source/sal/.antlr-generated/SalParser.ts
  var import_ATN = __toESM(require_ATN());
  var import_ATNDeserializer2 = __toESM(require_ATNDeserializer());
  var import_FailedPredicateException = __toESM(require_FailedPredicateException());
  var import_NoViableAltException = __toESM(require_NoViableAltException());
  var import_Parser = __toESM(require_Parser());
  var import_ParserRuleContext = __toESM(require_ParserRuleContext());
  var import_ParserATNSimulator = __toESM(require_ParserATNSimulator());
  var import_RecognitionException = __toESM(require_RecognitionException());
  var import_Token = __toESM(require_Token());
  var import_VocabularyImpl2 = __toESM(require_VocabularyImpl());
  var Utils2 = __toESM(require_Utils());
  var SalParser = class _SalParser extends import_Parser.Parser {
    static {
      this.T__0 = 1;
    }
    static {
      this.T__1 = 2;
    }
    static {
      this.T__2 = 3;
    }
    static {
      this.T__3 = 4;
    }
    static {
      this.T__4 = 5;
    }
    static {
      this.OR = 6;
    }
    static {
      this.AND = 7;
    }
    static {
      this.WHERE = 8;
    }
    static {
      this.FUNCTION = 9;
    }
    static {
      this.PAREN_BEGIN = 10;
    }
    static {
      this.PAREN_END = 11;
    }
    static {
      this.COLON = 12;
    }
    static {
      this.SLASH = 13;
    }
    static {
      this.AT = 14;
    }
    static {
      this.MINUS = 15;
    }
    static {
      this.EQUALS = 16;
    }
    static {
      this.NUMBER = 17;
    }
    static {
      this.STRING = 18;
    }
    static {
      this.WORD = 19;
    }
    static {
      this.LINE_COMMENT = 20;
    }
    static {
      this.BLOCK_COMMENT = 21;
    }
    static {
      this.WS = 22;
    }
    static {
      this.RULE_sourceFile = 0;
    }
    static {
      this.RULE_word = 1;
    }
    static {
      this.RULE_parameter = 2;
    }
    static {
      this.RULE_entry = 3;
    }
    static {
      this.RULE_expression = 4;
    }
    static {
      // tslint:disable:no-trailing-whitespace
      this.ruleNames = [
        "sourceFile",
        "word",
        "parameter",
        "entry",
        "expression"
      ];
    }
    static {
      this._LITERAL_NAMES = [
        void 0,
        "'['",
        "','",
        "']'",
        "'{'",
        "'}'",
        "'or'",
        "'and'",
        "'where'",
        void 0,
        "'('",
        "')'",
        "':'",
        "'/'",
        "'@'",
        "'-'",
        "'='"
      ];
    }
    static {
      this._SYMBOLIC_NAMES = [
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        "OR",
        "AND",
        "WHERE",
        "FUNCTION",
        "PAREN_BEGIN",
        "PAREN_END",
        "COLON",
        "SLASH",
        "AT",
        "MINUS",
        "EQUALS",
        "NUMBER",
        "STRING",
        "WORD",
        "LINE_COMMENT",
        "BLOCK_COMMENT",
        "WS"
      ];
    }
    static {
      this.VOCABULARY = new import_VocabularyImpl2.VocabularyImpl(_SalParser._LITERAL_NAMES, _SalParser._SYMBOLIC_NAMES, []);
    }
    // @Override
    // @NotNull
    get vocabulary() {
      return _SalParser.VOCABULARY;
    }
    // tslint:enable:no-trailing-whitespace
    // @Override
    get grammarFileName() {
      return "Sal.g4";
    }
    // @Override
    get ruleNames() {
      return _SalParser.ruleNames;
    }
    // @Override
    get serializedATN() {
      return _SalParser._serializedATN;
    }
    createFailedPredicateException(predicate, message) {
      return new import_FailedPredicateException.FailedPredicateException(this, predicate, message);
    }
    constructor(input) {
      super(input);
      this._interp = new import_ParserATNSimulator.ParserATNSimulator(_SalParser._ATN, this);
    }
    // @RuleVersion(0)
    sourceFile() {
      let _localctx = new SourceFileContext(this._ctx, this.state);
      this.enterRule(_localctx, 0, _SalParser.RULE_sourceFile);
      let _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 11;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if ((_la & ~31) === 0 && (1 << _la & (1 << _SalParser.T__0 | 1 << _SalParser.T__3 | 1 << _SalParser.WHERE | 1 << _SalParser.FUNCTION | 1 << _SalParser.PAREN_BEGIN | 1 << _SalParser.AT | 1 << _SalParser.MINUS | 1 << _SalParser.NUMBER | 1 << _SalParser.STRING | 1 << _SalParser.WORD)) !== 0) {
            {
              this.state = 10;
              this.expression(0);
            }
          }
          this.state = 13;
          this.match(_SalParser.EOF);
        }
      } catch (re) {
        if (re instanceof import_RecognitionException.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
    word() {
      let _localctx = new WordContext(this._ctx, this.state);
      this.enterRule(_localctx, 2, _SalParser.RULE_word);
      let _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 15;
          _la = this._input.LA(1);
          if (!((_la & ~31) === 0 && (1 << _la & (1 << _SalParser.WHERE | 1 << _SalParser.FUNCTION | 1 << _SalParser.WORD)) !== 0)) {
            this._errHandler.recoverInline(this);
          } else {
            if (this._input.LA(1) === import_Token.Token.EOF) {
              this.matchedEOF = true;
            }
            this._errHandler.reportMatch(this);
            this.consume();
          }
        }
      } catch (re) {
        if (re instanceof import_RecognitionException.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
    parameter() {
      let _localctx = new ParameterContext(this._ctx, this.state);
      this.enterRule(_localctx, 4, _SalParser.RULE_parameter);
      let _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 18;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _SalParser.AT) {
            {
              this.state = 17;
              this.match(_SalParser.AT);
            }
          }
          this.state = 20;
          this.word();
        }
      } catch (re) {
        if (re instanceof import_RecognitionException.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
    entry() {
      let _localctx = new EntryContext(this._ctx, this.state);
      this.enterRule(_localctx, 6, _SalParser.RULE_entry);
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 24;
          this._errHandler.sync(this);
          switch (this._input.LA(1)) {
            case _SalParser.WHERE:
            case _SalParser.FUNCTION:
            case _SalParser.WORD:
              {
                this.state = 22;
                this.word();
              }
              break;
            case _SalParser.STRING:
              {
                this.state = 23;
                this.match(_SalParser.STRING);
              }
              break;
            default:
              throw new import_NoViableAltException.NoViableAltException(this);
          }
          this.state = 26;
          this.match(_SalParser.COLON);
          this.state = 27;
          this.expression(0);
        }
      } catch (re) {
        if (re instanceof import_RecognitionException.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
    expression(_p) {
      if (_p === void 0) {
        _p = 0;
      }
      let _parentctx = this._ctx;
      let _parentState = this.state;
      let _localctx = new ExpressionContext(this._ctx, _parentState);
      let _prevctx = _localctx;
      let _startState = 8;
      this.enterRecursionRule(_localctx, 8, _SalParser.RULE_expression, _p);
      let _la;
      try {
        let _alt;
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 87;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 12, this._ctx)) {
            case 1:
              {
                _localctx = new NotExpressionContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 30;
                this.match(_SalParser.MINUS);
                this.state = 31;
                this.expression(14);
              }
              break;
            case 2:
              {
                _localctx = new LambdaExpressionContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 32;
                this.match(_SalParser.AT);
                this.state = 33;
                this.match(_SalParser.FUNCTION);
                this.state = 35;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                do {
                  {
                    {
                      this.state = 34;
                      this.parameter();
                    }
                  }
                  this.state = 37;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                } while ((_la & ~31) === 0 && (1 << _la & (1 << _SalParser.WHERE | 1 << _SalParser.FUNCTION | 1 << _SalParser.AT | 1 << _SalParser.WORD)) !== 0);
                this.state = 39;
                this.match(_SalParser.COLON);
                this.state = 40;
                this.expression(8);
              }
              break;
            case 3:
              {
                _localctx = new NumberContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 43;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _SalParser.AT) {
                  {
                    this.state = 42;
                    this.match(_SalParser.AT);
                  }
                }
                this.state = 45;
                this.match(_SalParser.NUMBER);
              }
              break;
            case 4:
              {
                _localctx = new StringContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 47;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _SalParser.AT) {
                  {
                    this.state = 46;
                    this.match(_SalParser.AT);
                  }
                }
                this.state = 49;
                this.match(_SalParser.STRING);
              }
              break;
            case 5:
              {
                _localctx = new VariableContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 50;
                this.match(_SalParser.AT);
                this.state = 51;
                this.word();
              }
              break;
            case 6:
              {
                _localctx = new WordExpressionContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 52;
                this.word();
              }
              break;
            case 7:
              {
                _localctx = new ListLiteralExpressionContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 53;
                this.match(_SalParser.T__0);
                this.state = 62;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & (1 << _SalParser.T__0 | 1 << _SalParser.T__3 | 1 << _SalParser.WHERE | 1 << _SalParser.FUNCTION | 1 << _SalParser.PAREN_BEGIN | 1 << _SalParser.AT | 1 << _SalParser.MINUS | 1 << _SalParser.NUMBER | 1 << _SalParser.STRING | 1 << _SalParser.WORD)) !== 0) {
                  {
                    this.state = 54;
                    this.expression(0);
                    this.state = 59;
                    this._errHandler.sync(this);
                    _alt = this.interpreter.adaptivePredict(this._input, 6, this._ctx);
                    while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
                      if (_alt === 1) {
                        {
                          {
                            this.state = 55;
                            this.match(_SalParser.T__1);
                            this.state = 56;
                            this.expression(0);
                          }
                        }
                      }
                      this.state = 61;
                      this._errHandler.sync(this);
                      _alt = this.interpreter.adaptivePredict(this._input, 6, this._ctx);
                    }
                  }
                }
                this.state = 65;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _SalParser.T__1) {
                  {
                    this.state = 64;
                    this.match(_SalParser.T__1);
                  }
                }
                this.state = 67;
                this.match(_SalParser.T__2);
              }
              break;
            case 8:
              {
                _localctx = new RecordLiteralExpressionContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 68;
                this.match(_SalParser.T__3);
                this.state = 77;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & (1 << _SalParser.WHERE | 1 << _SalParser.FUNCTION | 1 << _SalParser.STRING | 1 << _SalParser.WORD)) !== 0) {
                  {
                    this.state = 69;
                    this.entry();
                    this.state = 74;
                    this._errHandler.sync(this);
                    _alt = this.interpreter.adaptivePredict(this._input, 9, this._ctx);
                    while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
                      if (_alt === 1) {
                        {
                          {
                            this.state = 70;
                            this.match(_SalParser.T__1);
                            this.state = 71;
                            this.entry();
                          }
                        }
                      }
                      this.state = 76;
                      this._errHandler.sync(this);
                      _alt = this.interpreter.adaptivePredict(this._input, 9, this._ctx);
                    }
                  }
                }
                this.state = 80;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _SalParser.T__1) {
                  {
                    this.state = 79;
                    this.match(_SalParser.T__1);
                  }
                }
                this.state = 82;
                this.match(_SalParser.T__4);
              }
              break;
            case 9:
              {
                _localctx = new ParenthesizedExpressionContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 83;
                this.match(_SalParser.PAREN_BEGIN);
                this.state = 84;
                this.expression(0);
                this.state = 85;
                this.match(_SalParser.PAREN_END);
              }
              break;
          }
          this._ctx._stop = this._input.tryLT(-1);
          this.state = 118;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 15, this._ctx);
          while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
            if (_alt === 1) {
              if (this._parseListeners != null) {
                this.triggerExitRuleEvent();
              }
              _prevctx = _localctx;
              {
                this.state = 116;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 14, this._ctx)) {
                  case 1:
                    {
                      _localctx = new ApplyExpressionContext(new ExpressionContext(_parentctx, _parentState));
                      _localctx._left = _prevctx;
                      this.pushNewRecursionContext(_localctx, _startState, _SalParser.RULE_expression);
                      this.state = 89;
                      if (!this.precpred(this._ctx, 15)) {
                        throw this.createFailedPredicateException("this.precpred(this._ctx, 15)");
                      }
                      this.state = 90;
                      this.match(_SalParser.COLON);
                      this.state = 91;
                      _localctx._right = this.expression(16);
                    }
                    break;
                  case 2:
                    {
                      _localctx = new SequenceExpressionContext(new ExpressionContext(_parentctx, _parentState));
                      _localctx._left = _prevctx;
                      this.pushNewRecursionContext(_localctx, _startState, _SalParser.RULE_expression);
                      this.state = 92;
                      if (!this.precpred(this._ctx, 13)) {
                        throw this.createFailedPredicateException("this.precpred(this._ctx, 13)");
                      }
                      this.state = 93;
                      _localctx._right = this.expression(14);
                    }
                    break;
                  case 3:
                    {
                      _localctx = new OrExpressionContext(new ExpressionContext(_parentctx, _parentState));
                      _localctx._left = _prevctx;
                      this.pushNewRecursionContext(_localctx, _startState, _SalParser.RULE_expression);
                      this.state = 94;
                      if (!this.precpred(this._ctx, 12)) {
                        throw this.createFailedPredicateException("this.precpred(this._ctx, 12)");
                      }
                      this.state = 95;
                      this.match(_SalParser.OR);
                      this.state = 96;
                      _localctx._right = this.expression(13);
                    }
                    break;
                  case 4:
                    {
                      _localctx = new AndExpressionContext(new ExpressionContext(_parentctx, _parentState));
                      _localctx._left = _prevctx;
                      this.pushNewRecursionContext(_localctx, _startState, _SalParser.RULE_expression);
                      this.state = 97;
                      if (!this.precpred(this._ctx, 11)) {
                        throw this.createFailedPredicateException("this.precpred(this._ctx, 11)");
                      }
                      this.state = 98;
                      this.match(_SalParser.AND);
                      this.state = 99;
                      _localctx._right = this.expression(12);
                    }
                    break;
                  case 5:
                    {
                      _localctx = new BinaryExpressionContext(new ExpressionContext(_parentctx, _parentState));
                      _localctx._left = _prevctx;
                      this.pushNewRecursionContext(_localctx, _startState, _SalParser.RULE_expression);
                      this.state = 100;
                      if (!this.precpred(this._ctx, 10)) {
                        throw this.createFailedPredicateException("this.precpred(this._ctx, 10)");
                      }
                      this.state = 101;
                      this.match(_SalParser.SLASH);
                      this.state = 102;
                      this.word();
                      this.state = 103;
                      _localctx._right = this.expression(11);
                    }
                    break;
                  case 6:
                    {
                      _localctx = new WhereExpressionContext(new ExpressionContext(_parentctx, _parentState));
                      _localctx._scope = _prevctx;
                      this.pushNewRecursionContext(_localctx, _startState, _SalParser.RULE_expression);
                      this.state = 105;
                      if (!this.precpred(this._ctx, 9)) {
                        throw this.createFailedPredicateException("this.precpred(this._ctx, 9)");
                      }
                      this.state = 106;
                      this.match(_SalParser.AT);
                      this.state = 107;
                      this.match(_SalParser.WHERE);
                      this.state = 109;
                      this._errHandler.sync(this);
                      _la = this._input.LA(1);
                      do {
                        {
                          {
                            this.state = 108;
                            this.parameter();
                          }
                        }
                        this.state = 111;
                        this._errHandler.sync(this);
                        _la = this._input.LA(1);
                      } while ((_la & ~31) === 0 && (1 << _la & (1 << _SalParser.WHERE | 1 << _SalParser.FUNCTION | 1 << _SalParser.AT | 1 << _SalParser.WORD)) !== 0);
                      this.state = 113;
                      this.match(_SalParser.EQUALS);
                      this.state = 114;
                      _localctx._value = this.expression(10);
                    }
                    break;
                }
              }
            }
            this.state = 120;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 15, this._ctx);
          }
        }
      } catch (re) {
        if (re instanceof import_RecognitionException.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.unrollRecursionContexts(_parentctx);
      }
      return _localctx;
    }
    sempred(_localctx, ruleIndex, predIndex) {
      switch (ruleIndex) {
        case 4:
          return this.expression_sempred(_localctx, predIndex);
      }
      return true;
    }
    expression_sempred(_localctx, predIndex) {
      switch (predIndex) {
        case 0:
          return this.precpred(this._ctx, 15);
        case 1:
          return this.precpred(this._ctx, 13);
        case 2:
          return this.precpred(this._ctx, 12);
        case 3:
          return this.precpred(this._ctx, 11);
        case 4:
          return this.precpred(this._ctx, 10);
        case 5:
          return this.precpred(this._ctx, 9);
      }
      return true;
    }
    static {
      this._serializedATN = "\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241|					\n\n\x1B\n&\n\r'.\n2\n\x07<\n\f?\vA\nD\n\x07K\n\fN\vP\nS\nZ\np\n\rq\x07w\n\fz\v\n\x07\b\n\n\v\x91\r\b\nY\f\n\r\f\r\x07	\x07\x07\x1B\x1B\x07\x1B\x07\n	 \b !\x07!Z\n\"#\x07#%\x07\v$&%$&''%'(())*\x07*+\n\n+Z,.\x07-,-..//Z\x0702\x071012233Z\x0745\x075Z6Z7@\x078=\n9:\x07:<\n;9<?=;=>>A?=@8@AACBD\x07CBCDDEEZ\x07FO\x07GL\bHI\x07IK\bJHKNLJLMMPNLOGOPPRQS\x07RQRSSTTZ\x07\x07UV\x07\fVW\nWX\x07\rXZYY\"Y-Y1Y4Y6Y7YFYUZx[\\\f\\]\x07]w\n^_\f_w\n`a\fab\x07\bbw\ncd\f\rde\x07	ew\nfg\f\fgh\x07hiij\n\rjwkl\f\vlm\x07mo\x07\nnponpqqoqrrsst\x07tu\n\fuwv[v^v`vcvfvkwzxvxyy\vzx\r'-1=@CLORYqvx";
    }
    static get _ATN() {
      if (!_SalParser.__ATN) {
        _SalParser.__ATN = new import_ATNDeserializer2.ATNDeserializer().deserialize(Utils2.toCharArray(_SalParser._serializedATN));
      }
      return _SalParser.__ATN;
    }
  };
  var SourceFileContext = class extends import_ParserRuleContext.ParserRuleContext {
    EOF() {
      return this.getToken(SalParser.EOF, 0);
    }
    expression() {
      return this.tryGetRuleContext(0, ExpressionContext);
    }
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    // @Override
    get ruleIndex() {
      return SalParser.RULE_sourceFile;
    }
    // @Override
    enterRule(listener) {
      if (listener.enterSourceFile) {
        listener.enterSourceFile(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitSourceFile) {
        listener.exitSourceFile(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitSourceFile) {
        return visitor.visitSourceFile(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var WordContext = class extends import_ParserRuleContext.ParserRuleContext {
    WHERE() {
      return this.tryGetToken(SalParser.WHERE, 0);
    }
    FUNCTION() {
      return this.tryGetToken(SalParser.FUNCTION, 0);
    }
    WORD() {
      return this.tryGetToken(SalParser.WORD, 0);
    }
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    // @Override
    get ruleIndex() {
      return SalParser.RULE_word;
    }
    // @Override
    enterRule(listener) {
      if (listener.enterWord) {
        listener.enterWord(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitWord) {
        listener.exitWord(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitWord) {
        return visitor.visitWord(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var ParameterContext = class extends import_ParserRuleContext.ParserRuleContext {
    word() {
      return this.getRuleContext(0, WordContext);
    }
    AT() {
      return this.tryGetToken(SalParser.AT, 0);
    }
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    // @Override
    get ruleIndex() {
      return SalParser.RULE_parameter;
    }
    // @Override
    enterRule(listener) {
      if (listener.enterParameter) {
        listener.enterParameter(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitParameter) {
        listener.exitParameter(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitParameter) {
        return visitor.visitParameter(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var EntryContext = class extends import_ParserRuleContext.ParserRuleContext {
    COLON() {
      return this.getToken(SalParser.COLON, 0);
    }
    expression() {
      return this.getRuleContext(0, ExpressionContext);
    }
    word() {
      return this.tryGetRuleContext(0, WordContext);
    }
    STRING() {
      return this.tryGetToken(SalParser.STRING, 0);
    }
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    // @Override
    get ruleIndex() {
      return SalParser.RULE_entry;
    }
    // @Override
    enterRule(listener) {
      if (listener.enterEntry) {
        listener.enterEntry(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitEntry) {
        listener.exitEntry(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitEntry) {
        return visitor.visitEntry(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var ExpressionContext = class extends import_ParserRuleContext.ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    // @Override
    get ruleIndex() {
      return SalParser.RULE_expression;
    }
    copyFrom(ctx) {
      super.copyFrom(ctx);
    }
  };
  var ApplyExpressionContext = class extends ExpressionContext {
    COLON() {
      return this.getToken(SalParser.COLON, 0);
    }
    expression(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExpressionContext);
      } else {
        return this.getRuleContext(i, ExpressionContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterApplyExpression) {
        listener.enterApplyExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitApplyExpression) {
        listener.exitApplyExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitApplyExpression) {
        return visitor.visitApplyExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var NotExpressionContext = class extends ExpressionContext {
    MINUS() {
      return this.getToken(SalParser.MINUS, 0);
    }
    expression() {
      return this.getRuleContext(0, ExpressionContext);
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterNotExpression) {
        listener.enterNotExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitNotExpression) {
        listener.exitNotExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitNotExpression) {
        return visitor.visitNotExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var SequenceExpressionContext = class extends ExpressionContext {
    expression(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExpressionContext);
      } else {
        return this.getRuleContext(i, ExpressionContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterSequenceExpression) {
        listener.enterSequenceExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitSequenceExpression) {
        listener.exitSequenceExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitSequenceExpression) {
        return visitor.visitSequenceExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var OrExpressionContext = class extends ExpressionContext {
    OR() {
      return this.getToken(SalParser.OR, 0);
    }
    expression(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExpressionContext);
      } else {
        return this.getRuleContext(i, ExpressionContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterOrExpression) {
        listener.enterOrExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitOrExpression) {
        listener.exitOrExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitOrExpression) {
        return visitor.visitOrExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var AndExpressionContext = class extends ExpressionContext {
    AND() {
      return this.getToken(SalParser.AND, 0);
    }
    expression(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExpressionContext);
      } else {
        return this.getRuleContext(i, ExpressionContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterAndExpression) {
        listener.enterAndExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitAndExpression) {
        listener.exitAndExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitAndExpression) {
        return visitor.visitAndExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var BinaryExpressionContext = class extends ExpressionContext {
    SLASH() {
      return this.getToken(SalParser.SLASH, 0);
    }
    word() {
      return this.getRuleContext(0, WordContext);
    }
    expression(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExpressionContext);
      } else {
        return this.getRuleContext(i, ExpressionContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterBinaryExpression) {
        listener.enterBinaryExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitBinaryExpression) {
        listener.exitBinaryExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitBinaryExpression) {
        return visitor.visitBinaryExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var WhereExpressionContext = class extends ExpressionContext {
    AT() {
      return this.getToken(SalParser.AT, 0);
    }
    WHERE() {
      return this.getToken(SalParser.WHERE, 0);
    }
    EQUALS() {
      return this.getToken(SalParser.EQUALS, 0);
    }
    expression(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExpressionContext);
      } else {
        return this.getRuleContext(i, ExpressionContext);
      }
    }
    parameter(i) {
      if (i === void 0) {
        return this.getRuleContexts(ParameterContext);
      } else {
        return this.getRuleContext(i, ParameterContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterWhereExpression) {
        listener.enterWhereExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitWhereExpression) {
        listener.exitWhereExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitWhereExpression) {
        return visitor.visitWhereExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var LambdaExpressionContext = class extends ExpressionContext {
    AT() {
      return this.getToken(SalParser.AT, 0);
    }
    FUNCTION() {
      return this.getToken(SalParser.FUNCTION, 0);
    }
    COLON() {
      return this.getToken(SalParser.COLON, 0);
    }
    expression() {
      return this.getRuleContext(0, ExpressionContext);
    }
    parameter(i) {
      if (i === void 0) {
        return this.getRuleContexts(ParameterContext);
      } else {
        return this.getRuleContext(i, ParameterContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterLambdaExpression) {
        listener.enterLambdaExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitLambdaExpression) {
        listener.exitLambdaExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitLambdaExpression) {
        return visitor.visitLambdaExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var NumberContext = class extends ExpressionContext {
    NUMBER() {
      return this.getToken(SalParser.NUMBER, 0);
    }
    AT() {
      return this.tryGetToken(SalParser.AT, 0);
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterNumber) {
        listener.enterNumber(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitNumber) {
        listener.exitNumber(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitNumber) {
        return visitor.visitNumber(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var StringContext = class extends ExpressionContext {
    STRING() {
      return this.getToken(SalParser.STRING, 0);
    }
    AT() {
      return this.tryGetToken(SalParser.AT, 0);
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterString) {
        listener.enterString(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitString) {
        listener.exitString(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitString) {
        return visitor.visitString(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var VariableContext = class extends ExpressionContext {
    AT() {
      return this.getToken(SalParser.AT, 0);
    }
    word() {
      return this.getRuleContext(0, WordContext);
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterVariable) {
        listener.enterVariable(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitVariable) {
        listener.exitVariable(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitVariable) {
        return visitor.visitVariable(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var WordExpressionContext = class extends ExpressionContext {
    word() {
      return this.getRuleContext(0, WordContext);
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterWordExpression) {
        listener.enterWordExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitWordExpression) {
        listener.exitWordExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitWordExpression) {
        return visitor.visitWordExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var ListLiteralExpressionContext = class extends ExpressionContext {
    expression(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExpressionContext);
      } else {
        return this.getRuleContext(i, ExpressionContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterListLiteralExpression) {
        listener.enterListLiteralExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitListLiteralExpression) {
        listener.exitListLiteralExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitListLiteralExpression) {
        return visitor.visitListLiteralExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var RecordLiteralExpressionContext = class extends ExpressionContext {
    entry(i) {
      if (i === void 0) {
        return this.getRuleContexts(EntryContext);
      } else {
        return this.getRuleContext(i, EntryContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterRecordLiteralExpression) {
        listener.enterRecordLiteralExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitRecordLiteralExpression) {
        listener.exitRecordLiteralExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitRecordLiteralExpression) {
        return visitor.visitRecordLiteralExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var ParenthesizedExpressionContext = class extends ExpressionContext {
    PAREN_BEGIN() {
      return this.getToken(SalParser.PAREN_BEGIN, 0);
    }
    expression() {
      return this.getRuleContext(0, ExpressionContext);
    }
    PAREN_END() {
      return this.getToken(SalParser.PAREN_END, 0);
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterParenthesizedExpression) {
        listener.enterParenthesizedExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitParenthesizedExpression) {
        listener.exitParenthesizedExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitParenthesizedExpression) {
        return visitor.visitParenthesizedExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };

  // source/sal/evaluator.ts
  var import_TerminalNode = __toESM(require_TerminalNode());
  var import_ErrorNode = __toESM(require_ErrorNode());
  var import_ParseTree = __toESM(require_ParseTree());
  var import_RuleNode = __toESM(require_RuleNode());
  var unreachable = (node) => {
    if (node instanceof import_TerminalNode.TerminalNode) {
      const symbol = node.symbol;
      const position = {
        line: symbol.line,
        column: symbol.charPositionInLine
      };
      return raise`unreachable: ${JSON.stringify(position)}, ${node.toString()}`;
    }
    return raise`unreachable: ${node.toStringTree()}`;
  };
  function getNumberValue(v) {
    return JSON.parse(v.text);
  }
  function getStringValue(v) {
    return JSON.parse(v.text);
  }
  function getWordValue(v) {
    return v.text;
  }
  function getNameOfWordOrString(e) {
    const v = e.STRING();
    if (v != null) return getStringValue(v);
    const w = e.word();
    if (w != null) return getWordValue(w);
    return unreachable(e);
  }
  function getParameterName(e) {
    return getWordValue(e.word());
  }
  function createNestedFunctionOrValue(scope, parameterNames, body) {
    const [p, ...ps] = parameterNames;
    if (p == void 0) return scope.visitExpression(body);
    return done((v) => {
      scope.environment.set(p, v);
      return createNestedFunctionOrValue(scope, ps, body);
    });
  }
  function forceAsFunction(x) {
    if (typeof x !== "function") return raise`${x} is not function`;
    return x;
  }
  var SalEvaluationVisitor = class _SalEvaluationVisitor {
    constructor(tryResolveParentVariable) {
      this.tryResolveParentVariable = tryResolveParentVariable;
      this.visit = unreachable;
      this.visitChildren = unreachable;
      this.visitTerminal = unreachable;
      this.visitErrorNode = unreachable;
      this.environment = /* @__PURE__ */ new Map();
      this.tryResolveVariable = (k) => {
        const v = this.environment.get(k);
        return v === void 0 ? tryResolveParentVariable(k) : v;
      };
    }
    resolveVariable(name) {
      const v = this.tryResolveVariable(name);
      if (v === void 0) throw new Error(`undefined variable: ${name}`);
      return v;
    }
    *evaluateBinaryLikeExpression(left, opName, right) {
      const l = yield* this.visitExpression(left);
      const f = forceAsFunction(
        this.resolveVariable(opName)
      );
      const r = yield* this.visitExpression(right);
      return yield* (yield* f(l))(r);
    }
    *visitExpression(e) {
      if (e.exception) {
        const fromVoid = forceAsFunction(
          this.resolveVariable("fromMissing")
        );
        return yield* fromVoid(null);
      }
      try {
        return yield* e.accept(this);
      } catch (error) {
        let showPosition2 = function({ line, charPositionInLine }) {
          return `${line}:${charPositionInLine}`;
        };
        var showPosition = showPosition2;
        const start = showPosition2(e.start);
        const stop = e.stop ? `,${showPosition2(e.stop)}` : "";
        return raise`[${start}${stop}]: ${error}`;
      }
    }
    visitSourceFile(e) {
      const body = e.expression();
      if (body == null) {
        const fromEmpty = forceAsFunction(this.resolveVariable("fromVoid"));
        return fromEmpty(null);
      }
      return this.visitExpression(body);
    }
    visitLambdaExpression(e) {
      const newScope = new _SalEvaluationVisitor(this.tryResolveVariable);
      const ps = e.parameter().map(getParameterName);
      const body = e.expression();
      return createNestedFunctionOrValue(newScope, ps, body);
    }
    *visitNotExpression(e) {
      const not2 = forceAsFunction(this.resolveVariable("not_"));
      const v = yield* this.visitExpression(e.expression());
      return yield* not2(v);
    }
    *visitApplyExpression(e) {
      const f = forceAsFunction(yield* this.visitExpression(e._left));
      const x = yield* this.visitExpression(e._right);
      return yield* f(x);
    }
    visitSequenceExpression(e) {
      return this.evaluateBinaryLikeExpression(e._left, "_seq_", e._right);
    }
    visitOrExpression(e) {
      return this.evaluateBinaryLikeExpression(e._left, "_or_", e._right);
    }
    visitAndExpression(e) {
      return this.evaluateBinaryLikeExpression(e._left, "_and_", e._right);
    }
    *visitBinaryExpression(e) {
      const l = yield* this.visitExpression(e._left);
      const op = forceAsFunction(
        this.resolveVariable(getWordValue(e.word()))
      );
      const r = yield* this.visitExpression(e._right);
      return yield* (yield* op(l))(r);
    }
    *visitWhereExpression(e) {
      const newScope = new _SalEvaluationVisitor(this.tryResolveVariable);
      const [param0, ...params] = e.parameter();
      const id2 = getParameterName(param0);
      const ps = params.map(getParameterName);
      const value = yield* createNestedFunctionOrValue(
        newScope,
        ps,
        e._value
      );
      newScope.environment.set(id2, value);
      return yield* newScope.visitExpression(e._scope);
    }
    visitNumber(e) {
      const value = getNumberValue(e.NUMBER());
      if (e.AT() != null) return done(value);
      const fromNumber = forceAsFunction(
        this.resolveVariable("fromNumber")
      );
      return fromNumber(value);
    }
    visitString(e) {
      const value = getStringValue(e.STRING());
      if (e.AT() != null) return done(value);
      const fromString2 = forceAsFunction(
        this.resolveVariable("fromString")
      );
      return fromString2(value);
    }
    visitVariable(e) {
      const name = getWordValue(e.word());
      return done(this.resolveVariable(name));
    }
    visitWordExpression(e) {
      return e.word().accept(this);
    }
    visitWord(e) {
      const name = getWordValue(e);
      const value = this.tryResolveVariable(name);
      if (value !== void 0) return done(value);
      const fromWord = forceAsFunction(
        this.resolveVariable("fromWord")
      );
      return fromWord(name);
    }
    visitParenthesizedExpression(e) {
      return this.visitExpression(e.expression());
    }
    evaluateExpressionAsLiteral(e) {
      if (e instanceof NumberContext) {
        return done(getNumberValue(e.NUMBER()));
      }
      if (e instanceof StringContext) {
        return done(getStringValue(e.STRING()));
      }
      return this.visitExpression(e);
    }
    *visitListLiteralExpression(e) {
      const getEmptyList = forceAsFunction(
        this.resolveVariable("getEmptyList")
      );
      let list = yield* getEmptyList(null);
      let consList;
      for (const item of e.expression()) {
        const x = yield* this.evaluateExpressionAsLiteral(item);
        consList ??= forceAsFunction(
          this.resolveVariable("consList")
        );
        list = yield* (yield* consList(list))(x);
      }
      return list;
    }
    *visitRecordLiteralExpression(e) {
      const getEmptyRecord = forceAsFunction(
        this.resolveVariable("getEmptyRecord")
      );
      let record2 = yield* getEmptyRecord(null);
      let consRecord;
      for (const entry of e.entry()) {
        const key = getNameOfWordOrString(entry);
        const value = yield* this.evaluateExpressionAsLiteral(
          entry.expression()
        );
        consRecord ??= forceAsFunction(this.resolveVariable("consRecord"));
        record2 = yield* (yield* (yield* consRecord(record2))(key))(value);
      }
      return record2;
    }
  };
  function createStandardGlobals() {
    const globals = {
      fromVoid(_) {
        return done("fromVoid");
      },
      fromMissing(_) {
        return done("fromMissing");
      },
      fromWord(x) {
        return done(`fromWord(${x})`);
      },
      fromString(x) {
        return done(`fromString(${x})`);
      },
      fromNumber(x) {
        return done(`fromNumber(${x})`);
      },
      getEmptyList(_) {
        return done([]);
      },
      consList(list) {
        return done((item) => {
          list.push(item);
          return done(list);
        });
      },
      getEmptyRecord(_) {
        const x = /* @__PURE__ */ Object.create(null);
        return done(x);
      },
      consRecord(record2) {
        return done((k) => {
          return done((v) => {
            record2[k] = v;
            return done(record2);
          });
        });
      },
      not_(x) {
        return done(`not(${x})`);
      },
      _seq_(x) {
        return done((y) => done(`seq(${x}, ${y})`));
      },
      _or_(x) {
        return done((y) => done(`or(${x}, ${y})`));
      },
      _and_(x) {
        return done((y) => done(`and(${x}, ${y})`));
      }
    };
    return new Map(Object.entries(globals));
  }
  function evaluateExpression(source, resolveGlobal) {
    const chars = import_antlr4ts.CharStreams.fromString(source);
    const lexer = new SalLexer(chars);
    const tokens = new import_antlr4ts.CommonTokenStream(lexer);
    const parser = new SalParser(tokens);
    const tree = parser.sourceFile();
    const globals = createStandardGlobals();
    const tryResolveGlobalVariable = (k) => {
      const v = resolveGlobal(k);
      if (v !== void 0) return v;
      return globals.get(k);
    };
    return tree.accept(new SalEvaluationVisitor(tryResolveGlobalVariable));
  }

  // source/drafts-view/draft-filter.ts
  async function getDraftStat(source, cell14, signal) {
    const cell14Drafts = source.cell14DraftsLazy();
    const cell14Id = cell14.toString();
    const draft14 = cell14Drafts.get(cell14Id);
    if (draft14 == null) return;
    const stat14 = await source.cell14StatMemoized(cell14, signal);
    if (stat14 == null) return;
    let potentialStops = 0;
    for (const cell17IdOnDraft of draft14.cell17Drafts) {
      const stat17 = stat14.cell17s.get(cell17IdOnDraft);
      const stopCount = (stat17?.kindToCount.get("POKESTOP") ?? 0) + (stat17?.kindToCount.get("GYM") ?? 0);
      if (stopCount === 0) {
        potentialStops++;
      }
    }
    return {
      potentialStops
    };
  }
  async function getCell17(resource, cell, signal) {
    const cell14 = createCellFromCoordinates(cell.getLatLng(), 14);
    const stat = await resource.cell14StatMemoized(cell14, signal);
    if (stat == null) return;
    const cell17Id = getCellId(cell.getLatLng(), 17);
    return stat.cell17s.get(cell17Id);
  }
  function createEnvironment(records, drafts) {
    const resource = {
      records,
      cell14DraftsLazy: cached(() => buildDraftMap(drafts)),
      cell14StatMemoized: memoizeWith(
        (cell, _) => cell.toString(),
        (_, cell, signal) => getCell14Stats(records, cell, signal)
      ),
      draftStatMemoized: memoizeWith(
        (cell, _) => cell.toString(),
        (_, cell, signal) => getDraftStat(resource, cell, signal)
      )
    };
    const duration = 60 * 60 * 24 * 7;
    const minFreshDate = Date.now() - duration * 1e3;
    return {
      getUserLocation() {
        return done({
          lat: 0,
          lng: 0
        });
      },
      *getCell14Stat(d) {
        const signal = yield* getCancel();
        return yield* awaitPromise(
          resource.cell14StatMemoized(
            createCellFromCoordinates(d.coordinates[0], 14),
            signal
          )
        );
      },
      *getCell17Stat(d) {
        const signal = yield* getCancel();
        return yield* awaitPromise(
          getCell17(
            resource,
            createCellFromCoordinates(d.coordinates[0], 17),
            signal
          )
        );
      },
      *getCell14DraftStat(d) {
        const signal = yield* getCancel();
        return yield* awaitPromise(
          resource.draftStatMemoized(
            createCellFromCoordinates(d.coordinates[0], 14),
            signal
          )
        );
      },
      getMinFreshDate() {
        return done(minFreshDate);
      }
    };
  }
  async function filterDrafts(records, drafts, source, signal) {
    const queryGlobals = createStandardQueries();
    const effective = evaluateExpression(source, (k) => queryGlobals.get(k));
    const filter = await forceAsPromise(effective, signal);
    const queryBuilder = filter;
    const environment = createEnvironment(records, drafts);
    const query = await forceAsPromise(
      queryBuilder.initialize(environment),
      signal
    );
    const result = [];
    let error = null;
    for (const d of drafts) {
      let isVisible = false;
      try {
        isVisible = await forceAsPromise(query.isVisible(d), signal);
      } catch (e) {
        error ??= e;
      }
      if (isVisible) {
        result.push(d);
      }
    }
    if (error) console.error(error);
    return result;
  }

  // source/drafts-view/query-view/editor.module.css
  var cssText9 = '.container-d2884e1bfe18458a2c14f99c2858b84b0436b9fe {\r\n    height: 100%;\r\n    width: 100%;\r\n    overflow: hidden;\r\n}\r\n.textarea-9ee51246f4e15195eb839d111a36d9a96536f0f4 {\r\n    height: 100%;\r\n    width: 100%;\r\n    resize: none;\r\n    font-family: "Courier New", Courier, monospace;\r\n\r\n    background-color: transparent;\r\n}\r\n';
  var editor_default = {
    container: "container-d2884e1bfe18458a2c14f99c2858b84b0436b9fe",
    textarea: "textarea-9ee51246f4e15195eb839d111a36d9a96536f0f4"
  };

  // source/drafts-view/query-view/editor.tsx
  var setStyle9 = styleSetter(cssText9);
  function createEditor({ initialText }) {
    setStyle9();
    const events = createTypedEventTarget();
    const textarea = /* @__PURE__ */ jsx(
      "textarea",
      {
        class: editor_default.textarea,
        oninput: (e) => {
          const target = e.target;
          events.dispatchEvent(
            createTypedCustomEvent("input", target.value)
          );
        },
        children: initialText
      }
    );
    const element = /* @__PURE__ */ jsx("div", { class: editor_default.container, children: textarea });
    function setSource(value) {
      textarea.value = value;
    }
    return {
      element,
      events,
      setSource
    };
  }

  // source/drafts-view/draft-list.tsx
  function newFreshId(baseName, definedIds) {
    const names = new Set(definedIds);
    for (let i = 2; ; i++) {
      const id2 = `${baseName}${i}`;
      if (!names.has(id2)) return id2;
    }
  }
  function toSpliced(array2, start, deleteCount, ...items) {
    const result = [...array2];
    result.splice(start, deleteCount, ...items);
    return result;
  }
  function hasMinLength(items, length) {
    return items.length >= length;
  }
  function isTrivial({ id: id2, contents }, { sources }) {
    return contents === "" || contents.length <= 1 || sources.find((s) => s.id !== id2 && s.contents === contents);
  }
  function isAndroid() {
    return /android/i.test(navigator.userAgent);
  }
  function openGoogleMaps({ lat, lng }, title) {
    const url = isAndroid() ? (
      // &z=${zoom}
      `intent://0,0?q=${lat},${lng}%20(${encodeURIComponent(title)})#Intent;scheme=geo;package=com.google.android.apps.maps;end`
    ) : `https://www.google.com/maps/search/?api=1&query=${lat},${lng}`;
    window.open(url, "_blank");
  }
  var setStyle10 = styleSetter(cssText3);
  function createDraftList({
    overlay,
    remote,
    records,
    local,
    handleAsyncError: handleAsyncError2
  }) {
    setStyle10();
    const events = createTypedEventTarget();
    let allDrafts = Array.from(overlay.drafts.values()).map(
      (view) => view.draft
    );
    let filteredDrafts = [...allDrafts];
    let selectedDraft = null;
    let currentSources = local.getConfig().sources || {
      selectedIndex: 0,
      sources: [{ id: "source0", contents: "" }]
    };
    const sourceList = createSourceList({ initialList: currentSources });
    const sourceListDialog = createDialog(sourceList.element, {
      title: "\u691C\u7D22\u4E00\u89A7"
    });
    const editor = createEditor({ initialText: getSelectedSource() ?? "" });
    const editorDialog = createDialog(editor.element, {
      title: "\u691C\u7D22\u30EF\u30FC\u30C9\u3092\u7DE8\u96C6"
    });
    sourceList.events.addEventListener("select", ({ detail: index }) => {
      setCurrentSourcesAndNotify({
        ...currentSources,
        selectedIndex: index
      });
    });
    sourceList.events.addEventListener("delete", ({ detail: index }) => {
      const oldSource = currentSources.sources[index];
      if (oldSource == null || !hasMinLength(currentSources.sources, 2)) {
        return;
      }
      const oldSources = currentSources.sources;
      if (!isTrivial(oldSource, currentSources) && !confirm(
        `\u672C\u5F53\u306B ${JSON.stringify(
          oldSource.contents
        )} (id: ${JSON.stringify(oldSource.id)}) \u3092\u524A\u9664\u3057\u307E\u3059\u304B\uFF1F`
      )) {
        return;
      }
      const newSources = toSpliced(oldSources, index, 1);
      const newIndex = currentSources.sources.length === 0 ? null : currentSources.sources.length <= index + 1 ? index - 1 : index;
      setCurrentSourcesAndNotify({
        ...currentSources,
        selectedIndex: newIndex,
        sources: newSources
      });
    });
    sourceList.events.addEventListener("add", () => {
      const id2 = newFreshId(
        "source",
        currentSources.sources.map((s) => s.id)
      );
      const contents = getSelectedSource() ?? "";
      const newSource = { id: id2, contents };
      const index = currentSources.selectedIndex === null ? 0 : currentSources.selectedIndex + 1;
      const sources = toSpliced(currentSources.sources, index, 0, newSource);
      setCurrentSourcesAndNotify({
        ...currentSources,
        selectedIndex: index,
        sources
      });
    });
    editor.events.addEventListener("input", ({ detail: value }) => {
      setSelectedSourceAndNotify(value);
    });
    function setCurrentSourcesAndNotify(newSources) {
      currentSources = newSources;
      sourceList.setSources(currentSources);
      const selectedSource = getSelectedSource() ?? "";
      filterInput.setValue(selectedSource);
      requestFilterUpdate();
      editor.setSource(selectedSource);
      local.setConfig({ ...local.getConfig(), sources: currentSources });
    }
    function getSelectedSource() {
      return currentSources.sources[currentSources.selectedIndex ?? -1]?.contents;
    }
    function setSelectedSourceAndNotify(newContents) {
      const index = currentSources.selectedIndex ?? -1;
      const source = currentSources.sources[index];
      if (source == null) return;
      const sources = toSpliced(currentSources.sources, index, 1, {
        ...source,
        contents: newContents
      });
      setCurrentSourcesAndNotify({ ...currentSources, sources });
    }
    overlay.events.addEventListener("selection-changed", ({ detail: id2 }) => {
      if (id2 == null) {
        selectedDraft = null;
      } else {
        const draft = allDrafts.find((x) => x.id === id2);
        if (draft == null) return;
        selectedDraft = draft;
      }
      updateDetailPane();
      updateVirtualList();
    });
    overlay.events.addEventListener("draft-updated", ({ detail: id2 }) => {
      const draft = allDrafts.find((x) => x.id === id2);
      if (draft == null) return;
      updateDetailPane();
      updateVirtualList();
      saveDraftChanges(draft);
    });
    const dispatchCountUpdatedEvent = () => {
      events.dispatchEvent(
        createTypedCustomEvent("count-changed", {
          totalCount: allDrafts.length,
          filteredCount: filteredDrafts.length
        })
      );
    };
    dispatchCountUpdatedEvent();
    const saveDraftChanges = (draft) => {
      const { apiRoot, userId } = local.getConfig();
      if (!apiRoot || !userId) return;
      remote.set(
        {
          type: "route",
          "user-id": userId,
          "route-id": draft.id,
          "route-name": draft.name,
          coordinates: coordinatesToString(draft.coordinates),
          description: draft.description,
          note: draft.note,
          data: JSON.stringify(draft.data)
        },
        apiRoot
      );
    };
    const { element: virtualListElement, setItems: setVirtualListItems } = createVirtualList();
    const filterInput = createFilterBar({ value: getSelectedSource() ?? "" });
    filterInput.events.addEventListener("input-changed", () => {
      setSelectedSourceAndNotify(filterInput.getValue());
    });
    filterInput.events.addEventListener("click-list-button", () => {
      sourceListDialog.show();
    });
    filterInput.events.addEventListener("click-edit-button", () => {
      editorDialog.show();
    });
    const detailName = /* @__PURE__ */ jsx(
      "input",
      {
        type: "text",
        value: "",
        classList: [draft_list_default["detail-name"], draft_list_default["input-field"]],
        oninput: (event) => {
          if (!selectedDraft) return;
          selectedDraft.name = event.target.value;
          overlay.updateDraftTitle(selectedDraft);
          updateVirtualList();
          saveDraftChanges(selectedDraft);
        }
      }
    );
    const detailDescription = /* @__PURE__ */ jsx(
      "textarea",
      {
        value: "",
        classList: [
          draft_list_default["detail-description"],
          draft_list_default["input-field"]
        ],
        oninput: (event) => {
          if (!selectedDraft) return;
          selectedDraft.description = event.target.value;
          saveDraftChanges(selectedDraft);
        }
      }
    );
    const detailNote = /* @__PURE__ */ jsx(
      "textarea",
      {
        classList: [draft_list_default["detail-note"], draft_list_default["input-field"]],
        value: "",
        oninput: (event) => {
          if (!selectedDraft) return;
          selectedDraft.note = event.target.value;
          saveDraftChanges(selectedDraft);
        }
      }
    );
    const detailCoordinates = /* @__PURE__ */ jsx(
      "input",
      {
        type: "text",
        value: "",
        classList: [
          draft_list_default["detail-coordinates"],
          draft_list_default["input-field"]
        ],
        oninput: (event) => {
          if (!selectedDraft) return;
          const textarea = event.target;
          try {
            const newCoordinates = parseCoordinates(textarea.value);
            if (newCoordinates.length > 0) {
              selectedDraft.coordinates = newCoordinates;
              textarea.classList.remove(draft_list_default["input-error"]);
            } else {
              textarea.classList.add(draft_list_default["input-error"]);
              return;
            }
          } catch (e) {
            console.error("Failed to parse coordinates:", e);
            textarea.classList.add(draft_list_default["input-error"]);
            return;
          }
          overlay.updateDraftCoordinates(selectedDraft);
          saveDraftChanges(selectedDraft);
        },
        onfocus: (event) => event.target.select()
      }
    );
    const openMapButton = /* @__PURE__ */ jsx(
      "button",
      {
        class: draft_list_default["open-map-button"],
        onclick: () => {
          if (selectedDraft) {
            const coord = selectedDraft.coordinates[0];
            openGoogleMaps(coord, selectedDraft.name);
          }
        },
        children: "\u{1F5FA}\uFE0F"
      }
    );
    const deleteButton = /* @__PURE__ */ jsx(
      "button",
      {
        class: draft_list_default["delete-button"],
        onclick: () => {
          if (!selectedDraft) {
            alert("\u524A\u9664\u3059\u308B\u5019\u88DC\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002");
            return;
          }
          if (confirm(`\u672C\u5F53\u306B\u300C${selectedDraft.name}\u300D\u3092\u524A\u9664\u3057\u307E\u3059\u304B\uFF1F`)) {
            deleteSelectedDraft(selectedDraft.id);
          }
        },
        children: "\u{1F5D1}\uFE0F\u524A\u9664"
      }
    );
    const mapButton = /* @__PURE__ */ jsx(
      "button",
      {
        class: draft_list_default["map-button"],
        onclick: () => {
          if (selectedDraft) {
            overlay.map.setCenter(selectedDraft.coordinates[0]);
          }
        },
        children: "\u{1F3AF}\u5730\u56F3\u3067\u8868\u793A"
      }
    );
    const templateToggleButton = /* @__PURE__ */ jsx(
      "button",
      {
        class: draft_list_default["template-button"],
        onclick: () => {
          if (!selectedDraft) return;
          if (getDraftIsTemplate(selectedDraft)) {
            setDraftIsTemplate(selectedDraft, false);
            saveDraftChanges(selectedDraft);
          } else {
            const currentTemplate = allDrafts.find(
              (d) => getDraftIsTemplate(d)
            );
            if (currentTemplate) {
              setDraftIsTemplate(currentTemplate, false);
              saveDraftChanges(currentTemplate);
            }
            setDraftIsTemplate(selectedDraft, true);
            saveDraftChanges(selectedDraft);
          }
          updateVirtualList();
          updateDetailPane();
        },
        children: "\u{1F4C4}\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8"
      }
    );
    const configView = createLocalConfigView(local);
    const configDialog = createDialog(configView.element, { title: "\u8A2D\u5B9A" });
    const deleteSelectedDraft = (draftId) => {
      const { apiRoot, userId } = local.getConfig();
      if (!userId || !apiRoot) {
        console.error(
          "User ID or API Root not available. Cannot delete draft."
        );
        return;
      }
      overlay.deleteDraft(draftId);
      allDrafts = allDrafts.filter((d) => d.id !== draftId);
      filteredDrafts = filteredDrafts.filter((d) => d.id !== draftId);
      if (selectedDraft?.id === draftId) {
        selectedDraft = null;
        updateDetailPane();
      }
      updateVirtualList();
      remote.delete(
        {
          "route-id": draftId
        },
        apiRoot
      );
    };
    const container = /* @__PURE__ */ jsxs("div", { class: draft_list_default["container"], children: [
      filterInput.element,
      /* @__PURE__ */ jsx("div", { class: draft_list_default["list-container"], children: virtualListElement }),
      /* @__PURE__ */ jsxs("details", { class: draft_list_default["detail-pane"], open: true, children: [
        /* @__PURE__ */ jsx("summary", { class: draft_list_default["detail-summary"], children: detailName }),
        /* @__PURE__ */ jsxs("div", { class: draft_list_default["detail-content-wrapper"], children: [
          detailDescription,
          detailNote,
          /* @__PURE__ */ jsxs("div", { class: draft_list_default["coordinates-container"], children: [
            detailCoordinates,
            openMapButton
          ] }),
          /* @__PURE__ */ jsx(
            "button",
            {
              class: draft_list_default["create-button"],
              onclick: () => addNewDraft(),
              children: "\u{1F4CD}\u65B0\u898F\u4F5C\u6210"
            }
          ),
          deleteButton,
          mapButton,
          templateToggleButton,
          /* @__PURE__ */ jsx(
            "button",
            {
              class: draft_list_default["config-button"],
              onclick: () => {
                configDialog.show();
              },
              children: "\u2699\uFE0F\u8A2D\u5B9A"
            }
          )
        ] })
      ] })
    ] });
    const addNewDraft = () => {
      const { userId } = local.getConfig();
      if (!userId) {
        console.error("User ID not available. Cannot create draft.");
        return;
      }
      const center = overlay.map.getCenter();
      if (!center) return;
      const newDraftId = `draft-${Date.now()}-${Math.floor(
        Math.random() * 1e6
      )}`;
      const newDraft = {
        id: newDraftId,
        type: "route",
        userId,
        name: "\u65B0\u3057\u3044\u5019\u88DC",
        coordinates: [{ lat: center.lat(), lng: center.lng() }],
        description: "",
        note: "",
        data: {}
      };
      const templateDraft = allDrafts.find((d) => getDraftIsTemplate(d));
      if (templateDraft) {
        newDraft.name = applyTemplate(templateDraft.name);
        newDraft.description = applyTemplate(templateDraft.description);
        newDraft.note = applyTemplate(templateDraft.note);
        newDraft.data = structuredClone(templateDraft.data);
        setDraftIsTemplate(newDraft, false);
      }
      overlay.addDraft(newDraft);
      overlay.select(newDraft.id);
      selectedDraft = newDraft;
      updateDetailPane();
      updateVirtualList();
      dispatchCountUpdatedEvent();
      saveDraftChanges(newDraft);
    };
    const updateDetailPane = () => {
      if (selectedDraft) {
        detailName.value = selectedDraft.name;
        detailDescription.value = selectedDraft.description;
        detailNote.value = selectedDraft.note;
        detailCoordinates.value = coordinatesToString(
          selectedDraft.coordinates
        );
        detailCoordinates.classList.remove(draft_list_default["input-error"]);
        mapButton.style.display = "";
        openMapButton.style.display = "";
        deleteButton.style.display = "";
        templateToggleButton.style.display = "";
        if (getDraftIsTemplate(selectedDraft)) {
          templateToggleButton.textContent = "\u{1F4C4}\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8 (\u8A2D\u5B9A\u6E08\u307F)";
          templateToggleButton.classList.add(draft_list_default["is-template"]);
        } else {
          templateToggleButton.textContent = "\u{1F4C4}\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8\u306B\u8A2D\u5B9A";
          templateToggleButton.classList.remove(
            draft_list_default["is-template"]
          );
        }
      } else {
        detailName.value = "";
        detailDescription.value = "";
        detailNote.value = "";
        detailCoordinates.value = "";
        detailCoordinates.classList.remove(draft_list_default["input-error"]);
        mapButton.style.display = "none";
        openMapButton.style.display = "none";
        deleteButton.style.display = "none";
        templateToggleButton.style.display = "none";
      }
    };
    updateDetailPane();
    const applyFilterCancelScope = createAsyncCancelScope(handleAsyncError2);
    const requestFilterUpdate = () => applyFilterCancelScope(async (signal) => {
      await sleep(500, { signal });
      const query = getSelectedSource() ?? "";
      events.dispatchEvent(
        createTypedCustomEvent("filter-start", void 0)
      );
      try {
        filteredDrafts = await filterDrafts(
          records,
          allDrafts,
          query,
          signal
        );
      } finally {
        events.dispatchEvent(
          createTypedCustomEvent("filter-end", void 0)
        );
      }
      dispatchCountUpdatedEvent();
      updateVirtualList();
    });
    const updateVirtualList = () => {
      const virtualElements = {
        itemHeight: 40,
        count: filteredDrafts.length,
        get: (index) => {
          const draft = filteredDrafts[index];
          if (!draft) return void 0;
          const item = document.createElement("div");
          item.className = draft_list_default["item"];
          if (selectedDraft && selectedDraft.id === draft.id) {
            item.classList.add(draft_list_default["selected"]);
          }
          const nameDiv = document.createElement("div");
          nameDiv.className = draft_list_default["item-name"];
          nameDiv.textContent = draft.name;
          const noteDiv = document.createElement("div");
          noteDiv.className = draft_list_default["item-note"];
          noteDiv.textContent = draft.note;
          item.append(nameDiv, noteDiv);
          const onClick = () => {
            overlay.select(draft.id);
            updateDetailPane();
            updateVirtualList();
          };
          const onDblclick = () => {
            overlay.map.setCenter(draft.coordinates[0]);
          };
          let clickTimer = null;
          item.addEventListener("click", () => {
            clickTimer = setTimeout(() => {
              selectedDraft = draft;
              onClick();
              clickTimer = null;
            }, 0);
          });
          item.addEventListener("dblclick", () => {
            if (clickTimer !== null) clearTimeout(clickTimer);
            clickTimer = null;
            onDblclick();
          });
          return item;
        }
      };
      setVirtualListItems(virtualElements);
    };
    updateVirtualList();
    return {
      events,
      element: container,
      setDrafts(newDrafts) {
        allDrafts.splice(0, allDrafts.length, ...newDrafts);
        requestFilterUpdate();
        if (selectedDraft && !newDrafts.some((d) => d.id === selectedDraft?.id)) {
          selectedDraft = null;
          updateDetailPane();
        }
      }
    };
  }

  // source/locales/ja.json
  var ja_default = {
    draftsTitle: "\u5019\u88DC"
  };

  // source/drafts-view/drafts-dialog-title.module.css
  var cssText10 = ":root {\n    --text-color-b5fcef7c2e75eaff3726c619b44d741fa4d5c907: #333;\n    --secondary-text-color-688b6add60d632c00d21958cec42f53996ebfce5: #666;\n    --primary-color-85c1441dbfb39319542140435119ee442e85721a: #007bff;\n    --background-color-light-d3c1d427ed49fb706d5d27ecc2e2bf2144145b42: #f8f9fa;\n    --border-color-0c4d1205af0f0747deb181610984f634e079550a: #dee2e6;\n}\n\n.container-3a7a3702be125e4c680a49a5f6b48a0685a89213 {\n    display: flex;\n    align-items: center;\n    border-bottom: 1px solid var(--border-color-0c4d1205af0f0747deb181610984f634e079550a);\n    color: var(--text-color-b5fcef7c2e75eaff3726c619b44d741fa4d5c907);\n    gap: 10px;\n}\n\n.main-title-af45008e5a094765ba2506a66e549cf852ebcfe3 {\n    font-size: 1.2em;\n    font-weight: bold;\n    color: var(--text-color-b5fcef7c2e75eaff3726c619b44d741fa4d5c907);\n    flex-grow: 1;\n}\n\n.counts-element-a73b5f2718d6c70b187f8e1f493bdd0805dd7a96 {\n    font-size: 0.9em;\n    color: var(--secondary-text-color-688b6add60d632c00d21958cec42f53996ebfce5);\n    white-space: nowrap;\n}\n\n.saving-indicator-ff5b78079ff0b8a9d57fab5841cd61fa1bbc9865 {\n    display: none;\n    font-size: 0.85em;\n    color: var(--primary-color-85c1441dbfb39319542140435119ee442e85721a);\n    margin-left: auto;\n    white-space: nowrap;\n}\n\n.saving-63a9f84c54405daf885a836d67ad7091a22f7475 {\n    display: unset;\n    animation: blink 0.7s infinite steps(1);\n}\n\n@keyframes blink {\n    0% {\n        opacity: 0;\n    }\n\n    50% {\n        opacity: 1;\n    }\n\n    100% {\n        opacity: 0;\n    }\n}\n";
  var drafts_dialog_title_default = {
    container: "container-3a7a3702be125e4c680a49a5f6b48a0685a89213",
    "main-title": "main-title-af45008e5a094765ba2506a66e549cf852ebcfe3",
    "counts-element": "counts-element-a73b5f2718d6c70b187f8e1f493bdd0805dd7a96",
    "saving-indicator": "saving-indicator-ff5b78079ff0b8a9d57fab5841cd61fa1bbc9865",
    saving: "saving-63a9f84c54405daf885a836d67ad7091a22f7475"
  };

  // source/drafts-view/indicator.module.css
  var cssText11 = ".loader-62b568c1cf31831c16b87cb441cc3a63b60f4dbd {\n    position: relative;\n    width: 1rem;\n    height: 1rem;\n}\n\n.orb-86b430db43d2410a62a17c1ee0232463705b2aa5 {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    background: radial-gradient(\n        circle,\n        rgba(59, 130, 246, 0.95) 0%,\n        rgba(96, 165, 250, 0.6) 45%,\n        rgba(147, 197, 253, 0.25) 75%,\n        transparent 100%\n    );\n    box-shadow:\n        0 0 4px rgba(96, 165, 250, 0.8),\n        0 0 8px rgba(147, 197, 253, 0.5);\n    transform: translate(-50%, -50%);\n    opacity: 0;\n    animation: pulse var(--pulseDur-cefcb0590d6e63a0997f5b774909fa76285c1337, 2.6s) ease-in-out infinite;\n}\n\n@keyframes pulse {\n    0%,\n    100% {\n        opacity: 0.35;\n        filter: blur(0.6px);\n    }\n\n    50% {\n        opacity: 1;\n        filter: blur(0);\n    }\n}\n\n@keyframes softAppear {\n    from {\n        opacity: 0;\n        filter: blur(2px);\n    }\n\n    to {\n        opacity: 0.9;\n        filter: blur(0.6px);\n    }\n}\n\n@keyframes endFade {\n    to {\n        opacity: 0;\n        filter: blur(2px);\n    }\n}\n\n.starting-02933a59452e89089c97a52e6fe88a96cf4766d4 .orb-86b430db43d2410a62a17c1ee0232463705b2aa5 {\n    animation: softAppear 0.35s ease-out forwards;\n}\n\n.ending-701c23d5aacc00f9e4c0bb8ae539ee979c42e024 .orb-86b430db43d2410a62a17c1ee0232463705b2aa5 {\n    animation: endFade 0.4s ease-in forwards;\n}\n";
  var variables3 = {
    "--pulseDur": "--pulseDur-cefcb0590d6e63a0997f5b774909fa76285c1337"
  };
  var indicator_default = {
    loader: "loader-62b568c1cf31831c16b87cb441cc3a63b60f4dbd",
    orb: "orb-86b430db43d2410a62a17c1ee0232463705b2aa5",
    starting: "starting-02933a59452e89089c97a52e6fe88a96cf4766d4",
    ending: "ending-701c23d5aacc00f9e4c0bb8ae539ee979c42e024"
  };

  // source/drafts-view/indicator.tsx
  var setStyle11 = styleSetter(cssText11);
  function createIndicator() {
    setStyle11();
    const loader = /* @__PURE__ */ jsxs("div", { class: indicator_default.loader, "aria-label": "Communicating", children: [
      /* @__PURE__ */ jsx("div", { class: indicator_default.orb }),
      /* @__PURE__ */ jsx("div", { class: indicator_default.orb }),
      /* @__PURE__ */ jsx("div", { class: indicator_default.orb }),
      /* @__PURE__ */ jsx("div", { class: indicator_default.orb })
    ] });
    const orbs = [
      ...loader.getElementsByClassName(indicator_default.orb)
    ];
    const intervals = [];
    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }
    function setOrbPosition(orb, x, y) {
      orb.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
      orb._x = x;
      orb._y = y;
    }
    function animateOrbit(orb) {
      const radius = rand(5, 12);
      const duration = rand(2.5, 5);
      const drift = rand(-0.6, 0.6);
      const startAngle = Math.atan2(orb._y || 0, orb._x || 0);
      let start = null;
      function frame(ts) {
        if (!start) start = ts;
        const t = (ts - start) / 1e3;
        const angle = startAngle + t * (Math.PI * 2 / duration) + Math.sin(t) * drift;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        setOrbPosition(orb, x, y);
        orb._anim = requestAnimationFrame(frame);
      }
      orb._anim = requestAnimationFrame(frame);
    }
    function randomizePulse(orb) {
      orb.style.setProperty(variables3["--pulseDur"], rand(2, 4) + "s");
    }
    function startCommunication() {
      loader.classList.remove(indicator_default.ending);
      loader.classList.add(indicator_default.starting);
      loader.classList.remove(indicator_default.starting);
      orbs.forEach((orb) => {
        orb.style.opacity = String(0.9);
        randomizePulse(orb);
        animateOrbit(orb);
        const id2 = setInterval(() => randomizePulse(orb), rand(3e3, 5e3));
        intervals.push(id2);
      });
    }
    function stopCommunication() {
      loader.classList.add(indicator_default.ending);
      setTimeout(() => {
        intervals.forEach(clearInterval);
        intervals.length = 0;
        orbs.forEach((o) => cancelAnimationFrame(o._anim));
      }, 400);
    }
    stopCommunication();
    return {
      element: loader,
      start: startCommunication,
      stop: stopCommunication
    };
  }

  // source/drafts-view/drafts-dialog-title.tsx
  var setStyle12 = styleSetter(cssText10);
  function createDraftsDialogTitle({ title }) {
    setStyle12();
    const mainTitleElement = /* @__PURE__ */ jsx("div", { class: drafts_dialog_title_default["main-title"], children: title });
    const countsElement = /* @__PURE__ */ jsx("div", { class: drafts_dialog_title_default["counts-element"] });
    const indicator = createIndicator();
    const element = /* @__PURE__ */ jsxs("div", { class: drafts_dialog_title_default.container, children: [
      mainTitleElement,
      countsElement,
      indicator.element
    ] });
    let busyCount = 0;
    let currentIsBusy;
    function changeIsBusy() {
      const isBusy = 0 < busyCount;
      if (currentIsBusy !== isBusy) {
        if (isBusy) {
          indicator.start();
        } else {
          indicator.stop();
        }
        currentIsBusy = isBusy;
      }
    }
    return {
      element,
      setCounts({
        totalCount,
        filteredCount
      }) {
        if (filteredCount !== totalCount) {
          countsElement.innerText = `${filteredCount}/${totalCount}\u4EF6`;
        } else {
          countsElement.innerText = `${totalCount}\u4EF6`;
        }
      },
      pushIsBusy() {
        busyCount++;
        changeIsBusy();
      },
      popIsBusy() {
        busyCount--;
        changeIsBusy();
      }
    };
  }

  // source/setup.ts
  var localConfigKey = "wayfarer-map-extension-f079bd37-f7cd-4d65-9def-f0888b70b231";
  function handleAsyncError(reason) {
    console.error("An error occurred during asynchronous processing:", reason);
  }
  async function getGMapObject(options) {
    return await awaitElement(() => {
      try {
        const e = document.querySelector("app-wf-base-map");
        return e.__ngContext__[27];
      } catch {
        return null;
      }
    }, options);
  }
  var defaultDictionary = ja_default;
  async function setupWorkerRecorder(events) {
    const Comlink = await import("https://cdn.jsdelivr.net/npm/comlink@4.4.2/+esm");
    const mainApi = {
      dispatchEvent(type, data) {
        events.dispatchEvent(createTypedCustomEvent(type, data));
      }
    };
    const recordsWorker = new Worker3();
    Comlink.expose(mainApi, recordsWorker);
    const workerApi = Comlink.wrap(recordsWorker);
    injectGcsListener((url, responseText) => {
      events.dispatchEvent(createTypedCustomEvent("gcs-received", void 0));
      workerApi.onGcsReceived(url.toString(), responseText).catch(handleAsyncError);
    });
  }
  function getDictionaryEntry(page, key) {
    const lang = navigator.language;
    return page.local.getConfig().dictionaries?.[lang]?.[key] ?? page.defaultDictionary[key];
  }
  function setupDraftManagerDialog(page) {
    const draftList = createDraftList({
      overlay: page.drafts,
      remote: page.remote,
      records: page.records,
      local: page.local,
      handleAsyncError
    });
    const title = createDraftsDialogTitle({
      title: getDictionaryEntry(page, "draftsTitle")
    });
    const drafts = createDialog(draftList.element, {
      title: title.element
    });
    drafts.show();
    document.body.append(drafts.element);
    draftList.events.addEventListener("count-changed", (e) => {
      title.setCounts(e.detail);
    });
    draftList.events.addEventListener("filter-start", () => title.pushIsBusy());
    draftList.events.addEventListener("filter-end", () => title.popIsBusy());
    page.remote.events.addEventListener(
      "fetch-start",
      () => title.pushIsBusy()
    );
    page.remote.events.addEventListener("fetch-end", () => title.popIsBusy());
    page.drafts.events.addEventListener(
      "drafts-updated",
      (e) => draftList.setDrafts(e.detail)
    );
  }
  async function asyncSetup(signal) {
    const map = await getGMapObject({ signal });
    const events = createTypedEventTarget();
    const local = await createConfigAccessor(localConfigKey);
    local.events.addEventListener(
      "config-changed",
      () => events.dispatchEvent(
        createTypedCustomEvent("config-changed", void 0)
      )
    );
    const scheduler = createScheduler(signal);
    const page = {
      records: await openRecords(),
      remote: createRemote(handleAsyncError, 2e3),
      styleElement: document.createElement("style"),
      map,
      defaultAsyncErrorHandler: handleAsyncError,
      overlay: await createPoisOverlay(map, handleAsyncError),
      events,
      local,
      drafts: createDraftsOverlay(map, handleAsyncError),
      defaultDictionary
    };
    document.head.appendChild(page.styleElement);
    await setupWorkerRecorder(events);
    setupPoiRecordOverlay(page);
    setupDraftManagerDialog(page);
    await setupDraftsOverlay(page.drafts, local, scheduler);
  }
  function setup() {
    const cancel = new AbortController();
    asyncSetup(cancel.signal).catch(handleAsyncError);
  }

  // wayfarer-map-extension.user.ts
  setup();
})();
/*! Bundled license information:

antlr4ts/ANTLRErrorListener.js:
antlr4ts/ANTLRErrorStrategy.js:
antlr4ts/Decorators.js:
antlr4ts/IntStream.js:
antlr4ts/ANTLRInputStream.js:
antlr4ts/atn/ATNState.js:
antlr4ts/atn/ATNStateType.js:
antlr4ts/RecognitionException.js:
antlr4ts/atn/Transition.js:
antlr4ts/atn/AbstractPredicateTransition.js:
antlr4ts/misc/MurmurHash.js:
antlr4ts/misc/ObjectEqualityComparator.js:
antlr4ts/misc/DefaultEqualityComparator.js:
antlr4ts/misc/Array2DHashSet.js:
antlr4ts/misc/ArrayEqualityComparator.js:
antlr4ts/misc/Utils.js:
antlr4ts/atn/SemanticContext.js:
antlr4ts/atn/PredicateTransition.js:
antlr4ts/FailedPredicateException.js:
antlr4ts/InputMismatchException.js:
antlr4ts/misc/Arrays.js:
antlr4ts/misc/IntegerList.js:
antlr4ts/misc/Interval.js:
antlr4ts/Token.js:
antlr4ts/CommonToken.js:
antlr4ts/CommonTokenFactory.js:
antlr4ts/misc/IntegerStack.js:
antlr4ts/dfa/AcceptStateInfo.js:
antlr4ts/misc/Array2DHashMap.js:
antlr4ts/atn/DecisionState.js:
antlr4ts/atn/PredictionContextCache.js:
antlr4ts/atn/PredictionContext.js:
antlr4ts/atn/ATNConfig.js:
antlr4ts/misc/BitSet.js:
antlr4ts/atn/ATNConfigSet.js:
antlr4ts/dfa/DFAState.js:
antlr4ts/atn/ATNSimulator.js:
antlr4ts/ConsoleErrorListener.js:
antlr4ts/ProxyErrorListener.js:
antlr4ts/Recognizer.js:
antlr4ts/VocabularyImpl.js:
antlr4ts/dfa/DFASerializer.js:
antlr4ts/dfa/LexerDFASerializer.js:
antlr4ts/atn/StarLoopEntryState.js:
antlr4ts/dfa/DFA.js:
antlr4ts/atn/BasicState.js:
antlr4ts/atn/InvalidState.js:
antlr4ts/atn/SetTransition.js:
antlr4ts/atn/NotSetTransition.js:
antlr4ts/atn/RuleStopState.js:
antlr4ts/atn/RuleTransition.js:
antlr4ts/atn/WildcardTransition.js:
antlr4ts/atn/LL1Analyzer.js:
antlr4ts/atn/ATN.js:
antlr4ts/atn/LexerIndexedCustomAction.js:
antlr4ts/atn/LexerActionExecutor.js:
antlr4ts/LexerNoViableAltException.js:
antlr4ts/atn/OrderedATNConfigSet.js:
antlr4ts/atn/LexerATNSimulator.js:
antlr4ts/Lexer.js:
antlr4ts/misc/IntervalSet.js:
antlr4ts/atn/ATNDeserializationOptions.js:
antlr4ts/atn/ActionTransition.js:
antlr4ts/atn/AtomTransition.js:
antlr4ts/atn/BlockStartState.js:
antlr4ts/atn/BasicBlockStartState.js:
antlr4ts/atn/BlockEndState.js:
antlr4ts/atn/EpsilonTransition.js:
antlr4ts/atn/LexerChannelAction.js:
antlr4ts/atn/LexerCustomAction.js:
antlr4ts/atn/LexerModeAction.js:
antlr4ts/atn/LexerMoreAction.js:
antlr4ts/atn/LexerPopModeAction.js:
antlr4ts/atn/LexerPushModeAction.js:
antlr4ts/atn/LexerSkipAction.js:
antlr4ts/atn/LexerTypeAction.js:
antlr4ts/atn/LoopEndState.js:
antlr4ts/atn/ConflictInfo.js:
antlr4ts/tree/TerminalNode.js:
antlr4ts/tree/ErrorNode.js:
antlr4ts/tree/RuleNode.js:
antlr4ts/tree/Trees.js:
antlr4ts/RuleContext.js:
antlr4ts/ParserRuleContext.js:
antlr4ts/atn/PredictionMode.js:
antlr4ts/atn/SimulatorState.js:
antlr4ts/atn/ParserATNSimulator.js:
antlr4ts/atn/PlusBlockStartState.js:
antlr4ts/atn/PlusLoopbackState.js:
antlr4ts/atn/PrecedencePredicateTransition.js:
antlr4ts/atn/RangeTransition.js:
antlr4ts/atn/RuleStartState.js:
antlr4ts/atn/StarBlockStartState.js:
antlr4ts/atn/StarLoopbackState.js:
antlr4ts/atn/TokensStartState.js:
antlr4ts/misc/UUID.js:
antlr4ts/atn/ATNDeserializer.js:
antlr4ts/atn/ParseInfo.js:
antlr4ts/ProxyParserErrorListener.js:
antlr4ts/misc/Character.js:
antlr4ts/CodePointBuffer.js:
antlr4ts/CodePointCharStream.js:
antlr4ts/CharStreams.js:
antlr4ts/BufferedTokenStream.js:
antlr4ts/CommonTokenStream.js:
antlr4ts/ListTokenSource.js:
antlr4ts/misc/MultiMap.js:
antlr4ts/misc/ParseCancellationException.js:
antlr4ts/InterpreterRuleContext.js:
antlr4ts/ParserInterpreter.js:
antlr4ts/tree/pattern/ParseTreeMatch.js:
antlr4ts/tree/xpath/XPathLexerErrorListener.js:
antlr4ts/tree/xpath/XPathElement.js:
antlr4ts/tree/xpath/XPathRuleAnywhereElement.js:
antlr4ts/tree/xpath/XPathRuleElement.js:
antlr4ts/tree/xpath/XPathTokenAnywhereElement.js:
antlr4ts/tree/xpath/XPathTokenElement.js:
antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js:
antlr4ts/tree/xpath/XPathWildcardElement.js:
antlr4ts/tree/xpath/XPath.js:
antlr4ts/tree/pattern/ParseTreePattern.js:
antlr4ts/tree/pattern/RuleTagToken.js:
antlr4ts/tree/pattern/Chunk.js:
antlr4ts/tree/pattern/TagChunk.js:
antlr4ts/tree/pattern/TextChunk.js:
antlr4ts/tree/pattern/TokenTagToken.js:
antlr4ts/tree/pattern/ParseTreePatternMatcher.js:
antlr4ts/atn/DecisionEventInfo.js:
antlr4ts/atn/AmbiguityInfo.js:
antlr4ts/atn/ContextSensitivityInfo.js:
antlr4ts/atn/DecisionInfo.js:
antlr4ts/atn/ErrorInfo.js:
antlr4ts/atn/LookaheadEventInfo.js:
antlr4ts/atn/PredicateEvalInfo.js:
antlr4ts/atn/ProfilingATNSimulator.js:
antlr4ts/Parser.js:
antlr4ts/NoViableAltException.js:
antlr4ts/DefaultErrorStrategy.js:
antlr4ts/BailErrorStrategy.js:
antlr4ts/CharStream.js:
antlr4ts/Dependents.js:
antlr4ts/DiagnosticErrorListener.js:
antlr4ts/LexerInterpreter.js:
antlr4ts/ParserErrorListener.js:
antlr4ts/RuleContextWithAltNum.js:
antlr4ts/RuleDependency.js:
antlr4ts/RuleVersion.js:
antlr4ts/TokenFactory.js:
antlr4ts/TokenSource.js:
antlr4ts/TokenStream.js:
antlr4ts/TokenStreamRewriter.js:
antlr4ts/Vocabulary.js:
antlr4ts/WritableToken.js:
antlr4ts/index.js:
antlr4ts/tree/ParseTree.js:
  (*!
   * Copyright 2016 The ANTLR Project. All rights reserved.
   * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
   *)
*/
