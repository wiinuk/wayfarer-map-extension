// ==UserScript==
// @name         wayfarer-map-extension
// @namespace    http://tampermonkey.net/
// @version      0.4.4
// @description  A user script that extends the official Niantic Wayfarer map.
// @author       Wiinuk
// @match        https://wayfarer.nianticlabs.com/new/mapview
// @grant        none
// ==/UserScript==
"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/antlr4ts/ANTLRErrorListener.js
  var require_ANTLRErrorListener = __commonJS({
    "node_modules/antlr4ts/ANTLRErrorListener.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/antlr4ts/ANTLRErrorStrategy.js
  var require_ANTLRErrorStrategy = __commonJS({
    "node_modules/antlr4ts/ANTLRErrorStrategy.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // shims/assert.js
  var require_assert = __commonJS({
    "shims/assert.js"(exports, module2) {
      "use strict";
      function assert2(condition, message) {
        if (!condition) {
          throw new Error(message || "Assertion failed");
        }
      }
      module2.exports = assert2;
    }
  });

  // node_modules/antlr4ts/Decorators.js
  var require_Decorators = __commonJS({
    "node_modules/antlr4ts/Decorators.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SuppressWarnings = exports.Override = exports.Nullable = exports.NotNull = void 0;
      function NotNull(target, propertyKey, propertyDescriptor) {
      }
      exports.NotNull = NotNull;
      function Nullable(target, propertyKey, propertyDescriptor) {
      }
      exports.Nullable = Nullable;
      function Override(target, propertyKey, propertyDescriptor) {
      }
      exports.Override = Override;
      function SuppressWarnings(options) {
        return (target, propertyKey, descriptor) => {
        };
      }
      exports.SuppressWarnings = SuppressWarnings;
    }
  });

  // node_modules/antlr4ts/IntStream.js
  var require_IntStream = __commonJS({
    "node_modules/antlr4ts/IntStream.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IntStream = void 0;
      var IntStream;
      (function(IntStream2) {
        IntStream2.EOF = -1;
        IntStream2.UNKNOWN_SOURCE_NAME = "<unknown>";
      })(IntStream = exports.IntStream || (exports.IntStream = {}));
    }
  });

  // node_modules/antlr4ts/ANTLRInputStream.js
  var require_ANTLRInputStream = __commonJS({
    "node_modules/antlr4ts/ANTLRInputStream.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ANTLRInputStream = void 0;
      var assert2 = require_assert();
      var Decorators_1 = require_Decorators();
      var IntStream_1 = require_IntStream();
      var ANTLRInputStream = class {
        /** Copy data in string to a local char array */
        constructor(input) {
          this.p = 0;
          this.data = input;
          this.n = input.length;
        }
        /** Reset the stream so that it's in the same state it was
         *  when the object was created *except* the data array is not
         *  touched.
         */
        reset() {
          this.p = 0;
        }
        consume() {
          if (this.p >= this.n) {
            assert2(this.LA(1) === IntStream_1.IntStream.EOF);
            throw new Error("cannot consume EOF");
          }
          if (this.p < this.n) {
            this.p++;
          }
        }
        LA(i) {
          if (i === 0) {
            return 0;
          }
          if (i < 0) {
            i++;
            if (this.p + i - 1 < 0) {
              return IntStream_1.IntStream.EOF;
            }
          }
          if (this.p + i - 1 >= this.n) {
            return IntStream_1.IntStream.EOF;
          }
          return this.data.charCodeAt(this.p + i - 1);
        }
        LT(i) {
          return this.LA(i);
        }
        /** Return the current input symbol index 0..n where n indicates the
         *  last symbol has been read.  The index is the index of char to
         *  be returned from LA(1).
         */
        get index() {
          return this.p;
        }
        get size() {
          return this.n;
        }
        /** mark/release do nothing; we have entire buffer */
        mark() {
          return -1;
        }
        release(marker) {
        }
        /** consume() ahead until p==index; can't just set p=index as we must
         *  update line and charPositionInLine. If we seek backwards, just set p
         */
        seek(index) {
          if (index <= this.p) {
            this.p = index;
            return;
          }
          index = Math.min(index, this.n);
          while (this.p < index) {
            this.consume();
          }
        }
        getText(interval) {
          let start = interval.a;
          let stop = interval.b;
          if (stop >= this.n) {
            stop = this.n - 1;
          }
          let count = stop - start + 1;
          if (start >= this.n) {
            return "";
          }
          return this.data.substr(start, count);
        }
        get sourceName() {
          if (!this.name) {
            return IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
          }
          return this.name;
        }
        toString() {
          return this.data;
        }
      };
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "consume", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "LA", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "index", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "mark", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "release", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "seek", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "getText", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "sourceName", null);
      __decorate([
        Decorators_1.Override
      ], ANTLRInputStream.prototype, "toString", null);
      exports.ANTLRInputStream = ANTLRInputStream;
    }
  });

  // node_modules/antlr4ts/atn/ATNState.js
  var require_ATNState = __commonJS({
    "node_modules/antlr4ts/atn/ATNState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATNState = void 0;
      var Decorators_1 = require_Decorators();
      var ATNState = class _ATNState {
        constructor() {
          this.stateNumber = _ATNState.INVALID_STATE_NUMBER;
          this.ruleIndex = 0;
          this.epsilonOnlyTransitions = false;
          this.transitions = [];
          this.optimizedTransitions = this.transitions;
        }
        /**
         * Gets the state number.
         *
         * @returns the state number
         */
        getStateNumber() {
          return this.stateNumber;
        }
        /**
         * For all states except {@link RuleStopState}, this returns the state
         * number. Returns -1 for stop states.
         *
         * @returns -1 for {@link RuleStopState}, otherwise the state number
         */
        get nonStopStateNumber() {
          return this.getStateNumber();
        }
        hashCode() {
          return this.stateNumber;
        }
        equals(o) {
          if (o instanceof _ATNState) {
            return this.stateNumber === o.stateNumber;
          }
          return false;
        }
        get isNonGreedyExitState() {
          return false;
        }
        toString() {
          return String(this.stateNumber);
        }
        getTransitions() {
          return this.transitions.slice(0);
        }
        get numberOfTransitions() {
          return this.transitions.length;
        }
        addTransition(e, index) {
          if (this.transitions.length === 0) {
            this.epsilonOnlyTransitions = e.isEpsilon;
          } else if (this.epsilonOnlyTransitions !== e.isEpsilon) {
            this.epsilonOnlyTransitions = false;
            throw new Error("ATN state " + this.stateNumber + " has both epsilon and non-epsilon transitions.");
          }
          this.transitions.splice(index !== void 0 ? index : this.transitions.length, 0, e);
        }
        transition(i) {
          return this.transitions[i];
        }
        setTransition(i, e) {
          this.transitions[i] = e;
        }
        removeTransition(index) {
          return this.transitions.splice(index, 1)[0];
        }
        get onlyHasEpsilonTransitions() {
          return this.epsilonOnlyTransitions;
        }
        setRuleIndex(ruleIndex) {
          this.ruleIndex = ruleIndex;
        }
        get isOptimized() {
          return this.optimizedTransitions !== this.transitions;
        }
        get numberOfOptimizedTransitions() {
          return this.optimizedTransitions.length;
        }
        getOptimizedTransition(i) {
          return this.optimizedTransitions[i];
        }
        addOptimizedTransition(e) {
          if (!this.isOptimized) {
            this.optimizedTransitions = new Array();
          }
          this.optimizedTransitions.push(e);
        }
        setOptimizedTransition(i, e) {
          if (!this.isOptimized) {
            throw new Error("This ATNState is not optimized.");
          }
          this.optimizedTransitions[i] = e;
        }
        removeOptimizedTransition(i) {
          if (!this.isOptimized) {
            throw new Error("This ATNState is not optimized.");
          }
          this.optimizedTransitions.splice(i, 1);
        }
      };
      __decorate([
        Decorators_1.Override
      ], ATNState.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], ATNState.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], ATNState.prototype, "toString", null);
      exports.ATNState = ATNState;
      (function(ATNState2) {
        ATNState2.INVALID_STATE_NUMBER = -1;
      })(ATNState = exports.ATNState || (exports.ATNState = {}));
    }
  });

  // node_modules/antlr4ts/atn/ATNStateType.js
  var require_ATNStateType = __commonJS({
    "node_modules/antlr4ts/atn/ATNStateType.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATNStateType = void 0;
      var ATNStateType;
      (function(ATNStateType2) {
        ATNStateType2[ATNStateType2["INVALID_TYPE"] = 0] = "INVALID_TYPE";
        ATNStateType2[ATNStateType2["BASIC"] = 1] = "BASIC";
        ATNStateType2[ATNStateType2["RULE_START"] = 2] = "RULE_START";
        ATNStateType2[ATNStateType2["BLOCK_START"] = 3] = "BLOCK_START";
        ATNStateType2[ATNStateType2["PLUS_BLOCK_START"] = 4] = "PLUS_BLOCK_START";
        ATNStateType2[ATNStateType2["STAR_BLOCK_START"] = 5] = "STAR_BLOCK_START";
        ATNStateType2[ATNStateType2["TOKEN_START"] = 6] = "TOKEN_START";
        ATNStateType2[ATNStateType2["RULE_STOP"] = 7] = "RULE_STOP";
        ATNStateType2[ATNStateType2["BLOCK_END"] = 8] = "BLOCK_END";
        ATNStateType2[ATNStateType2["STAR_LOOP_BACK"] = 9] = "STAR_LOOP_BACK";
        ATNStateType2[ATNStateType2["STAR_LOOP_ENTRY"] = 10] = "STAR_LOOP_ENTRY";
        ATNStateType2[ATNStateType2["PLUS_LOOP_BACK"] = 11] = "PLUS_LOOP_BACK";
        ATNStateType2[ATNStateType2["LOOP_END"] = 12] = "LOOP_END";
      })(ATNStateType = exports.ATNStateType || (exports.ATNStateType = {}));
    }
  });

  // node_modules/antlr4ts/RecognitionException.js
  var require_RecognitionException = __commonJS({
    "node_modules/antlr4ts/RecognitionException.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RecognitionException = void 0;
      var RecognitionException2 = class extends Error {
        constructor(recognizer, input, ctx, message) {
          super(message);
          this._offendingState = -1;
          this._recognizer = recognizer;
          this.input = input;
          this.ctx = ctx;
          if (recognizer) {
            this._offendingState = recognizer.state;
          }
        }
        /**
         * Get the ATN state number the parser was in at the time the error
         * occurred. For {@link NoViableAltException} and
         * {@link LexerNoViableAltException} exceptions, this is the
         * {@link DecisionState} number. For others, it is the state whose outgoing
         * edge we couldn't match.
         *
         * If the state number is not known, this method returns -1.
         */
        get offendingState() {
          return this._offendingState;
        }
        setOffendingState(offendingState) {
          this._offendingState = offendingState;
        }
        /**
         * Gets the set of input symbols which could potentially follow the
         * previously matched symbol at the time this exception was thrown.
         *
         * If the set of expected tokens is not known and could not be computed,
         * this method returns `undefined`.
         *
         * @returns The set of token types that could potentially follow the current
         * state in the ATN, or `undefined` if the information is not available.
         */
        get expectedTokens() {
          if (this._recognizer) {
            return this._recognizer.atn.getExpectedTokens(this._offendingState, this.ctx);
          }
          return void 0;
        }
        /**
         * Gets the {@link RuleContext} at the time this exception was thrown.
         *
         * If the context is not available, this method returns `undefined`.
         *
         * @returns The {@link RuleContext} at the time this exception was thrown.
         * If the context is not available, this method returns `undefined`.
         */
        get context() {
          return this.ctx;
        }
        /**
         * Gets the input stream which is the symbol source for the recognizer where
         * this exception was thrown.
         *
         * If the input stream is not available, this method returns `undefined`.
         *
         * @returns The input stream which is the symbol source for the recognizer
         * where this exception was thrown, or `undefined` if the stream is not
         * available.
         */
        get inputStream() {
          return this.input;
        }
        getOffendingToken(recognizer) {
          if (recognizer && recognizer !== this._recognizer) {
            return void 0;
          }
          return this.offendingToken;
        }
        setOffendingToken(recognizer, offendingToken) {
          if (recognizer === this._recognizer) {
            this.offendingToken = offendingToken;
          }
        }
        /**
         * Gets the {@link Recognizer} where this exception occurred.
         *
         * If the recognizer is not available, this method returns `undefined`.
         *
         * @returns The recognizer where this exception occurred, or `undefined` if
         * the recognizer is not available.
         */
        get recognizer() {
          return this._recognizer;
        }
      };
      exports.RecognitionException = RecognitionException2;
    }
  });

  // node_modules/antlr4ts/atn/Transition.js
  var require_Transition = __commonJS({
    "node_modules/antlr4ts/atn/Transition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Transition = void 0;
      var Decorators_1 = require_Decorators();
      var Transition = class Transition {
        constructor(target) {
          if (target == null) {
            throw new Error("target cannot be null.");
          }
          this.target = target;
        }
        /**
         * Determines if the transition is an "epsilon" transition.
         *
         * The default implementation returns `false`.
         *
         * @returns `true` if traversing this transition in the ATN does not
         * consume an input symbol; otherwise, `false` if traversing this
         * transition consumes (matches) an input symbol.
         */
        get isEpsilon() {
          return false;
        }
        get label() {
          return void 0;
        }
      };
      Transition.serializationNames = [
        "INVALID",
        "EPSILON",
        "RANGE",
        "RULE",
        "PREDICATE",
        "ATOM",
        "ACTION",
        "SET",
        "NOT_SET",
        "WILDCARD",
        "PRECEDENCE"
      ];
      __decorate([
        Decorators_1.NotNull
      ], Transition.prototype, "target", void 0);
      Transition = __decorate([
        __param(0, Decorators_1.NotNull)
      ], Transition);
      exports.Transition = Transition;
    }
  });

  // node_modules/antlr4ts/atn/AbstractPredicateTransition.js
  var require_AbstractPredicateTransition = __commonJS({
    "node_modules/antlr4ts/atn/AbstractPredicateTransition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractPredicateTransition = void 0;
      var Transition_1 = require_Transition();
      var AbstractPredicateTransition = class extends Transition_1.Transition {
        constructor(target) {
          super(target);
        }
      };
      exports.AbstractPredicateTransition = AbstractPredicateTransition;
    }
  });

  // node_modules/antlr4ts/misc/MurmurHash.js
  var require_MurmurHash = __commonJS({
    "node_modules/antlr4ts/misc/MurmurHash.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MurmurHash = void 0;
      var MurmurHash;
      (function(MurmurHash2) {
        const DEFAULT_SEED = 0;
        function initialize(seed = DEFAULT_SEED) {
          return seed;
        }
        MurmurHash2.initialize = initialize;
        function update(hash2, value) {
          const c1 = 3432918353;
          const c2 = 461845907;
          const r1 = 15;
          const r2 = 13;
          const m = 5;
          const n = 3864292196;
          if (value == null) {
            value = 0;
          } else if (typeof value === "string") {
            value = hashString(value);
          } else if (typeof value === "object") {
            value = value.hashCode();
          }
          let k = value;
          k = Math.imul(k, c1);
          k = k << r1 | k >>> 32 - r1;
          k = Math.imul(k, c2);
          hash2 = hash2 ^ k;
          hash2 = hash2 << r2 | hash2 >>> 32 - r2;
          hash2 = Math.imul(hash2, m) + n;
          return hash2 & 4294967295;
        }
        MurmurHash2.update = update;
        function finish(hash2, numberOfWords) {
          hash2 = hash2 ^ numberOfWords * 4;
          hash2 = hash2 ^ hash2 >>> 16;
          hash2 = Math.imul(hash2, 2246822507);
          hash2 = hash2 ^ hash2 >>> 13;
          hash2 = Math.imul(hash2, 3266489909);
          hash2 = hash2 ^ hash2 >>> 16;
          return hash2;
        }
        MurmurHash2.finish = finish;
        function hashCode(data, seed = DEFAULT_SEED) {
          let hash2 = initialize(seed);
          let length = 0;
          for (let value of data) {
            hash2 = update(hash2, value);
            length++;
          }
          hash2 = finish(hash2, length);
          return hash2;
        }
        MurmurHash2.hashCode = hashCode;
        function hashString(str) {
          let len = str.length;
          if (len === 0) {
            return 0;
          }
          let hash2 = 0;
          for (let i = 0; i < len; i++) {
            let c = str.charCodeAt(i);
            hash2 = (hash2 << 5 >>> 0) - hash2 + c;
            hash2 |= 0;
          }
          return hash2;
        }
      })(MurmurHash = exports.MurmurHash || (exports.MurmurHash = {}));
    }
  });

  // node_modules/antlr4ts/misc/ObjectEqualityComparator.js
  var require_ObjectEqualityComparator = __commonJS({
    "node_modules/antlr4ts/misc/ObjectEqualityComparator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ObjectEqualityComparator = void 0;
      var Decorators_1 = require_Decorators();
      var ObjectEqualityComparator = class {
        /**
         * {@inheritDoc}
         *
         * This implementation returns
         * `obj.`{@link Object#hashCode hashCode()}.
         */
        hashCode(obj) {
          if (obj == null) {
            return 0;
          }
          return obj.hashCode();
        }
        /**
         * {@inheritDoc}
         *
         * This implementation relies on object equality. If both objects are
         * `undefined` or `null`, this method returns `true`. Otherwise if only
         * `a` is `undefined` or `null`, this method returns `false`. Otherwise,
         * this method returns the result of
         * `a.`{@link Object#equals equals}`(b)`.
         */
        equals(a, b) {
          if (a == null) {
            return b == null;
          }
          return a.equals(b);
        }
      };
      ObjectEqualityComparator.INSTANCE = new ObjectEqualityComparator();
      __decorate([
        Decorators_1.Override
      ], ObjectEqualityComparator.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], ObjectEqualityComparator.prototype, "equals", null);
      exports.ObjectEqualityComparator = ObjectEqualityComparator;
    }
  });

  // node_modules/antlr4ts/misc/DefaultEqualityComparator.js
  var require_DefaultEqualityComparator = __commonJS({
    "node_modules/antlr4ts/misc/DefaultEqualityComparator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultEqualityComparator = void 0;
      var Decorators_1 = require_Decorators();
      var MurmurHash_1 = require_MurmurHash();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var DefaultEqualityComparator = class {
        /**
         * {@inheritDoc}
         *
         * This implementation returns
         * `obj.`{@link Object#hashCode hashCode()}.
         */
        hashCode(obj) {
          if (obj == null) {
            return 0;
          } else if (typeof obj === "string" || typeof obj === "number") {
            return MurmurHash_1.MurmurHash.hashCode([obj]);
          } else {
            return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.hashCode(obj);
          }
        }
        /**
         * {@inheritDoc}
         *
         * This implementation relies on object equality. If both objects are
         * `undefined` or `null`, this method returns `true`. Otherwise if only
         * `a` is `undefined` or `null`, this method returns `false`. Otherwise,
         * this method returns the result of
         * `a.`{@link Object#equals equals}`(b)`.
         */
        equals(a, b) {
          if (a == null) {
            return b == null;
          } else if (typeof a === "string" || typeof a === "number") {
            return a === b;
          } else {
            return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a, b);
          }
        }
      };
      DefaultEqualityComparator.INSTANCE = new DefaultEqualityComparator();
      __decorate([
        Decorators_1.Override
      ], DefaultEqualityComparator.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], DefaultEqualityComparator.prototype, "equals", null);
      exports.DefaultEqualityComparator = DefaultEqualityComparator;
    }
  });

  // node_modules/antlr4ts/misc/Array2DHashSet.js
  var require_Array2DHashSet = __commonJS({
    "node_modules/antlr4ts/misc/Array2DHashSet.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Array2DHashSet = void 0;
      var assert2 = require_assert();
      var DefaultEqualityComparator_1 = require_DefaultEqualityComparator();
      var Decorators_1 = require_Decorators();
      var MurmurHash_1 = require_MurmurHash();
      var INITAL_CAPACITY = 16;
      var LOAD_FACTOR = 0.75;
      var Array2DHashSet = class _Array2DHashSet {
        constructor(comparatorOrSet, initialCapacity = INITAL_CAPACITY) {
          this.n = 0;
          this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
          if (comparatorOrSet instanceof _Array2DHashSet) {
            this.comparator = comparatorOrSet.comparator;
            this.buckets = comparatorOrSet.buckets.slice(0);
            for (let i = 0; i < this.buckets.length; i++) {
              let bucket = this.buckets[i];
              if (bucket) {
                this.buckets[i] = bucket.slice(0);
              }
            }
            this.n = comparatorOrSet.n;
            this.threshold = comparatorOrSet.threshold;
          } else {
            this.comparator = comparatorOrSet || DefaultEqualityComparator_1.DefaultEqualityComparator.INSTANCE;
            this.buckets = this.createBuckets(initialCapacity);
          }
        }
        /**
         * Add `o` to set if not there; return existing value if already
         * there. This method performs the same operation as {@link #add} aside from
         * the return value.
         */
        getOrAdd(o) {
          if (this.n > this.threshold) {
            this.expand();
          }
          return this.getOrAddImpl(o);
        }
        getOrAddImpl(o) {
          let b = this.getBucket(o);
          let bucket = this.buckets[b];
          if (!bucket) {
            bucket = [o];
            this.buckets[b] = bucket;
            this.n++;
            return o;
          }
          for (let existing of bucket) {
            if (this.comparator.equals(existing, o)) {
              return existing;
            }
          }
          bucket.push(o);
          this.n++;
          return o;
        }
        get(o) {
          if (o == null) {
            return o;
          }
          let b = this.getBucket(o);
          let bucket = this.buckets[b];
          if (!bucket) {
            return void 0;
          }
          for (let e of bucket) {
            if (this.comparator.equals(e, o)) {
              return e;
            }
          }
          return void 0;
        }
        getBucket(o) {
          let hash2 = this.comparator.hashCode(o);
          let b = hash2 & this.buckets.length - 1;
          return b;
        }
        hashCode() {
          let hash2 = MurmurHash_1.MurmurHash.initialize();
          for (let bucket of this.buckets) {
            if (bucket == null) {
              continue;
            }
            for (let o of bucket) {
              if (o == null) {
                break;
              }
              hash2 = MurmurHash_1.MurmurHash.update(hash2, this.comparator.hashCode(o));
            }
          }
          hash2 = MurmurHash_1.MurmurHash.finish(hash2, this.size);
          return hash2;
        }
        equals(o) {
          if (o === this) {
            return true;
          }
          if (!(o instanceof _Array2DHashSet)) {
            return false;
          }
          if (o.size !== this.size) {
            return false;
          }
          let same = this.containsAll(o);
          return same;
        }
        expand() {
          let old = this.buckets;
          let newCapacity = this.buckets.length * 2;
          let newTable = this.createBuckets(newCapacity);
          this.buckets = newTable;
          this.threshold = Math.floor(newCapacity * LOAD_FACTOR);
          let oldSize = this.size;
          for (let bucket of old) {
            if (!bucket) {
              continue;
            }
            for (let o of bucket) {
              let b = this.getBucket(o);
              let newBucket = this.buckets[b];
              if (!newBucket) {
                newBucket = [];
                this.buckets[b] = newBucket;
              }
              newBucket.push(o);
            }
          }
          assert2(this.n === oldSize);
        }
        add(t) {
          let existing = this.getOrAdd(t);
          return existing === t;
        }
        get size() {
          return this.n;
        }
        get isEmpty() {
          return this.n === 0;
        }
        contains(o) {
          return this.containsFast(this.asElementType(o));
        }
        containsFast(obj) {
          if (obj == null) {
            return false;
          }
          return this.get(obj) != null;
        }
        *[Symbol.iterator]() {
          yield* this.toArray();
        }
        toArray() {
          const a = new Array(this.size);
          let i = 0;
          for (let bucket of this.buckets) {
            if (bucket == null) {
              continue;
            }
            for (let o of bucket) {
              if (o == null) {
                break;
              }
              a[i++] = o;
            }
          }
          return a;
        }
        containsAll(collection) {
          if (collection instanceof _Array2DHashSet) {
            let s = collection;
            for (let bucket of s.buckets) {
              if (bucket == null) {
                continue;
              }
              for (let o of bucket) {
                if (o == null) {
                  break;
                }
                if (!this.containsFast(this.asElementType(o))) {
                  return false;
                }
              }
            }
          } else {
            for (let o of collection) {
              if (!this.containsFast(this.asElementType(o))) {
                return false;
              }
            }
          }
          return true;
        }
        addAll(c) {
          let changed = false;
          for (let o of c) {
            let existing = this.getOrAdd(o);
            if (existing !== o) {
              changed = true;
            }
          }
          return changed;
        }
        clear() {
          this.buckets = this.createBuckets(INITAL_CAPACITY);
          this.n = 0;
          this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
        }
        toString() {
          if (this.size === 0) {
            return "{}";
          }
          let buf = "{";
          let first = true;
          for (let bucket of this.buckets) {
            if (bucket == null) {
              continue;
            }
            for (let o of bucket) {
              if (o == null) {
                break;
              }
              if (first) {
                first = false;
              } else {
                buf += ", ";
              }
              buf += o.toString();
            }
          }
          buf += "}";
          return buf;
        }
        toTableString() {
          let buf = "";
          for (let bucket of this.buckets) {
            if (bucket == null) {
              buf += "null\n";
              continue;
            }
            buf += "[";
            let first = true;
            for (let o of bucket) {
              if (first) {
                first = false;
              } else {
                buf += " ";
              }
              if (o == null) {
                buf += "_";
              } else {
                buf += o.toString();
              }
            }
            buf += "]\n";
          }
          return buf;
        }
        /**
         * Return `o` as an instance of the element type `T`. If
         * `o` is non-undefined but known to not be an instance of `T`, this
         * method returns `undefined`. The base implementation does not perform any
         * type checks; override this method to provide strong type checks for the
         * {@link #contains} and {@link #remove} methods to ensure the arguments to
         * the {@link EqualityComparator} for the set always have the expected
         * types.
         *
         * @param o the object to try and cast to the element type of the set
         * @returns `o` if it could be an instance of `T`, otherwise
         * `undefined`.
         */
        asElementType(o) {
          return o;
        }
        /**
         * Return an array of `T[]` with length `capacity`.
         *
         * @param capacity the length of the array to return
         * @returns the newly constructed array
         */
        createBuckets(capacity) {
          return new Array(capacity);
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], Array2DHashSet.prototype, "comparator", void 0);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "add", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "isEmpty", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "contains", null);
      __decorate([
        __param(0, Decorators_1.Nullable)
      ], Array2DHashSet.prototype, "containsFast", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, Symbol.iterator, null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "toArray", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "containsAll", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "addAll", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "clear", null);
      __decorate([
        Decorators_1.Override
      ], Array2DHashSet.prototype, "toString", null);
      __decorate([
        Decorators_1.SuppressWarnings("unchecked")
      ], Array2DHashSet.prototype, "asElementType", null);
      __decorate([
        Decorators_1.SuppressWarnings("unchecked")
      ], Array2DHashSet.prototype, "createBuckets", null);
      exports.Array2DHashSet = Array2DHashSet;
    }
  });

  // node_modules/antlr4ts/misc/ArrayEqualityComparator.js
  var require_ArrayEqualityComparator = __commonJS({
    "node_modules/antlr4ts/misc/ArrayEqualityComparator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ArrayEqualityComparator = void 0;
      var Decorators_1 = require_Decorators();
      var MurmurHash_1 = require_MurmurHash();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var ArrayEqualityComparator = class {
        /**
         * {@inheritDoc}
         *
         * This implementation returns
         * `obj.`{@link Object#hashCode hashCode()}.
         */
        hashCode(obj) {
          if (obj == null) {
            return 0;
          }
          return MurmurHash_1.MurmurHash.hashCode(obj, 0);
        }
        /**
         * {@inheritDoc}
         *
         * This implementation relies on object equality. If both objects are
         * `undefined`, this method returns `true`. Otherwise if only
         * `a` is `undefined`, this method returns `false`. Otherwise,
         * this method returns the result of
         * `a.`{@link Object#equals equals}`(b)`.
         */
        equals(a, b) {
          if (a == null) {
            return b == null;
          } else if (b == null) {
            return false;
          }
          if (a.length !== b.length) {
            return false;
          }
          for (let i = 0; i < a.length; i++) {
            if (!ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a[i], b[i])) {
              return false;
            }
          }
          return true;
        }
      };
      ArrayEqualityComparator.INSTANCE = new ArrayEqualityComparator();
      __decorate([
        Decorators_1.Override
      ], ArrayEqualityComparator.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], ArrayEqualityComparator.prototype, "equals", null);
      exports.ArrayEqualityComparator = ArrayEqualityComparator;
    }
  });

  // node_modules/antlr4ts/misc/Utils.js
  var require_Utils = __commonJS({
    "node_modules/antlr4ts/misc/Utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toCharArray = exports.toMap = exports.equals = exports.join = exports.escapeWhitespace = void 0;
      function escapeWhitespace(s, escapeSpaces) {
        return escapeSpaces ? s.replace(/ /, "\xB7") : s.replace(/\t/, "\\t").replace(/\n/, "\\n").replace(/\r/, "\\r");
      }
      exports.escapeWhitespace = escapeWhitespace;
      function join2(collection, separator) {
        let buf = "";
        let first = true;
        for (let current of collection) {
          if (first) {
            first = false;
          } else {
            buf += separator;
          }
          buf += current;
        }
        return buf;
      }
      exports.join = join2;
      function equals(x, y) {
        if (x === y) {
          return true;
        }
        if (x === void 0 || y === void 0) {
          return false;
        }
        return x.equals(y);
      }
      exports.equals = equals;
      function toMap(keys) {
        let m = /* @__PURE__ */ new Map();
        for (let i = 0; i < keys.length; i++) {
          m.set(keys[i], i);
        }
        return m;
      }
      exports.toMap = toMap;
      function toCharArray3(str) {
        if (typeof str === "string") {
          let result = new Uint16Array(str.length);
          for (let i = 0; i < str.length; i++) {
            result[i] = str.charCodeAt(i);
          }
          return result;
        } else {
          return str.toCharArray();
        }
      }
      exports.toCharArray = toCharArray3;
    }
  });

  // node_modules/antlr4ts/atn/SemanticContext.js
  var require_SemanticContext = __commonJS({
    "node_modules/antlr4ts/atn/SemanticContext.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SemanticContext = void 0;
      var Array2DHashSet_1 = require_Array2DHashSet();
      var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var Utils3 = require_Utils();
      function max(items) {
        let result;
        for (let current of items) {
          if (result === void 0) {
            result = current;
            continue;
          }
          let comparison = result.compareTo(current);
          if (comparison < 0) {
            result = current;
          }
        }
        return result;
      }
      function min(items) {
        let result;
        for (let current of items) {
          if (result === void 0) {
            result = current;
            continue;
          }
          let comparison = result.compareTo(current);
          if (comparison > 0) {
            result = current;
          }
        }
        return result;
      }
      var SemanticContext = class _SemanticContext {
        /**
         * The default {@link SemanticContext}, which is semantically equivalent to
         * a predicate of the form `{true}?`.
         */
        static get NONE() {
          if (_SemanticContext._NONE === void 0) {
            _SemanticContext._NONE = new _SemanticContext.Predicate();
          }
          return _SemanticContext._NONE;
        }
        /**
         * Evaluate the precedence predicates for the context and reduce the result.
         *
         * @param parser The parser instance.
         * @param parserCallStack
         * @returns The simplified semantic context after precedence predicates are
         * evaluated, which will be one of the following values.
         *
         * * {@link #NONE}: if the predicate simplifies to `true` after
         *   precedence predicates are evaluated.
         * * `undefined`: if the predicate simplifies to `false` after
         *   precedence predicates are evaluated.
         * * `this`: if the semantic context is not changed as a result of
         *   precedence predicate evaluation.
         * * A non-`undefined` {@link SemanticContext}: the new simplified
         *   semantic context after precedence predicates are evaluated.
         */
        evalPrecedence(parser, parserCallStack) {
          return this;
        }
        static and(a, b) {
          if (!a || a === _SemanticContext.NONE) {
            return b;
          }
          if (b === _SemanticContext.NONE) {
            return a;
          }
          let result = new _SemanticContext.AND(a, b);
          if (result.opnds.length === 1) {
            return result.opnds[0];
          }
          return result;
        }
        /**
         *
         *  @see ParserATNSimulator#getPredsForAmbigAlts
         */
        static or(a, b) {
          if (!a) {
            return b;
          }
          if (a === _SemanticContext.NONE || b === _SemanticContext.NONE) {
            return _SemanticContext.NONE;
          }
          let result = new _SemanticContext.OR(a, b);
          if (result.opnds.length === 1) {
            return result.opnds[0];
          }
          return result;
        }
      };
      exports.SemanticContext = SemanticContext;
      (function(SemanticContext2) {
        const AND_HASHCODE = 40363613;
        const OR_HASHCODE = 486279973;
        function filterPrecedencePredicates(collection) {
          let result = [];
          for (let i = 0; i < collection.length; i++) {
            let context = collection[i];
            if (context instanceof SemanticContext2.PrecedencePredicate) {
              result.push(context);
              collection.splice(i, 1);
              i--;
            }
          }
          return result;
        }
        class Predicate extends SemanticContext2 {
          constructor(ruleIndex = -1, predIndex = -1, isCtxDependent = false) {
            super();
            this.ruleIndex = ruleIndex;
            this.predIndex = predIndex;
            this.isCtxDependent = isCtxDependent;
          }
          eval(parser, parserCallStack) {
            let localctx = this.isCtxDependent ? parserCallStack : void 0;
            return parser.sempred(localctx, this.ruleIndex, this.predIndex);
          }
          hashCode() {
            let hashCode = MurmurHash_1.MurmurHash.initialize();
            hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.ruleIndex);
            hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.predIndex);
            hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);
            hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 3);
            return hashCode;
          }
          equals(obj) {
            if (!(obj instanceof Predicate)) {
              return false;
            }
            if (this === obj) {
              return true;
            }
            return this.ruleIndex === obj.ruleIndex && this.predIndex === obj.predIndex && this.isCtxDependent === obj.isCtxDependent;
          }
          toString() {
            return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
          }
        }
        __decorate([
          Decorators_1.Override
        ], Predicate.prototype, "eval", null);
        __decorate([
          Decorators_1.Override
        ], Predicate.prototype, "hashCode", null);
        __decorate([
          Decorators_1.Override
        ], Predicate.prototype, "equals", null);
        __decorate([
          Decorators_1.Override
        ], Predicate.prototype, "toString", null);
        SemanticContext2.Predicate = Predicate;
        class PrecedencePredicate extends SemanticContext2 {
          constructor(precedence) {
            super();
            this.precedence = precedence;
          }
          eval(parser, parserCallStack) {
            return parser.precpred(parserCallStack, this.precedence);
          }
          evalPrecedence(parser, parserCallStack) {
            if (parser.precpred(parserCallStack, this.precedence)) {
              return SemanticContext2.NONE;
            } else {
              return void 0;
            }
          }
          compareTo(o) {
            return this.precedence - o.precedence;
          }
          hashCode() {
            let hashCode = 1;
            hashCode = 31 * hashCode + this.precedence;
            return hashCode;
          }
          equals(obj) {
            if (!(obj instanceof PrecedencePredicate)) {
              return false;
            }
            if (this === obj) {
              return true;
            }
            return this.precedence === obj.precedence;
          }
          toString() {
            return "{" + this.precedence + ">=prec}?";
          }
        }
        __decorate([
          Decorators_1.Override
        ], PrecedencePredicate.prototype, "eval", null);
        __decorate([
          Decorators_1.Override
        ], PrecedencePredicate.prototype, "evalPrecedence", null);
        __decorate([
          Decorators_1.Override
        ], PrecedencePredicate.prototype, "compareTo", null);
        __decorate([
          Decorators_1.Override
        ], PrecedencePredicate.prototype, "hashCode", null);
        __decorate([
          Decorators_1.Override
        ], PrecedencePredicate.prototype, "equals", null);
        __decorate([
          Decorators_1.Override
        ], PrecedencePredicate.prototype, "toString", null);
        SemanticContext2.PrecedencePredicate = PrecedencePredicate;
        class Operator extends SemanticContext2 {
        }
        SemanticContext2.Operator = Operator;
        let AND = class AND2 extends Operator {
          constructor(a, b) {
            super();
            let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
            if (a instanceof AND2) {
              operands.addAll(a.opnds);
            } else {
              operands.add(a);
            }
            if (b instanceof AND2) {
              operands.addAll(b.opnds);
            } else {
              operands.add(b);
            }
            this.opnds = operands.toArray();
            let precedencePredicates = filterPrecedencePredicates(this.opnds);
            let reduced = min(precedencePredicates);
            if (reduced) {
              this.opnds.push(reduced);
            }
          }
          get operands() {
            return this.opnds;
          }
          equals(obj) {
            if (this === obj) {
              return true;
            }
            if (!(obj instanceof AND2)) {
              return false;
            }
            return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
          }
          hashCode() {
            return MurmurHash_1.MurmurHash.hashCode(this.opnds, AND_HASHCODE);
          }
          /**
           * {@inheritDoc}
           *
           * The evaluation of predicates by this context is short-circuiting, but
           * unordered.
           */
          eval(parser, parserCallStack) {
            for (let opnd of this.opnds) {
              if (!opnd.eval(parser, parserCallStack)) {
                return false;
              }
            }
            return true;
          }
          evalPrecedence(parser, parserCallStack) {
            let differs = false;
            let operands = [];
            for (let context of this.opnds) {
              let evaluated = context.evalPrecedence(parser, parserCallStack);
              differs = differs || evaluated !== context;
              if (evaluated == null) {
                return void 0;
              } else if (evaluated !== SemanticContext2.NONE) {
                operands.push(evaluated);
              }
            }
            if (!differs) {
              return this;
            }
            if (operands.length === 0) {
              return SemanticContext2.NONE;
            }
            let result = operands[0];
            for (let i = 1; i < operands.length; i++) {
              result = SemanticContext2.and(result, operands[i]);
            }
            return result;
          }
          toString() {
            return Utils3.join(this.opnds, "&&");
          }
        };
        __decorate([
          Decorators_1.Override
        ], AND.prototype, "operands", null);
        __decorate([
          Decorators_1.Override
        ], AND.prototype, "equals", null);
        __decorate([
          Decorators_1.Override
        ], AND.prototype, "hashCode", null);
        __decorate([
          Decorators_1.Override
        ], AND.prototype, "eval", null);
        __decorate([
          Decorators_1.Override
        ], AND.prototype, "evalPrecedence", null);
        __decorate([
          Decorators_1.Override
        ], AND.prototype, "toString", null);
        AND = __decorate([
          __param(0, Decorators_1.NotNull),
          __param(1, Decorators_1.NotNull)
        ], AND);
        SemanticContext2.AND = AND;
        let OR = class OR2 extends Operator {
          constructor(a, b) {
            super();
            let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
            if (a instanceof OR2) {
              operands.addAll(a.opnds);
            } else {
              operands.add(a);
            }
            if (b instanceof OR2) {
              operands.addAll(b.opnds);
            } else {
              operands.add(b);
            }
            this.opnds = operands.toArray();
            let precedencePredicates = filterPrecedencePredicates(this.opnds);
            let reduced = max(precedencePredicates);
            if (reduced) {
              this.opnds.push(reduced);
            }
          }
          get operands() {
            return this.opnds;
          }
          equals(obj) {
            if (this === obj) {
              return true;
            }
            if (!(obj instanceof OR2)) {
              return false;
            }
            return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
          }
          hashCode() {
            return MurmurHash_1.MurmurHash.hashCode(this.opnds, OR_HASHCODE);
          }
          /**
           * {@inheritDoc}
           *
           * The evaluation of predicates by this context is short-circuiting, but
           * unordered.
           */
          eval(parser, parserCallStack) {
            for (let opnd of this.opnds) {
              if (opnd.eval(parser, parserCallStack)) {
                return true;
              }
            }
            return false;
          }
          evalPrecedence(parser, parserCallStack) {
            let differs = false;
            let operands = [];
            for (let context of this.opnds) {
              let evaluated = context.evalPrecedence(parser, parserCallStack);
              differs = differs || evaluated !== context;
              if (evaluated === SemanticContext2.NONE) {
                return SemanticContext2.NONE;
              } else if (evaluated) {
                operands.push(evaluated);
              }
            }
            if (!differs) {
              return this;
            }
            if (operands.length === 0) {
              return void 0;
            }
            let result = operands[0];
            for (let i = 1; i < operands.length; i++) {
              result = SemanticContext2.or(result, operands[i]);
            }
            return result;
          }
          toString() {
            return Utils3.join(this.opnds, "||");
          }
        };
        __decorate([
          Decorators_1.Override
        ], OR.prototype, "operands", null);
        __decorate([
          Decorators_1.Override
        ], OR.prototype, "equals", null);
        __decorate([
          Decorators_1.Override
        ], OR.prototype, "hashCode", null);
        __decorate([
          Decorators_1.Override
        ], OR.prototype, "eval", null);
        __decorate([
          Decorators_1.Override
        ], OR.prototype, "evalPrecedence", null);
        __decorate([
          Decorators_1.Override
        ], OR.prototype, "toString", null);
        OR = __decorate([
          __param(0, Decorators_1.NotNull),
          __param(1, Decorators_1.NotNull)
        ], OR);
        SemanticContext2.OR = OR;
      })(SemanticContext = exports.SemanticContext || (exports.SemanticContext = {}));
    }
  });

  // node_modules/antlr4ts/atn/PredicateTransition.js
  var require_PredicateTransition = __commonJS({
    "node_modules/antlr4ts/atn/PredicateTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PredicateTransition = void 0;
      var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
      var Decorators_1 = require_Decorators();
      var SemanticContext_1 = require_SemanticContext();
      var PredicateTransition = class PredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {
        constructor(target, ruleIndex, predIndex, isCtxDependent) {
          super(target);
          this.ruleIndex = ruleIndex;
          this.predIndex = predIndex;
          this.isCtxDependent = isCtxDependent;
        }
        get serializationType() {
          return 4;
        }
        get isEpsilon() {
          return true;
        }
        matches(symbol2, minVocabSymbol, maxVocabSymbol) {
          return false;
        }
        get predicate() {
          return new SemanticContext_1.SemanticContext.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
        }
        toString() {
          return "pred_" + this.ruleIndex + ":" + this.predIndex;
        }
      };
      __decorate([
        Decorators_1.Override
      ], PredicateTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override
      ], PredicateTransition.prototype, "isEpsilon", null);
      __decorate([
        Decorators_1.Override
      ], PredicateTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], PredicateTransition.prototype, "toString", null);
      PredicateTransition = __decorate([
        __param(0, Decorators_1.NotNull)
      ], PredicateTransition);
      exports.PredicateTransition = PredicateTransition;
    }
  });

  // node_modules/antlr4ts/FailedPredicateException.js
  var require_FailedPredicateException = __commonJS({
    "node_modules/antlr4ts/FailedPredicateException.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FailedPredicateException = void 0;
      var RecognitionException_1 = require_RecognitionException();
      var Decorators_1 = require_Decorators();
      var PredicateTransition_1 = require_PredicateTransition();
      var FailedPredicateException2 = class FailedPredicateException3 extends RecognitionException_1.RecognitionException {
        constructor(recognizer, predicate, message) {
          super(recognizer, recognizer.inputStream, recognizer.context, FailedPredicateException3.formatMessage(predicate, message));
          let s = recognizer.interpreter.atn.states[recognizer.state];
          let trans = s.transition(0);
          if (trans instanceof PredicateTransition_1.PredicateTransition) {
            this._ruleIndex = trans.ruleIndex;
            this._predicateIndex = trans.predIndex;
          } else {
            this._ruleIndex = 0;
            this._predicateIndex = 0;
          }
          this._predicate = predicate;
          super.setOffendingToken(recognizer, recognizer.currentToken);
        }
        get ruleIndex() {
          return this._ruleIndex;
        }
        get predicateIndex() {
          return this._predicateIndex;
        }
        get predicate() {
          return this._predicate;
        }
        static formatMessage(predicate, message) {
          if (message) {
            return message;
          }
          return `failed predicate: {${predicate}}?`;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], FailedPredicateException2, "formatMessage", null);
      FailedPredicateException2 = __decorate([
        __param(0, Decorators_1.NotNull)
      ], FailedPredicateException2);
      exports.FailedPredicateException = FailedPredicateException2;
    }
  });

  // node_modules/antlr4ts/InputMismatchException.js
  var require_InputMismatchException = __commonJS({
    "node_modules/antlr4ts/InputMismatchException.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InputMismatchException = void 0;
      var RecognitionException_1 = require_RecognitionException();
      var Decorators_1 = require_Decorators();
      var InputMismatchException = class InputMismatchException extends RecognitionException_1.RecognitionException {
        constructor(recognizer, state, context) {
          if (context === void 0) {
            context = recognizer.context;
          }
          super(recognizer, recognizer.inputStream, context);
          if (state !== void 0) {
            this.setOffendingState(state);
          }
          this.setOffendingToken(recognizer, recognizer.currentToken);
        }
      };
      InputMismatchException = __decorate([
        __param(0, Decorators_1.NotNull)
      ], InputMismatchException);
      exports.InputMismatchException = InputMismatchException;
    }
  });

  // node_modules/antlr4ts/misc/Arrays.js
  var require_Arrays = __commonJS({
    "node_modules/antlr4ts/misc/Arrays.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Arrays = void 0;
      var Arrays;
      (function(Arrays2) {
        function binarySearch(array3, key, fromIndex, toIndex) {
          return binarySearch0(array3, fromIndex !== void 0 ? fromIndex : 0, toIndex !== void 0 ? toIndex : array3.length, key);
        }
        Arrays2.binarySearch = binarySearch;
        function binarySearch0(array3, fromIndex, toIndex, key) {
          let low = fromIndex;
          let high = toIndex - 1;
          while (low <= high) {
            let mid = low + high >>> 1;
            let midVal = array3[mid];
            if (midVal < key) {
              low = mid + 1;
            } else if (midVal > key) {
              high = mid - 1;
            } else {
              return mid;
            }
          }
          return -(low + 1);
        }
        function toString(array3) {
          let result = "[";
          let first = true;
          for (let element of array3) {
            if (first) {
              first = false;
            } else {
              result += ", ";
            }
            if (element === null) {
              result += "null";
            } else if (element === void 0) {
              result += "undefined";
            } else {
              result += element;
            }
          }
          result += "]";
          return result;
        }
        Arrays2.toString = toString;
      })(Arrays = exports.Arrays || (exports.Arrays = {}));
    }
  });

  // node_modules/antlr4ts/misc/IntegerList.js
  var require_IntegerList = __commonJS({
    "node_modules/antlr4ts/misc/IntegerList.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IntegerList = void 0;
      var Arrays_1 = require_Arrays();
      var Decorators_1 = require_Decorators();
      var EMPTY_DATA = new Int32Array(0);
      var INITIAL_SIZE = 4;
      var MAX_ARRAY_SIZE = (1 << 31 >>> 0) - 1 - 8;
      var IntegerList = class _IntegerList {
        constructor(arg) {
          if (!arg) {
            this._data = EMPTY_DATA;
            this._size = 0;
          } else if (arg instanceof _IntegerList) {
            this._data = arg._data.slice(0);
            this._size = arg._size;
          } else if (typeof arg === "number") {
            if (arg === 0) {
              this._data = EMPTY_DATA;
              this._size = 0;
            } else {
              this._data = new Int32Array(arg);
              this._size = 0;
            }
          } else {
            this._data = EMPTY_DATA;
            this._size = 0;
            for (let value of arg) {
              this.add(value);
            }
          }
        }
        add(value) {
          if (this._data.length === this._size) {
            this.ensureCapacity(this._size + 1);
          }
          this._data[this._size] = value;
          this._size++;
        }
        addAll(list) {
          if (Array.isArray(list)) {
            this.ensureCapacity(this._size + list.length);
            this._data.subarray(this._size, this._size + list.length).set(list);
            this._size += list.length;
          } else if (list instanceof _IntegerList) {
            this.ensureCapacity(this._size + list._size);
            this._data.subarray(this._size, this._size + list.size).set(list._data);
            this._size += list._size;
          } else {
            this.ensureCapacity(this._size + list.size);
            let current = 0;
            for (let xi of list) {
              this._data[this._size + current] = xi;
              current++;
            }
            this._size += list.size;
          }
        }
        get(index) {
          if (index < 0 || index >= this._size) {
            throw RangeError();
          }
          return this._data[index];
        }
        contains(value) {
          for (let i = 0; i < this._size; i++) {
            if (this._data[i] === value) {
              return true;
            }
          }
          return false;
        }
        set(index, value) {
          if (index < 0 || index >= this._size) {
            throw RangeError();
          }
          let previous = this._data[index];
          this._data[index] = value;
          return previous;
        }
        removeAt(index) {
          let value = this.get(index);
          this._data.copyWithin(index, index + 1, this._size);
          this._data[this._size - 1] = 0;
          this._size--;
          return value;
        }
        removeRange(fromIndex, toIndex) {
          if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
            throw RangeError();
          }
          if (fromIndex > toIndex) {
            throw RangeError();
          }
          this._data.copyWithin(toIndex, fromIndex, this._size);
          this._data.fill(0, this._size - (toIndex - fromIndex), this._size);
          this._size -= toIndex - fromIndex;
        }
        get isEmpty() {
          return this._size === 0;
        }
        get size() {
          return this._size;
        }
        trimToSize() {
          if (this._data.length === this._size) {
            return;
          }
          this._data = this._data.slice(0, this._size);
        }
        clear() {
          this._data.fill(0, 0, this._size);
          this._size = 0;
        }
        toArray() {
          if (this._size === 0) {
            return [];
          }
          return Array.from(this._data.subarray(0, this._size));
        }
        sort() {
          this._data.subarray(0, this._size).sort();
        }
        /**
         * Compares the specified object with this list for equality.  Returns
         * `true` if and only if the specified object is also an {@link IntegerList},
         * both lists have the same size, and all corresponding pairs of elements in
         * the two lists are equal.  In other words, two lists are defined to be
         * equal if they contain the same elements in the same order.
         *
         * This implementation first checks if the specified object is this
         * list. If so, it returns `true`; if not, it checks if the
         * specified object is an {@link IntegerList}. If not, it returns `false`;
         * if so, it checks the size of both lists. If the lists are not the same size,
         * it returns `false`; otherwise it iterates over both lists, comparing
         * corresponding pairs of elements.  If any comparison returns `false`,
         * this method returns `false`.
         *
         * @param o the object to be compared for equality with this list
         * @returns `true` if the specified object is equal to this list
         */
        equals(o) {
          if (o === this) {
            return true;
          }
          if (!(o instanceof _IntegerList)) {
            return false;
          }
          if (this._size !== o._size) {
            return false;
          }
          for (let i = 0; i < this._size; i++) {
            if (this._data[i] !== o._data[i]) {
              return false;
            }
          }
          return true;
        }
        /**
         * Returns the hash code value for this list.
         *
         * This implementation uses exactly the code that is used to define the
         * list hash function in the documentation for the {@link List#hashCode}
         * method.
         *
         * @returns the hash code value for this list
         */
        hashCode() {
          let hashCode = 1;
          for (let i = 0; i < this._size; i++) {
            hashCode = 31 * hashCode + this._data[i];
          }
          return hashCode;
        }
        /**
         * Returns a string representation of this list.
         */
        toString() {
          return this._data.toString();
        }
        binarySearch(key, fromIndex, toIndex) {
          if (fromIndex === void 0) {
            fromIndex = 0;
          }
          if (toIndex === void 0) {
            toIndex = this._size;
          }
          if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
            throw new RangeError();
          }
          if (fromIndex > toIndex) {
            throw new RangeError();
          }
          return Arrays_1.Arrays.binarySearch(this._data, key, fromIndex, toIndex);
        }
        ensureCapacity(capacity) {
          if (capacity < 0 || capacity > MAX_ARRAY_SIZE) {
            throw new RangeError();
          }
          let newLength;
          if (this._data.length === 0) {
            newLength = INITIAL_SIZE;
          } else {
            newLength = this._data.length;
          }
          while (newLength < capacity) {
            newLength = newLength * 2;
            if (newLength < 0 || newLength > MAX_ARRAY_SIZE) {
              newLength = MAX_ARRAY_SIZE;
            }
          }
          let tmp = new Int32Array(newLength);
          tmp.set(this._data);
          this._data = tmp;
        }
        /** Convert the list to a UTF-16 encoded char array. If all values are less
         *  than the 0xFFFF 16-bit code point limit then this is just a char array
         *  of 16-bit char as usual. For values in the supplementary range, encode
         * them as two UTF-16 code units.
         */
        toCharArray() {
          let resultArray = new Uint16Array(this._size);
          let resultIdx = 0;
          let calculatedPreciseResultSize = false;
          for (let i = 0; i < this._size; i++) {
            let codePoint = this._data[i];
            if (codePoint >= 0 && codePoint < 65536) {
              resultArray[resultIdx] = codePoint;
              resultIdx++;
              continue;
            }
            if (!calculatedPreciseResultSize) {
              let newResultArray = new Uint16Array(this.charArraySize());
              newResultArray.set(resultArray, 0);
              resultArray = newResultArray;
              calculatedPreciseResultSize = true;
            }
            let pair = String.fromCodePoint(codePoint);
            resultArray[resultIdx] = pair.charCodeAt(0);
            resultArray[resultIdx + 1] = pair.charCodeAt(1);
            resultIdx += 2;
          }
          return resultArray;
        }
        charArraySize() {
          let result = 0;
          for (let i = 0; i < this._size; i++) {
            result += this._data[i] >= 65536 ? 2 : 1;
          }
          return result;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], IntegerList.prototype, "_data", void 0);
      __decorate([
        Decorators_1.Override
      ], IntegerList.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], IntegerList.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], IntegerList.prototype, "toString", null);
      exports.IntegerList = IntegerList;
    }
  });

  // node_modules/antlr4ts/misc/Interval.js
  var require_Interval = __commonJS({
    "node_modules/antlr4ts/misc/Interval.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Interval = void 0;
      var Decorators_1 = require_Decorators();
      var INTERVAL_POOL_MAX_VALUE = 1e3;
      var Interval = class _Interval {
        /**
         * @param a The start of the interval
         * @param b The end of the interval (inclusive)
         */
        constructor(a, b) {
          this.a = a;
          this.b = b;
        }
        static get INVALID() {
          return _Interval._INVALID;
        }
        /** Interval objects are used readonly so share all with the
         *  same single value a==b up to some max size.  Use an array as a perfect hash.
         *  Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new
         *  Interval object with a..a in it.  On Java.g4, 218623 IntervalSets
         *  have a..a (set with 1 element).
         */
        static of(a, b) {
          if (a !== b || a < 0 || a > INTERVAL_POOL_MAX_VALUE) {
            return new _Interval(a, b);
          }
          if (_Interval.cache[a] == null) {
            _Interval.cache[a] = new _Interval(a, a);
          }
          return _Interval.cache[a];
        }
        /** return number of elements between a and b inclusively. x..x is length 1.
         *  if b &lt; a, then length is 0.  9..10 has length 2.
         */
        get length() {
          if (this.b < this.a) {
            return 0;
          }
          return this.b - this.a + 1;
        }
        equals(o) {
          if (o === this) {
            return true;
          } else if (!(o instanceof _Interval)) {
            return false;
          }
          return this.a === o.a && this.b === o.b;
        }
        hashCode() {
          let hash2 = 23;
          hash2 = hash2 * 31 + this.a;
          hash2 = hash2 * 31 + this.b;
          return hash2;
        }
        /** Does this start completely before other? Disjoint */
        startsBeforeDisjoint(other) {
          return this.a < other.a && this.b < other.a;
        }
        /** Does this start at or before other? Nondisjoint */
        startsBeforeNonDisjoint(other) {
          return this.a <= other.a && this.b >= other.a;
        }
        /** Does this.a start after other.b? May or may not be disjoint */
        startsAfter(other) {
          return this.a > other.a;
        }
        /** Does this start completely after other? Disjoint */
        startsAfterDisjoint(other) {
          return this.a > other.b;
        }
        /** Does this start after other? NonDisjoint */
        startsAfterNonDisjoint(other) {
          return this.a > other.a && this.a <= other.b;
        }
        /** Are both ranges disjoint? I.e., no overlap? */
        disjoint(other) {
          return this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);
        }
        /** Are two intervals adjacent such as 0..41 and 42..42? */
        adjacent(other) {
          return this.a === other.b + 1 || this.b === other.a - 1;
        }
        properlyContains(other) {
          return other.a >= this.a && other.b <= this.b;
        }
        /** Return the interval computed from combining this and other */
        union(other) {
          return _Interval.of(Math.min(this.a, other.a), Math.max(this.b, other.b));
        }
        /** Return the interval in common between this and o */
        intersection(other) {
          return _Interval.of(Math.max(this.a, other.a), Math.min(this.b, other.b));
        }
        /** Return the interval with elements from `this` not in `other`;
         *  `other` must not be totally enclosed (properly contained)
         *  within `this`, which would result in two disjoint intervals
         *  instead of the single one returned by this method.
         */
        differenceNotProperlyContained(other) {
          let diff;
          if (other.startsBeforeNonDisjoint(this)) {
            diff = _Interval.of(Math.max(this.a, other.b + 1), this.b);
          } else if (other.startsAfterNonDisjoint(this)) {
            diff = _Interval.of(this.a, other.a - 1);
          }
          return diff;
        }
        toString() {
          return this.a + ".." + this.b;
        }
      };
      Interval._INVALID = new Interval(-1, -2);
      Interval.cache = new Array(INTERVAL_POOL_MAX_VALUE + 1);
      __decorate([
        Decorators_1.Override
      ], Interval.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], Interval.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], Interval.prototype, "toString", null);
      exports.Interval = Interval;
    }
  });

  // node_modules/antlr4ts/Token.js
  var require_Token = __commonJS({
    "node_modules/antlr4ts/Token.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Token = void 0;
      var IntStream_1 = require_IntStream();
      var Token3;
      (function(Token4) {
        Token4.INVALID_TYPE = 0;
        Token4.EPSILON = -2;
        Token4.MIN_USER_TOKEN_TYPE = 1;
        Token4.EOF = IntStream_1.IntStream.EOF;
        Token4.DEFAULT_CHANNEL = 0;
        Token4.HIDDEN_CHANNEL = 1;
        Token4.MIN_USER_CHANNEL_VALUE = 2;
      })(Token3 = exports.Token || (exports.Token = {}));
    }
  });

  // node_modules/antlr4ts/CommonToken.js
  var require_CommonToken = __commonJS({
    "node_modules/antlr4ts/CommonToken.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommonToken = void 0;
      var Interval_1 = require_Interval();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var CommonToken = class CommonToken2 {
        constructor(type, text, source = CommonToken2.EMPTY_SOURCE, channel = Token_1.Token.DEFAULT_CHANNEL, start = 0, stop = 0) {
          this._line = 0;
          this._charPositionInLine = -1;
          this._channel = Token_1.Token.DEFAULT_CHANNEL;
          this.index = -1;
          this._text = text;
          this._type = type;
          this.source = source;
          this._channel = channel;
          this.start = start;
          this.stop = stop;
          if (source.source != null) {
            this._line = source.source.line;
            this._charPositionInLine = source.source.charPositionInLine;
          }
        }
        /**
         * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
         *
         * If `oldToken` is also a {@link CommonToken} instance, the newly
         * constructed token will share a reference to the {@link #text} field and
         * the {@link Tuple2} stored in {@link #source}. Otherwise, {@link #text} will
         * be assigned the result of calling {@link #getText}, and {@link #source}
         * will be constructed from the result of {@link Token#getTokenSource} and
         * {@link Token#getInputStream}.
         *
         * @param oldToken The token to copy.
         */
        static fromToken(oldToken) {
          let result = new CommonToken2(oldToken.type, void 0, CommonToken2.EMPTY_SOURCE, oldToken.channel, oldToken.startIndex, oldToken.stopIndex);
          result._line = oldToken.line;
          result.index = oldToken.tokenIndex;
          result._charPositionInLine = oldToken.charPositionInLine;
          if (oldToken instanceof CommonToken2) {
            result._text = oldToken._text;
            result.source = oldToken.source;
          } else {
            result._text = oldToken.text;
            result.source = { source: oldToken.tokenSource, stream: oldToken.inputStream };
          }
          return result;
        }
        get type() {
          return this._type;
        }
        // @Override
        set type(type) {
          this._type = type;
        }
        get line() {
          return this._line;
        }
        // @Override
        set line(line) {
          this._line = line;
        }
        get text() {
          if (this._text != null) {
            return this._text;
          }
          let input = this.inputStream;
          if (input == null) {
            return void 0;
          }
          let n = input.size;
          if (this.start < n && this.stop < n) {
            return input.getText(Interval_1.Interval.of(this.start, this.stop));
          } else {
            return "<EOF>";
          }
        }
        /**
         * Explicitly set the text for this token. If {code text} is not
         * `undefined`, then {@link #getText} will return this value rather than
         * extracting the text from the input.
         *
         * @param text The explicit text of the token, or `undefined` if the text
         * should be obtained from the input along with the start and stop indexes
         * of the token.
         */
        // @Override
        set text(text) {
          this._text = text;
        }
        get charPositionInLine() {
          return this._charPositionInLine;
        }
        // @Override
        set charPositionInLine(charPositionInLine) {
          this._charPositionInLine = charPositionInLine;
        }
        get channel() {
          return this._channel;
        }
        // @Override
        set channel(channel) {
          this._channel = channel;
        }
        get startIndex() {
          return this.start;
        }
        set startIndex(start) {
          this.start = start;
        }
        get stopIndex() {
          return this.stop;
        }
        set stopIndex(stop) {
          this.stop = stop;
        }
        get tokenIndex() {
          return this.index;
        }
        // @Override
        set tokenIndex(index) {
          this.index = index;
        }
        get tokenSource() {
          return this.source.source;
        }
        get inputStream() {
          return this.source.stream;
        }
        toString(recognizer) {
          let channelStr = "";
          if (this._channel > 0) {
            channelStr = ",channel=" + this._channel;
          }
          let txt = this.text;
          if (txt != null) {
            txt = txt.replace(/\n/g, "\\n");
            txt = txt.replace(/\r/g, "\\r");
            txt = txt.replace(/\t/g, "\\t");
          } else {
            txt = "<no text>";
          }
          let typeString = String(this._type);
          if (recognizer) {
            typeString = recognizer.vocabulary.getDisplayName(this._type);
          }
          return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + txt + "',<" + typeString + ">" + channelStr + "," + this._line + ":" + this.charPositionInLine + "]";
        }
      };
      CommonToken.EMPTY_SOURCE = { source: void 0, stream: void 0 };
      __decorate([
        Decorators_1.NotNull
      ], CommonToken.prototype, "source", void 0);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "type", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "line", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "text", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "charPositionInLine", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "channel", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "startIndex", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "stopIndex", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "tokenIndex", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "tokenSource", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "inputStream", null);
      __decorate([
        Decorators_1.Override
      ], CommonToken.prototype, "toString", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], CommonToken, "fromToken", null);
      CommonToken = __decorate([
        __param(2, Decorators_1.NotNull)
      ], CommonToken);
      exports.CommonToken = CommonToken;
    }
  });

  // node_modules/antlr4ts/CommonTokenFactory.js
  var require_CommonTokenFactory = __commonJS({
    "node_modules/antlr4ts/CommonTokenFactory.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommonTokenFactory = void 0;
      var CommonToken_1 = require_CommonToken();
      var Interval_1 = require_Interval();
      var Decorators_1 = require_Decorators();
      var CommonTokenFactory = class {
        /**
         * Constructs a {@link CommonTokenFactory} with the specified value for
         * {@link #copyText}.
         *
         * When `copyText` is `false`, the {@link #DEFAULT} instance
         * should be used instead of constructing a new instance.
         *
         * @param copyText The value for {@link #copyText}.
         */
        constructor(copyText = false) {
          this.copyText = copyText;
        }
        create(source, type, text, channel, start, stop, line, charPositionInLine) {
          let t = new CommonToken_1.CommonToken(type, text, source, channel, start, stop);
          t.line = line;
          t.charPositionInLine = charPositionInLine;
          if (text == null && this.copyText && source.stream != null) {
            t.text = source.stream.getText(Interval_1.Interval.of(start, stop));
          }
          return t;
        }
        createSimple(type, text) {
          return new CommonToken_1.CommonToken(type, text);
        }
      };
      __decorate([
        Decorators_1.Override
      ], CommonTokenFactory.prototype, "create", null);
      __decorate([
        Decorators_1.Override
      ], CommonTokenFactory.prototype, "createSimple", null);
      exports.CommonTokenFactory = CommonTokenFactory;
      (function(CommonTokenFactory2) {
        CommonTokenFactory2.DEFAULT = new CommonTokenFactory2();
      })(CommonTokenFactory = exports.CommonTokenFactory || (exports.CommonTokenFactory = {}));
    }
  });

  // node_modules/antlr4ts/misc/IntegerStack.js
  var require_IntegerStack = __commonJS({
    "node_modules/antlr4ts/misc/IntegerStack.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IntegerStack = void 0;
      var IntegerList_1 = require_IntegerList();
      var IntegerStack = class extends IntegerList_1.IntegerList {
        constructor(arg) {
          super(arg);
        }
        push(value) {
          this.add(value);
        }
        pop() {
          return this.removeAt(this.size - 1);
        }
        peek() {
          return this.get(this.size - 1);
        }
      };
      exports.IntegerStack = IntegerStack;
    }
  });

  // node_modules/antlr4ts/dfa/AcceptStateInfo.js
  var require_AcceptStateInfo = __commonJS({
    "node_modules/antlr4ts/dfa/AcceptStateInfo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AcceptStateInfo = void 0;
      var AcceptStateInfo = class {
        constructor(prediction, lexerActionExecutor) {
          this._prediction = prediction;
          this._lexerActionExecutor = lexerActionExecutor;
        }
        /**
         * Gets the prediction made by this accept state. Note that this value
         * assumes the predicates, if any, in the {@link DFAState} evaluate to
         * `true`. If predicate evaluation is enabled, the final prediction of
         * the accept state will be determined by the result of predicate
         * evaluation.
         */
        get prediction() {
          return this._prediction;
        }
        /**
         * Gets the {@link LexerActionExecutor} which can be used to execute actions
         * and/or commands after the lexer matches a token.
         */
        get lexerActionExecutor() {
          return this._lexerActionExecutor;
        }
      };
      exports.AcceptStateInfo = AcceptStateInfo;
    }
  });

  // node_modules/antlr4ts/misc/Array2DHashMap.js
  var require_Array2DHashMap = __commonJS({
    "node_modules/antlr4ts/misc/Array2DHashMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Array2DHashMap = void 0;
      var Array2DHashSet_1 = require_Array2DHashSet();
      var MapKeyEqualityComparator = class {
        constructor(keyComparator) {
          this.keyComparator = keyComparator;
        }
        hashCode(obj) {
          return this.keyComparator.hashCode(obj.key);
        }
        equals(a, b) {
          return this.keyComparator.equals(a.key, b.key);
        }
      };
      var Array2DHashMap = class _Array2DHashMap {
        constructor(keyComparer) {
          if (keyComparer instanceof _Array2DHashMap) {
            this.backingStore = new Array2DHashSet_1.Array2DHashSet(keyComparer.backingStore);
          } else {
            this.backingStore = new Array2DHashSet_1.Array2DHashSet(new MapKeyEqualityComparator(keyComparer));
          }
        }
        clear() {
          this.backingStore.clear();
        }
        containsKey(key) {
          return this.backingStore.contains({ key });
        }
        get(key) {
          let bucket = this.backingStore.get({ key });
          if (!bucket) {
            return void 0;
          }
          return bucket.value;
        }
        get isEmpty() {
          return this.backingStore.isEmpty;
        }
        put(key, value) {
          let element = this.backingStore.get({ key, value });
          let result;
          if (!element) {
            this.backingStore.add({ key, value });
          } else {
            result = element.value;
            element.value = value;
          }
          return result;
        }
        putIfAbsent(key, value) {
          let element = this.backingStore.get({ key, value });
          let result;
          if (!element) {
            this.backingStore.add({ key, value });
          } else {
            result = element.value;
          }
          return result;
        }
        get size() {
          return this.backingStore.size;
        }
        hashCode() {
          return this.backingStore.hashCode();
        }
        equals(o) {
          if (!(o instanceof _Array2DHashMap)) {
            return false;
          }
          return this.backingStore.equals(o.backingStore);
        }
      };
      exports.Array2DHashMap = Array2DHashMap;
    }
  });

  // node_modules/antlr4ts/atn/DecisionState.js
  var require_DecisionState = __commonJS({
    "node_modules/antlr4ts/atn/DecisionState.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DecisionState = void 0;
      var ATNState_1 = require_ATNState();
      var DecisionState = class extends ATNState_1.ATNState {
        constructor() {
          super(...arguments);
          this.decision = -1;
          this.nonGreedy = false;
          this.sll = false;
        }
      };
      exports.DecisionState = DecisionState;
    }
  });

  // node_modules/antlr4ts/atn/PredictionContextCache.js
  var require_PredictionContextCache = __commonJS({
    "node_modules/antlr4ts/atn/PredictionContextCache.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PredictionContextCache = void 0;
      var Array2DHashMap_1 = require_Array2DHashMap();
      var Decorators_1 = require_Decorators();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var PredictionContext_1 = require_PredictionContext();
      var assert2 = require_assert();
      var PredictionContextCache = class _PredictionContextCache {
        constructor(enableCache = true) {
          this.contexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          this.childContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          this.joinContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          this.enableCache = enableCache;
        }
        getAsCached(context) {
          if (!this.enableCache) {
            return context;
          }
          let result = this.contexts.get(context);
          if (!result) {
            result = context;
            this.contexts.put(context, context);
          }
          return result;
        }
        getChild(context, invokingState) {
          if (!this.enableCache) {
            return context.getChild(invokingState);
          }
          let operands = new _PredictionContextCache.PredictionContextAndInt(context, invokingState);
          let result = this.childContexts.get(operands);
          if (!result) {
            result = context.getChild(invokingState);
            result = this.getAsCached(result);
            this.childContexts.put(operands, result);
          }
          return result;
        }
        join(x, y) {
          if (!this.enableCache) {
            return PredictionContext_1.PredictionContext.join(x, y, this);
          }
          let operands = new _PredictionContextCache.IdentityCommutativePredictionContextOperands(x, y);
          let result = this.joinContexts.get(operands);
          if (result) {
            return result;
          }
          result = PredictionContext_1.PredictionContext.join(x, y, this);
          result = this.getAsCached(result);
          this.joinContexts.put(operands, result);
          return result;
        }
      };
      exports.PredictionContextCache = PredictionContextCache;
      PredictionContextCache.UNCACHED = new PredictionContextCache(false);
      (function(PredictionContextCache2) {
        class PredictionContextAndInt {
          constructor(obj, value) {
            this.obj = obj;
            this.value = value;
          }
          equals(obj) {
            if (!(obj instanceof PredictionContextAndInt)) {
              return false;
            } else if (obj === this) {
              return true;
            }
            let other = obj;
            return this.value === other.value && (this.obj === other.obj || this.obj != null && this.obj.equals(other.obj));
          }
          hashCode() {
            let hashCode = 5;
            hashCode = 7 * hashCode + (this.obj != null ? this.obj.hashCode() : 0);
            hashCode = 7 * hashCode + this.value;
            return hashCode;
          }
        }
        __decorate([
          Decorators_1.Override
        ], PredictionContextAndInt.prototype, "equals", null);
        __decorate([
          Decorators_1.Override
        ], PredictionContextAndInt.prototype, "hashCode", null);
        PredictionContextCache2.PredictionContextAndInt = PredictionContextAndInt;
        class IdentityCommutativePredictionContextOperands {
          constructor(x, y) {
            assert2(x != null);
            assert2(y != null);
            this._x = x;
            this._y = y;
          }
          get x() {
            return this._x;
          }
          get y() {
            return this._y;
          }
          equals(o) {
            if (!(o instanceof IdentityCommutativePredictionContextOperands)) {
              return false;
            } else if (this === o) {
              return true;
            }
            let other = o;
            return this._x === other._x && this._y === other._y || this._x === other._y && this._y === other._x;
          }
          hashCode() {
            return this._x.hashCode() ^ this._y.hashCode();
          }
        }
        __decorate([
          Decorators_1.Override
        ], IdentityCommutativePredictionContextOperands.prototype, "equals", null);
        __decorate([
          Decorators_1.Override
        ], IdentityCommutativePredictionContextOperands.prototype, "hashCode", null);
        PredictionContextCache2.IdentityCommutativePredictionContextOperands = IdentityCommutativePredictionContextOperands;
      })(PredictionContextCache = exports.PredictionContextCache || (exports.PredictionContextCache = {}));
    }
  });

  // node_modules/antlr4ts/atn/PredictionContext.js
  var require_PredictionContext = __commonJS({
    "node_modules/antlr4ts/atn/PredictionContext.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SingletonPredictionContext = exports.PredictionContext = void 0;
      var Array2DHashMap_1 = require_Array2DHashMap();
      var Array2DHashSet_1 = require_Array2DHashSet();
      var Arrays_1 = require_Arrays();
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var PredictionContextCache_1 = require_PredictionContextCache();
      var assert2 = require_assert();
      var INITIAL_HASH = 1;
      var PredictionContext = class _PredictionContext {
        constructor(cachedHashCode) {
          this.cachedHashCode = cachedHashCode;
        }
        static calculateEmptyHashCode() {
          let hash2 = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
          hash2 = MurmurHash_1.MurmurHash.finish(hash2, 0);
          return hash2;
        }
        static calculateSingleHashCode(parent, returnState) {
          let hash2 = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
          hash2 = MurmurHash_1.MurmurHash.update(hash2, parent);
          hash2 = MurmurHash_1.MurmurHash.update(hash2, returnState);
          hash2 = MurmurHash_1.MurmurHash.finish(hash2, 2);
          return hash2;
        }
        static calculateHashCode(parents, returnStates) {
          let hash2 = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
          for (let parent of parents) {
            hash2 = MurmurHash_1.MurmurHash.update(hash2, parent);
          }
          for (let returnState of returnStates) {
            hash2 = MurmurHash_1.MurmurHash.update(hash2, returnState);
          }
          hash2 = MurmurHash_1.MurmurHash.finish(hash2, 2 * parents.length);
          return hash2;
        }
        static fromRuleContext(atn, outerContext, fullContext = true) {
          if (outerContext.isEmpty) {
            return fullContext ? _PredictionContext.EMPTY_FULL : _PredictionContext.EMPTY_LOCAL;
          }
          let parent;
          if (outerContext._parent) {
            parent = _PredictionContext.fromRuleContext(atn, outerContext._parent, fullContext);
          } else {
            parent = fullContext ? _PredictionContext.EMPTY_FULL : _PredictionContext.EMPTY_LOCAL;
          }
          let state = atn.states[outerContext.invokingState];
          let transition = state.transition(0);
          return parent.getChild(transition.followState.stateNumber);
        }
        static addEmptyContext(context) {
          return context.addEmptyContext();
        }
        static removeEmptyContext(context) {
          return context.removeEmptyContext();
        }
        static join(context0, context1, contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED) {
          if (context0 === context1) {
            return context0;
          }
          if (context0.isEmpty) {
            return _PredictionContext.isEmptyLocal(context0) ? context0 : _PredictionContext.addEmptyContext(context1);
          } else if (context1.isEmpty) {
            return _PredictionContext.isEmptyLocal(context1) ? context1 : _PredictionContext.addEmptyContext(context0);
          }
          let context0size = context0.size;
          let context1size = context1.size;
          if (context0size === 1 && context1size === 1 && context0.getReturnState(0) === context1.getReturnState(0)) {
            let merged = contextCache.join(context0.getParent(0), context1.getParent(0));
            if (merged === context0.getParent(0)) {
              return context0;
            } else if (merged === context1.getParent(0)) {
              return context1;
            } else {
              return merged.getChild(context0.getReturnState(0));
            }
          }
          let count = 0;
          let parentsList = new Array(context0size + context1size);
          let returnStatesList = new Array(parentsList.length);
          let leftIndex = 0;
          let rightIndex = 0;
          let canReturnLeft = true;
          let canReturnRight = true;
          while (leftIndex < context0size && rightIndex < context1size) {
            if (context0.getReturnState(leftIndex) === context1.getReturnState(rightIndex)) {
              parentsList[count] = contextCache.join(context0.getParent(leftIndex), context1.getParent(rightIndex));
              returnStatesList[count] = context0.getReturnState(leftIndex);
              canReturnLeft = canReturnLeft && parentsList[count] === context0.getParent(leftIndex);
              canReturnRight = canReturnRight && parentsList[count] === context1.getParent(rightIndex);
              leftIndex++;
              rightIndex++;
            } else if (context0.getReturnState(leftIndex) < context1.getReturnState(rightIndex)) {
              parentsList[count] = context0.getParent(leftIndex);
              returnStatesList[count] = context0.getReturnState(leftIndex);
              canReturnRight = false;
              leftIndex++;
            } else {
              assert2(context1.getReturnState(rightIndex) < context0.getReturnState(leftIndex));
              parentsList[count] = context1.getParent(rightIndex);
              returnStatesList[count] = context1.getReturnState(rightIndex);
              canReturnLeft = false;
              rightIndex++;
            }
            count++;
          }
          while (leftIndex < context0size) {
            parentsList[count] = context0.getParent(leftIndex);
            returnStatesList[count] = context0.getReturnState(leftIndex);
            leftIndex++;
            canReturnRight = false;
            count++;
          }
          while (rightIndex < context1size) {
            parentsList[count] = context1.getParent(rightIndex);
            returnStatesList[count] = context1.getReturnState(rightIndex);
            rightIndex++;
            canReturnLeft = false;
            count++;
          }
          if (canReturnLeft) {
            return context0;
          } else if (canReturnRight) {
            return context1;
          }
          if (count < parentsList.length) {
            parentsList = parentsList.slice(0, count);
            returnStatesList = returnStatesList.slice(0, count);
          }
          if (parentsList.length === 0) {
            return _PredictionContext.EMPTY_FULL;
          } else if (parentsList.length === 1) {
            return new SingletonPredictionContext(parentsList[0], returnStatesList[0]);
          } else {
            return new ArrayPredictionContext(parentsList, returnStatesList);
          }
        }
        static isEmptyLocal(context) {
          return context === _PredictionContext.EMPTY_LOCAL;
        }
        static getCachedContext(context, contextCache, visited) {
          if (context.isEmpty) {
            return context;
          }
          let existing = visited.get(context);
          if (existing) {
            return existing;
          }
          existing = contextCache.get(context);
          if (existing) {
            visited.put(context, existing);
            return existing;
          }
          let changed = false;
          let parents = new Array(context.size);
          for (let i = 0; i < parents.length; i++) {
            let parent = _PredictionContext.getCachedContext(context.getParent(i), contextCache, visited);
            if (changed || parent !== context.getParent(i)) {
              if (!changed) {
                parents = new Array(context.size);
                for (let j = 0; j < context.size; j++) {
                  parents[j] = context.getParent(j);
                }
                changed = true;
              }
              parents[i] = parent;
            }
          }
          if (!changed) {
            existing = contextCache.putIfAbsent(context, context);
            visited.put(context, existing != null ? existing : context);
            return context;
          }
          let updated;
          if (parents.length === 1) {
            updated = new SingletonPredictionContext(parents[0], context.getReturnState(0));
          } else {
            let returnStates = new Array(context.size);
            for (let i = 0; i < context.size; i++) {
              returnStates[i] = context.getReturnState(i);
            }
            updated = new ArrayPredictionContext(parents, returnStates, context.hashCode());
          }
          existing = contextCache.putIfAbsent(updated, updated);
          visited.put(updated, existing || updated);
          visited.put(context, existing || updated);
          return updated;
        }
        appendSingleContext(returnContext, contextCache) {
          return this.appendContext(_PredictionContext.EMPTY_FULL.getChild(returnContext), contextCache);
        }
        getChild(returnState) {
          return new SingletonPredictionContext(this, returnState);
        }
        hashCode() {
          return this.cachedHashCode;
        }
        toStrings(recognizer, currentState, stop = _PredictionContext.EMPTY_FULL) {
          let result = [];
          outer: for (let perm = 0; ; perm++) {
            let offset = 0;
            let last = true;
            let p = this;
            let stateNumber = currentState;
            let localBuffer = "";
            localBuffer += "[";
            while (!p.isEmpty && p !== stop) {
              let index = 0;
              if (p.size > 0) {
                let bits = 1;
                while (1 << bits >>> 0 < p.size) {
                  bits++;
                }
                let mask = (1 << bits >>> 0) - 1;
                index = perm >> offset & mask;
                last = last && index >= p.size - 1;
                if (index >= p.size) {
                  continue outer;
                }
                offset += bits;
              }
              if (recognizer) {
                if (localBuffer.length > 1) {
                  localBuffer += " ";
                }
                let atn = recognizer.atn;
                let s = atn.states[stateNumber];
                let ruleName = recognizer.ruleNames[s.ruleIndex];
                localBuffer += ruleName;
              } else if (p.getReturnState(index) !== _PredictionContext.EMPTY_FULL_STATE_KEY) {
                if (!p.isEmpty) {
                  if (localBuffer.length > 1) {
                    localBuffer += " ";
                  }
                  localBuffer += p.getReturnState(index);
                }
              }
              stateNumber = p.getReturnState(index);
              p = p.getParent(index);
            }
            localBuffer += "]";
            result.push(localBuffer);
            if (last) {
              break;
            }
          }
          return result;
        }
      };
      __decorate([
        Decorators_1.Override
      ], PredictionContext.prototype, "hashCode", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], PredictionContext, "join", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], PredictionContext, "getCachedContext", null);
      exports.PredictionContext = PredictionContext;
      var EmptyPredictionContext = class extends PredictionContext {
        constructor(fullContext) {
          super(PredictionContext.calculateEmptyHashCode());
          this.fullContext = fullContext;
        }
        get isFullContext() {
          return this.fullContext;
        }
        addEmptyContext() {
          return this;
        }
        removeEmptyContext() {
          throw new Error("Cannot remove the empty context from itself.");
        }
        getParent(index) {
          throw new Error("index out of bounds");
        }
        getReturnState(index) {
          throw new Error("index out of bounds");
        }
        findReturnState(returnState) {
          return -1;
        }
        get size() {
          return 0;
        }
        appendSingleContext(returnContext, contextCache) {
          return contextCache.getChild(this, returnContext);
        }
        appendContext(suffix, contextCache) {
          return suffix;
        }
        get isEmpty() {
          return true;
        }
        get hasEmpty() {
          return true;
        }
        equals(o) {
          return this === o;
        }
        toStrings(recognizer, currentState, stop) {
          return ["[]"];
        }
      };
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "addEmptyContext", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "removeEmptyContext", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "getParent", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "getReturnState", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "findReturnState", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "appendSingleContext", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "appendContext", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "isEmpty", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "hasEmpty", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], EmptyPredictionContext.prototype, "toStrings", null);
      var ArrayPredictionContext = class ArrayPredictionContext2 extends PredictionContext {
        constructor(parents, returnStates, hashCode) {
          super(hashCode || PredictionContext.calculateHashCode(parents, returnStates));
          assert2(parents.length === returnStates.length);
          assert2(returnStates.length > 1 || returnStates[0] !== PredictionContext.EMPTY_FULL_STATE_KEY, "Should be using PredictionContext.EMPTY instead.");
          this.parents = parents;
          this.returnStates = returnStates;
        }
        getParent(index) {
          return this.parents[index];
        }
        getReturnState(index) {
          return this.returnStates[index];
        }
        findReturnState(returnState) {
          return Arrays_1.Arrays.binarySearch(this.returnStates, returnState);
        }
        get size() {
          return this.returnStates.length;
        }
        get isEmpty() {
          return false;
        }
        get hasEmpty() {
          return this.returnStates[this.returnStates.length - 1] === PredictionContext.EMPTY_FULL_STATE_KEY;
        }
        addEmptyContext() {
          if (this.hasEmpty) {
            return this;
          }
          let parents2 = this.parents.slice(0);
          let returnStates2 = this.returnStates.slice(0);
          parents2.push(PredictionContext.EMPTY_FULL);
          returnStates2.push(PredictionContext.EMPTY_FULL_STATE_KEY);
          return new ArrayPredictionContext2(parents2, returnStates2);
        }
        removeEmptyContext() {
          if (!this.hasEmpty) {
            return this;
          }
          if (this.returnStates.length === 2) {
            return new SingletonPredictionContext(this.parents[0], this.returnStates[0]);
          } else {
            let parents2 = this.parents.slice(0, this.parents.length - 1);
            let returnStates2 = this.returnStates.slice(0, this.returnStates.length - 1);
            return new ArrayPredictionContext2(parents2, returnStates2);
          }
        }
        appendContext(suffix, contextCache) {
          return ArrayPredictionContext2.appendContextImpl(this, suffix, new PredictionContext.IdentityHashMap());
        }
        static appendContextImpl(context, suffix, visited) {
          if (suffix.isEmpty) {
            if (PredictionContext.isEmptyLocal(suffix)) {
              if (context.hasEmpty) {
                return PredictionContext.EMPTY_LOCAL;
              }
              throw new Error("what to do here?");
            }
            return context;
          }
          if (suffix.size !== 1) {
            throw new Error("Appending a tree suffix is not yet supported.");
          }
          let result = visited.get(context);
          if (!result) {
            if (context.isEmpty) {
              result = suffix;
            } else {
              let parentCount = context.size;
              if (context.hasEmpty) {
                parentCount--;
              }
              let updatedParents = new Array(parentCount);
              let updatedReturnStates = new Array(parentCount);
              for (let i = 0; i < parentCount; i++) {
                updatedReturnStates[i] = context.getReturnState(i);
              }
              for (let i = 0; i < parentCount; i++) {
                updatedParents[i] = ArrayPredictionContext2.appendContextImpl(context.getParent(i), suffix, visited);
              }
              if (updatedParents.length === 1) {
                result = new SingletonPredictionContext(updatedParents[0], updatedReturnStates[0]);
              } else {
                assert2(updatedParents.length > 1);
                result = new ArrayPredictionContext2(updatedParents, updatedReturnStates);
              }
              if (context.hasEmpty) {
                result = PredictionContext.join(result, suffix);
              }
            }
            visited.put(context, result);
          }
          return result;
        }
        equals(o) {
          if (this === o) {
            return true;
          } else if (!(o instanceof ArrayPredictionContext2)) {
            return false;
          }
          if (this.hashCode() !== o.hashCode()) {
            return false;
          }
          let other = o;
          return this.equalsImpl(other, new Array2DHashSet_1.Array2DHashSet());
        }
        equalsImpl(other, visited) {
          let selfWorkList = [];
          let otherWorkList = [];
          selfWorkList.push(this);
          otherWorkList.push(other);
          while (true) {
            let currentSelf = selfWorkList.pop();
            let currentOther = otherWorkList.pop();
            if (!currentSelf || !currentOther) {
              break;
            }
            let operands = new PredictionContextCache_1.PredictionContextCache.IdentityCommutativePredictionContextOperands(currentSelf, currentOther);
            if (!visited.add(operands)) {
              continue;
            }
            let selfSize = operands.x.size;
            if (selfSize === 0) {
              if (!operands.x.equals(operands.y)) {
                return false;
              }
              continue;
            }
            let otherSize = operands.y.size;
            if (selfSize !== otherSize) {
              return false;
            }
            for (let i = 0; i < selfSize; i++) {
              if (operands.x.getReturnState(i) !== operands.y.getReturnState(i)) {
                return false;
              }
              let selfParent = operands.x.getParent(i);
              let otherParent = operands.y.getParent(i);
              if (selfParent.hashCode() !== otherParent.hashCode()) {
                return false;
              }
              if (selfParent !== otherParent) {
                selfWorkList.push(selfParent);
                otherWorkList.push(otherParent);
              }
            }
          }
          return true;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ArrayPredictionContext.prototype, "parents", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ArrayPredictionContext.prototype, "returnStates", void 0);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "getParent", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "getReturnState", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "findReturnState", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "isEmpty", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "hasEmpty", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "addEmptyContext", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "removeEmptyContext", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "appendContext", null);
      __decorate([
        Decorators_1.Override
      ], ArrayPredictionContext.prototype, "equals", null);
      ArrayPredictionContext = __decorate([
        __param(0, Decorators_1.NotNull)
      ], ArrayPredictionContext);
      var SingletonPredictionContext = class SingletonPredictionContext2 extends PredictionContext {
        constructor(parent, returnState) {
          super(PredictionContext.calculateSingleHashCode(parent, returnState));
          this.parent = parent;
          this.returnState = returnState;
        }
        getParent(index) {
          return this.parent;
        }
        getReturnState(index) {
          return this.returnState;
        }
        findReturnState(returnState) {
          return this.returnState === returnState ? 0 : -1;
        }
        get size() {
          return 1;
        }
        get isEmpty() {
          return false;
        }
        get hasEmpty() {
          return false;
        }
        appendContext(suffix, contextCache) {
          return contextCache.getChild(this.parent.appendContext(suffix, contextCache), this.returnState);
        }
        addEmptyContext() {
          let parents = [this.parent, PredictionContext.EMPTY_FULL];
          let returnStates = [this.returnState, PredictionContext.EMPTY_FULL_STATE_KEY];
          return new ArrayPredictionContext(parents, returnStates);
        }
        removeEmptyContext() {
          return this;
        }
        equals(o) {
          if (o === this) {
            return true;
          } else if (!(o instanceof SingletonPredictionContext2)) {
            return false;
          }
          let other = o;
          if (this.hashCode() !== other.hashCode()) {
            return false;
          }
          return this.returnState === other.returnState && this.parent.equals(other.parent);
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], SingletonPredictionContext.prototype, "parent", void 0);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "getParent", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "getReturnState", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "findReturnState", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "isEmpty", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "hasEmpty", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "appendContext", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "addEmptyContext", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "removeEmptyContext", null);
      __decorate([
        Decorators_1.Override
      ], SingletonPredictionContext.prototype, "equals", null);
      SingletonPredictionContext = __decorate([
        __param(0, Decorators_1.NotNull)
      ], SingletonPredictionContext);
      exports.SingletonPredictionContext = SingletonPredictionContext;
      (function(PredictionContext2) {
        PredictionContext2.EMPTY_LOCAL = new EmptyPredictionContext(false);
        PredictionContext2.EMPTY_FULL = new EmptyPredictionContext(true);
        PredictionContext2.EMPTY_LOCAL_STATE_KEY = -(1 << 31 >>> 0);
        PredictionContext2.EMPTY_FULL_STATE_KEY = (1 << 31 >>> 0) - 1;
        class IdentityHashMap extends Array2DHashMap_1.Array2DHashMap {
          constructor() {
            super(IdentityEqualityComparator.INSTANCE);
          }
        }
        PredictionContext2.IdentityHashMap = IdentityHashMap;
        class IdentityEqualityComparator {
          IdentityEqualityComparator() {
          }
          hashCode(obj) {
            return obj.hashCode();
          }
          equals(a, b) {
            return a === b;
          }
        }
        IdentityEqualityComparator.INSTANCE = new IdentityEqualityComparator();
        __decorate([
          Decorators_1.Override
        ], IdentityEqualityComparator.prototype, "hashCode", null);
        __decorate([
          Decorators_1.Override
        ], IdentityEqualityComparator.prototype, "equals", null);
        PredictionContext2.IdentityEqualityComparator = IdentityEqualityComparator;
      })(PredictionContext = exports.PredictionContext || (exports.PredictionContext = {}));
    }
  });

  // node_modules/antlr4ts/atn/ATNConfig.js
  var require_ATNConfig = __commonJS({
    "node_modules/antlr4ts/atn/ATNConfig.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATNConfig = void 0;
      var Array2DHashMap_1 = require_Array2DHashMap();
      var DecisionState_1 = require_DecisionState();
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var PredictionContext_1 = require_PredictionContext();
      var SemanticContext_1 = require_SemanticContext();
      var assert2 = require_assert();
      var SUPPRESS_PRECEDENCE_FILTER = 2147483648;
      var ATNConfig = class ATNConfig2 {
        constructor(state, altOrConfig, context) {
          if (typeof altOrConfig === "number") {
            assert2((altOrConfig & 16777215) === altOrConfig);
            this._state = state;
            this.altAndOuterContextDepth = altOrConfig;
            this._context = context;
          } else {
            this._state = state;
            this.altAndOuterContextDepth = altOrConfig.altAndOuterContextDepth;
            this._context = context;
          }
        }
        static create(state, alt, context, semanticContext = SemanticContext_1.SemanticContext.NONE, lexerActionExecutor) {
          if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
            if (lexerActionExecutor != null) {
              return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, alt, context, false);
            } else {
              return new SemanticContextATNConfig(semanticContext, state, alt, context);
            }
          } else if (lexerActionExecutor != null) {
            return new ActionATNConfig(lexerActionExecutor, state, alt, context, false);
          } else {
            return new ATNConfig2(state, alt, context);
          }
        }
        /** Gets the ATN state associated with this configuration */
        get state() {
          return this._state;
        }
        /** What alt (or lexer rule) is predicted by this configuration */
        get alt() {
          return this.altAndOuterContextDepth & 16777215;
        }
        get context() {
          return this._context;
        }
        set context(context) {
          this._context = context;
        }
        get reachesIntoOuterContext() {
          return this.outerContextDepth !== 0;
        }
        /**
         * We cannot execute predicates dependent upon local context unless
         * we know for sure we are in the correct context. Because there is
         * no way to do this efficiently, we simply cannot evaluate
         * dependent predicates unless we are in the rule that initially
         * invokes the ATN simulator.
         *
         * closure() tracks the depth of how far we dip into the outer context:
         * depth &gt; 0.  Note that it may not be totally accurate depth since I
         * don't ever decrement. TODO: make it a boolean then
         */
        get outerContextDepth() {
          return this.altAndOuterContextDepth >>> 24 & 127;
        }
        set outerContextDepth(outerContextDepth) {
          assert2(outerContextDepth >= 0);
          outerContextDepth = Math.min(outerContextDepth, 127);
          this.altAndOuterContextDepth = outerContextDepth << 24 | (this.altAndOuterContextDepth & ~2130706432) >>> 0;
        }
        get lexerActionExecutor() {
          return void 0;
        }
        get semanticContext() {
          return SemanticContext_1.SemanticContext.NONE;
        }
        get hasPassedThroughNonGreedyDecision() {
          return false;
        }
        clone() {
          return this.transform(this.state, false);
        }
        transform(state, checkNonGreedy, arg2) {
          if (arg2 == null) {
            return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
          } else if (arg2 instanceof PredictionContext_1.PredictionContext) {
            return this.transformImpl(state, arg2, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
          } else if (arg2 instanceof SemanticContext_1.SemanticContext) {
            return this.transformImpl(state, this._context, arg2, checkNonGreedy, this.lexerActionExecutor);
          } else {
            return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, arg2);
          }
        }
        transformImpl(state, context, semanticContext, checkNonGreedy, lexerActionExecutor) {
          let passedThroughNonGreedy = checkNonGreedy && ATNConfig2.checkNonGreedyDecision(this, state);
          if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
            if (lexerActionExecutor != null || passedThroughNonGreedy) {
              return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, this, context, passedThroughNonGreedy);
            } else {
              return new SemanticContextATNConfig(semanticContext, state, this, context);
            }
          } else if (lexerActionExecutor != null || passedThroughNonGreedy) {
            return new ActionATNConfig(lexerActionExecutor, state, this, context, passedThroughNonGreedy);
          } else {
            return new ATNConfig2(state, this, context);
          }
        }
        static checkNonGreedyDecision(source, target) {
          return source.hasPassedThroughNonGreedyDecision || target instanceof DecisionState_1.DecisionState && target.nonGreedy;
        }
        appendContext(context, contextCache) {
          if (typeof context === "number") {
            let appendedContext = this.context.appendSingleContext(context, contextCache);
            let result = this.transform(this.state, false, appendedContext);
            return result;
          } else {
            let appendedContext = this.context.appendContext(context, contextCache);
            let result = this.transform(this.state, false, appendedContext);
            return result;
          }
        }
        /**
         * Determines if this `ATNConfig` fully contains another `ATNConfig`.
         *
         * An ATN configuration represents a position (including context) in an ATN during parsing. Since `ATNConfig` stores
         * the context as a graph, a single `ATNConfig` instance is capable of representing many ATN configurations which
         * are all in the same "location" but have different contexts. These `ATNConfig` instances are again merged when
         * they are added to an `ATNConfigSet`. This method supports `ATNConfigSet.contains` by evaluating whether a
         * particular `ATNConfig` contains all of the ATN configurations represented by another `ATNConfig`.
         *
         * An `ATNConfig` _a_ contains another `ATNConfig` _b_ if all of the following conditions are met:
         *
         * * The configurations are in the same state (`state`)
         * * The configurations predict the same alternative (`alt`)
         * * The semantic context of _a_ implies the semantic context of _b_ (this method performs a weaker equality check)
         * * Joining the prediction contexts of _a_ and _b_ results in the prediction context of _a_
         *
         * This method implements a conservative approximation of containment. As a result, when this method returns `true`
         * it is known that parsing from `subconfig` can only recognize a subset of the inputs which can be recognized
         * starting at the current `ATNConfig`. However, due to the imprecise evaluation of implication for the semantic
         * contexts, no assumptions can be made about the relationship between the configurations when this method returns
         * `false`.
         *
         * @param subconfig The sub configuration.
         * @returns `true` if this configuration contains `subconfig`; otherwise, `false`.
         */
        contains(subconfig) {
          if (this.state.stateNumber !== subconfig.state.stateNumber || this.alt !== subconfig.alt || !this.semanticContext.equals(subconfig.semanticContext)) {
            return false;
          }
          let leftWorkList = [];
          let rightWorkList = [];
          leftWorkList.push(this.context);
          rightWorkList.push(subconfig.context);
          while (true) {
            let left = leftWorkList.pop();
            let right = rightWorkList.pop();
            if (!left || !right) {
              break;
            }
            if (left === right) {
              return true;
            }
            if (left.size < right.size) {
              return false;
            }
            if (right.isEmpty) {
              return left.hasEmpty;
            } else {
              for (let i = 0; i < right.size; i++) {
                let index = left.findReturnState(right.getReturnState(i));
                if (index < 0) {
                  return false;
                }
                leftWorkList.push(left.getParent(index));
                rightWorkList.push(right.getParent(i));
              }
            }
          }
          return false;
        }
        get isPrecedenceFilterSuppressed() {
          return (this.altAndOuterContextDepth & SUPPRESS_PRECEDENCE_FILTER) !== 0;
        }
        set isPrecedenceFilterSuppressed(value) {
          if (value) {
            this.altAndOuterContextDepth |= SUPPRESS_PRECEDENCE_FILTER;
          } else {
            this.altAndOuterContextDepth &= ~SUPPRESS_PRECEDENCE_FILTER;
          }
        }
        /** An ATN configuration is equal to another if both have
         *  the same state, they predict the same alternative, and
         *  syntactic/semantic contexts are the same.
         */
        equals(o) {
          if (this === o) {
            return true;
          } else if (!(o instanceof ATNConfig2)) {
            return false;
          }
          return this.state.stateNumber === o.state.stateNumber && this.alt === o.alt && this.reachesIntoOuterContext === o.reachesIntoOuterContext && this.context.equals(o.context) && this.semanticContext.equals(o.semanticContext) && this.isPrecedenceFilterSuppressed === o.isPrecedenceFilterSuppressed && this.hasPassedThroughNonGreedyDecision === o.hasPassedThroughNonGreedyDecision && ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(this.lexerActionExecutor, o.lexerActionExecutor);
        }
        hashCode() {
          let hashCode = MurmurHash_1.MurmurHash.initialize(7);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.state.stateNumber);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.alt);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.reachesIntoOuterContext ? 1 : 0);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.context);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.semanticContext);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.hasPassedThroughNonGreedyDecision ? 1 : 0);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.lexerActionExecutor);
          hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 7);
          return hashCode;
        }
        /**
         * Returns a graphical representation of the current `ATNConfig` in Graphviz format. The graph can be stored to a
         * **.dot** file and then rendered to an image using Graphviz.
         *
         * @returns A Graphviz graph representing the current `ATNConfig`.
         *
         * @see http://www.graphviz.org/
         */
        toDotString() {
          let builder = "";
          builder += "digraph G {\n";
          builder += "rankdir=LR;\n";
          let visited = new Array2DHashMap_1.Array2DHashMap(PredictionContext_1.PredictionContext.IdentityEqualityComparator.INSTANCE);
          let workList = [];
          function getOrAddContext(context) {
            let newNumber = visited.size;
            let result = visited.putIfAbsent(context, newNumber);
            if (result != null) {
              return result;
            }
            workList.push(context);
            return newNumber;
          }
          workList.push(this.context);
          visited.put(this.context, 0);
          while (true) {
            let current = workList.pop();
            if (!current) {
              break;
            }
            for (let i = 0; i < current.size; i++) {
              builder += "  s" + getOrAddContext(current);
              builder += "->";
              builder += "s" + getOrAddContext(current.getParent(i));
              builder += '[label="' + current.getReturnState(i) + '"];\n';
            }
          }
          builder += "}\n";
          return builder.toString();
        }
        toString(recog, showAlt, showContext) {
          if (showContext == null) {
            showContext = showAlt != null;
          }
          if (showAlt == null) {
            showAlt = true;
          }
          let buf = "";
          let contexts;
          if (showContext) {
            contexts = this.context.toStrings(recog, this.state.stateNumber);
          } else {
            contexts = ["?"];
          }
          let first = true;
          for (let contextDesc of contexts) {
            if (first) {
              first = false;
            } else {
              buf += ", ";
            }
            buf += "(";
            buf += this.state;
            if (showAlt) {
              buf += ",";
              buf += this.alt;
            }
            if (this.context) {
              buf += ",";
              buf += contextDesc;
            }
            if (this.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
              buf += ",";
              buf += this.semanticContext;
            }
            if (this.reachesIntoOuterContext) {
              buf += ",up=" + this.outerContextDepth;
            }
            buf += ")";
          }
          return buf.toString();
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ATNConfig.prototype, "_state", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATNConfig.prototype, "_context", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATNConfig.prototype, "state", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], ATNConfig.prototype, "context", null);
      __decorate([
        Decorators_1.NotNull
      ], ATNConfig.prototype, "semanticContext", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfig.prototype, "clone", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ATNConfig.prototype, "transformImpl", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfig.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfig.prototype, "hashCode", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(3, Decorators_1.NotNull)
      ], ATNConfig, "create", null);
      ATNConfig = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ATNConfig);
      exports.ATNConfig = ATNConfig;
      var SemanticContextATNConfig = class SemanticContextATNConfig extends ATNConfig {
        constructor(semanticContext, state, altOrConfig, context) {
          if (typeof altOrConfig === "number") {
            super(state, altOrConfig, context);
          } else {
            super(state, altOrConfig, context);
          }
          this._semanticContext = semanticContext;
        }
        get semanticContext() {
          return this._semanticContext;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], SemanticContextATNConfig.prototype, "_semanticContext", void 0);
      __decorate([
        Decorators_1.Override
      ], SemanticContextATNConfig.prototype, "semanticContext", null);
      SemanticContextATNConfig = __decorate([
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], SemanticContextATNConfig);
      var ActionATNConfig = class ActionATNConfig extends ATNConfig {
        constructor(lexerActionExecutor, state, altOrConfig, context, passedThroughNonGreedyDecision) {
          if (typeof altOrConfig === "number") {
            super(state, altOrConfig, context);
          } else {
            super(state, altOrConfig, context);
            if (altOrConfig.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
              throw new Error("Not supported");
            }
          }
          this._lexerActionExecutor = lexerActionExecutor;
          this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
        }
        get lexerActionExecutor() {
          return this._lexerActionExecutor;
        }
        get hasPassedThroughNonGreedyDecision() {
          return this.passedThroughNonGreedyDecision;
        }
      };
      __decorate([
        Decorators_1.Override
      ], ActionATNConfig.prototype, "lexerActionExecutor", null);
      __decorate([
        Decorators_1.Override
      ], ActionATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
      ActionATNConfig = __decorate([
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ActionATNConfig);
      var ActionSemanticContextATNConfig = class ActionSemanticContextATNConfig extends SemanticContextATNConfig {
        constructor(lexerActionExecutor, semanticContext, state, altOrConfig, context, passedThroughNonGreedyDecision) {
          if (typeof altOrConfig === "number") {
            super(semanticContext, state, altOrConfig, context);
          } else {
            super(semanticContext, state, altOrConfig, context);
          }
          this._lexerActionExecutor = lexerActionExecutor;
          this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
        }
        get lexerActionExecutor() {
          return this._lexerActionExecutor;
        }
        get hasPassedThroughNonGreedyDecision() {
          return this.passedThroughNonGreedyDecision;
        }
      };
      __decorate([
        Decorators_1.Override
      ], ActionSemanticContextATNConfig.prototype, "lexerActionExecutor", null);
      __decorate([
        Decorators_1.Override
      ], ActionSemanticContextATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
      ActionSemanticContextATNConfig = __decorate([
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ActionSemanticContextATNConfig);
    }
  });

  // shims/util.js
  var require_util = __commonJS({
    "shims/util.js"(exports, module2) {
      "use strict";
      module2.exports = {
        inspect: {
          custom: "util.inspect.custom"
        }
      };
    }
  });

  // node_modules/antlr4ts/misc/BitSet.js
  var require_BitSet = __commonJS({
    "node_modules/antlr4ts/misc/BitSet.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BitSet = void 0;
      var util = require_util();
      var MurmurHash_1 = require_MurmurHash();
      var EMPTY_DATA = new Uint16Array(0);
      function getIndex2(bitNumber) {
        return bitNumber >>> 4;
      }
      function unIndex(n) {
        return n * 16;
      }
      function findLSBSet(word) {
        let bit = 1;
        for (let i = 0; i < 16; i++) {
          if ((word & bit) !== 0) {
            return i;
          }
          bit = bit << 1 >>> 0;
        }
        throw new RangeError("No specified bit found");
      }
      function findMSBSet(word) {
        let bit = 1 << 15 >>> 0;
        for (let i = 15; i >= 0; i--) {
          if ((word & bit) !== 0) {
            return i;
          }
          bit = bit >>> 1;
        }
        throw new RangeError("No specified bit found");
      }
      function bitsFor(fromBit, toBit) {
        fromBit &= 15;
        toBit &= 15;
        if (fromBit === toBit) {
          return 1 << fromBit >>> 0;
        }
        return 65535 >>> 15 - toBit ^ 65535 >>> 16 - fromBit;
      }
      var POP_CNT = new Uint8Array(65536);
      for (let i = 0; i < 16; i++) {
        const stride = 1 << i >>> 0;
        let index = 0;
        while (index < POP_CNT.length) {
          index += stride;
          for (let j = 0; j < stride; j++) {
            POP_CNT[index]++;
            index++;
          }
        }
      }
      var BitSet = class _BitSet {
        /*
        ** constructor implementation
        */
        constructor(arg) {
          if (!arg) {
            this.data = EMPTY_DATA;
          } else if (typeof arg === "number") {
            if (arg < 0) {
              throw new RangeError("nbits cannot be negative");
            } else {
              this.data = new Uint16Array(getIndex2(arg - 1) + 1);
            }
          } else {
            if (arg instanceof _BitSet) {
              this.data = arg.data.slice(0);
            } else {
              let max = -1;
              for (let v of arg) {
                if (max < v) {
                  max = v;
                }
              }
              this.data = new Uint16Array(getIndex2(max - 1) + 1);
              for (let v of arg) {
                this.set(v);
              }
            }
          }
        }
        /**
         * Performs a logical **AND** of this target bit set with the argument bit set. This bit set is modified so that
         * each bit in it has the value `true` if and only if it both initially had the value `true` and the corresponding
         * bit in the bit set argument also had the value `true`.
         */
        and(set2) {
          const data = this.data;
          const other = set2.data;
          const words = Math.min(data.length, other.length);
          let lastWord = -1;
          for (let i = 0; i < words; i++) {
            let value = data[i] &= other[i];
            if (value !== 0) {
              lastWord = i;
            }
          }
          if (lastWord === -1) {
            this.data = EMPTY_DATA;
          }
          if (lastWord < data.length - 1) {
            this.data = data.slice(0, lastWord + 1);
          }
        }
        /**
         * Clears all of the bits in this `BitSet` whose corresponding bit is set in the specified `BitSet`.
         */
        andNot(set2) {
          const data = this.data;
          const other = set2.data;
          const words = Math.min(data.length, other.length);
          let lastWord = -1;
          for (let i = 0; i < words; i++) {
            let value = data[i] &= other[i] ^ 65535;
            if (value !== 0) {
              lastWord = i;
            }
          }
          if (lastWord === -1) {
            this.data = EMPTY_DATA;
          }
          if (lastWord < data.length - 1) {
            this.data = data.slice(0, lastWord + 1);
          }
        }
        /**
         * Returns the number of bits set to `true` in this `BitSet`.
         */
        cardinality() {
          if (this.isEmpty) {
            return 0;
          }
          const data = this.data;
          const length = data.length;
          let result = 0;
          for (let i = 0; i < length; i++) {
            result += POP_CNT[data[i]];
          }
          return result;
        }
        clear(fromIndex, toIndex) {
          if (fromIndex == null) {
            this.data.fill(0);
          } else if (toIndex == null) {
            this.set(fromIndex, false);
          } else {
            this.set(fromIndex, toIndex, false);
          }
        }
        flip(fromIndex, toIndex) {
          if (toIndex == null) {
            toIndex = fromIndex;
          }
          if (fromIndex < 0 || toIndex < fromIndex) {
            throw new RangeError();
          }
          let word = getIndex2(fromIndex);
          const lastWord = getIndex2(toIndex);
          if (word === lastWord) {
            this.data[word] ^= bitsFor(fromIndex, toIndex);
          } else {
            this.data[word++] ^= bitsFor(fromIndex, 15);
            while (word < lastWord) {
              this.data[word++] ^= 65535;
            }
            this.data[word++] ^= bitsFor(0, toIndex);
          }
        }
        get(fromIndex, toIndex) {
          if (toIndex === void 0) {
            return !!(this.data[getIndex2(fromIndex)] & bitsFor(fromIndex, fromIndex));
          } else {
            let result = new _BitSet(toIndex + 1);
            for (let i = fromIndex; i <= toIndex; i++) {
              result.set(i, this.get(i));
            }
            return result;
          }
        }
        /**
         * Returns true if the specified `BitSet` has any bits set to `true` that are also set to `true` in this `BitSet`.
         *
         * @param set `BitSet` to intersect with
         */
        intersects(set2) {
          let smallerLength = Math.min(this.length(), set2.length());
          if (smallerLength === 0) {
            return false;
          }
          let bound = getIndex2(smallerLength - 1);
          for (let i = 0; i <= bound; i++) {
            if ((this.data[i] & set2.data[i]) !== 0) {
              return true;
            }
          }
          return false;
        }
        /**
         * Returns true if this `BitSet` contains no bits that are set to `true`.
         */
        get isEmpty() {
          return this.length() === 0;
        }
        /**
         * Returns the "logical size" of this `BitSet`: the index of the highest set bit in the `BitSet` plus one. Returns
         * zero if the `BitSet` contains no set bits.
         */
        length() {
          if (!this.data.length) {
            return 0;
          }
          return this.previousSetBit(unIndex(this.data.length) - 1) + 1;
        }
        /**
         * Returns the index of the first bit that is set to `false` that occurs on or after the specified starting index,
         * If no such bit exists then `-1` is returned.
         *
         * @param fromIndex the index to start checking from (inclusive)
         *
         * @throws RangeError if the specified index is negative
         */
        nextClearBit(fromIndex) {
          if (fromIndex < 0) {
            throw new RangeError("fromIndex cannot be negative");
          }
          const data = this.data;
          const length = data.length;
          let word = getIndex2(fromIndex);
          if (word > length) {
            return -1;
          }
          let ignore2 = 65535 ^ bitsFor(fromIndex, 15);
          if ((data[word] | ignore2) === 65535) {
            word++;
            ignore2 = 0;
            for (; word < length; word++) {
              if (data[word] !== 65535) {
                break;
              }
            }
            if (word === length) {
              return -1;
            }
          }
          return unIndex(word) + findLSBSet((data[word] | ignore2) ^ 65535);
        }
        /**
         * Returns the index of the first bit that is set to `true` that occurs on or after the specified starting index.
         * If no such bit exists then `-1` is returned.
         *
         * To iterate over the `true` bits in a `BitSet`, use the following loop:
         *
         * ```
         * for (let i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {
         *   // operate on index i here
         * }
         * ```
         *
         * @param fromIndex the index to start checking from (inclusive)
         *
         * @throws RangeError if the specified index is negative
         */
        nextSetBit(fromIndex) {
          if (fromIndex < 0) {
            throw new RangeError("fromIndex cannot be negative");
          }
          const data = this.data;
          const length = data.length;
          let word = getIndex2(fromIndex);
          if (word > length) {
            return -1;
          }
          let mask = bitsFor(fromIndex, 15);
          if ((data[word] & mask) === 0) {
            word++;
            mask = 65535;
            for (; word < length; word++) {
              if (data[word] !== 0) {
                break;
              }
            }
            if (word >= length) {
              return -1;
            }
          }
          return unIndex(word) + findLSBSet(data[word] & mask);
        }
        /**
         * Performs a logical **OR** of this bit set with the bit set argument. This bit set is modified so that a bit in it
         * has the value `true` if and only if it either already had the value `true` or the corresponding bit in the bit
         * set argument has the value `true`.
         */
        or(set2) {
          const data = this.data;
          const other = set2.data;
          const minWords = Math.min(data.length, other.length);
          const words = Math.max(data.length, other.length);
          const dest = data.length === words ? data : new Uint16Array(words);
          let lastWord = -1;
          for (let i = 0; i < minWords; i++) {
            let value = dest[i] = data[i] | other[i];
            if (value !== 0) {
              lastWord = i;
            }
          }
          const longer = data.length > other.length ? data : other;
          for (let i = minWords; i < words; i++) {
            let value = dest[i] = longer[i];
            if (value !== 0) {
              lastWord = i;
            }
          }
          if (lastWord === -1) {
            this.data = EMPTY_DATA;
          } else if (dest.length === lastWord + 1) {
            this.data = dest;
          } else {
            this.data = dest.slice(0, lastWord);
          }
        }
        /**
         * Returns the index of the nearest bit that is set to `false` that occurs on or before the specified starting
         * index. If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.
         *
         * @param fromIndex the index to start checking from (inclusive)
         *
         * @throws RangeError if the specified index is less than `-1`
         */
        previousClearBit(fromIndex) {
          if (fromIndex < 0) {
            throw new RangeError("fromIndex cannot be negative");
          }
          const data = this.data;
          const length = data.length;
          let word = getIndex2(fromIndex);
          if (word >= length) {
            word = length - 1;
          }
          let ignore2 = 65535 ^ bitsFor(0, fromIndex);
          if ((data[word] | ignore2) === 65535) {
            ignore2 = 0;
            word--;
            for (; word >= 0; word--) {
              if (data[word] !== 65535) {
                break;
              }
            }
            if (word < 0) {
              return -1;
            }
          }
          return unIndex(word) + findMSBSet((data[word] | ignore2) ^ 65535);
        }
        /**
         * Returns the index of the nearest bit that is set to `true` that occurs on or before the specified starting index.
         * If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.
         *
         * To iterate over the `true` bits in a `BitSet`, use the following loop:
         *
         * ```
         * for (let i = bs.length(); (i = bs.previousSetBit(i-1)) >= 0; ) {
         *   // operate on index i here
         * }
         * ```
         *
         * @param fromIndex the index to start checking from (inclusive)
         *
         * @throws RangeError if the specified index is less than `-1`
         */
        previousSetBit(fromIndex) {
          if (fromIndex < 0) {
            throw new RangeError("fromIndex cannot be negative");
          }
          const data = this.data;
          const length = data.length;
          let word = getIndex2(fromIndex);
          if (word >= length) {
            word = length - 1;
          }
          let mask = bitsFor(0, fromIndex);
          if ((data[word] & mask) === 0) {
            word--;
            mask = 65535;
            for (; word >= 0; word--) {
              if (data[word] !== 0) {
                break;
              }
            }
            if (word < 0) {
              return -1;
            }
          }
          return unIndex(word) + findMSBSet(data[word] & mask);
        }
        set(fromIndex, toIndex, value) {
          if (toIndex === void 0) {
            toIndex = fromIndex;
            value = true;
          } else if (typeof toIndex === "boolean") {
            value = toIndex;
            toIndex = fromIndex;
          }
          if (value === void 0) {
            value = true;
          }
          if (fromIndex < 0 || fromIndex > toIndex) {
            throw new RangeError();
          }
          let word = getIndex2(fromIndex);
          let lastWord = getIndex2(toIndex);
          if (value && lastWord >= this.data.length) {
            let temp = new Uint16Array(lastWord + 1);
            this.data.forEach((value2, index) => temp[index] = value2);
            this.data = temp;
          } else if (!value) {
            if (word >= this.data.length) {
              return;
            }
            if (lastWord >= this.data.length) {
              lastWord = this.data.length - 1;
              toIndex = this.data.length * 16 - 1;
            }
          }
          if (word === lastWord) {
            this._setBits(word, value, bitsFor(fromIndex, toIndex));
          } else {
            this._setBits(word++, value, bitsFor(fromIndex, 15));
            while (word < lastWord) {
              this.data[word++] = value ? 65535 : 0;
            }
            this._setBits(word, value, bitsFor(0, toIndex));
          }
        }
        _setBits(word, value, mask) {
          if (value) {
            this.data[word] |= mask;
          } else {
            this.data[word] &= 65535 ^ mask;
          }
        }
        /**
         * Returns the number of bits of space actually in use by this `BitSet` to represent bit values. The maximum element
         * in the set is the size - 1st element.
         */
        get size() {
          return this.data.byteLength * 8;
        }
        /**
         * Returns a new byte array containing all the bits in this bit set.
         *
         * More precisely, if
         * `let bytes = s.toByteArray();`
         * then `bytes.length === (s.length()+7)/8` and `s.get(n) === ((bytes[n/8] & (1<<(n%8))) != 0)` for all
         * `n < 8 * bytes.length`.
         */
        // toByteArray(): Int8Array {
        // 	throw new Error("NOT IMPLEMENTED");
        // }
        /**
         * Returns a new integer array containing all the bits in this bit set.
         *
         * More precisely, if
         * `let integers = s.toIntegerArray();`
         * then `integers.length === (s.length()+31)/32` and `s.get(n) === ((integers[n/32] & (1<<(n%32))) != 0)` for all
         * `n < 32 * integers.length`.
         */
        // toIntegerArray(): Int32Array {
        // 	throw new Error("NOT IMPLEMENTED");
        // }
        hashCode() {
          return MurmurHash_1.MurmurHash.hashCode(this.data, 22);
        }
        /**
         * Compares this object against the specified object. The result is `true` if and only if the argument is not
         * `undefined` and is a `Bitset` object that has exactly the same set of bits set to `true` as this bit set. That
         * is, for every nonnegative index `k`,
         *
         * ```
         * ((BitSet)obj).get(k) == this.get(k)
         * ```
         *
         * must be true. The current sizes of the two bit sets are not compared.
         */
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof _BitSet)) {
            return false;
          }
          const len = this.length();
          if (len !== obj.length()) {
            return false;
          }
          if (len === 0) {
            return true;
          }
          let bound = getIndex2(len - 1);
          for (let i = 0; i <= bound; i++) {
            if (this.data[i] !== obj.data[i]) {
              return false;
            }
          }
          return true;
        }
        /**
         * Returns a string representation of this bit set. For every index for which this `BitSet` contains a bit in the
         * set state, the decimal representation of that index is included in the result. Such indices are listed in order
         * from lowest to highest, separated by ", " (a comma and a space) and surrounded by braces, resulting in the usual
         * mathematical notation for a set of integers.
         *
         * Example:
         *
         *     BitSet drPepper = new BitSet();
         *
         * Now `drPepper.toString()` returns `"{}"`.
         *
         *     drPepper.set(2);
         *
         * Now `drPepper.toString()` returns `"{2}"`.
         *
         *     drPepper.set(4);
         *     drPepper.set(10);
         *
         * Now `drPepper.toString()` returns `"{2, 4, 10}"`.
         */
        toString() {
          let result = "{";
          let first = true;
          for (let i = this.nextSetBit(0); i >= 0; i = this.nextSetBit(i + 1)) {
            if (first) {
              first = false;
            } else {
              result += ", ";
            }
            result += i;
          }
          result += "}";
          return result;
        }
        // static valueOf(bytes: Int8Array): BitSet;
        // static valueOf(buffer: ArrayBuffer): BitSet;
        // static valueOf(integers: Int32Array): BitSet;
        // static valueOf(data: Int8Array | Int32Array | ArrayBuffer): BitSet {
        // 	throw new Error("NOT IMPLEMENTED");
        // }
        /**
         * Performs a logical **XOR** of this bit set with the bit set argument. This bit set is modified so that a bit in
         * it has the value `true` if and only if one of the following statements holds:
         *
         * * The bit initially has the value `true`, and the corresponding bit in the argument has the value `false`.
         * * The bit initially has the value `false`, and the corresponding bit in the argument has the value `true`.
         */
        xor(set2) {
          const data = this.data;
          const other = set2.data;
          const minWords = Math.min(data.length, other.length);
          const words = Math.max(data.length, other.length);
          const dest = data.length === words ? data : new Uint16Array(words);
          let lastWord = -1;
          for (let i = 0; i < minWords; i++) {
            let value = dest[i] = data[i] ^ other[i];
            if (value !== 0) {
              lastWord = i;
            }
          }
          const longer = data.length > other.length ? data : other;
          for (let i = minWords; i < words; i++) {
            let value = dest[i] = longer[i];
            if (value !== 0) {
              lastWord = i;
            }
          }
          if (lastWord === -1) {
            this.data = EMPTY_DATA;
          } else if (dest.length === lastWord + 1) {
            this.data = dest;
          } else {
            this.data = dest.slice(0, lastWord + 1);
          }
        }
        clone() {
          return new _BitSet(this);
        }
        [Symbol.iterator]() {
          return new BitSetIterator(this.data);
        }
        // Overrides formatting for nodejs assert etc.
        [util.inspect.custom]() {
          return "BitSet " + this.toString();
        }
      };
      exports.BitSet = BitSet;
      var BitSetIterator = class {
        constructor(data) {
          this.data = data;
          this.index = 0;
          this.mask = 65535;
        }
        next() {
          while (this.index < this.data.length) {
            const bits = this.data[this.index] & this.mask;
            if (bits !== 0) {
              const bitNumber = unIndex(this.index) + findLSBSet(bits);
              this.mask = bitsFor(bitNumber + 1, 15);
              return { done: false, value: bitNumber };
            }
            this.index++;
            this.mask = 65535;
          }
          return { done: true, value: -1 };
        }
        [Symbol.iterator]() {
          return this;
        }
      };
    }
  });

  // node_modules/antlr4ts/atn/ATNConfigSet.js
  var require_ATNConfigSet = __commonJS({
    "node_modules/antlr4ts/atn/ATNConfigSet.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATNConfigSet = void 0;
      var Array2DHashMap_1 = require_Array2DHashMap();
      var Array2DHashSet_1 = require_Array2DHashSet();
      var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
      var ATN_1 = require_ATN();
      var ATNConfig_1 = require_ATNConfig();
      var BitSet_1 = require_BitSet();
      var Decorators_1 = require_Decorators();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var PredictionContext_1 = require_PredictionContext();
      var PredictionContextCache_1 = require_PredictionContextCache();
      var SemanticContext_1 = require_SemanticContext();
      var assert2 = require_assert();
      var Utils3 = require_Utils();
      var KeyTypeEqualityComparer = class {
        hashCode(key) {
          return key.state ^ key.alt;
        }
        equals(a, b) {
          return a.state === b.state && a.alt === b.alt;
        }
      };
      KeyTypeEqualityComparer.INSTANCE = new KeyTypeEqualityComparer();
      function NewKeyedConfigMap(map2) {
        if (map2) {
          return new Array2DHashMap_1.Array2DHashMap(map2);
        } else {
          return new Array2DHashMap_1.Array2DHashMap(KeyTypeEqualityComparer.INSTANCE);
        }
      }
      var ATNConfigSet = class _ATNConfigSet {
        constructor(set2, readonly2) {
          this._uniqueAlt = 0;
          this._hasSemanticContext = false;
          this._dipsIntoOuterContext = false;
          this.outermostConfigSet = false;
          this.cachedHashCode = -1;
          if (!set2) {
            this.mergedConfigs = NewKeyedConfigMap();
            this.unmerged = [];
            this.configs = [];
            this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
          } else {
            if (readonly2) {
              this.mergedConfigs = void 0;
              this.unmerged = void 0;
            } else if (!set2.isReadOnly) {
              this.mergedConfigs = NewKeyedConfigMap(set2.mergedConfigs);
              this.unmerged = set2.unmerged.slice(0);
            } else {
              this.mergedConfigs = NewKeyedConfigMap();
              this.unmerged = [];
            }
            this.configs = set2.configs.slice(0);
            this._dipsIntoOuterContext = set2._dipsIntoOuterContext;
            this._hasSemanticContext = set2._hasSemanticContext;
            this.outermostConfigSet = set2.outermostConfigSet;
            if (readonly2 || !set2.isReadOnly) {
              this._uniqueAlt = set2._uniqueAlt;
              this._conflictInfo = set2._conflictInfo;
            }
          }
        }
        /**
         * Get the set of all alternatives represented by configurations in this
         * set.
         */
        getRepresentedAlternatives() {
          if (this._conflictInfo != null) {
            return this._conflictInfo.conflictedAlts.clone();
          }
          let alts = new BitSet_1.BitSet();
          for (let config2 of this) {
            alts.set(config2.alt);
          }
          return alts;
        }
        get isReadOnly() {
          return this.mergedConfigs == null;
        }
        get isOutermostConfigSet() {
          return this.outermostConfigSet;
        }
        set isOutermostConfigSet(outermostConfigSet) {
          if (this.outermostConfigSet && !outermostConfigSet) {
            throw new Error("IllegalStateException");
          }
          assert2(!outermostConfigSet || !this._dipsIntoOuterContext);
          this.outermostConfigSet = outermostConfigSet;
        }
        getStates() {
          let states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          for (let c of this.configs) {
            states.add(c.state);
          }
          return states;
        }
        optimizeConfigs(interpreter) {
          if (this.configs.length === 0) {
            return;
          }
          for (let config2 of this.configs) {
            config2.context = interpreter.atn.getCachedContext(config2.context);
          }
        }
        clone(readonly2) {
          let copy = new _ATNConfigSet(this, readonly2);
          if (!readonly2 && this.isReadOnly) {
            copy.addAll(this.configs);
          }
          return copy;
        }
        get size() {
          return this.configs.length;
        }
        get isEmpty() {
          return this.configs.length === 0;
        }
        contains(o) {
          if (!(o instanceof ATNConfig_1.ATNConfig)) {
            return false;
          }
          if (this.mergedConfigs && this.unmerged) {
            let config2 = o;
            let configKey = this.getKey(config2);
            let mergedConfig = this.mergedConfigs.get(configKey);
            if (mergedConfig != null && this.canMerge(config2, configKey, mergedConfig)) {
              return mergedConfig.contains(config2);
            }
            for (let c of this.unmerged) {
              if (c.contains(o)) {
                return true;
              }
            }
          } else {
            for (let c of this.configs) {
              if (c.contains(o)) {
                return true;
              }
            }
          }
          return false;
        }
        *[Symbol.iterator]() {
          yield* this.configs;
        }
        toArray() {
          return this.configs;
        }
        add(e, contextCache) {
          this.ensureWritable();
          if (!this.mergedConfigs || !this.unmerged) {
            throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
          }
          assert2(!this.outermostConfigSet || !e.reachesIntoOuterContext);
          if (contextCache == null) {
            contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
          }
          let addKey;
          let key = this.getKey(e);
          let mergedConfig = this.mergedConfigs.get(key);
          addKey = mergedConfig == null;
          if (mergedConfig != null && this.canMerge(e, key, mergedConfig)) {
            mergedConfig.outerContextDepth = Math.max(mergedConfig.outerContextDepth, e.outerContextDepth);
            if (e.isPrecedenceFilterSuppressed) {
              mergedConfig.isPrecedenceFilterSuppressed = true;
            }
            let joined = PredictionContext_1.PredictionContext.join(mergedConfig.context, e.context, contextCache);
            this.updatePropertiesForMergedConfig(e);
            if (mergedConfig.context === joined) {
              return false;
            }
            mergedConfig.context = joined;
            return true;
          }
          for (let i = 0; i < this.unmerged.length; i++) {
            let unmergedConfig = this.unmerged[i];
            if (this.canMerge(e, key, unmergedConfig)) {
              unmergedConfig.outerContextDepth = Math.max(unmergedConfig.outerContextDepth, e.outerContextDepth);
              if (e.isPrecedenceFilterSuppressed) {
                unmergedConfig.isPrecedenceFilterSuppressed = true;
              }
              let joined = PredictionContext_1.PredictionContext.join(unmergedConfig.context, e.context, contextCache);
              this.updatePropertiesForMergedConfig(e);
              if (unmergedConfig.context === joined) {
                return false;
              }
              unmergedConfig.context = joined;
              if (addKey) {
                this.mergedConfigs.put(key, unmergedConfig);
                this.unmerged.splice(i, 1);
              }
              return true;
            }
          }
          this.configs.push(e);
          if (addKey) {
            this.mergedConfigs.put(key, e);
          } else {
            this.unmerged.push(e);
          }
          this.updatePropertiesForAddedConfig(e);
          return true;
        }
        updatePropertiesForMergedConfig(config2) {
          this._dipsIntoOuterContext = this._dipsIntoOuterContext || config2.reachesIntoOuterContext;
          assert2(!this.outermostConfigSet || !this._dipsIntoOuterContext);
        }
        updatePropertiesForAddedConfig(config2) {
          if (this.configs.length === 1) {
            this._uniqueAlt = config2.alt;
          } else if (this._uniqueAlt !== config2.alt) {
            this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
          }
          this._hasSemanticContext = this._hasSemanticContext || !SemanticContext_1.SemanticContext.NONE.equals(config2.semanticContext);
          this._dipsIntoOuterContext = this._dipsIntoOuterContext || config2.reachesIntoOuterContext;
          assert2(!this.outermostConfigSet || !this._dipsIntoOuterContext);
        }
        canMerge(left, leftKey, right) {
          if (left.state.stateNumber !== right.state.stateNumber) {
            return false;
          }
          if (leftKey.alt !== right.alt) {
            return false;
          }
          return left.semanticContext.equals(right.semanticContext);
        }
        getKey(e) {
          return { state: e.state.stateNumber, alt: e.alt };
        }
        containsAll(c) {
          for (let o of c) {
            if (!(o instanceof ATNConfig_1.ATNConfig)) {
              return false;
            }
            if (!this.contains(o)) {
              return false;
            }
          }
          return true;
        }
        addAll(c, contextCache) {
          this.ensureWritable();
          let changed = false;
          for (let group of c) {
            if (this.add(group, contextCache)) {
              changed = true;
            }
          }
          return changed;
        }
        clear() {
          this.ensureWritable();
          if (!this.mergedConfigs || !this.unmerged) {
            throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
          }
          this.mergedConfigs.clear();
          this.unmerged.length = 0;
          this.configs.length = 0;
          this._dipsIntoOuterContext = false;
          this._hasSemanticContext = false;
          this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
          this._conflictInfo = void 0;
        }
        equals(obj) {
          if (this === obj) {
            return true;
          }
          if (!(obj instanceof _ATNConfigSet)) {
            return false;
          }
          return this.outermostConfigSet === obj.outermostConfigSet && Utils3.equals(this._conflictInfo, obj._conflictInfo) && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.configs, obj.configs);
        }
        hashCode() {
          if (this.isReadOnly && this.cachedHashCode !== -1) {
            return this.cachedHashCode;
          }
          let hashCode = 1;
          hashCode = 5 * hashCode ^ (this.outermostConfigSet ? 1 : 0);
          hashCode = 5 * hashCode ^ ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.hashCode(this.configs);
          if (this.isReadOnly) {
            this.cachedHashCode = hashCode;
          }
          return hashCode;
        }
        toString(showContext) {
          if (showContext == null) {
            showContext = false;
          }
          let buf = "";
          let sortedConfigs = this.configs.slice(0);
          sortedConfigs.sort((o1, o2) => {
            if (o1.alt !== o2.alt) {
              return o1.alt - o2.alt;
            } else if (o1.state.stateNumber !== o2.state.stateNumber) {
              return o1.state.stateNumber - o2.state.stateNumber;
            } else {
              return o1.semanticContext.toString().localeCompare(o2.semanticContext.toString());
            }
          });
          buf += "[";
          for (let i = 0; i < sortedConfigs.length; i++) {
            if (i > 0) {
              buf += ", ";
            }
            buf += sortedConfigs[i].toString(void 0, true, showContext);
          }
          buf += "]";
          if (this._hasSemanticContext) {
            buf += ",hasSemanticContext=" + this._hasSemanticContext;
          }
          if (this._uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            buf += ",uniqueAlt=" + this._uniqueAlt;
          }
          if (this._conflictInfo != null) {
            buf += ",conflictingAlts=" + this._conflictInfo.conflictedAlts;
            if (!this._conflictInfo.isExact) {
              buf += "*";
            }
          }
          if (this._dipsIntoOuterContext) {
            buf += ",dipsIntoOuterContext";
          }
          return buf.toString();
        }
        get uniqueAlt() {
          return this._uniqueAlt;
        }
        get hasSemanticContext() {
          return this._hasSemanticContext;
        }
        set hasSemanticContext(value) {
          this.ensureWritable();
          this._hasSemanticContext = value;
        }
        get conflictInfo() {
          return this._conflictInfo;
        }
        set conflictInfo(conflictInfo) {
          this.ensureWritable();
          this._conflictInfo = conflictInfo;
        }
        get conflictingAlts() {
          if (this._conflictInfo == null) {
            return void 0;
          }
          return this._conflictInfo.conflictedAlts;
        }
        get isExactConflict() {
          if (this._conflictInfo == null) {
            return false;
          }
          return this._conflictInfo.isExact;
        }
        get dipsIntoOuterContext() {
          return this._dipsIntoOuterContext;
        }
        get(index) {
          return this.configs[index];
        }
        ensureWritable() {
          if (this.isReadOnly) {
            throw new Error("This ATNConfigSet is read only.");
          }
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ATNConfigSet.prototype, "getRepresentedAlternatives", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, "isEmpty", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, "contains", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, Symbol.iterator, null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, "toArray", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, "containsAll", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, "clear", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], ATNConfigSet.prototype, "hashCode", null);
      exports.ATNConfigSet = ATNConfigSet;
    }
  });

  // node_modules/antlr4ts/dfa/DFAState.js
  var require_DFAState = __commonJS({
    "node_modules/antlr4ts/dfa/DFAState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DFAState = void 0;
      var ATN_1 = require_ATN();
      var BitSet_1 = require_BitSet();
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var PredictionContext_1 = require_PredictionContext();
      var assert2 = require_assert();
      var DFAState = class _DFAState {
        /**
         * Constructs a new `DFAState`.
         *
         * @param configs The set of ATN configurations defining this state.
         */
        constructor(configs) {
          this.stateNumber = -1;
          this.configs = configs;
          this.edges = /* @__PURE__ */ new Map();
          this.contextEdges = /* @__PURE__ */ new Map();
        }
        get isContextSensitive() {
          return !!this.contextSymbols;
        }
        isContextSymbol(symbol2) {
          if (!this.isContextSensitive) {
            return false;
          }
          return this.contextSymbols.get(symbol2);
        }
        setContextSymbol(symbol2) {
          assert2(this.isContextSensitive);
          this.contextSymbols.set(symbol2);
        }
        setContextSensitive(atn) {
          assert2(!this.configs.isOutermostConfigSet);
          if (this.isContextSensitive) {
            return;
          }
          if (!this.contextSymbols) {
            this.contextSymbols = new BitSet_1.BitSet();
          }
        }
        get acceptStateInfo() {
          return this._acceptStateInfo;
        }
        set acceptStateInfo(acceptStateInfo) {
          this._acceptStateInfo = acceptStateInfo;
        }
        get isAcceptState() {
          return !!this._acceptStateInfo;
        }
        get prediction() {
          if (!this._acceptStateInfo) {
            return ATN_1.ATN.INVALID_ALT_NUMBER;
          }
          return this._acceptStateInfo.prediction;
        }
        get lexerActionExecutor() {
          if (!this._acceptStateInfo) {
            return void 0;
          }
          return this._acceptStateInfo.lexerActionExecutor;
        }
        getTarget(symbol2) {
          return this.edges.get(symbol2);
        }
        setTarget(symbol2, target) {
          this.edges.set(symbol2, target);
        }
        getEdgeMap() {
          return this.edges;
        }
        getContextTarget(invokingState) {
          if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            invokingState = -1;
          }
          return this.contextEdges.get(invokingState);
        }
        setContextTarget(invokingState, target) {
          if (!this.isContextSensitive) {
            throw new Error("The state is not context sensitive.");
          }
          if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            invokingState = -1;
          }
          this.contextEdges.set(invokingState, target);
        }
        getContextEdgeMap() {
          let map2 = new Map(this.contextEdges);
          let existing = map2.get(-1);
          if (existing !== void 0) {
            if (map2.size === 1) {
              let result = /* @__PURE__ */ new Map();
              result.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
              return result;
            } else {
              map2.delete(-1);
              map2.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
            }
          }
          return map2;
        }
        hashCode() {
          let hash2 = MurmurHash_1.MurmurHash.initialize(7);
          hash2 = MurmurHash_1.MurmurHash.update(hash2, this.configs.hashCode());
          hash2 = MurmurHash_1.MurmurHash.finish(hash2, 1);
          return hash2;
        }
        /**
         * Two {@link DFAState} instances are equal if their ATN configuration sets
         * are the same. This method is used to see if a state already exists.
         *
         * Because the number of alternatives and number of ATN configurations are
         * finite, there is a finite number of DFA states that can be processed.
         * This is necessary to show that the algorithm terminates.
         *
         * Cannot test the DFA state numbers here because in
         * {@link ParserATNSimulator#addDFAState} we need to know if any other state
         * exists that has this exact set of ATN configurations. The
         * {@link #stateNumber} is irrelevant.
         */
        equals(o) {
          if (this === o) {
            return true;
          }
          if (!(o instanceof _DFAState)) {
            return false;
          }
          let other = o;
          let sameSet = this.configs.equals(other.configs);
          return sameSet;
        }
        toString() {
          let buf = "";
          buf += this.stateNumber + ":" + this.configs;
          if (this.isAcceptState) {
            buf += "=>";
            if (this.predicates) {
              buf += this.predicates;
            } else {
              buf += this.prediction;
            }
          }
          return buf.toString();
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], DFAState.prototype, "configs", void 0);
      __decorate([
        Decorators_1.NotNull
      ], DFAState.prototype, "edges", void 0);
      __decorate([
        Decorators_1.NotNull
      ], DFAState.prototype, "contextEdges", void 0);
      __decorate([
        Decorators_1.Override
      ], DFAState.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], DFAState.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], DFAState.prototype, "toString", null);
      exports.DFAState = DFAState;
      (function(DFAState2) {
        let PredPrediction = class PredPrediction {
          constructor(pred, alt) {
            this.alt = alt;
            this.pred = pred;
          }
          toString() {
            return "(" + this.pred + ", " + this.alt + ")";
          }
        };
        __decorate([
          Decorators_1.NotNull
        ], PredPrediction.prototype, "pred", void 0);
        __decorate([
          Decorators_1.Override
        ], PredPrediction.prototype, "toString", null);
        PredPrediction = __decorate([
          __param(0, Decorators_1.NotNull)
        ], PredPrediction);
        DFAState2.PredPrediction = PredPrediction;
      })(DFAState = exports.DFAState || (exports.DFAState = {}));
    }
  });

  // node_modules/antlr4ts/atn/ATNSimulator.js
  var require_ATNSimulator = __commonJS({
    "node_modules/antlr4ts/atn/ATNSimulator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATNSimulator = void 0;
      var ATNConfigSet_1 = require_ATNConfigSet();
      var DFAState_1 = require_DFAState();
      var Decorators_1 = require_Decorators();
      var PredictionContext_1 = require_PredictionContext();
      var ATNSimulator = class ATNSimulator2 {
        constructor(atn) {
          this.atn = atn;
        }
        static get ERROR() {
          if (!ATNSimulator2._ERROR) {
            ATNSimulator2._ERROR = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
            ATNSimulator2._ERROR.stateNumber = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
          }
          return ATNSimulator2._ERROR;
        }
        /**
         * Clear the DFA cache used by the current instance. Since the DFA cache may
         * be shared by multiple ATN simulators, this method may affect the
         * performance (but not accuracy) of other parsers which are being used
         * concurrently.
         *
         * @ if the current instance does not
         * support clearing the DFA.
         *
         * @since 4.3
         */
        clearDFA() {
          this.atn.clearDFA();
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ATNSimulator.prototype, "atn", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATNSimulator, "ERROR", null);
      ATNSimulator = __decorate([
        __param(0, Decorators_1.NotNull)
      ], ATNSimulator);
      exports.ATNSimulator = ATNSimulator;
      /* @__PURE__ */ (function(ATNSimulator2) {
        const RULE_VARIANT_DELIMITER = "$";
        const RULE_LF_VARIANT_MARKER = "$lf$";
        const RULE_NOLF_VARIANT_MARKER = "$nolf$";
      })(ATNSimulator = exports.ATNSimulator || (exports.ATNSimulator = {}));
      exports.ATNSimulator = ATNSimulator;
    }
  });

  // node_modules/antlr4ts/ConsoleErrorListener.js
  var require_ConsoleErrorListener = __commonJS({
    "node_modules/antlr4ts/ConsoleErrorListener.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConsoleErrorListener = void 0;
      var ConsoleErrorListener = class {
        /**
         * {@inheritDoc}
         *
         * This implementation prints messages to {@link System#err} containing the
         * values of `line`, `charPositionInLine`, and `msg` using
         * the following format.
         *
         * <pre>
         * line *line*:*charPositionInLine* *msg*
         * </pre>
         */
        syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
          console.error(`line ${line}:${charPositionInLine} ${msg}`);
        }
      };
      exports.ConsoleErrorListener = ConsoleErrorListener;
      ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();
    }
  });

  // node_modules/antlr4ts/ProxyErrorListener.js
  var require_ProxyErrorListener = __commonJS({
    "node_modules/antlr4ts/ProxyErrorListener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProxyErrorListener = void 0;
      var Decorators_1 = require_Decorators();
      var ProxyErrorListener = class {
        constructor(delegates) {
          this.delegates = delegates;
          if (!delegates) {
            throw new Error("Invalid delegates");
          }
        }
        getDelegates() {
          return this.delegates;
        }
        syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
          this.delegates.forEach((listener) => {
            if (listener.syntaxError) {
              listener.syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e);
            }
          });
        }
      };
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull),
        __param(4, Decorators_1.NotNull)
      ], ProxyErrorListener.prototype, "syntaxError", null);
      exports.ProxyErrorListener = ProxyErrorListener;
    }
  });

  // node_modules/antlr4ts/Recognizer.js
  var require_Recognizer = __commonJS({
    "node_modules/antlr4ts/Recognizer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Recognizer = void 0;
      var ConsoleErrorListener_1 = require_ConsoleErrorListener();
      var ProxyErrorListener_1 = require_ProxyErrorListener();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var Utils3 = require_Utils();
      var Recognizer = class _Recognizer {
        constructor() {
          this._listeners = [ConsoleErrorListener_1.ConsoleErrorListener.INSTANCE];
          this._stateNumber = -1;
        }
        /**
         * Get a map from token names to token types.
         *
         * Used for XPath and tree pattern compilation.
         */
        getTokenTypeMap() {
          let vocabulary = this.vocabulary;
          let result = _Recognizer.tokenTypeMapCache.get(vocabulary);
          if (result == null) {
            let intermediateResult = /* @__PURE__ */ new Map();
            for (let i = 0; i <= this.atn.maxTokenType; i++) {
              let literalName = vocabulary.getLiteralName(i);
              if (literalName != null) {
                intermediateResult.set(literalName, i);
              }
              let symbolicName = vocabulary.getSymbolicName(i);
              if (symbolicName != null) {
                intermediateResult.set(symbolicName, i);
              }
            }
            intermediateResult.set("EOF", Token_1.Token.EOF);
            result = intermediateResult;
            _Recognizer.tokenTypeMapCache.set(vocabulary, result);
          }
          return result;
        }
        /**
         * Get a map from rule names to rule indexes.
         *
         * Used for XPath and tree pattern compilation.
         */
        getRuleIndexMap() {
          let ruleNames = this.ruleNames;
          if (ruleNames == null) {
            throw new Error("The current recognizer does not provide a list of rule names.");
          }
          let result = _Recognizer.ruleIndexMapCache.get(ruleNames);
          if (result == null) {
            result = Utils3.toMap(ruleNames);
            _Recognizer.ruleIndexMapCache.set(ruleNames, result);
          }
          return result;
        }
        getTokenType(tokenName) {
          let ttype = this.getTokenTypeMap().get(tokenName);
          if (ttype != null) {
            return ttype;
          }
          return Token_1.Token.INVALID_TYPE;
        }
        /**
         * If this recognizer was generated, it will have a serialized ATN
         * representation of the grammar.
         *
         * For interpreters, we don't know their serialized ATN despite having
         * created the interpreter from it.
         */
        get serializedATN() {
          throw new Error("there is no serialized ATN");
        }
        /**
         * Get the {@link ATN} used by the recognizer for prediction.
         *
         * @returns The {@link ATN} used by the recognizer for prediction.
         */
        get atn() {
          return this._interp.atn;
        }
        /**
         * Get the ATN interpreter used by the recognizer for prediction.
         *
         * @returns The ATN interpreter used by the recognizer for prediction.
         */
        get interpreter() {
          return this._interp;
        }
        /**
         * Set the ATN interpreter used by the recognizer for prediction.
         *
         * @param interpreter The ATN interpreter used by the recognizer for
         * prediction.
         */
        set interpreter(interpreter) {
          this._interp = interpreter;
        }
        /** If profiling during the parse/lex, this will return DecisionInfo records
         *  for each decision in recognizer in a ParseInfo object.
         *
         * @since 4.3
         */
        get parseInfo() {
          return Promise.resolve(void 0);
        }
        /** What is the error header, normally line/character position information? */
        getErrorHeader(e) {
          let token = e.getOffendingToken();
          if (!token) {
            return "";
          }
          let line = token.line;
          let charPositionInLine = token.charPositionInLine;
          return "line " + line + ":" + charPositionInLine;
        }
        /**
         * @exception NullPointerException if `listener` is `undefined`.
         */
        addErrorListener(listener) {
          if (!listener) {
            throw new TypeError("listener must not be null");
          }
          this._listeners.push(listener);
        }
        removeErrorListener(listener) {
          let position = this._listeners.indexOf(listener);
          if (position !== -1) {
            this._listeners.splice(position, 1);
          }
        }
        removeErrorListeners() {
          this._listeners.length = 0;
        }
        getErrorListeners() {
          return this._listeners.slice(0);
        }
        getErrorListenerDispatch() {
          return new ProxyErrorListener_1.ProxyErrorListener(this.getErrorListeners());
        }
        // subclass needs to override these if there are sempreds or actions
        // that the ATN interp needs to execute
        sempred(_localctx, ruleIndex, actionIndex) {
          return true;
        }
        precpred(localctx, precedence) {
          return true;
        }
        action(_localctx, ruleIndex, actionIndex) {
        }
        get state() {
          return this._stateNumber;
        }
        /** Indicate that the recognizer has changed internal state that is
         *  consistent with the ATN state passed in.  This way we always know
         *  where we are in the ATN as the parser goes along. The rule
         *  context objects form a stack that lets us see the stack of
         *  invoking rules. Combine this and we have complete ATN
         *  configuration information.
         */
        set state(atnState) {
          this._stateNumber = atnState;
        }
      };
      Recognizer.EOF = -1;
      Recognizer.tokenTypeMapCache = /* @__PURE__ */ new WeakMap();
      Recognizer.ruleIndexMapCache = /* @__PURE__ */ new WeakMap();
      __decorate([
        Decorators_1.SuppressWarnings("serial"),
        Decorators_1.NotNull
      ], Recognizer.prototype, "_listeners", void 0);
      __decorate([
        Decorators_1.NotNull
      ], Recognizer.prototype, "getTokenTypeMap", null);
      __decorate([
        Decorators_1.NotNull
      ], Recognizer.prototype, "getRuleIndexMap", null);
      __decorate([
        Decorators_1.NotNull
      ], Recognizer.prototype, "serializedATN", null);
      __decorate([
        Decorators_1.NotNull
      ], Recognizer.prototype, "atn", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], Recognizer.prototype, "interpreter", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], Recognizer.prototype, "getErrorHeader", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], Recognizer.prototype, "addErrorListener", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], Recognizer.prototype, "removeErrorListener", null);
      __decorate([
        Decorators_1.NotNull
      ], Recognizer.prototype, "getErrorListeners", null);
      exports.Recognizer = Recognizer;
    }
  });

  // node_modules/antlr4ts/VocabularyImpl.js
  var require_VocabularyImpl = __commonJS({
    "node_modules/antlr4ts/VocabularyImpl.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.VocabularyImpl = void 0;
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var VocabularyImpl3 = class {
        /**
         * Constructs a new instance of {@link VocabularyImpl} from the specified
         * literal, symbolic, and display token names.
         *
         * @param literalNames The literal names assigned to tokens, or an empty array
         * if no literal names are assigned.
         * @param symbolicNames The symbolic names assigned to tokens, or
         * an empty array if no symbolic names are assigned.
         * @param displayNames The display names assigned to tokens, or an empty array
         * to use the values in `literalNames` and `symbolicNames` as
         * the source of display names, as described in
         * {@link #getDisplayName(int)}.
         *
         * @see #getLiteralName(int)
         * @see #getSymbolicName(int)
         * @see #getDisplayName(int)
         */
        constructor(literalNames, symbolicNames, displayNames) {
          this.literalNames = literalNames;
          this.symbolicNames = symbolicNames;
          this.displayNames = displayNames;
          this._maxTokenType = Math.max(this.displayNames.length, Math.max(this.literalNames.length, this.symbolicNames.length)) - 1;
        }
        get maxTokenType() {
          return this._maxTokenType;
        }
        getLiteralName(tokenType) {
          if (tokenType >= 0 && tokenType < this.literalNames.length) {
            return this.literalNames[tokenType];
          }
          return void 0;
        }
        getSymbolicName(tokenType) {
          if (tokenType >= 0 && tokenType < this.symbolicNames.length) {
            return this.symbolicNames[tokenType];
          }
          if (tokenType === Token_1.Token.EOF) {
            return "EOF";
          }
          return void 0;
        }
        getDisplayName(tokenType) {
          if (tokenType >= 0 && tokenType < this.displayNames.length) {
            let displayName = this.displayNames[tokenType];
            if (displayName) {
              return displayName;
            }
          }
          let literalName = this.getLiteralName(tokenType);
          if (literalName) {
            return literalName;
          }
          let symbolicName = this.getSymbolicName(tokenType);
          if (symbolicName) {
            return symbolicName;
          }
          return String(tokenType);
        }
      };
      VocabularyImpl3.EMPTY_VOCABULARY = new VocabularyImpl3([], [], []);
      __decorate([
        Decorators_1.NotNull
      ], VocabularyImpl3.prototype, "literalNames", void 0);
      __decorate([
        Decorators_1.NotNull
      ], VocabularyImpl3.prototype, "symbolicNames", void 0);
      __decorate([
        Decorators_1.NotNull
      ], VocabularyImpl3.prototype, "displayNames", void 0);
      __decorate([
        Decorators_1.Override
      ], VocabularyImpl3.prototype, "maxTokenType", null);
      __decorate([
        Decorators_1.Override
      ], VocabularyImpl3.prototype, "getLiteralName", null);
      __decorate([
        Decorators_1.Override
      ], VocabularyImpl3.prototype, "getSymbolicName", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], VocabularyImpl3.prototype, "getDisplayName", null);
      __decorate([
        Decorators_1.NotNull
      ], VocabularyImpl3, "EMPTY_VOCABULARY", void 0);
      exports.VocabularyImpl = VocabularyImpl3;
    }
  });

  // node_modules/antlr4ts/dfa/DFASerializer.js
  var require_DFASerializer = __commonJS({
    "node_modules/antlr4ts/dfa/DFASerializer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DFASerializer = void 0;
      var ATNSimulator_1 = require_ATNSimulator();
      var Decorators_1 = require_Decorators();
      var PredictionContext_1 = require_PredictionContext();
      var Recognizer_1 = require_Recognizer();
      var VocabularyImpl_1 = require_VocabularyImpl();
      var DFASerializer = class {
        constructor(dfa, vocabulary, ruleNames, atn) {
          if (vocabulary instanceof Recognizer_1.Recognizer) {
            ruleNames = vocabulary.ruleNames;
            atn = vocabulary.atn;
            vocabulary = vocabulary.vocabulary;
          } else if (!vocabulary) {
            vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
          }
          this.dfa = dfa;
          this.vocabulary = vocabulary;
          this.ruleNames = ruleNames;
          this.atn = atn;
        }
        toString() {
          if (!this.dfa.s0) {
            return "";
          }
          let buf = "";
          if (this.dfa.states) {
            let states = new Array(...this.dfa.states.toArray());
            states.sort((o1, o2) => o1.stateNumber - o2.stateNumber);
            for (let s of states) {
              let edges = s.getEdgeMap();
              let edgeKeys = [...edges.keys()].sort((a, b) => a - b);
              let contextEdges = s.getContextEdgeMap();
              let contextEdgeKeys = [...contextEdges.keys()].sort((a, b) => a - b);
              for (let entry of edgeKeys) {
                let value = edges.get(entry);
                if ((value == null || value === ATNSimulator_1.ATNSimulator.ERROR) && !s.isContextSymbol(entry)) {
                  continue;
                }
                let contextSymbol = false;
                buf += this.getStateString(s) + "-" + this.getEdgeLabel(entry) + "->";
                if (s.isContextSymbol(entry)) {
                  buf += "!";
                  contextSymbol = true;
                }
                let t = value;
                if (t && t.stateNumber !== ATNSimulator_1.ATNSimulator.ERROR.stateNumber) {
                  buf += this.getStateString(t) + "\n";
                } else if (contextSymbol) {
                  buf += "ctx\n";
                }
              }
              if (s.isContextSensitive) {
                for (let entry of contextEdgeKeys) {
                  buf += this.getStateString(s) + "-" + this.getContextLabel(entry) + "->" + this.getStateString(contextEdges.get(entry)) + "\n";
                }
              }
            }
          }
          let output = buf;
          if (output.length === 0) {
            return "";
          }
          return output;
        }
        getContextLabel(i) {
          if (i === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            return "ctx:EMPTY_FULL";
          } else if (i === PredictionContext_1.PredictionContext.EMPTY_LOCAL_STATE_KEY) {
            return "ctx:EMPTY_LOCAL";
          }
          if (this.atn && i > 0 && i <= this.atn.states.length) {
            let state = this.atn.states[i];
            let ruleIndex = state.ruleIndex;
            if (this.ruleNames && ruleIndex >= 0 && ruleIndex < this.ruleNames.length) {
              return "ctx:" + String(i) + "(" + this.ruleNames[ruleIndex] + ")";
            }
          }
          return "ctx:" + String(i);
        }
        getEdgeLabel(i) {
          return this.vocabulary.getDisplayName(i);
        }
        getStateString(s) {
          if (s === ATNSimulator_1.ATNSimulator.ERROR) {
            return "ERROR";
          }
          let n = s.stateNumber;
          let stateStr = "s" + n;
          if (s.isAcceptState) {
            if (s.predicates) {
              stateStr = ":s" + n + "=>" + s.predicates;
            } else {
              stateStr = ":s" + n + "=>" + s.prediction;
            }
          }
          if (s.isContextSensitive) {
            stateStr += "*";
            for (let config2 of s.configs) {
              if (config2.reachesIntoOuterContext) {
                stateStr += "*";
                break;
              }
            }
          }
          return stateStr;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], DFASerializer.prototype, "dfa", void 0);
      __decorate([
        Decorators_1.NotNull
      ], DFASerializer.prototype, "vocabulary", void 0);
      __decorate([
        Decorators_1.Override
      ], DFASerializer.prototype, "toString", null);
      exports.DFASerializer = DFASerializer;
    }
  });

  // node_modules/antlr4ts/dfa/LexerDFASerializer.js
  var require_LexerDFASerializer = __commonJS({
    "node_modules/antlr4ts/dfa/LexerDFASerializer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerDFASerializer = void 0;
      var DFASerializer_1 = require_DFASerializer();
      var Decorators_1 = require_Decorators();
      var VocabularyImpl_1 = require_VocabularyImpl();
      var LexerDFASerializer = class LexerDFASerializer extends DFASerializer_1.DFASerializer {
        constructor(dfa) {
          super(dfa, VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY);
        }
        getEdgeLabel(i) {
          return "'" + String.fromCodePoint(i) + "'";
        }
      };
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], LexerDFASerializer.prototype, "getEdgeLabel", null);
      LexerDFASerializer = __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerDFASerializer);
      exports.LexerDFASerializer = LexerDFASerializer;
    }
  });

  // node_modules/antlr4ts/atn/StarLoopEntryState.js
  var require_StarLoopEntryState = __commonJS({
    "node_modules/antlr4ts/atn/StarLoopEntryState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StarLoopEntryState = void 0;
      var ATNStateType_1 = require_ATNStateType();
      var BitSet_1 = require_BitSet();
      var DecisionState_1 = require_DecisionState();
      var Decorators_1 = require_Decorators();
      var StarLoopEntryState = class extends DecisionState_1.DecisionState {
        constructor() {
          super(...arguments);
          this.precedenceRuleDecision = false;
          this.precedenceLoopbackStates = new BitSet_1.BitSet();
        }
        get stateType() {
          return ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY;
        }
      };
      __decorate([
        Decorators_1.Override
      ], StarLoopEntryState.prototype, "stateType", null);
      exports.StarLoopEntryState = StarLoopEntryState;
    }
  });

  // node_modules/antlr4ts/dfa/DFA.js
  var require_DFA = __commonJS({
    "node_modules/antlr4ts/dfa/DFA.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DFA = void 0;
      var Array2DHashSet_1 = require_Array2DHashSet();
      var ATNConfigSet_1 = require_ATNConfigSet();
      var DFASerializer_1 = require_DFASerializer();
      var DFAState_1 = require_DFAState();
      var LexerDFASerializer_1 = require_LexerDFASerializer();
      var Decorators_1 = require_Decorators();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var StarLoopEntryState_1 = require_StarLoopEntryState();
      var VocabularyImpl_1 = require_VocabularyImpl();
      var DFA = class DFA {
        constructor(atnStartState, decision = 0) {
          this.states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          this.nextStateNumber = 0;
          if (!atnStartState.atn) {
            throw new Error("The ATNState must be associated with an ATN");
          }
          this.atnStartState = atnStartState;
          this.atn = atnStartState.atn;
          this.decision = decision;
          let isPrecedenceDfa = false;
          if (atnStartState instanceof StarLoopEntryState_1.StarLoopEntryState) {
            if (atnStartState.precedenceRuleDecision) {
              isPrecedenceDfa = true;
              this.s0 = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
              this.s0full = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
            }
          }
          this.precedenceDfa = isPrecedenceDfa;
        }
        /**
         * Gets whether this DFA is a precedence DFA. Precedence DFAs use a special
         * start state {@link #s0} which is not stored in {@link #states}. The
         * {@link DFAState#edges} array for this start state contains outgoing edges
         * supplying individual start states corresponding to specific precedence
         * values.
         *
         * @returns `true` if this is a precedence DFA; otherwise,
         * `false`.
         * @see Parser.precedence
         */
        get isPrecedenceDfa() {
          return this.precedenceDfa;
        }
        /**
         * Get the start state for a specific precedence value.
         *
         * @param precedence The current precedence.
         * @returns The start state corresponding to the specified precedence, or
         * `undefined` if no start state exists for the specified precedence.
         *
         * @ if this is not a precedence DFA.
         * @see `isPrecedenceDfa`
         */
        getPrecedenceStartState(precedence, fullContext) {
          if (!this.isPrecedenceDfa) {
            throw new Error("Only precedence DFAs may contain a precedence start state.");
          }
          if (fullContext) {
            return this.s0full.getTarget(precedence);
          } else {
            return this.s0.getTarget(precedence);
          }
        }
        /**
         * Set the start state for a specific precedence value.
         *
         * @param precedence The current precedence.
         * @param startState The start state corresponding to the specified
         * precedence.
         *
         * @ if this is not a precedence DFA.
         * @see `isPrecedenceDfa`
         */
        setPrecedenceStartState(precedence, fullContext, startState) {
          if (!this.isPrecedenceDfa) {
            throw new Error("Only precedence DFAs may contain a precedence start state.");
          }
          if (precedence < 0) {
            return;
          }
          if (fullContext) {
            this.s0full.setTarget(precedence, startState);
          } else {
            this.s0.setTarget(precedence, startState);
          }
        }
        get isEmpty() {
          if (this.isPrecedenceDfa) {
            return this.s0.getEdgeMap().size === 0 && this.s0full.getEdgeMap().size === 0;
          }
          return this.s0 == null && this.s0full == null;
        }
        get isContextSensitive() {
          if (this.isPrecedenceDfa) {
            return this.s0full.getEdgeMap().size > 0;
          }
          return this.s0full != null;
        }
        addState(state) {
          state.stateNumber = this.nextStateNumber++;
          return this.states.getOrAdd(state);
        }
        toString(vocabulary, ruleNames) {
          if (!vocabulary) {
            vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
          }
          if (!this.s0) {
            return "";
          }
          let serializer;
          if (ruleNames) {
            serializer = new DFASerializer_1.DFASerializer(this, vocabulary, ruleNames, this.atnStartState.atn);
          } else {
            serializer = new DFASerializer_1.DFASerializer(this, vocabulary);
          }
          return serializer.toString();
        }
        toLexerString() {
          if (!this.s0) {
            return "";
          }
          let serializer = new LexerDFASerializer_1.LexerDFASerializer(this);
          return serializer.toString();
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], DFA.prototype, "states", void 0);
      __decorate([
        Decorators_1.NotNull
      ], DFA.prototype, "atnStartState", void 0);
      __decorate([
        Decorators_1.NotNull
      ], DFA.prototype, "atn", void 0);
      DFA = __decorate([
        __param(0, Decorators_1.NotNull)
      ], DFA);
      exports.DFA = DFA;
    }
  });

  // node_modules/antlr4ts/atn/BasicState.js
  var require_BasicState = __commonJS({
    "node_modules/antlr4ts/atn/BasicState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BasicState = void 0;
      var ATNState_1 = require_ATNState();
      var ATNStateType_1 = require_ATNStateType();
      var Decorators_1 = require_Decorators();
      var BasicState = class extends ATNState_1.ATNState {
        get stateType() {
          return ATNStateType_1.ATNStateType.BASIC;
        }
      };
      __decorate([
        Decorators_1.Override
      ], BasicState.prototype, "stateType", null);
      exports.BasicState = BasicState;
    }
  });

  // node_modules/antlr4ts/atn/InvalidState.js
  var require_InvalidState = __commonJS({
    "node_modules/antlr4ts/atn/InvalidState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InvalidState = void 0;
      var ATNStateType_1 = require_ATNStateType();
      var BasicState_1 = require_BasicState();
      var Decorators_1 = require_Decorators();
      var InvalidState = class extends BasicState_1.BasicState {
        get stateType() {
          return ATNStateType_1.ATNStateType.INVALID_TYPE;
        }
      };
      __decorate([
        Decorators_1.Override
      ], InvalidState.prototype, "stateType", null);
      exports.InvalidState = InvalidState;
    }
  });

  // node_modules/antlr4ts/atn/SetTransition.js
  var require_SetTransition = __commonJS({
    "node_modules/antlr4ts/atn/SetTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetTransition = void 0;
      var IntervalSet_1 = require_IntervalSet();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var Transition_1 = require_Transition();
      var SetTransition = class SetTransition extends Transition_1.Transition {
        // TODO (sam): should we really allow undefined here?
        constructor(target, set2) {
          super(target);
          if (set2 == null) {
            set2 = IntervalSet_1.IntervalSet.of(Token_1.Token.INVALID_TYPE);
          }
          this.set = set2;
        }
        get serializationType() {
          return 7;
        }
        get label() {
          return this.set;
        }
        matches(symbol2, minVocabSymbol, maxVocabSymbol) {
          return this.set.contains(symbol2);
        }
        toString() {
          return this.set.toString();
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], SetTransition.prototype, "set", void 0);
      __decorate([
        Decorators_1.Override
      ], SetTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], SetTransition.prototype, "label", null);
      __decorate([
        Decorators_1.Override
      ], SetTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], SetTransition.prototype, "toString", null);
      SetTransition = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.Nullable)
      ], SetTransition);
      exports.SetTransition = SetTransition;
    }
  });

  // node_modules/antlr4ts/atn/NotSetTransition.js
  var require_NotSetTransition = __commonJS({
    "node_modules/antlr4ts/atn/NotSetTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NotSetTransition = void 0;
      var Decorators_1 = require_Decorators();
      var SetTransition_1 = require_SetTransition();
      var NotSetTransition = class NotSetTransition extends SetTransition_1.SetTransition {
        constructor(target, set2) {
          super(target, set2);
        }
        get serializationType() {
          return 8;
        }
        matches(symbol2, minVocabSymbol, maxVocabSymbol) {
          return symbol2 >= minVocabSymbol && symbol2 <= maxVocabSymbol && !super.matches(symbol2, minVocabSymbol, maxVocabSymbol);
        }
        toString() {
          return "~" + super.toString();
        }
      };
      __decorate([
        Decorators_1.Override
      ], NotSetTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override
      ], NotSetTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override
      ], NotSetTransition.prototype, "toString", null);
      NotSetTransition = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.Nullable)
      ], NotSetTransition);
      exports.NotSetTransition = NotSetTransition;
    }
  });

  // node_modules/antlr4ts/atn/RuleStopState.js
  var require_RuleStopState = __commonJS({
    "node_modules/antlr4ts/atn/RuleStopState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleStopState = void 0;
      var ATNState_1 = require_ATNState();
      var ATNStateType_1 = require_ATNStateType();
      var Decorators_1 = require_Decorators();
      var RuleStopState = class extends ATNState_1.ATNState {
        get nonStopStateNumber() {
          return -1;
        }
        get stateType() {
          return ATNStateType_1.ATNStateType.RULE_STOP;
        }
      };
      __decorate([
        Decorators_1.Override
      ], RuleStopState.prototype, "nonStopStateNumber", null);
      __decorate([
        Decorators_1.Override
      ], RuleStopState.prototype, "stateType", null);
      exports.RuleStopState = RuleStopState;
    }
  });

  // node_modules/antlr4ts/atn/RuleTransition.js
  var require_RuleTransition = __commonJS({
    "node_modules/antlr4ts/atn/RuleTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleTransition = void 0;
      var Decorators_1 = require_Decorators();
      var Transition_1 = require_Transition();
      var RuleTransition = class RuleTransition extends Transition_1.Transition {
        constructor(ruleStart, ruleIndex, precedence, followState) {
          super(ruleStart);
          this.tailCall = false;
          this.optimizedTailCall = false;
          this.ruleIndex = ruleIndex;
          this.precedence = precedence;
          this.followState = followState;
        }
        get serializationType() {
          return 3;
        }
        get isEpsilon() {
          return true;
        }
        matches(symbol2, minVocabSymbol, maxVocabSymbol) {
          return false;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], RuleTransition.prototype, "followState", void 0);
      __decorate([
        Decorators_1.Override
      ], RuleTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override
      ], RuleTransition.prototype, "isEpsilon", null);
      __decorate([
        Decorators_1.Override
      ], RuleTransition.prototype, "matches", null);
      RuleTransition = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(3, Decorators_1.NotNull)
      ], RuleTransition);
      exports.RuleTransition = RuleTransition;
    }
  });

  // node_modules/antlr4ts/atn/WildcardTransition.js
  var require_WildcardTransition = __commonJS({
    "node_modules/antlr4ts/atn/WildcardTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WildcardTransition = void 0;
      var Decorators_1 = require_Decorators();
      var Transition_1 = require_Transition();
      var WildcardTransition = class WildcardTransition extends Transition_1.Transition {
        constructor(target) {
          super(target);
        }
        get serializationType() {
          return 9;
        }
        matches(symbol2, minVocabSymbol, maxVocabSymbol) {
          return symbol2 >= minVocabSymbol && symbol2 <= maxVocabSymbol;
        }
        toString() {
          return ".";
        }
      };
      __decorate([
        Decorators_1.Override
      ], WildcardTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override
      ], WildcardTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], WildcardTransition.prototype, "toString", null);
      WildcardTransition = __decorate([
        __param(0, Decorators_1.NotNull)
      ], WildcardTransition);
      exports.WildcardTransition = WildcardTransition;
    }
  });

  // node_modules/antlr4ts/atn/LL1Analyzer.js
  var require_LL1Analyzer = __commonJS({
    "node_modules/antlr4ts/atn/LL1Analyzer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LL1Analyzer = void 0;
      var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
      var Array2DHashSet_1 = require_Array2DHashSet();
      var ATNConfig_1 = require_ATNConfig();
      var BitSet_1 = require_BitSet();
      var IntervalSet_1 = require_IntervalSet();
      var Decorators_1 = require_Decorators();
      var NotSetTransition_1 = require_NotSetTransition();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var PredictionContext_1 = require_PredictionContext();
      var RuleStopState_1 = require_RuleStopState();
      var RuleTransition_1 = require_RuleTransition();
      var Token_1 = require_Token();
      var WildcardTransition_1 = require_WildcardTransition();
      var LL1Analyzer = class LL1Analyzer2 {
        constructor(atn) {
          this.atn = atn;
        }
        /**
         * Calculates the SLL(1) expected lookahead set for each outgoing transition
         * of an {@link ATNState}. The returned array has one element for each
         * outgoing transition in `s`. If the closure from transition
         * *i* leads to a semantic predicate before matching a symbol, the
         * element at index *i* of the result will be `undefined`.
         *
         * @param s the ATN state
         * @returns the expected symbols for each outgoing transition of `s`.
         */
        getDecisionLookahead(s) {
          if (s == null) {
            return void 0;
          }
          let look = new Array(s.numberOfTransitions);
          for (let alt = 0; alt < s.numberOfTransitions; alt++) {
            let current = new IntervalSet_1.IntervalSet();
            look[alt] = current;
            let lookBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
            let seeThruPreds = false;
            this._LOOK(s.transition(alt).target, void 0, PredictionContext_1.PredictionContext.EMPTY_LOCAL, current, lookBusy, new BitSet_1.BitSet(), seeThruPreds, false);
            if (current.size === 0 || current.contains(LL1Analyzer2.HIT_PRED)) {
              current = void 0;
              look[alt] = current;
            }
          }
          return look;
        }
        LOOK(s, ctx, stopState) {
          if (stopState === void 0) {
            if (s.atn == null) {
              throw new Error("Illegal state");
            }
            stopState = s.atn.ruleToStopState[s.ruleIndex];
          } else if (stopState === null) {
            stopState = void 0;
          }
          let r = new IntervalSet_1.IntervalSet();
          let seeThruPreds = true;
          let addEOF = true;
          this._LOOK(s, stopState, ctx, r, new Array2DHashSet_1.Array2DHashSet(), new BitSet_1.BitSet(), seeThruPreds, addEOF);
          return r;
        }
        /**
         * Compute set of tokens that can follow `s` in the ATN in the
         * specified `ctx`.
         * <p/>
         * If `ctx` is {@link PredictionContext#EMPTY_LOCAL} and
         * `stopState` or the end of the rule containing `s` is reached,
         * {@link Token#EPSILON} is added to the result set. If `ctx` is not
         * {@link PredictionContext#EMPTY_LOCAL} and `addEOF` is `true`
         * and `stopState` or the end of the outermost rule is reached,
         * {@link Token#EOF} is added to the result set.
         *
         * @param s the ATN state.
         * @param stopState the ATN state to stop at. This can be a
         * {@link BlockEndState} to detect epsilon paths through a closure.
         * @param ctx The outer context, or {@link PredictionContext#EMPTY_LOCAL} if
         * the outer context should not be used.
         * @param look The result lookahead set.
         * @param lookBusy A set used for preventing epsilon closures in the ATN
         * from causing a stack overflow. Outside code should pass
         * `new HashSet<ATNConfig>` for this argument.
         * @param calledRuleStack A set used for preventing left recursion in the
         * ATN from causing a stack overflow. Outside code should pass
         * `new BitSet()` for this argument.
         * @param seeThruPreds `true` to true semantic predicates as
         * implicitly `true` and "see through them", otherwise `false`
         * to treat semantic predicates as opaque and add {@link #HIT_PRED} to the
         * result if one is encountered.
         * @param addEOF Add {@link Token#EOF} to the result if the end of the
         * outermost context is reached. This parameter has no effect if `ctx`
         * is {@link PredictionContext#EMPTY_LOCAL}.
         */
        _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
          let c = ATNConfig_1.ATNConfig.create(s, 0, ctx);
          if (!lookBusy.add(c)) {
            return;
          }
          if (s === stopState) {
            if (PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
              look.add(Token_1.Token.EPSILON);
              return;
            } else if (ctx.isEmpty) {
              if (addEOF) {
                look.add(Token_1.Token.EOF);
              }
              return;
            }
          }
          if (s instanceof RuleStopState_1.RuleStopState) {
            if (ctx.isEmpty && !PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
              if (addEOF) {
                look.add(Token_1.Token.EOF);
              }
              return;
            }
            let removed = calledRuleStack.get(s.ruleIndex);
            try {
              calledRuleStack.clear(s.ruleIndex);
              for (let i = 0; i < ctx.size; i++) {
                if (ctx.getReturnState(i) === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                  continue;
                }
                let returnState = this.atn.states[ctx.getReturnState(i)];
                this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
              }
            } finally {
              if (removed) {
                calledRuleStack.set(s.ruleIndex);
              }
            }
          }
          let n = s.numberOfTransitions;
          for (let i = 0; i < n; i++) {
            let t = s.transition(i);
            if (t instanceof RuleTransition_1.RuleTransition) {
              if (calledRuleStack.get(t.ruleIndex)) {
                continue;
              }
              let newContext = ctx.getChild(t.followState.stateNumber);
              try {
                calledRuleStack.set(t.ruleIndex);
                this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
              } finally {
                calledRuleStack.clear(t.ruleIndex);
              }
            } else if (t instanceof AbstractPredicateTransition_1.AbstractPredicateTransition) {
              if (seeThruPreds) {
                this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
              } else {
                look.add(LL1Analyzer2.HIT_PRED);
              }
            } else if (t.isEpsilon) {
              this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } else if (t instanceof WildcardTransition_1.WildcardTransition) {
              look.addAll(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
            } else {
              let set2 = t.label;
              if (set2 != null) {
                if (t instanceof NotSetTransition_1.NotSetTransition) {
                  set2 = set2.complement(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
                }
                look.addAll(set2);
              }
            }
          }
        }
      };
      LL1Analyzer.HIT_PRED = Token_1.Token.INVALID_TYPE;
      __decorate([
        Decorators_1.NotNull
      ], LL1Analyzer.prototype, "atn", void 0);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], LL1Analyzer.prototype, "LOOK", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull),
        __param(3, Decorators_1.NotNull),
        __param(4, Decorators_1.NotNull),
        __param(5, Decorators_1.NotNull)
      ], LL1Analyzer.prototype, "_LOOK", null);
      LL1Analyzer = __decorate([
        __param(0, Decorators_1.NotNull)
      ], LL1Analyzer);
      exports.LL1Analyzer = LL1Analyzer;
    }
  });

  // node_modules/antlr4ts/atn/ATN.js
  var require_ATN = __commonJS({
    "node_modules/antlr4ts/atn/ATN.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATN = void 0;
      var Array2DHashMap_1 = require_Array2DHashMap();
      var DFA_1 = require_DFA();
      var IntervalSet_1 = require_IntervalSet();
      var InvalidState_1 = require_InvalidState();
      var LL1Analyzer_1 = require_LL1Analyzer();
      var Decorators_1 = require_Decorators();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var PredictionContext_1 = require_PredictionContext();
      var Token_1 = require_Token();
      var assert2 = require_assert();
      var ATN2 = class ATN {
        /** Used for runtime deserialization of ATNs from strings */
        constructor(grammarType, maxTokenType) {
          this.states = [];
          this.decisionToState = [];
          this.modeNameToStartState = /* @__PURE__ */ new Map();
          this.modeToStartState = [];
          this.contextCache = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          this.decisionToDFA = [];
          this.modeToDFA = [];
          this.LL1Table = /* @__PURE__ */ new Map();
          this.grammarType = grammarType;
          this.maxTokenType = maxTokenType;
        }
        clearDFA() {
          this.decisionToDFA = new Array(this.decisionToState.length);
          for (let i = 0; i < this.decisionToDFA.length; i++) {
            this.decisionToDFA[i] = new DFA_1.DFA(this.decisionToState[i], i);
          }
          this.modeToDFA = new Array(this.modeToStartState.length);
          for (let i = 0; i < this.modeToDFA.length; i++) {
            this.modeToDFA[i] = new DFA_1.DFA(this.modeToStartState[i]);
          }
          this.contextCache.clear();
          this.LL1Table.clear();
        }
        get contextCacheSize() {
          return this.contextCache.size;
        }
        getCachedContext(context) {
          return PredictionContext_1.PredictionContext.getCachedContext(context, this.contextCache, new PredictionContext_1.PredictionContext.IdentityHashMap());
        }
        getDecisionToDFA() {
          assert2(this.decisionToDFA != null && this.decisionToDFA.length === this.decisionToState.length);
          return this.decisionToDFA;
        }
        nextTokens(s, ctx) {
          if (ctx) {
            let anal = new LL1Analyzer_1.LL1Analyzer(this);
            let next = anal.LOOK(s, ctx);
            return next;
          } else {
            if (s.nextTokenWithinRule) {
              return s.nextTokenWithinRule;
            }
            s.nextTokenWithinRule = this.nextTokens(s, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
            s.nextTokenWithinRule.setReadonly(true);
            return s.nextTokenWithinRule;
          }
        }
        addState(state) {
          state.atn = this;
          state.stateNumber = this.states.length;
          this.states.push(state);
        }
        removeState(state) {
          let invalidState = new InvalidState_1.InvalidState();
          invalidState.atn = this;
          invalidState.stateNumber = state.stateNumber;
          this.states[state.stateNumber] = invalidState;
        }
        defineMode(name, s) {
          this.modeNameToStartState.set(name, s);
          this.modeToStartState.push(s);
          this.modeToDFA.push(new DFA_1.DFA(s));
          this.defineDecisionState(s);
        }
        defineDecisionState(s) {
          this.decisionToState.push(s);
          s.decision = this.decisionToState.length - 1;
          this.decisionToDFA.push(new DFA_1.DFA(s, s.decision));
          return s.decision;
        }
        getDecisionState(decision) {
          if (this.decisionToState.length > 0) {
            return this.decisionToState[decision];
          }
          return void 0;
        }
        get numberOfDecisions() {
          return this.decisionToState.length;
        }
        /**
         * Computes the set of input symbols which could follow ATN state number
         * `stateNumber` in the specified full `context`. This method
         * considers the complete parser context, but does not evaluate semantic
         * predicates (i.e. all predicates encountered during the calculation are
         * assumed true). If a path in the ATN exists from the starting state to the
         * {@link RuleStopState} of the outermost context without matching any
         * symbols, {@link Token#EOF} is added to the returned set.
         *
         * If `context` is `undefined`, it is treated as
         * {@link ParserRuleContext#EMPTY}.
         *
         * Note that this does NOT give you the set of all tokens that could
         * appear at a given token position in the input phrase.  In other words, it
         * does not answer:
         *
         * > Given a specific partial input phrase, return the set of all
         * > tokens that can follow the last token in the input phrase.
         *
         * The big difference is that with just the input, the parser could land
         * right in the middle of a lookahead decision. Getting all
         * *possible* tokens given a partial input stream is a separate
         * computation. See https://github.com/antlr/antlr4/issues/1428
         *
         * For this function, we are specifying an ATN state and call stack to
         * compute what token(s) can come next and specifically: outside of a
         * lookahead decision. That is what you want for error reporting and
         * recovery upon parse error.
         *
         * @param stateNumber the ATN state number
         * @param context the full parse context
         * @returns The set of potentially valid input symbols which could follow the
         * specified state in the specified context.
         * @ if the ATN does not contain a state with
         * number `stateNumber`
         */
        getExpectedTokens(stateNumber, context) {
          if (stateNumber < 0 || stateNumber >= this.states.length) {
            throw new RangeError("Invalid state number.");
          }
          let ctx = context;
          let s = this.states[stateNumber];
          let following = this.nextTokens(s);
          if (!following.contains(Token_1.Token.EPSILON)) {
            return following;
          }
          let expected = new IntervalSet_1.IntervalSet();
          expected.addAll(following);
          expected.remove(Token_1.Token.EPSILON);
          while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
            let invokingState = this.states[ctx.invokingState];
            let rt = invokingState.transition(0);
            following = this.nextTokens(rt.followState);
            expected.addAll(following);
            expected.remove(Token_1.Token.EPSILON);
            ctx = ctx._parent;
          }
          if (following.contains(Token_1.Token.EPSILON)) {
            expected.add(Token_1.Token.EOF);
          }
          return expected;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ATN2.prototype, "states", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATN2.prototype, "decisionToState", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATN2.prototype, "modeNameToStartState", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATN2.prototype, "modeToStartState", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATN2.prototype, "decisionToDFA", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATN2.prototype, "modeToDFA", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ATN2.prototype, "nextTokens", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ATN2.prototype, "removeState", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ATN2.prototype, "defineMode", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ATN2.prototype, "defineDecisionState", null);
      __decorate([
        Decorators_1.NotNull
      ], ATN2.prototype, "getExpectedTokens", null);
      ATN2 = __decorate([
        __param(0, Decorators_1.NotNull)
      ], ATN2);
      exports.ATN = ATN2;
      (function(ATN3) {
        ATN3.INVALID_ALT_NUMBER = 0;
      })(ATN2 = exports.ATN || (exports.ATN = {}));
      exports.ATN = ATN2;
    }
  });

  // node_modules/antlr4ts/atn/LexerIndexedCustomAction.js
  var require_LexerIndexedCustomAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerIndexedCustomAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerIndexedCustomAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerIndexedCustomAction = class LexerIndexedCustomAction2 {
        /**
         * Constructs a new indexed custom action by associating a character offset
         * with a {@link LexerAction}.
         *
         * Note: This class is only required for lexer actions for which
         * {@link LexerAction#isPositionDependent} returns `true`.
         *
         * @param offset The offset into the input {@link CharStream}, relative to
         * the token start index, at which the specified lexer action should be
         * executed.
         * @param action The lexer action to execute at a particular offset in the
         * input {@link CharStream}.
         */
        constructor(offset, action) {
          this._offset = offset;
          this._action = action;
        }
        /**
         * Gets the location in the input {@link CharStream} at which the lexer
         * action should be executed. The value is interpreted as an offset relative
         * to the token start index.
         *
         * @returns The location in the input {@link CharStream} at which the lexer
         * action should be executed.
         */
        get offset() {
          return this._offset;
        }
        /**
         * Gets the lexer action to execute.
         *
         * @returns A {@link LexerAction} object which executes the lexer action.
         */
        get action() {
          return this._action;
        }
        /**
         * {@inheritDoc}
         *
         * @returns This method returns the result of calling {@link #getActionType}
         * on the {@link LexerAction} returned by {@link #getAction}.
         */
        get actionType() {
          return this._action.actionType;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns `true`.
         */
        get isPositionDependent() {
          return true;
        }
        /**
         * {@inheritDoc}
         *
         * This method calls {@link #execute} on the result of {@link #getAction}
         * using the provided `lexer`.
         */
        execute(lexer) {
          this._action.execute(lexer);
        }
        hashCode() {
          let hash2 = MurmurHash_1.MurmurHash.initialize();
          hash2 = MurmurHash_1.MurmurHash.update(hash2, this._offset);
          hash2 = MurmurHash_1.MurmurHash.update(hash2, this._action);
          return MurmurHash_1.MurmurHash.finish(hash2, 2);
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof LexerIndexedCustomAction2)) {
            return false;
          }
          return this._offset === obj._offset && this._action.equals(obj._action);
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], LexerIndexedCustomAction.prototype, "action", null);
      __decorate([
        Decorators_1.Override
      ], LexerIndexedCustomAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerIndexedCustomAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override
      ], LexerIndexedCustomAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerIndexedCustomAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerIndexedCustomAction.prototype, "equals", null);
      LexerIndexedCustomAction = __decorate([
        __param(1, Decorators_1.NotNull)
      ], LexerIndexedCustomAction);
      exports.LexerIndexedCustomAction = LexerIndexedCustomAction;
    }
  });

  // node_modules/antlr4ts/atn/LexerActionExecutor.js
  var require_LexerActionExecutor = __commonJS({
    "node_modules/antlr4ts/atn/LexerActionExecutor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerActionExecutor = void 0;
      var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
      var LexerIndexedCustomAction_1 = require_LexerIndexedCustomAction();
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerActionExecutor = class LexerActionExecutor2 {
        /**
         * Constructs an executor for a sequence of {@link LexerAction} actions.
         * @param lexerActions The lexer actions to execute.
         */
        constructor(lexerActions) {
          this._lexerActions = lexerActions;
          let hash2 = MurmurHash_1.MurmurHash.initialize();
          for (let lexerAction of lexerActions) {
            hash2 = MurmurHash_1.MurmurHash.update(hash2, lexerAction);
          }
          this.cachedHashCode = MurmurHash_1.MurmurHash.finish(hash2, lexerActions.length);
        }
        /**
         * Creates a {@link LexerActionExecutor} which executes the actions for
         * the input `lexerActionExecutor` followed by a specified
         * `lexerAction`.
         *
         * @param lexerActionExecutor The executor for actions already traversed by
         * the lexer while matching a token within a particular
         * {@link ATNConfig}. If this is `undefined`, the method behaves as though
         * it were an empty executor.
         * @param lexerAction The lexer action to execute after the actions
         * specified in `lexerActionExecutor`.
         *
         * @returns A {@link LexerActionExecutor} for executing the combine actions
         * of `lexerActionExecutor` and `lexerAction`.
         */
        static append(lexerActionExecutor, lexerAction) {
          if (!lexerActionExecutor) {
            return new LexerActionExecutor2([lexerAction]);
          }
          let lexerActions = lexerActionExecutor._lexerActions.slice(0);
          lexerActions.push(lexerAction);
          return new LexerActionExecutor2(lexerActions);
        }
        /**
         * Creates a {@link LexerActionExecutor} which encodes the current offset
         * for position-dependent lexer actions.
         *
         * Normally, when the executor encounters lexer actions where
         * {@link LexerAction#isPositionDependent} returns `true`, it calls
         * {@link IntStream#seek} on the input {@link CharStream} to set the input
         * position to the *end* of the current token. This behavior provides
         * for efficient DFA representation of lexer actions which appear at the end
         * of a lexer rule, even when the lexer rule matches a variable number of
         * characters.
         *
         * Prior to traversing a match transition in the ATN, the current offset
         * from the token start index is assigned to all position-dependent lexer
         * actions which have not already been assigned a fixed offset. By storing
         * the offsets relative to the token start index, the DFA representation of
         * lexer actions which appear in the middle of tokens remains efficient due
         * to sharing among tokens of the same length, regardless of their absolute
         * position in the input stream.
         *
         * If the current executor already has offsets assigned to all
         * position-dependent lexer actions, the method returns `this`.
         *
         * @param offset The current offset to assign to all position-dependent
         * lexer actions which do not already have offsets assigned.
         *
         * @returns A {@link LexerActionExecutor} which stores input stream offsets
         * for all position-dependent lexer actions.
         */
        fixOffsetBeforeMatch(offset) {
          let updatedLexerActions;
          for (let i = 0; i < this._lexerActions.length; i++) {
            if (this._lexerActions[i].isPositionDependent && !(this._lexerActions[i] instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction)) {
              if (!updatedLexerActions) {
                updatedLexerActions = this._lexerActions.slice(0);
              }
              updatedLexerActions[i] = new LexerIndexedCustomAction_1.LexerIndexedCustomAction(offset, this._lexerActions[i]);
            }
          }
          if (!updatedLexerActions) {
            return this;
          }
          return new LexerActionExecutor2(updatedLexerActions);
        }
        /**
         * Gets the lexer actions to be executed by this executor.
         * @returns The lexer actions to be executed by this executor.
         */
        get lexerActions() {
          return this._lexerActions;
        }
        /**
         * Execute the actions encapsulated by this executor within the context of a
         * particular {@link Lexer}.
         *
         * This method calls {@link IntStream#seek} to set the position of the
         * `input` {@link CharStream} prior to calling
         * {@link LexerAction#execute} on a position-dependent action. Before the
         * method returns, the input position will be restored to the same position
         * it was in when the method was invoked.
         *
         * @param lexer The lexer instance.
         * @param input The input stream which is the source for the current token.
         * When this method is called, the current {@link IntStream#index} for
         * `input` should be the start of the following token, i.e. 1
         * character past the end of the current token.
         * @param startIndex The token start index. This value may be passed to
         * {@link IntStream#seek} to set the `input` position to the beginning
         * of the token.
         */
        execute(lexer, input, startIndex) {
          let requiresSeek = false;
          let stopIndex = input.index;
          try {
            for (let lexerAction of this._lexerActions) {
              if (lexerAction instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction) {
                let offset = lexerAction.offset;
                input.seek(startIndex + offset);
                lexerAction = lexerAction.action;
                requiresSeek = startIndex + offset !== stopIndex;
              } else if (lexerAction.isPositionDependent) {
                input.seek(stopIndex);
                requiresSeek = false;
              }
              lexerAction.execute(lexer);
            }
          } finally {
            if (requiresSeek) {
              input.seek(stopIndex);
            }
          }
        }
        hashCode() {
          return this.cachedHashCode;
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof LexerActionExecutor2)) {
            return false;
          }
          return this.cachedHashCode === obj.cachedHashCode && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._lexerActions, obj._lexerActions);
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], LexerActionExecutor.prototype, "_lexerActions", void 0);
      __decorate([
        Decorators_1.NotNull
      ], LexerActionExecutor.prototype, "lexerActions", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerActionExecutor.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerActionExecutor.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerActionExecutor.prototype, "equals", null);
      __decorate([
        Decorators_1.NotNull,
        __param(1, Decorators_1.NotNull)
      ], LexerActionExecutor, "append", null);
      LexerActionExecutor = __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerActionExecutor);
      exports.LexerActionExecutor = LexerActionExecutor;
    }
  });

  // node_modules/antlr4ts/LexerNoViableAltException.js
  var require_LexerNoViableAltException = __commonJS({
    "node_modules/antlr4ts/LexerNoViableAltException.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerNoViableAltException = void 0;
      var RecognitionException_1 = require_RecognitionException();
      var Decorators_1 = require_Decorators();
      var Interval_1 = require_Interval();
      var Utils3 = require_Utils();
      var LexerNoViableAltException = class LexerNoViableAltException extends RecognitionException_1.RecognitionException {
        constructor(lexer, input, startIndex, deadEndConfigs) {
          super(lexer, input);
          this._startIndex = startIndex;
          this._deadEndConfigs = deadEndConfigs;
        }
        get startIndex() {
          return this._startIndex;
        }
        get deadEndConfigs() {
          return this._deadEndConfigs;
        }
        get inputStream() {
          return super.inputStream;
        }
        toString() {
          let symbol2 = "";
          if (this._startIndex >= 0 && this._startIndex < this.inputStream.size) {
            symbol2 = this.inputStream.getText(Interval_1.Interval.of(this._startIndex, this._startIndex));
            symbol2 = Utils3.escapeWhitespace(symbol2, false);
          }
          return `LexerNoViableAltException('${symbol2}')`;
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerNoViableAltException.prototype, "inputStream", null);
      __decorate([
        Decorators_1.Override
      ], LexerNoViableAltException.prototype, "toString", null);
      LexerNoViableAltException = __decorate([
        __param(1, Decorators_1.NotNull)
      ], LexerNoViableAltException);
      exports.LexerNoViableAltException = LexerNoViableAltException;
    }
  });

  // node_modules/antlr4ts/atn/OrderedATNConfigSet.js
  var require_OrderedATNConfigSet = __commonJS({
    "node_modules/antlr4ts/atn/OrderedATNConfigSet.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.OrderedATNConfigSet = void 0;
      var ATNConfigSet_1 = require_ATNConfigSet();
      var Decorators_1 = require_Decorators();
      var OrderedATNConfigSet = class _OrderedATNConfigSet extends ATNConfigSet_1.ATNConfigSet {
        constructor(set2, readonly2) {
          if (set2 != null && readonly2 != null) {
            super(set2, readonly2);
          } else {
            super();
          }
        }
        clone(readonly2) {
          let copy = new _OrderedATNConfigSet(this, readonly2);
          if (!readonly2 && this.isReadOnly) {
            copy.addAll(this);
          }
          return copy;
        }
        getKey(e) {
          return { state: 0, alt: e.hashCode() };
        }
        canMerge(left, leftKey, right) {
          return left.equals(right);
        }
      };
      __decorate([
        Decorators_1.Override
      ], OrderedATNConfigSet.prototype, "clone", null);
      __decorate([
        Decorators_1.Override
      ], OrderedATNConfigSet.prototype, "getKey", null);
      __decorate([
        Decorators_1.Override
      ], OrderedATNConfigSet.prototype, "canMerge", null);
      exports.OrderedATNConfigSet = OrderedATNConfigSet;
    }
  });

  // node_modules/antlr4ts/atn/LexerATNSimulator.js
  var require_LexerATNSimulator = __commonJS({
    "node_modules/antlr4ts/atn/LexerATNSimulator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerATNSimulator = void 0;
      var AcceptStateInfo_1 = require_AcceptStateInfo();
      var ATN_1 = require_ATN();
      var ATNConfig_1 = require_ATNConfig();
      var ATNConfigSet_1 = require_ATNConfigSet();
      var ATNSimulator_1 = require_ATNSimulator();
      var DFAState_1 = require_DFAState();
      var Interval_1 = require_Interval();
      var IntStream_1 = require_IntStream();
      var Lexer_1 = require_Lexer();
      var LexerActionExecutor_1 = require_LexerActionExecutor();
      var LexerNoViableAltException_1 = require_LexerNoViableAltException();
      var Decorators_1 = require_Decorators();
      var OrderedATNConfigSet_1 = require_OrderedATNConfigSet();
      var PredictionContext_1 = require_PredictionContext();
      var RuleStopState_1 = require_RuleStopState();
      var Token_1 = require_Token();
      var assert2 = require_assert();
      var LexerATNSimulator2 = class LexerATNSimulator3 extends ATNSimulator_1.ATNSimulator {
        constructor(atn, recog) {
          super(atn);
          this.optimize_tail_calls = true;
          this.startIndex = -1;
          this._line = 1;
          this._charPositionInLine = 0;
          this.mode = Lexer_1.Lexer.DEFAULT_MODE;
          this.prevAccept = new LexerATNSimulator3.SimState();
          this.recog = recog;
        }
        copyState(simulator) {
          this._charPositionInLine = simulator.charPositionInLine;
          this._line = simulator._line;
          this.mode = simulator.mode;
          this.startIndex = simulator.startIndex;
        }
        match(input, mode) {
          this.mode = mode;
          let mark = input.mark();
          try {
            this.startIndex = input.index;
            this.prevAccept.reset();
            let s0 = this.atn.modeToDFA[mode].s0;
            if (s0 == null) {
              return this.matchATN(input);
            } else {
              return this.execATN(input, s0);
            }
          } finally {
            input.release(mark);
          }
        }
        reset() {
          this.prevAccept.reset();
          this.startIndex = -1;
          this._line = 1;
          this._charPositionInLine = 0;
          this.mode = Lexer_1.Lexer.DEFAULT_MODE;
        }
        matchATN(input) {
          let startState = this.atn.modeToStartState[this.mode];
          if (LexerATNSimulator3.debug) {
            console.log(`matchATN mode ${this.mode} start: ${startState}`);
          }
          let old_mode = this.mode;
          let s0_closure = this.computeStartState(input, startState);
          let suppressEdge = s0_closure.hasSemanticContext;
          if (suppressEdge) {
            s0_closure.hasSemanticContext = false;
          }
          let next = this.addDFAState(s0_closure);
          if (!suppressEdge) {
            let dfa = this.atn.modeToDFA[this.mode];
            if (!dfa.s0) {
              dfa.s0 = next;
            } else {
              next = dfa.s0;
            }
          }
          let predict = this.execATN(input, next);
          if (LexerATNSimulator3.debug) {
            console.log(`DFA after matchATN: ${this.atn.modeToDFA[old_mode].toLexerString()}`);
          }
          return predict;
        }
        execATN(input, ds0) {
          if (LexerATNSimulator3.debug) {
            console.log(`start state closure=${ds0.configs}`);
          }
          if (ds0.isAcceptState) {
            this.captureSimState(this.prevAccept, input, ds0);
          }
          let t = input.LA(1);
          let s = ds0;
          while (true) {
            if (LexerATNSimulator3.debug) {
              console.log(`execATN loop starting closure: ${s.configs}`);
            }
            let target = this.getExistingTargetState(s, t);
            if (target == null) {
              target = this.computeTargetState(input, s, t);
            }
            if (target === ATNSimulator_1.ATNSimulator.ERROR) {
              break;
            }
            if (t !== IntStream_1.IntStream.EOF) {
              this.consume(input);
            }
            if (target.isAcceptState) {
              this.captureSimState(this.prevAccept, input, target);
              if (t === IntStream_1.IntStream.EOF) {
                break;
              }
            }
            t = input.LA(1);
            s = target;
          }
          return this.failOrAccept(this.prevAccept, input, s.configs, t);
        }
        /**
         * Get an existing target state for an edge in the DFA. If the target state
         * for the edge has not yet been computed or is otherwise not available,
         * this method returns `undefined`.
         *
         * @param s The current DFA state
         * @param t The next input symbol
         * @returns The existing target DFA state for the given input symbol
         * `t`, or `undefined` if the target state for this edge is not
         * already cached
         */
        getExistingTargetState(s, t) {
          let target = s.getTarget(t);
          if (LexerATNSimulator3.debug && target != null) {
            console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
          }
          return target;
        }
        /**
         * Compute a target state for an edge in the DFA, and attempt to add the
         * computed state and corresponding edge to the DFA.
         *
         * @param input The input stream
         * @param s The current DFA state
         * @param t The next input symbol
         *
         * @returns The computed target DFA state for the given input symbol
         * `t`. If `t` does not lead to a valid DFA state, this method
         * returns {@link #ERROR}.
         */
        computeTargetState(input, s, t) {
          let reach = new OrderedATNConfigSet_1.OrderedATNConfigSet();
          this.getReachableConfigSet(input, s.configs, reach, t);
          if (reach.isEmpty) {
            if (!reach.hasSemanticContext) {
              this.addDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
            }
            return ATNSimulator_1.ATNSimulator.ERROR;
          }
          return this.addDFAEdge(s, t, reach);
        }
        failOrAccept(prevAccept, input, reach, t) {
          if (prevAccept.dfaState != null) {
            let lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
            this.accept(input, lexerActionExecutor, this.startIndex, prevAccept.index, prevAccept.line, prevAccept.charPos);
            return prevAccept.dfaState.prediction;
          } else {
            if (t === IntStream_1.IntStream.EOF && input.index === this.startIndex) {
              return Token_1.Token.EOF;
            }
            throw new LexerNoViableAltException_1.LexerNoViableAltException(this.recog, input, this.startIndex, reach);
          }
        }
        /** Given a starting configuration set, figure out all ATN configurations
         *  we can reach upon input `t`. Parameter `reach` is a return
         *  parameter.
         */
        getReachableConfigSet(input, closure, reach, t) {
          let skipAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
          for (let c of closure) {
            let currentAltReachedAcceptState = c.alt === skipAlt;
            if (currentAltReachedAcceptState && c.hasPassedThroughNonGreedyDecision) {
              continue;
            }
            if (LexerATNSimulator3.debug) {
              console.log(`testing ${this.getTokenName(t)} at ${c.toString(this.recog, true)}`);
            }
            let n = c.state.numberOfOptimizedTransitions;
            for (let ti = 0; ti < n; ti++) {
              let trans = c.state.getOptimizedTransition(ti);
              let target = this.getReachableTarget(trans, t);
              if (target != null) {
                let lexerActionExecutor = c.lexerActionExecutor;
                let config2;
                if (lexerActionExecutor != null) {
                  lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
                  config2 = c.transform(target, true, lexerActionExecutor);
                } else {
                  assert2(c.lexerActionExecutor == null);
                  config2 = c.transform(target, true);
                }
                let treatEofAsEpsilon = t === IntStream_1.IntStream.EOF;
                if (this.closure(input, config2, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
                  skipAlt = c.alt;
                  break;
                }
              }
            }
          }
        }
        accept(input, lexerActionExecutor, startIndex, index, line, charPos) {
          if (LexerATNSimulator3.debug) {
            console.log(`ACTION ${lexerActionExecutor}`);
          }
          input.seek(index);
          this._line = line;
          this._charPositionInLine = charPos;
          if (lexerActionExecutor != null && this.recog != null) {
            lexerActionExecutor.execute(this.recog, input, startIndex);
          }
        }
        getReachableTarget(trans, t) {
          if (trans.matches(t, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
            return trans.target;
          }
          return void 0;
        }
        computeStartState(input, p) {
          let initialContext = PredictionContext_1.PredictionContext.EMPTY_FULL;
          let configs = new OrderedATNConfigSet_1.OrderedATNConfigSet();
          for (let i = 0; i < p.numberOfTransitions; i++) {
            let target = p.transition(i).target;
            let c = ATNConfig_1.ATNConfig.create(target, i + 1, initialContext);
            this.closure(input, c, configs, false, false, false);
          }
          return configs;
        }
        /**
         * Since the alternatives within any lexer decision are ordered by
         * preference, this method stops pursuing the closure as soon as an accept
         * state is reached. After the first accept state is reached by depth-first
         * search from `config`, all other (potentially reachable) states for
         * this rule would have a lower priority.
         *
         * @returns `true` if an accept state is reached, otherwise
         * `false`.
         */
        closure(input, config2, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
          if (LexerATNSimulator3.debug) {
            console.log("closure(" + config2.toString(this.recog, true) + ")");
          }
          if (config2.state instanceof RuleStopState_1.RuleStopState) {
            if (LexerATNSimulator3.debug) {
              if (this.recog != null) {
                console.log(`closure at ${this.recog.ruleNames[config2.state.ruleIndex]} rule stop ${config2}`);
              } else {
                console.log(`closure at rule stop ${config2}`);
              }
            }
            let context = config2.context;
            if (context.isEmpty) {
              configs.add(config2);
              return true;
            } else if (context.hasEmpty) {
              configs.add(config2.transform(config2.state, true, PredictionContext_1.PredictionContext.EMPTY_FULL));
              currentAltReachedAcceptState = true;
            }
            for (let i = 0; i < context.size; i++) {
              let returnStateNumber = context.getReturnState(i);
              if (returnStateNumber === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                continue;
              }
              let newContext = context.getParent(i);
              let returnState = this.atn.states[returnStateNumber];
              let c = config2.transform(returnState, false, newContext);
              currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
            }
            return currentAltReachedAcceptState;
          }
          if (!config2.state.onlyHasEpsilonTransitions) {
            if (!currentAltReachedAcceptState || !config2.hasPassedThroughNonGreedyDecision) {
              configs.add(config2);
            }
          }
          let p = config2.state;
          for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {
            let t = p.getOptimizedTransition(i);
            let c = this.getEpsilonTarget(input, config2, t, configs, speculative, treatEofAsEpsilon);
            if (c != null) {
              currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
            }
          }
          return currentAltReachedAcceptState;
        }
        // side-effect: can alter configs.hasSemanticContext
        getEpsilonTarget(input, config2, t, configs, speculative, treatEofAsEpsilon) {
          let c;
          switch (t.serializationType) {
            case 3:
              let ruleTransition = t;
              if (this.optimize_tail_calls && ruleTransition.optimizedTailCall && !config2.context.hasEmpty) {
                c = config2.transform(t.target, true);
              } else {
                let newContext = config2.context.getChild(ruleTransition.followState.stateNumber);
                c = config2.transform(t.target, true, newContext);
              }
              break;
            case 10:
              throw new Error("Precedence predicates are not supported in lexers.");
            case 4:
              let pt = t;
              if (LexerATNSimulator3.debug) {
                console.log("EVAL rule " + pt.ruleIndex + ":" + pt.predIndex);
              }
              configs.hasSemanticContext = true;
              if (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) {
                c = config2.transform(t.target, true);
              } else {
                c = void 0;
              }
              break;
            case 6:
              if (config2.context.hasEmpty) {
                let lexerActionExecutor = LexerActionExecutor_1.LexerActionExecutor.append(config2.lexerActionExecutor, this.atn.lexerActions[t.actionIndex]);
                c = config2.transform(t.target, true, lexerActionExecutor);
                break;
              } else {
                c = config2.transform(t.target, true);
                break;
              }
            case 1:
              c = config2.transform(t.target, true);
              break;
            case 5:
            case 2:
            case 7:
              if (treatEofAsEpsilon) {
                if (t.matches(IntStream_1.IntStream.EOF, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
                  c = config2.transform(t.target, false);
                  break;
                }
              }
              c = void 0;
              break;
            default:
              c = void 0;
              break;
          }
          return c;
        }
        /**
         * Evaluate a predicate specified in the lexer.
         *
         * If `speculative` is `true`, this method was called before
         * {@link #consume} for the matched character. This method should call
         * {@link #consume} before evaluating the predicate to ensure position
         * sensitive values, including {@link Lexer#getText}, {@link Lexer#getLine},
         * and {@link Lexer#getCharPositionInLine}, properly reflect the current
         * lexer state. This method should restore `input` and the simulator
         * to the original state before returning (i.e. undo the actions made by the
         * call to {@link #consume}.
         *
         * @param input The input stream.
         * @param ruleIndex The rule containing the predicate.
         * @param predIndex The index of the predicate within the rule.
         * @param speculative `true` if the current index in `input` is
         * one character before the predicate's location.
         *
         * @returns `true` if the specified predicate evaluates to
         * `true`.
         */
        evaluatePredicate(input, ruleIndex, predIndex, speculative) {
          if (this.recog == null) {
            return true;
          }
          if (!speculative) {
            return this.recog.sempred(void 0, ruleIndex, predIndex);
          }
          let savedCharPositionInLine = this._charPositionInLine;
          let savedLine = this._line;
          let index = input.index;
          let marker = input.mark();
          try {
            this.consume(input);
            return this.recog.sempred(void 0, ruleIndex, predIndex);
          } finally {
            this._charPositionInLine = savedCharPositionInLine;
            this._line = savedLine;
            input.seek(index);
            input.release(marker);
          }
        }
        captureSimState(settings, input, dfaState) {
          settings.index = input.index;
          settings.line = this._line;
          settings.charPos = this._charPositionInLine;
          settings.dfaState = dfaState;
        }
        addDFAEdge(p, t, q) {
          if (q instanceof ATNConfigSet_1.ATNConfigSet) {
            let suppressEdge = q.hasSemanticContext;
            if (suppressEdge) {
              q.hasSemanticContext = false;
            }
            let to = this.addDFAState(q);
            if (suppressEdge) {
              return to;
            }
            this.addDFAEdge(p, t, to);
            return to;
          } else {
            if (LexerATNSimulator3.debug) {
              console.log("EDGE " + p + " -> " + q + " upon " + String.fromCharCode(t));
            }
            if (p != null) {
              p.setTarget(t, q);
            }
          }
        }
        /** Add a new DFA state if there isn't one with this set of
         * 	configurations already. This method also detects the first
         * 	configuration containing an ATN rule stop state. Later, when
         * 	traversing the DFA, we will know which rule to accept.
         */
        addDFAState(configs) {
          assert2(!configs.hasSemanticContext);
          let proposed = new DFAState_1.DFAState(configs);
          let existing = this.atn.modeToDFA[this.mode].states.get(proposed);
          if (existing != null) {
            return existing;
          }
          configs.optimizeConfigs(this);
          let newState = new DFAState_1.DFAState(configs.clone(true));
          let firstConfigWithRuleStopState;
          for (let c of configs) {
            if (c.state instanceof RuleStopState_1.RuleStopState) {
              firstConfigWithRuleStopState = c;
              break;
            }
          }
          if (firstConfigWithRuleStopState != null) {
            let prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
            let lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
            newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(prediction, lexerActionExecutor);
          }
          return this.atn.modeToDFA[this.mode].addState(newState);
        }
        getDFA(mode) {
          return this.atn.modeToDFA[mode];
        }
        /** Get the text matched so far for the current token.
         */
        getText(input) {
          return input.getText(Interval_1.Interval.of(this.startIndex, input.index - 1));
        }
        get line() {
          return this._line;
        }
        set line(line) {
          this._line = line;
        }
        get charPositionInLine() {
          return this._charPositionInLine;
        }
        set charPositionInLine(charPositionInLine) {
          this._charPositionInLine = charPositionInLine;
        }
        consume(input) {
          let curChar = input.LA(1);
          if (curChar === "\n".charCodeAt(0)) {
            this._line++;
            this._charPositionInLine = 0;
          } else {
            this._charPositionInLine++;
          }
          input.consume();
        }
        getTokenName(t) {
          if (t === -1) {
            return "EOF";
          }
          return "'" + String.fromCharCode(t) + "'";
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], LexerATNSimulator2.prototype, "prevAccept", void 0);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "copyState", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "match", null);
      __decorate([
        Decorators_1.Override
      ], LexerATNSimulator2.prototype, "reset", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "matchATN", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "execATN", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "getExistingTargetState", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "computeTargetState", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "getReachableConfigSet", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "accept", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "computeStartState", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "closure", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull),
        __param(3, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "getEpsilonTarget", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "evaluatePredicate", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "captureSimState", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "addDFAState", null);
      __decorate([
        Decorators_1.NotNull
      ], LexerATNSimulator2.prototype, "getDFA", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "getText", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2.prototype, "consume", null);
      __decorate([
        Decorators_1.NotNull
      ], LexerATNSimulator2.prototype, "getTokenName", null);
      LexerATNSimulator2 = __decorate([
        __param(0, Decorators_1.NotNull)
      ], LexerATNSimulator2);
      exports.LexerATNSimulator = LexerATNSimulator2;
      (function(LexerATNSimulator3) {
        LexerATNSimulator3.debug = false;
        LexerATNSimulator3.dfa_debug = false;
        class SimState {
          constructor() {
            this.index = -1;
            this.line = 0;
            this.charPos = -1;
          }
          reset() {
            this.index = -1;
            this.line = 0;
            this.charPos = -1;
            this.dfaState = void 0;
          }
        }
        LexerATNSimulator3.SimState = SimState;
      })(LexerATNSimulator2 = exports.LexerATNSimulator || (exports.LexerATNSimulator = {}));
      exports.LexerATNSimulator = LexerATNSimulator2;
    }
  });

  // node_modules/antlr4ts/Lexer.js
  var require_Lexer = __commonJS({
    "node_modules/antlr4ts/Lexer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Lexer = void 0;
      var CommonTokenFactory_1 = require_CommonTokenFactory();
      var IntegerStack_1 = require_IntegerStack();
      var Interval_1 = require_Interval();
      var IntStream_1 = require_IntStream();
      var LexerATNSimulator_1 = require_LexerATNSimulator();
      var LexerNoViableAltException_1 = require_LexerNoViableAltException();
      var Decorators_1 = require_Decorators();
      var Recognizer_1 = require_Recognizer();
      var Token_1 = require_Token();
      var Lexer2 = class _Lexer extends Recognizer_1.Recognizer {
        constructor(input) {
          super();
          this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
          this._tokenStartCharIndex = -1;
          this._tokenStartLine = 0;
          this._tokenStartCharPositionInLine = 0;
          this._hitEOF = false;
          this._channel = 0;
          this._type = 0;
          this._modeStack = new IntegerStack_1.IntegerStack();
          this._mode = _Lexer.DEFAULT_MODE;
          this._input = input;
          this._tokenFactorySourcePair = { source: this, stream: input };
        }
        static get DEFAULT_TOKEN_CHANNEL() {
          return Token_1.Token.DEFAULT_CHANNEL;
        }
        static get HIDDEN() {
          return Token_1.Token.HIDDEN_CHANNEL;
        }
        reset(resetInput) {
          if (resetInput === void 0 || resetInput) {
            this._input.seek(0);
          }
          this._token = void 0;
          this._type = Token_1.Token.INVALID_TYPE;
          this._channel = Token_1.Token.DEFAULT_CHANNEL;
          this._tokenStartCharIndex = -1;
          this._tokenStartCharPositionInLine = -1;
          this._tokenStartLine = -1;
          this._text = void 0;
          this._hitEOF = false;
          this._mode = _Lexer.DEFAULT_MODE;
          this._modeStack.clear();
          this.interpreter.reset();
        }
        /** Return a token from this source; i.e., match a token on the char
         *  stream.
         */
        nextToken() {
          if (this._input == null) {
            throw new Error("nextToken requires a non-null input stream.");
          }
          let tokenStartMarker = this._input.mark();
          try {
            outer: while (true) {
              if (this._hitEOF) {
                return this.emitEOF();
              }
              this._token = void 0;
              this._channel = Token_1.Token.DEFAULT_CHANNEL;
              this._tokenStartCharIndex = this._input.index;
              this._tokenStartCharPositionInLine = this.interpreter.charPositionInLine;
              this._tokenStartLine = this.interpreter.line;
              this._text = void 0;
              do {
                this._type = Token_1.Token.INVALID_TYPE;
                let ttype;
                try {
                  ttype = this.interpreter.match(this._input, this._mode);
                } catch (e) {
                  if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
                    this.notifyListeners(e);
                    this.recover(e);
                    ttype = _Lexer.SKIP;
                  } else {
                    throw e;
                  }
                }
                if (this._input.LA(1) === IntStream_1.IntStream.EOF) {
                  this._hitEOF = true;
                }
                if (this._type === Token_1.Token.INVALID_TYPE) {
                  this._type = ttype;
                }
                if (this._type === _Lexer.SKIP) {
                  continue outer;
                }
              } while (this._type === _Lexer.MORE);
              if (this._token == null) {
                return this.emit();
              }
              return this._token;
            }
          } finally {
            this._input.release(tokenStartMarker);
          }
        }
        /** Instruct the lexer to skip creating a token for current lexer rule
         *  and look for another token.  nextToken() knows to keep looking when
         *  a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
         *  if token==undefined at end of any token rule, it creates one for you
         *  and emits it.
         */
        skip() {
          this._type = _Lexer.SKIP;
        }
        more() {
          this._type = _Lexer.MORE;
        }
        mode(m) {
          this._mode = m;
        }
        pushMode(m) {
          if (LexerATNSimulator_1.LexerATNSimulator.debug) {
            console.log("pushMode " + m);
          }
          this._modeStack.push(this._mode);
          this.mode(m);
        }
        popMode() {
          if (this._modeStack.isEmpty) {
            throw new Error("EmptyStackException");
          }
          if (LexerATNSimulator_1.LexerATNSimulator.debug) {
            console.log("popMode back to " + this._modeStack.peek());
          }
          this.mode(this._modeStack.pop());
          return this._mode;
        }
        get tokenFactory() {
          return this._factory;
        }
        // @Override
        set tokenFactory(factory) {
          this._factory = factory;
        }
        get inputStream() {
          return this._input;
        }
        /** Set the char stream and reset the lexer */
        set inputStream(input) {
          this.reset(false);
          this._input = input;
          this._tokenFactorySourcePair = { source: this, stream: this._input };
        }
        get sourceName() {
          return this._input.sourceName;
        }
        emit(token) {
          if (!token) {
            token = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.charIndex - 1, this._tokenStartLine, this._tokenStartCharPositionInLine);
          }
          this._token = token;
          return token;
        }
        emitEOF() {
          let cpos = this.charPositionInLine;
          let line = this.line;
          let eof = this._factory.create(this._tokenFactorySourcePair, Token_1.Token.EOF, void 0, Token_1.Token.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, line, cpos);
          this.emit(eof);
          return eof;
        }
        get line() {
          return this.interpreter.line;
        }
        set line(line) {
          this.interpreter.line = line;
        }
        get charPositionInLine() {
          return this.interpreter.charPositionInLine;
        }
        set charPositionInLine(charPositionInLine) {
          this.interpreter.charPositionInLine = charPositionInLine;
        }
        /** What is the index of the current character of lookahead? */
        get charIndex() {
          return this._input.index;
        }
        /** Return the text matched so far for the current token or any
         *  text override.
         */
        get text() {
          if (this._text != null) {
            return this._text;
          }
          return this.interpreter.getText(this._input);
        }
        /** Set the complete text of this token; it wipes any previous
         *  changes to the text.
         */
        set text(text) {
          this._text = text;
        }
        /** Override if emitting multiple tokens. */
        get token() {
          return this._token;
        }
        set token(_token) {
          this._token = _token;
        }
        set type(ttype) {
          this._type = ttype;
        }
        get type() {
          return this._type;
        }
        set channel(channel) {
          this._channel = channel;
        }
        get channel() {
          return this._channel;
        }
        /** Return a list of all Token objects in input char stream.
         *  Forces load of all tokens. Does not include EOF token.
         */
        getAllTokens() {
          let tokens = [];
          let t = this.nextToken();
          while (t.type !== Token_1.Token.EOF) {
            tokens.push(t);
            t = this.nextToken();
          }
          return tokens;
        }
        notifyListeners(e) {
          let text = this._input.getText(Interval_1.Interval.of(this._tokenStartCharIndex, this._input.index));
          let msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
          let listener = this.getErrorListenerDispatch();
          if (listener.syntaxError) {
            listener.syntaxError(this, void 0, this._tokenStartLine, this._tokenStartCharPositionInLine, msg, e);
          }
        }
        getErrorDisplay(s) {
          if (typeof s === "number") {
            switch (s) {
              case Token_1.Token.EOF:
                return "<EOF>";
              case 10:
                return "\\n";
              case 9:
                return "\\t";
              case 13:
                return "\\r";
            }
            return String.fromCharCode(s);
          }
          return s.replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r");
        }
        getCharErrorDisplay(c) {
          let s = this.getErrorDisplay(c);
          return "'" + s + "'";
        }
        recover(re) {
          if (re instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
            if (this._input.LA(1) !== IntStream_1.IntStream.EOF) {
              this.interpreter.consume(this._input);
            }
          } else {
            this._input.consume();
          }
        }
      };
      Lexer2.DEFAULT_MODE = 0;
      Lexer2.MORE = -2;
      Lexer2.SKIP = -3;
      Lexer2.MIN_CHAR_VALUE = 0;
      Lexer2.MAX_CHAR_VALUE = 1114111;
      __decorate([
        Decorators_1.Override
      ], Lexer2.prototype, "nextToken", null);
      __decorate([
        Decorators_1.Override
      ], Lexer2.prototype, "tokenFactory", null);
      __decorate([
        Decorators_1.Override
      ], Lexer2.prototype, "inputStream", null);
      __decorate([
        Decorators_1.Override
      ], Lexer2.prototype, "sourceName", null);
      __decorate([
        Decorators_1.Override
      ], Lexer2.prototype, "line", null);
      __decorate([
        Decorators_1.Override
      ], Lexer2.prototype, "charPositionInLine", null);
      exports.Lexer = Lexer2;
    }
  });

  // node_modules/antlr4ts/misc/IntervalSet.js
  var require_IntervalSet = __commonJS({
    "node_modules/antlr4ts/misc/IntervalSet.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IntervalSet = void 0;
      var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
      var IntegerList_1 = require_IntegerList();
      var Interval_1 = require_Interval();
      var Lexer_1 = require_Lexer();
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var IntervalSet = class _IntervalSet {
        constructor(intervals) {
          this.readonly = false;
          if (intervals != null) {
            this._intervals = intervals.slice(0);
          } else {
            this._intervals = [];
          }
        }
        static get COMPLETE_CHAR_SET() {
          if (_IntervalSet._COMPLETE_CHAR_SET === void 0) {
            _IntervalSet._COMPLETE_CHAR_SET = _IntervalSet.of(Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE);
            _IntervalSet._COMPLETE_CHAR_SET.setReadonly(true);
          }
          return _IntervalSet._COMPLETE_CHAR_SET;
        }
        static get EMPTY_SET() {
          if (_IntervalSet._EMPTY_SET == null) {
            _IntervalSet._EMPTY_SET = new _IntervalSet();
            _IntervalSet._EMPTY_SET.setReadonly(true);
          }
          return _IntervalSet._EMPTY_SET;
        }
        /**
         * Create a set with all ints within range [a..b] (inclusive). If b is omitted, the set contains the single element
         * a.
         */
        static of(a, b = a) {
          let s = new _IntervalSet();
          s.add(a, b);
          return s;
        }
        clear() {
          if (this.readonly) {
            throw new Error("can't alter readonly IntervalSet");
          }
          this._intervals.length = 0;
        }
        /** Add interval; i.e., add all integers from a to b to set.
         *  If b&lt;a, do nothing.
         *  Keep list in sorted order (by left range value).
         *  If overlap, combine ranges.  For example,
         *  If this is {1..5, 10..20}, adding 6..7 yields
         *  {1..5, 6..7, 10..20}.  Adding 4..8 yields {1..8, 10..20}.
         */
        add(a, b = a) {
          this.addRange(Interval_1.Interval.of(a, b));
        }
        // copy on write so we can cache a..a intervals and sets of that
        addRange(addition) {
          if (this.readonly) {
            throw new Error("can't alter readonly IntervalSet");
          }
          if (addition.b < addition.a) {
            return;
          }
          for (let i = 0; i < this._intervals.length; i++) {
            let r = this._intervals[i];
            if (addition.equals(r)) {
              return;
            }
            if (addition.adjacent(r) || !addition.disjoint(r)) {
              let bigger = addition.union(r);
              this._intervals[i] = bigger;
              while (i < this._intervals.length - 1) {
                i++;
                let next = this._intervals[i];
                if (!bigger.adjacent(next) && bigger.disjoint(next)) {
                  break;
                }
                this._intervals.splice(i, 1);
                i--;
                this._intervals[i] = bigger.union(next);
              }
              return;
            }
            if (addition.startsBeforeDisjoint(r)) {
              this._intervals.splice(i, 0, addition);
              return;
            }
          }
          this._intervals.push(addition);
        }
        /** combine all sets in the array returned the or'd value */
        static or(sets) {
          let r = new _IntervalSet();
          for (let s of sets) {
            r.addAll(s);
          }
          return r;
        }
        addAll(set2) {
          if (set2 == null) {
            return this;
          }
          if (set2 instanceof _IntervalSet) {
            let other = set2;
            let n = other._intervals.length;
            for (let i = 0; i < n; i++) {
              let I = other._intervals[i];
              this.add(I.a, I.b);
            }
          } else {
            for (let value of set2.toArray()) {
              this.add(value);
            }
          }
          return this;
        }
        complementRange(minElement, maxElement) {
          return this.complement(_IntervalSet.of(minElement, maxElement));
        }
        /** {@inheritDoc} */
        complement(vocabulary) {
          if (vocabulary.isNil) {
            return _IntervalSet.EMPTY_SET;
          }
          let vocabularyIS;
          if (vocabulary instanceof _IntervalSet) {
            vocabularyIS = vocabulary;
          } else {
            vocabularyIS = new _IntervalSet();
            vocabularyIS.addAll(vocabulary);
          }
          return vocabularyIS.subtract(this);
        }
        subtract(a) {
          if (a == null || a.isNil) {
            return new _IntervalSet(this._intervals);
          }
          if (a instanceof _IntervalSet) {
            return _IntervalSet.subtract(this, a);
          }
          let other = new _IntervalSet();
          other.addAll(a);
          return _IntervalSet.subtract(this, other);
        }
        /**
         * Compute the set difference between two interval sets. The specific
         * operation is `left - right`.
         */
        static subtract(left, right) {
          if (left.isNil) {
            return new _IntervalSet();
          }
          let result = new _IntervalSet(left._intervals);
          if (right.isNil) {
            return result;
          }
          let resultI = 0;
          let rightI = 0;
          while (resultI < result._intervals.length && rightI < right._intervals.length) {
            let resultInterval = result._intervals[resultI];
            let rightInterval = right._intervals[rightI];
            if (rightInterval.b < resultInterval.a) {
              rightI++;
              continue;
            }
            if (rightInterval.a > resultInterval.b) {
              resultI++;
              continue;
            }
            let beforeCurrent;
            let afterCurrent;
            if (rightInterval.a > resultInterval.a) {
              beforeCurrent = new Interval_1.Interval(resultInterval.a, rightInterval.a - 1);
            }
            if (rightInterval.b < resultInterval.b) {
              afterCurrent = new Interval_1.Interval(rightInterval.b + 1, resultInterval.b);
            }
            if (beforeCurrent) {
              if (afterCurrent) {
                result._intervals[resultI] = beforeCurrent;
                result._intervals.splice(resultI + 1, 0, afterCurrent);
                resultI++;
                rightI++;
                continue;
              } else {
                result._intervals[resultI] = beforeCurrent;
                resultI++;
                continue;
              }
            } else {
              if (afterCurrent) {
                result._intervals[resultI] = afterCurrent;
                rightI++;
                continue;
              } else {
                result._intervals.splice(resultI, 1);
                continue;
              }
            }
          }
          return result;
        }
        or(a) {
          let o = new _IntervalSet();
          o.addAll(this);
          o.addAll(a);
          return o;
        }
        /** {@inheritDoc} */
        and(other) {
          if (other.isNil) {
            return new _IntervalSet();
          }
          let myIntervals = this._intervals;
          let theirIntervals = other._intervals;
          let intersection2;
          let mySize = myIntervals.length;
          let theirSize = theirIntervals.length;
          let i = 0;
          let j = 0;
          while (i < mySize && j < theirSize) {
            let mine = myIntervals[i];
            let theirs = theirIntervals[j];
            if (mine.startsBeforeDisjoint(theirs)) {
              i++;
            } else if (theirs.startsBeforeDisjoint(mine)) {
              j++;
            } else if (mine.properlyContains(theirs)) {
              if (!intersection2) {
                intersection2 = new _IntervalSet();
              }
              intersection2.addRange(mine.intersection(theirs));
              j++;
            } else if (theirs.properlyContains(mine)) {
              if (!intersection2) {
                intersection2 = new _IntervalSet();
              }
              intersection2.addRange(mine.intersection(theirs));
              i++;
            } else if (!mine.disjoint(theirs)) {
              if (!intersection2) {
                intersection2 = new _IntervalSet();
              }
              intersection2.addRange(mine.intersection(theirs));
              if (mine.startsAfterNonDisjoint(theirs)) {
                j++;
              } else if (theirs.startsAfterNonDisjoint(mine)) {
                i++;
              }
            }
          }
          if (!intersection2) {
            return new _IntervalSet();
          }
          return intersection2;
        }
        /** {@inheritDoc} */
        contains(el) {
          let n = this._intervals.length;
          let l = 0;
          let r = n - 1;
          while (l <= r) {
            let m = l + r >> 1;
            let I = this._intervals[m];
            let a = I.a;
            let b = I.b;
            if (b < el) {
              l = m + 1;
            } else if (a > el) {
              r = m - 1;
            } else {
              return true;
            }
          }
          return false;
        }
        /** {@inheritDoc} */
        get isNil() {
          return this._intervals == null || this._intervals.length === 0;
        }
        /**
         * Returns the maximum value contained in the set if not isNil.
         *
         * @return the maximum value contained in the set.
         * @throws RangeError if set is empty
         */
        get maxElement() {
          if (this.isNil) {
            throw new RangeError("set is empty");
          }
          let last = this._intervals[this._intervals.length - 1];
          return last.b;
        }
        /**
         * Returns the minimum value contained in the set if not isNil.
         *
         * @return the minimum value contained in the set.
         * @throws RangeError if set is empty
         */
        get minElement() {
          if (this.isNil) {
            throw new RangeError("set is empty");
          }
          return this._intervals[0].a;
        }
        /** Return a list of Interval objects. */
        get intervals() {
          return this._intervals;
        }
        hashCode() {
          let hash2 = MurmurHash_1.MurmurHash.initialize();
          for (let I of this._intervals) {
            hash2 = MurmurHash_1.MurmurHash.update(hash2, I.a);
            hash2 = MurmurHash_1.MurmurHash.update(hash2, I.b);
          }
          hash2 = MurmurHash_1.MurmurHash.finish(hash2, this._intervals.length * 2);
          return hash2;
        }
        /** Are two IntervalSets equal?  Because all intervals are sorted
         *  and disjoint, equals is a simple linear walk over both lists
         *  to make sure they are the same.  Interval.equals() is used
         *  by the List.equals() method to check the ranges.
         */
        equals(o) {
          if (o == null || !(o instanceof _IntervalSet)) {
            return false;
          }
          return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._intervals, o._intervals);
        }
        toString(elemAreChar = false) {
          let buf = "";
          if (this._intervals == null || this._intervals.length === 0) {
            return "{}";
          }
          if (this.size > 1) {
            buf += "{";
          }
          let first = true;
          for (let I of this._intervals) {
            if (first) {
              first = false;
            } else {
              buf += ", ";
            }
            let a = I.a;
            let b = I.b;
            if (a === b) {
              if (a === Token_1.Token.EOF) {
                buf += "<EOF>";
              } else if (elemAreChar) {
                buf += "'" + String.fromCodePoint(a) + "'";
              } else {
                buf += a;
              }
            } else {
              if (elemAreChar) {
                buf += "'" + String.fromCodePoint(a) + "'..'" + String.fromCodePoint(b) + "'";
              } else {
                buf += a + ".." + b;
              }
            }
          }
          if (this.size > 1) {
            buf += "}";
          }
          return buf;
        }
        toStringVocabulary(vocabulary) {
          if (this._intervals == null || this._intervals.length === 0) {
            return "{}";
          }
          let buf = "";
          if (this.size > 1) {
            buf += "{";
          }
          let first = true;
          for (let I of this._intervals) {
            if (first) {
              first = false;
            } else {
              buf += ", ";
            }
            let a = I.a;
            let b = I.b;
            if (a === b) {
              buf += this.elementName(vocabulary, a);
            } else {
              for (let i = a; i <= b; i++) {
                if (i > a) {
                  buf += ", ";
                }
                buf += this.elementName(vocabulary, i);
              }
            }
          }
          if (this.size > 1) {
            buf += "}";
          }
          return buf;
        }
        elementName(vocabulary, a) {
          if (a === Token_1.Token.EOF) {
            return "<EOF>";
          } else if (a === Token_1.Token.EPSILON) {
            return "<EPSILON>";
          } else {
            return vocabulary.getDisplayName(a);
          }
        }
        get size() {
          let n = 0;
          let numIntervals = this._intervals.length;
          if (numIntervals === 1) {
            let firstInterval = this._intervals[0];
            return firstInterval.b - firstInterval.a + 1;
          }
          for (let i = 0; i < numIntervals; i++) {
            let I = this._intervals[i];
            n += I.b - I.a + 1;
          }
          return n;
        }
        toIntegerList() {
          let values = new IntegerList_1.IntegerList(this.size);
          let n = this._intervals.length;
          for (let i = 0; i < n; i++) {
            let I = this._intervals[i];
            let a = I.a;
            let b = I.b;
            for (let v = a; v <= b; v++) {
              values.add(v);
            }
          }
          return values;
        }
        toSet() {
          let s = /* @__PURE__ */ new Set();
          for (let I of this._intervals) {
            let a = I.a;
            let b = I.b;
            for (let v = a; v <= b; v++) {
              s.add(v);
            }
          }
          return s;
        }
        toArray() {
          let values = new Array();
          let n = this._intervals.length;
          for (let i = 0; i < n; i++) {
            let I = this._intervals[i];
            let a = I.a;
            let b = I.b;
            for (let v = a; v <= b; v++) {
              values.push(v);
            }
          }
          return values;
        }
        remove(el) {
          if (this.readonly) {
            throw new Error("can't alter readonly IntervalSet");
          }
          let n = this._intervals.length;
          for (let i = 0; i < n; i++) {
            let I = this._intervals[i];
            let a = I.a;
            let b = I.b;
            if (el < a) {
              break;
            }
            if (el === a && el === b) {
              this._intervals.splice(i, 1);
              break;
            }
            if (el === a) {
              this._intervals[i] = Interval_1.Interval.of(I.a + 1, I.b);
              break;
            }
            if (el === b) {
              this._intervals[i] = Interval_1.Interval.of(I.a, I.b - 1);
              break;
            }
            if (el > a && el < b) {
              let oldb = I.b;
              this._intervals[i] = Interval_1.Interval.of(I.a, el - 1);
              this.add(el + 1, oldb);
            }
          }
        }
        get isReadonly() {
          return this.readonly;
        }
        setReadonly(readonly2) {
          if (this.readonly && !readonly2) {
            throw new Error("can't alter readonly IntervalSet");
          }
          this.readonly = readonly2;
        }
      };
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "addAll", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "complement", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "subtract", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "or", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "and", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "contains", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "isNil", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "equals", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], IntervalSet.prototype, "toStringVocabulary", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], IntervalSet.prototype, "elementName", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], IntervalSet.prototype, "remove", null);
      __decorate([
        Decorators_1.NotNull
      ], IntervalSet, "of", null);
      __decorate([
        Decorators_1.NotNull
      ], IntervalSet, "subtract", null);
      exports.IntervalSet = IntervalSet;
    }
  });

  // node_modules/antlr4ts/atn/ATNDeserializationOptions.js
  var require_ATNDeserializationOptions = __commonJS({
    "node_modules/antlr4ts/atn/ATNDeserializationOptions.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATNDeserializationOptions = void 0;
      var Decorators_1 = require_Decorators();
      var ATNDeserializationOptions = class _ATNDeserializationOptions {
        constructor(options) {
          this.readOnly = false;
          if (options) {
            this.verifyATN = options.verifyATN;
            this.generateRuleBypassTransitions = options.generateRuleBypassTransitions;
            this.optimize = options.optimize;
          } else {
            this.verifyATN = true;
            this.generateRuleBypassTransitions = false;
            this.optimize = true;
          }
        }
        static get defaultOptions() {
          if (_ATNDeserializationOptions._defaultOptions == null) {
            _ATNDeserializationOptions._defaultOptions = new _ATNDeserializationOptions();
            _ATNDeserializationOptions._defaultOptions.makeReadOnly();
          }
          return _ATNDeserializationOptions._defaultOptions;
        }
        get isReadOnly() {
          return this.readOnly;
        }
        makeReadOnly() {
          this.readOnly = true;
        }
        get isVerifyATN() {
          return this.verifyATN;
        }
        set isVerifyATN(verifyATN) {
          this.throwIfReadOnly();
          this.verifyATN = verifyATN;
        }
        get isGenerateRuleBypassTransitions() {
          return this.generateRuleBypassTransitions;
        }
        set isGenerateRuleBypassTransitions(generateRuleBypassTransitions) {
          this.throwIfReadOnly();
          this.generateRuleBypassTransitions = generateRuleBypassTransitions;
        }
        get isOptimize() {
          return this.optimize;
        }
        set isOptimize(optimize) {
          this.throwIfReadOnly();
          this.optimize = optimize;
        }
        throwIfReadOnly() {
          if (this.isReadOnly) {
            throw new Error("The object is read only.");
          }
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ATNDeserializationOptions, "defaultOptions", null);
      exports.ATNDeserializationOptions = ATNDeserializationOptions;
    }
  });

  // node_modules/antlr4ts/atn/ActionTransition.js
  var require_ActionTransition = __commonJS({
    "node_modules/antlr4ts/atn/ActionTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ActionTransition = void 0;
      var Decorators_1 = require_Decorators();
      var Transition_1 = require_Transition();
      var ActionTransition = class ActionTransition extends Transition_1.Transition {
        constructor(target, ruleIndex, actionIndex = -1, isCtxDependent = false) {
          super(target);
          this.ruleIndex = ruleIndex;
          this.actionIndex = actionIndex;
          this.isCtxDependent = isCtxDependent;
        }
        get serializationType() {
          return 6;
        }
        get isEpsilon() {
          return true;
        }
        matches(symbol2, minVocabSymbol, maxVocabSymbol) {
          return false;
        }
        toString() {
          return "action_" + this.ruleIndex + ":" + this.actionIndex;
        }
      };
      __decorate([
        Decorators_1.Override
      ], ActionTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override
      ], ActionTransition.prototype, "isEpsilon", null);
      __decorate([
        Decorators_1.Override
      ], ActionTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override
      ], ActionTransition.prototype, "toString", null);
      ActionTransition = __decorate([
        __param(0, Decorators_1.NotNull)
      ], ActionTransition);
      exports.ActionTransition = ActionTransition;
    }
  });

  // node_modules/antlr4ts/atn/AtomTransition.js
  var require_AtomTransition = __commonJS({
    "node_modules/antlr4ts/atn/AtomTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AtomTransition = void 0;
      var IntervalSet_1 = require_IntervalSet();
      var Decorators_1 = require_Decorators();
      var Transition_1 = require_Transition();
      var AtomTransition = class AtomTransition extends Transition_1.Transition {
        constructor(target, label) {
          super(target);
          this._label = label;
        }
        get serializationType() {
          return 5;
        }
        get label() {
          return IntervalSet_1.IntervalSet.of(this._label);
        }
        matches(symbol2, minVocabSymbol, maxVocabSymbol) {
          return this._label === symbol2;
        }
        toString() {
          return String(this.label);
        }
      };
      __decorate([
        Decorators_1.Override
      ], AtomTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], AtomTransition.prototype, "label", null);
      __decorate([
        Decorators_1.Override
      ], AtomTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], AtomTransition.prototype, "toString", null);
      AtomTransition = __decorate([
        __param(0, Decorators_1.NotNull)
      ], AtomTransition);
      exports.AtomTransition = AtomTransition;
    }
  });

  // node_modules/antlr4ts/atn/BlockStartState.js
  var require_BlockStartState = __commonJS({
    "node_modules/antlr4ts/atn/BlockStartState.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BlockStartState = void 0;
      var DecisionState_1 = require_DecisionState();
      var BlockStartState = class extends DecisionState_1.DecisionState {
      };
      exports.BlockStartState = BlockStartState;
    }
  });

  // node_modules/antlr4ts/atn/BasicBlockStartState.js
  var require_BasicBlockStartState = __commonJS({
    "node_modules/antlr4ts/atn/BasicBlockStartState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BasicBlockStartState = void 0;
      var ATNStateType_1 = require_ATNStateType();
      var BlockStartState_1 = require_BlockStartState();
      var Decorators_1 = require_Decorators();
      var BasicBlockStartState = class extends BlockStartState_1.BlockStartState {
        get stateType() {
          return ATNStateType_1.ATNStateType.BLOCK_START;
        }
      };
      __decorate([
        Decorators_1.Override
      ], BasicBlockStartState.prototype, "stateType", null);
      exports.BasicBlockStartState = BasicBlockStartState;
    }
  });

  // node_modules/antlr4ts/atn/BlockEndState.js
  var require_BlockEndState = __commonJS({
    "node_modules/antlr4ts/atn/BlockEndState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BlockEndState = void 0;
      var ATNState_1 = require_ATNState();
      var ATNStateType_1 = require_ATNStateType();
      var Decorators_1 = require_Decorators();
      var BlockEndState = class extends ATNState_1.ATNState {
        get stateType() {
          return ATNStateType_1.ATNStateType.BLOCK_END;
        }
      };
      __decorate([
        Decorators_1.Override
      ], BlockEndState.prototype, "stateType", null);
      exports.BlockEndState = BlockEndState;
    }
  });

  // node_modules/antlr4ts/atn/EpsilonTransition.js
  var require_EpsilonTransition = __commonJS({
    "node_modules/antlr4ts/atn/EpsilonTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EpsilonTransition = void 0;
      var Decorators_1 = require_Decorators();
      var Transition_1 = require_Transition();
      var EpsilonTransition = class EpsilonTransition extends Transition_1.Transition {
        constructor(target, outermostPrecedenceReturn = -1) {
          super(target);
          this._outermostPrecedenceReturn = outermostPrecedenceReturn;
        }
        /**
         * @returns the rule index of a precedence rule for which this transition is
         * returning from, where the precedence value is 0; otherwise, -1.
         *
         * @see ATNConfig.isPrecedenceFilterSuppressed
         * @see ParserATNSimulator#applyPrecedenceFilter(ATNConfigSet, ParserRuleContext, PredictionContextCache)
         * @since 4.4.1
         */
        get outermostPrecedenceReturn() {
          return this._outermostPrecedenceReturn;
        }
        get serializationType() {
          return 1;
        }
        get isEpsilon() {
          return true;
        }
        matches(symbol2, minVocabSymbol, maxVocabSymbol) {
          return false;
        }
        toString() {
          return "epsilon";
        }
      };
      __decorate([
        Decorators_1.Override
      ], EpsilonTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override
      ], EpsilonTransition.prototype, "isEpsilon", null);
      __decorate([
        Decorators_1.Override
      ], EpsilonTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], EpsilonTransition.prototype, "toString", null);
      EpsilonTransition = __decorate([
        __param(0, Decorators_1.NotNull)
      ], EpsilonTransition);
      exports.EpsilonTransition = EpsilonTransition;
    }
  });

  // node_modules/antlr4ts/atn/LexerChannelAction.js
  var require_LexerChannelAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerChannelAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerChannelAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerChannelAction = class _LexerChannelAction {
        /**
         * Constructs a new `channel` action with the specified channel value.
         * @param channel The channel value to pass to {@link Lexer#setChannel}.
         */
        constructor(channel) {
          this._channel = channel;
        }
        /**
         * Gets the channel to use for the {@link Token} created by the lexer.
         *
         * @returns The channel to use for the {@link Token} created by the lexer.
         */
        get channel() {
          return this._channel;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns {@link LexerActionType#CHANNEL}.
         */
        get actionType() {
          return 0;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns `false`.
         */
        get isPositionDependent() {
          return false;
        }
        /**
         * {@inheritDoc}
         *
         * This action is implemented by calling {@link Lexer#setChannel} with the
         * value provided by {@link #getChannel}.
         */
        execute(lexer) {
          lexer.channel = this._channel;
        }
        hashCode() {
          let hash2 = MurmurHash_1.MurmurHash.initialize();
          hash2 = MurmurHash_1.MurmurHash.update(hash2, this.actionType);
          hash2 = MurmurHash_1.MurmurHash.update(hash2, this._channel);
          return MurmurHash_1.MurmurHash.finish(hash2, 2);
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof _LexerChannelAction)) {
            return false;
          }
          return this._channel === obj._channel;
        }
        toString() {
          return `channel(${this._channel})`;
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerChannelAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerChannelAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], LexerChannelAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerChannelAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerChannelAction.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], LexerChannelAction.prototype, "toString", null);
      exports.LexerChannelAction = LexerChannelAction;
    }
  });

  // node_modules/antlr4ts/atn/LexerCustomAction.js
  var require_LexerCustomAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerCustomAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerCustomAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerCustomAction = class _LexerCustomAction {
        /**
         * Constructs a custom lexer action with the specified rule and action
         * indexes.
         *
         * @param ruleIndex The rule index to use for calls to
         * {@link Recognizer#action}.
         * @param actionIndex The action index to use for calls to
         * {@link Recognizer#action}.
         */
        constructor(ruleIndex, actionIndex) {
          this._ruleIndex = ruleIndex;
          this._actionIndex = actionIndex;
        }
        /**
         * Gets the rule index to use for calls to {@link Recognizer#action}.
         *
         * @returns The rule index for the custom action.
         */
        get ruleIndex() {
          return this._ruleIndex;
        }
        /**
         * Gets the action index to use for calls to {@link Recognizer#action}.
         *
         * @returns The action index for the custom action.
         */
        get actionIndex() {
          return this._actionIndex;
        }
        /**
         * {@inheritDoc}
         *
         * @returns This method returns {@link LexerActionType#CUSTOM}.
         */
        get actionType() {
          return 1;
        }
        /**
         * Gets whether the lexer action is position-dependent. Position-dependent
         * actions may have different semantics depending on the {@link CharStream}
         * index at the time the action is executed.
         *
         * Custom actions are position-dependent since they may represent a
         * user-defined embedded action which makes calls to methods like
         * {@link Lexer#getText}.
         *
         * @returns This method returns `true`.
         */
        get isPositionDependent() {
          return true;
        }
        /**
         * {@inheritDoc}
         *
         * Custom actions are implemented by calling {@link Lexer#action} with the
         * appropriate rule and action indexes.
         */
        execute(lexer) {
          lexer.action(void 0, this._ruleIndex, this._actionIndex);
        }
        hashCode() {
          let hash2 = MurmurHash_1.MurmurHash.initialize();
          hash2 = MurmurHash_1.MurmurHash.update(hash2, this.actionType);
          hash2 = MurmurHash_1.MurmurHash.update(hash2, this._ruleIndex);
          hash2 = MurmurHash_1.MurmurHash.update(hash2, this._actionIndex);
          return MurmurHash_1.MurmurHash.finish(hash2, 3);
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof _LexerCustomAction)) {
            return false;
          }
          return this._ruleIndex === obj._ruleIndex && this._actionIndex === obj._actionIndex;
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerCustomAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerCustomAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], LexerCustomAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerCustomAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerCustomAction.prototype, "equals", null);
      exports.LexerCustomAction = LexerCustomAction;
    }
  });

  // node_modules/antlr4ts/atn/LexerModeAction.js
  var require_LexerModeAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerModeAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerModeAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerModeAction = class _LexerModeAction {
        /**
         * Constructs a new `mode` action with the specified mode value.
         * @param mode The mode value to pass to {@link Lexer#mode}.
         */
        constructor(mode) {
          this._mode = mode;
        }
        /**
         * Get the lexer mode this action should transition the lexer to.
         *
         * @returns The lexer mode for this `mode` command.
         */
        get mode() {
          return this._mode;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns {@link LexerActionType#MODE}.
         */
        get actionType() {
          return 2;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns `false`.
         */
        get isPositionDependent() {
          return false;
        }
        /**
         * {@inheritDoc}
         *
         * This action is implemented by calling {@link Lexer#mode} with the
         * value provided by {@link #getMode}.
         */
        execute(lexer) {
          lexer.mode(this._mode);
        }
        hashCode() {
          let hash2 = MurmurHash_1.MurmurHash.initialize();
          hash2 = MurmurHash_1.MurmurHash.update(hash2, this.actionType);
          hash2 = MurmurHash_1.MurmurHash.update(hash2, this._mode);
          return MurmurHash_1.MurmurHash.finish(hash2, 2);
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof _LexerModeAction)) {
            return false;
          }
          return this._mode === obj._mode;
        }
        toString() {
          return `mode(${this._mode})`;
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerModeAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerModeAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], LexerModeAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerModeAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerModeAction.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], LexerModeAction.prototype, "toString", null);
      exports.LexerModeAction = LexerModeAction;
    }
  });

  // node_modules/antlr4ts/atn/LexerMoreAction.js
  var require_LexerMoreAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerMoreAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerMoreAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerMoreAction = class {
        /**
         * Constructs the singleton instance of the lexer `more` command.
         */
        constructor() {
        }
        /**
         * {@inheritDoc}
         * @returns This method returns {@link LexerActionType#MORE}.
         */
        get actionType() {
          return 3;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns `false`.
         */
        get isPositionDependent() {
          return false;
        }
        /**
         * {@inheritDoc}
         *
         * This action is implemented by calling {@link Lexer#more}.
         */
        execute(lexer) {
          lexer.more();
        }
        hashCode() {
          let hash2 = MurmurHash_1.MurmurHash.initialize();
          hash2 = MurmurHash_1.MurmurHash.update(hash2, this.actionType);
          return MurmurHash_1.MurmurHash.finish(hash2, 1);
        }
        equals(obj) {
          return obj === this;
        }
        toString() {
          return "more";
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerMoreAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerMoreAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], LexerMoreAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerMoreAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerMoreAction.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], LexerMoreAction.prototype, "toString", null);
      exports.LexerMoreAction = LexerMoreAction;
      (function(LexerMoreAction2) {
        LexerMoreAction2.INSTANCE = new LexerMoreAction2();
      })(LexerMoreAction = exports.LexerMoreAction || (exports.LexerMoreAction = {}));
    }
  });

  // node_modules/antlr4ts/atn/LexerPopModeAction.js
  var require_LexerPopModeAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerPopModeAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerPopModeAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerPopModeAction = class {
        /**
         * Constructs the singleton instance of the lexer `popMode` command.
         */
        constructor() {
        }
        /**
         * {@inheritDoc}
         * @returns This method returns {@link LexerActionType#POP_MODE}.
         */
        get actionType() {
          return 4;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns `false`.
         */
        get isPositionDependent() {
          return false;
        }
        /**
         * {@inheritDoc}
         *
         * This action is implemented by calling {@link Lexer#popMode}.
         */
        execute(lexer) {
          lexer.popMode();
        }
        hashCode() {
          let hash2 = MurmurHash_1.MurmurHash.initialize();
          hash2 = MurmurHash_1.MurmurHash.update(hash2, this.actionType);
          return MurmurHash_1.MurmurHash.finish(hash2, 1);
        }
        equals(obj) {
          return obj === this;
        }
        toString() {
          return "popMode";
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerPopModeAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerPopModeAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], LexerPopModeAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerPopModeAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerPopModeAction.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], LexerPopModeAction.prototype, "toString", null);
      exports.LexerPopModeAction = LexerPopModeAction;
      (function(LexerPopModeAction2) {
        LexerPopModeAction2.INSTANCE = new LexerPopModeAction2();
      })(LexerPopModeAction = exports.LexerPopModeAction || (exports.LexerPopModeAction = {}));
    }
  });

  // node_modules/antlr4ts/atn/LexerPushModeAction.js
  var require_LexerPushModeAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerPushModeAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerPushModeAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerPushModeAction = class _LexerPushModeAction {
        /**
         * Constructs a new `pushMode` action with the specified mode value.
         * @param mode The mode value to pass to {@link Lexer#pushMode}.
         */
        constructor(mode) {
          this._mode = mode;
        }
        /**
         * Get the lexer mode this action should transition the lexer to.
         *
         * @returns The lexer mode for this `pushMode` command.
         */
        get mode() {
          return this._mode;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns {@link LexerActionType#PUSH_MODE}.
         */
        get actionType() {
          return 5;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns `false`.
         */
        get isPositionDependent() {
          return false;
        }
        /**
         * {@inheritDoc}
         *
         * This action is implemented by calling {@link Lexer#pushMode} with the
         * value provided by {@link #getMode}.
         */
        execute(lexer) {
          lexer.pushMode(this._mode);
        }
        hashCode() {
          let hash2 = MurmurHash_1.MurmurHash.initialize();
          hash2 = MurmurHash_1.MurmurHash.update(hash2, this.actionType);
          hash2 = MurmurHash_1.MurmurHash.update(hash2, this._mode);
          return MurmurHash_1.MurmurHash.finish(hash2, 2);
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof _LexerPushModeAction)) {
            return false;
          }
          return this._mode === obj._mode;
        }
        toString() {
          return `pushMode(${this._mode})`;
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerPushModeAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerPushModeAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], LexerPushModeAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerPushModeAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerPushModeAction.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], LexerPushModeAction.prototype, "toString", null);
      exports.LexerPushModeAction = LexerPushModeAction;
    }
  });

  // node_modules/antlr4ts/atn/LexerSkipAction.js
  var require_LexerSkipAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerSkipAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerSkipAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerSkipAction = class {
        /**
         * Constructs the singleton instance of the lexer `skip` command.
         */
        constructor() {
        }
        /**
         * {@inheritDoc}
         * @returns This method returns {@link LexerActionType#SKIP}.
         */
        get actionType() {
          return 6;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns `false`.
         */
        get isPositionDependent() {
          return false;
        }
        /**
         * {@inheritDoc}
         *
         * This action is implemented by calling {@link Lexer#skip}.
         */
        execute(lexer) {
          lexer.skip();
        }
        hashCode() {
          let hash2 = MurmurHash_1.MurmurHash.initialize();
          hash2 = MurmurHash_1.MurmurHash.update(hash2, this.actionType);
          return MurmurHash_1.MurmurHash.finish(hash2, 1);
        }
        equals(obj) {
          return obj === this;
        }
        toString() {
          return "skip";
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerSkipAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerSkipAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], LexerSkipAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerSkipAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerSkipAction.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], LexerSkipAction.prototype, "toString", null);
      exports.LexerSkipAction = LexerSkipAction;
      (function(LexerSkipAction2) {
        LexerSkipAction2.INSTANCE = new LexerSkipAction2();
      })(LexerSkipAction = exports.LexerSkipAction || (exports.LexerSkipAction = {}));
    }
  });

  // node_modules/antlr4ts/atn/LexerTypeAction.js
  var require_LexerTypeAction = __commonJS({
    "node_modules/antlr4ts/atn/LexerTypeAction.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerTypeAction = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var LexerTypeAction = class _LexerTypeAction {
        /**
         * Constructs a new `type` action with the specified token type value.
         * @param type The type to assign to the token using `Lexer.type`.
         */
        constructor(type) {
          this._type = type;
        }
        /**
         * Gets the type to assign to a token created by the lexer.
         * @returns The type to assign to a token created by the lexer.
         */
        get type() {
          return this._type;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns {@link LexerActionType#TYPE}.
         */
        get actionType() {
          return 7;
        }
        /**
         * {@inheritDoc}
         * @returns This method returns `false`.
         */
        get isPositionDependent() {
          return false;
        }
        /**
         * {@inheritDoc}
         *
         * This action is implemented by setting `Lexer.type` with the
         * value provided by `type`.
         */
        execute(lexer) {
          lexer.type = this._type;
        }
        hashCode() {
          let hash2 = MurmurHash_1.MurmurHash.initialize();
          hash2 = MurmurHash_1.MurmurHash.update(hash2, this.actionType);
          hash2 = MurmurHash_1.MurmurHash.update(hash2, this._type);
          return MurmurHash_1.MurmurHash.finish(hash2, 2);
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof _LexerTypeAction)) {
            return false;
          }
          return this._type === obj._type;
        }
        toString() {
          return `type(${this._type})`;
        }
      };
      __decorate([
        Decorators_1.Override
      ], LexerTypeAction.prototype, "actionType", null);
      __decorate([
        Decorators_1.Override
      ], LexerTypeAction.prototype, "isPositionDependent", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], LexerTypeAction.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], LexerTypeAction.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], LexerTypeAction.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], LexerTypeAction.prototype, "toString", null);
      exports.LexerTypeAction = LexerTypeAction;
    }
  });

  // node_modules/antlr4ts/atn/LoopEndState.js
  var require_LoopEndState = __commonJS({
    "node_modules/antlr4ts/atn/LoopEndState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LoopEndState = void 0;
      var ATNState_1 = require_ATNState();
      var ATNStateType_1 = require_ATNStateType();
      var Decorators_1 = require_Decorators();
      var LoopEndState = class extends ATNState_1.ATNState {
        get stateType() {
          return ATNStateType_1.ATNStateType.LOOP_END;
        }
      };
      __decorate([
        Decorators_1.Override
      ], LoopEndState.prototype, "stateType", null);
      exports.LoopEndState = LoopEndState;
    }
  });

  // node_modules/antlr4ts/atn/ConflictInfo.js
  var require_ConflictInfo = __commonJS({
    "node_modules/antlr4ts/atn/ConflictInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConflictInfo = void 0;
      var Decorators_1 = require_Decorators();
      var Utils3 = require_Utils();
      var ConflictInfo = class _ConflictInfo {
        constructor(conflictedAlts, exact) {
          this._conflictedAlts = conflictedAlts;
          this.exact = exact;
        }
        /**
         * Gets the set of conflicting alternatives for the configuration set.
         */
        get conflictedAlts() {
          return this._conflictedAlts;
        }
        /**
         * Gets whether or not the configuration conflict is an exact conflict.
         * An exact conflict occurs when the prediction algorithm determines that
         * the represented alternatives for a particular configuration set cannot be
         * further reduced by consuming additional input. After reaching an exact
         * conflict during an SLL prediction, only switch to full-context prediction
         * could reduce the set of viable alternatives. In LL prediction, an exact
         * conflict indicates a true ambiguity in the input.
         *
         * For the {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} prediction mode,
         * accept states are conflicting but not exact are treated as non-accept
         * states.
         */
        get isExact() {
          return this.exact;
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof _ConflictInfo)) {
            return false;
          }
          return this.isExact === obj.isExact && Utils3.equals(this.conflictedAlts, obj.conflictedAlts);
        }
        hashCode() {
          return this.conflictedAlts.hashCode();
        }
      };
      __decorate([
        Decorators_1.Override
      ], ConflictInfo.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], ConflictInfo.prototype, "hashCode", null);
      exports.ConflictInfo = ConflictInfo;
    }
  });

  // node_modules/antlr4ts/tree/TerminalNode.js
  var require_TerminalNode = __commonJS({
    "node_modules/antlr4ts/tree/TerminalNode.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TerminalNode = void 0;
      var Interval_1 = require_Interval();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var TerminalNode2 = class {
        constructor(symbol2) {
          this._symbol = symbol2;
        }
        getChild(i) {
          throw new RangeError("Terminal Node has no children.");
        }
        get symbol() {
          return this._symbol;
        }
        get parent() {
          return this._parent;
        }
        setParent(parent) {
          this._parent = parent;
        }
        get payload() {
          return this._symbol;
        }
        get sourceInterval() {
          let tokenIndex = this._symbol.tokenIndex;
          return new Interval_1.Interval(tokenIndex, tokenIndex);
        }
        get childCount() {
          return 0;
        }
        accept(visitor) {
          return visitor.visitTerminal(this);
        }
        get text() {
          return this._symbol.text || "";
        }
        toStringTree(parser) {
          return this.toString();
        }
        toString() {
          if (this._symbol.type === Token_1.Token.EOF) {
            return "<EOF>";
          }
          return this._symbol.text || "";
        }
      };
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "getChild", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "parent", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "setParent", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "payload", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "sourceInterval", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "childCount", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "accept", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "text", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "toStringTree", null);
      __decorate([
        Decorators_1.Override
      ], TerminalNode2.prototype, "toString", null);
      exports.TerminalNode = TerminalNode2;
    }
  });

  // node_modules/antlr4ts/tree/ErrorNode.js
  var require_ErrorNode = __commonJS({
    "node_modules/antlr4ts/tree/ErrorNode.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ErrorNode = void 0;
      var Decorators_1 = require_Decorators();
      var TerminalNode_1 = require_TerminalNode();
      var ErrorNode2 = class extends TerminalNode_1.TerminalNode {
        constructor(token) {
          super(token);
        }
        accept(visitor) {
          return visitor.visitErrorNode(this);
        }
      };
      __decorate([
        Decorators_1.Override
      ], ErrorNode2.prototype, "accept", null);
      exports.ErrorNode = ErrorNode2;
    }
  });

  // node_modules/antlr4ts/tree/RuleNode.js
  var require_RuleNode = __commonJS({
    "node_modules/antlr4ts/tree/RuleNode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleNode = void 0;
      var RuleNode = class {
      };
      exports.RuleNode = RuleNode;
    }
  });

  // node_modules/antlr4ts/tree/Trees.js
  var require_Trees = __commonJS({
    "node_modules/antlr4ts/tree/Trees.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Trees = void 0;
      var ATN_1 = require_ATN();
      var CommonToken_1 = require_CommonToken();
      var ErrorNode_1 = require_ErrorNode();
      var Decorators_1 = require_Decorators();
      var Parser_1 = require_Parser();
      var ParserRuleContext_1 = require_ParserRuleContext();
      var RuleNode_1 = require_RuleNode();
      var TerminalNode_1 = require_TerminalNode();
      var Token_1 = require_Token();
      var Utils3 = require_Utils();
      var Trees = class _Trees {
        static toStringTree(t, arg2) {
          let ruleNames;
          if (arg2 instanceof Parser_1.Parser) {
            ruleNames = arg2.ruleNames;
          } else {
            ruleNames = arg2;
          }
          let s = Utils3.escapeWhitespace(this.getNodeText(t, ruleNames), false);
          if (t.childCount === 0) {
            return s;
          }
          let buf = "";
          buf += "(";
          s = Utils3.escapeWhitespace(this.getNodeText(t, ruleNames), false);
          buf += s;
          buf += " ";
          for (let i = 0; i < t.childCount; i++) {
            if (i > 0) {
              buf += " ";
            }
            buf += this.toStringTree(t.getChild(i), ruleNames);
          }
          buf += ")";
          return buf;
        }
        static getNodeText(t, arg2) {
          let ruleNames;
          if (arg2 instanceof Parser_1.Parser) {
            ruleNames = arg2.ruleNames;
          } else if (arg2) {
            ruleNames = arg2;
          } else {
            let payload = t.payload;
            if (typeof payload.text === "string") {
              return payload.text;
            }
            return t.payload.toString();
          }
          if (t instanceof RuleNode_1.RuleNode) {
            let ruleContext = t.ruleContext;
            let ruleIndex = ruleContext.ruleIndex;
            let ruleName = ruleNames[ruleIndex];
            let altNumber = ruleContext.altNumber;
            if (altNumber !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              return ruleName + ":" + altNumber;
            }
            return ruleName;
          } else if (t instanceof ErrorNode_1.ErrorNode) {
            return t.toString();
          } else if (t instanceof TerminalNode_1.TerminalNode) {
            let symbol2 = t.symbol;
            return symbol2.text || "";
          }
          throw new TypeError("Unexpected node type");
        }
        static getChildren(t) {
          let kids = [];
          for (let i = 0; i < t.childCount; i++) {
            kids.push(t.getChild(i));
          }
          return kids;
        }
        static getAncestors(t) {
          let ancestors = [];
          let p = t.parent;
          while (p) {
            ancestors.unshift(p);
            p = p.parent;
          }
          return ancestors;
        }
        /** Return true if t is u's parent or a node on path to root from u.
         *  Use === not equals().
         *
         *  @since 4.5.1
         */
        static isAncestorOf(t, u) {
          if (!t || !u || !t.parent) {
            return false;
          }
          let p = u.parent;
          while (p) {
            if (t === p) {
              return true;
            }
            p = p.parent;
          }
          return false;
        }
        static findAllTokenNodes(t, ttype) {
          return _Trees.findAllNodes(t, ttype, true);
        }
        static findAllRuleNodes(t, ruleIndex) {
          return _Trees.findAllNodes(t, ruleIndex, false);
        }
        static findAllNodes(t, index, findTokens) {
          let nodes = [];
          _Trees._findAllNodes(t, index, findTokens, nodes);
          return nodes;
        }
        static _findAllNodes(t, index, findTokens, nodes) {
          if (findTokens && t instanceof TerminalNode_1.TerminalNode) {
            if (t.symbol.type === index) {
              nodes.push(t);
            }
          } else if (!findTokens && t instanceof ParserRuleContext_1.ParserRuleContext) {
            if (t.ruleIndex === index) {
              nodes.push(t);
            }
          }
          for (let i = 0; i < t.childCount; i++) {
            _Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);
          }
        }
        /** Get all descendents; includes t itself.
         *
         * @since 4.5.1
         */
        static getDescendants(t) {
          let nodes = [];
          function recurse(e) {
            nodes.push(e);
            const n = e.childCount;
            for (let i = 0; i < n; i++) {
              recurse(e.getChild(i));
            }
          }
          recurse(t);
          return nodes;
        }
        /** Find smallest subtree of t enclosing range startTokenIndex..stopTokenIndex
         *  inclusively using postorder traversal.  Recursive depth-first-search.
         *
         *  @since 4.5
         */
        static getRootOfSubtreeEnclosingRegion(t, startTokenIndex, stopTokenIndex) {
          let n = t.childCount;
          for (let i = 0; i < n; i++) {
            let child = t.getChild(i);
            let r = _Trees.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);
            if (r) {
              return r;
            }
          }
          if (t instanceof ParserRuleContext_1.ParserRuleContext) {
            let stopToken = t.stop;
            if (startTokenIndex >= t.start.tokenIndex && // is range fully contained in t?
            (stopToken == null || stopTokenIndex <= stopToken.tokenIndex)) {
              return t;
            }
          }
          return void 0;
        }
        /** Replace any subtree siblings of root that are completely to left
         *  or right of lookahead range with a CommonToken(Token.INVALID_TYPE,"...")
         *  node. The source interval for t is not altered to suit smaller range!
         *
         *  WARNING: destructive to t.
         *
         *  @since 4.5.1
         */
        static stripChildrenOutOfRange(t, root, startIndex, stopIndex) {
          if (!t) {
            return;
          }
          let count = t.childCount;
          for (let i = 0; i < count; i++) {
            let child = t.getChild(i);
            let range = child.sourceInterval;
            if (child instanceof ParserRuleContext_1.ParserRuleContext && (range.b < startIndex || range.a > stopIndex)) {
              if (_Trees.isAncestorOf(child, root)) {
                let abbrev = new CommonToken_1.CommonToken(Token_1.Token.INVALID_TYPE, "...");
                t.children[i] = new TerminalNode_1.TerminalNode(abbrev);
              }
            }
          }
        }
        static findNodeSuchThat(t, pred) {
          if (pred(t)) {
            return t;
          }
          let n = t.childCount;
          for (let i = 0; i < n; i++) {
            let u = _Trees.findNodeSuchThat(t.getChild(i), pred);
            if (u !== void 0) {
              return u;
            }
          }
          return void 0;
        }
      };
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], Trees, "toStringTree", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], Trees, "getAncestors", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], Trees, "getRootOfSubtreeEnclosingRegion", null);
      exports.Trees = Trees;
    }
  });

  // node_modules/antlr4ts/RuleContext.js
  var require_RuleContext = __commonJS({
    "node_modules/antlr4ts/RuleContext.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleContext = void 0;
      var ATN_1 = require_ATN();
      var Recognizer_1 = require_Recognizer();
      var RuleNode_1 = require_RuleNode();
      var Interval_1 = require_Interval();
      var Decorators_1 = require_Decorators();
      var Trees_1 = require_Trees();
      var ParserRuleContext_1 = require_ParserRuleContext();
      var RuleContext = class _RuleContext extends RuleNode_1.RuleNode {
        constructor(parent, invokingState) {
          super();
          this._parent = parent;
          this.invokingState = invokingState != null ? invokingState : -1;
        }
        static getChildContext(parent, invokingState) {
          return new _RuleContext(parent, invokingState);
        }
        depth() {
          let n = 0;
          let p = this;
          while (p) {
            p = p._parent;
            n++;
          }
          return n;
        }
        /** A context is empty if there is no invoking state; meaning nobody called
         *  current context.
         */
        get isEmpty() {
          return this.invokingState === -1;
        }
        // satisfy the ParseTree / SyntaxTree interface
        get sourceInterval() {
          return Interval_1.Interval.INVALID;
        }
        get ruleContext() {
          return this;
        }
        get parent() {
          return this._parent;
        }
        /** @since 4.7. {@see ParseTree#setParent} comment */
        setParent(parent) {
          this._parent = parent;
        }
        get payload() {
          return this;
        }
        /** Return the combined text of all child nodes. This method only considers
         *  tokens which have been added to the parse tree.
         *
         *  Since tokens on hidden channels (e.g. whitespace or comments) are not
         *  added to the parse trees, they will not appear in the output of this
         *  method.
         */
        get text() {
          if (this.childCount === 0) {
            return "";
          }
          let builder = "";
          for (let i = 0; i < this.childCount; i++) {
            builder += this.getChild(i).text;
          }
          return builder.toString();
        }
        get ruleIndex() {
          return -1;
        }
        /** For rule associated with this parse tree internal node, return
         *  the outer alternative number used to match the input. Default
         *  implementation does not compute nor store this alt num. Create
         *  a subclass of ParserRuleContext with backing field and set
         *  option contextSuperClass.
         *  to set it.
         *
         *  @since 4.5.3
         */
        get altNumber() {
          return ATN_1.ATN.INVALID_ALT_NUMBER;
        }
        /** Set the outer alternative number for this context node. Default
         *  implementation does nothing to avoid backing field overhead for
         *  trees that don't need it.  Create
         *  a subclass of ParserRuleContext with backing field and set
         *  option contextSuperClass.
         *
         *  @since 4.5.3
         */
        set altNumber(altNumber) {
        }
        getChild(i) {
          throw new RangeError("i must be greater than or equal to 0 and less than childCount");
        }
        get childCount() {
          return 0;
        }
        accept(visitor) {
          return visitor.visitChildren(this);
        }
        toStringTree(recog) {
          return Trees_1.Trees.toStringTree(this, recog);
        }
        toString(arg1, stop) {
          const ruleNames = arg1 instanceof Recognizer_1.Recognizer ? arg1.ruleNames : arg1;
          stop = stop || ParserRuleContext_1.ParserRuleContext.emptyContext();
          let buf = "";
          let p = this;
          buf += "[";
          while (p && p !== stop) {
            if (!ruleNames) {
              if (!p.isEmpty) {
                buf += p.invokingState;
              }
            } else {
              let ruleIndex = p.ruleIndex;
              let ruleName = ruleIndex >= 0 && ruleIndex < ruleNames.length ? ruleNames[ruleIndex] : ruleIndex.toString();
              buf += ruleName;
            }
            if (p._parent && (ruleNames || !p._parent.isEmpty)) {
              buf += " ";
            }
            p = p._parent;
          }
          buf += "]";
          return buf.toString();
        }
      };
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "sourceInterval", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "ruleContext", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "parent", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "setParent", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "payload", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "text", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "getChild", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "childCount", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "accept", null);
      __decorate([
        Decorators_1.Override
      ], RuleContext.prototype, "toStringTree", null);
      exports.RuleContext = RuleContext;
    }
  });

  // node_modules/antlr4ts/ParserRuleContext.js
  var require_ParserRuleContext = __commonJS({
    "node_modules/antlr4ts/ParserRuleContext.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParserRuleContext = void 0;
      var ErrorNode_1 = require_ErrorNode();
      var Interval_1 = require_Interval();
      var Decorators_1 = require_Decorators();
      var RuleContext_1 = require_RuleContext();
      var TerminalNode_1 = require_TerminalNode();
      var ParserRuleContext2 = class _ParserRuleContext extends RuleContext_1.RuleContext {
        constructor(parent, invokingStateNumber) {
          if (invokingStateNumber == null) {
            super();
          } else {
            super(parent, invokingStateNumber);
          }
        }
        static emptyContext() {
          return _ParserRuleContext.EMPTY;
        }
        /**
         * COPY a ctx (I'm deliberately not using copy constructor) to avoid
         * confusion with creating node with parent. Does not copy children
         * (except error leaves).
         *
         * This is used in the generated parser code to flip a generic XContext
         * node for rule X to a YContext for alt label Y. In that sense, it is not
         * really a generic copy function.
         *
         * If we do an error sync() at start of a rule, we might add error nodes
         * to the generic XContext so this function must copy those nodes to the
         * YContext as well else they are lost!
         */
        copyFrom(ctx) {
          this._parent = ctx._parent;
          this.invokingState = ctx.invokingState;
          this._start = ctx._start;
          this._stop = ctx._stop;
          if (ctx.children) {
            this.children = [];
            for (let child of ctx.children) {
              if (child instanceof ErrorNode_1.ErrorNode) {
                this.addChild(child);
              }
            }
          }
        }
        // Double dispatch methods for listeners
        enterRule(listener) {
        }
        exitRule(listener) {
        }
        /** Add a parse tree node to this as a child.  Works for
         *  internal and leaf nodes. Does not set parent link;
         *  other add methods must do that. Other addChild methods
         *  call this.
         *
         *  We cannot set the parent pointer of the incoming node
         *  because the existing interfaces do not have a setParent()
         *  method and I don't want to break backward compatibility for this.
         *
         *  @since 4.7
         */
        addAnyChild(t) {
          if (!this.children) {
            this.children = [t];
          } else {
            this.children.push(t);
          }
          return t;
        }
        addChild(t) {
          let result;
          if (t instanceof TerminalNode_1.TerminalNode) {
            t.setParent(this);
            this.addAnyChild(t);
            return;
          } else if (t instanceof RuleContext_1.RuleContext) {
            this.addAnyChild(t);
            return;
          } else {
            t = new TerminalNode_1.TerminalNode(t);
            this.addAnyChild(t);
            t.setParent(this);
            return t;
          }
        }
        addErrorNode(node) {
          if (node instanceof ErrorNode_1.ErrorNode) {
            const errorNode = node;
            errorNode.setParent(this);
            return this.addAnyChild(errorNode);
          } else {
            const badToken = node;
            let t = new ErrorNode_1.ErrorNode(badToken);
            this.addAnyChild(t);
            t.setParent(this);
            return t;
          }
        }
        //	public void trace(int s) {
        //		if ( states==null ) states = new ArrayList<Integer>();
        //		states.add(s);
        //	}
        /** Used by enterOuterAlt to toss out a RuleContext previously added as
         *  we entered a rule. If we have # label, we will need to remove
         *  generic ruleContext object.
         */
        removeLastChild() {
          if (this.children) {
            this.children.pop();
          }
        }
        get parent() {
          let parent = super.parent;
          if (parent === void 0 || parent instanceof _ParserRuleContext) {
            return parent;
          }
          throw new TypeError("Invalid parent type for ParserRuleContext");
        }
        // Note: in TypeScript, order or arguments reversed
        getChild(i, ctxType) {
          if (!this.children || i < 0 || i >= this.children.length) {
            throw new RangeError("index parameter must be between >= 0 and <= number of children.");
          }
          if (ctxType == null) {
            return this.children[i];
          }
          let result = this.tryGetChild(i, ctxType);
          if (result === void 0) {
            throw new Error("The specified node does not exist");
          }
          return result;
        }
        tryGetChild(i, ctxType) {
          if (!this.children || i < 0 || i >= this.children.length) {
            return void 0;
          }
          let j = -1;
          for (let o of this.children) {
            if (o instanceof ctxType) {
              j++;
              if (j === i) {
                return o;
              }
            }
          }
          return void 0;
        }
        getToken(ttype, i) {
          let result = this.tryGetToken(ttype, i);
          if (result === void 0) {
            throw new Error("The specified token does not exist");
          }
          return result;
        }
        tryGetToken(ttype, i) {
          if (!this.children || i < 0 || i >= this.children.length) {
            return void 0;
          }
          let j = -1;
          for (let o of this.children) {
            if (o instanceof TerminalNode_1.TerminalNode) {
              let symbol2 = o.symbol;
              if (symbol2.type === ttype) {
                j++;
                if (j === i) {
                  return o;
                }
              }
            }
          }
          return void 0;
        }
        getTokens(ttype) {
          let tokens = [];
          if (!this.children) {
            return tokens;
          }
          for (let o of this.children) {
            if (o instanceof TerminalNode_1.TerminalNode) {
              let symbol2 = o.symbol;
              if (symbol2.type === ttype) {
                tokens.push(o);
              }
            }
          }
          return tokens;
        }
        get ruleContext() {
          return this;
        }
        // NOTE: argument order change from Java version
        getRuleContext(i, ctxType) {
          return this.getChild(i, ctxType);
        }
        tryGetRuleContext(i, ctxType) {
          return this.tryGetChild(i, ctxType);
        }
        getRuleContexts(ctxType) {
          let contexts = [];
          if (!this.children) {
            return contexts;
          }
          for (let o of this.children) {
            if (o instanceof ctxType) {
              contexts.push(o);
            }
          }
          return contexts;
        }
        get childCount() {
          return this.children ? this.children.length : 0;
        }
        get sourceInterval() {
          if (!this._start) {
            return Interval_1.Interval.INVALID;
          }
          if (!this._stop || this._stop.tokenIndex < this._start.tokenIndex) {
            return Interval_1.Interval.of(this._start.tokenIndex, this._start.tokenIndex - 1);
          }
          return Interval_1.Interval.of(this._start.tokenIndex, this._stop.tokenIndex);
        }
        /**
         * Get the initial token in this context.
         * Note that the range from start to stop is inclusive, so for rules that do not consume anything
         * (for example, zero length or error productions) this token may exceed stop.
         */
        get start() {
          return this._start;
        }
        /**
         * Get the final token in this context.
         * Note that the range from start to stop is inclusive, so for rules that do not consume anything
         * (for example, zero length or error productions) this token may precede start.
         */
        get stop() {
          return this._stop;
        }
        /** Used for rule context info debugging during parse-time, not so much for ATN debugging */
        toInfoString(recognizer) {
          let rules = recognizer.getRuleInvocationStack(this).reverse();
          return "ParserRuleContext" + rules + "{start=" + this._start + ", stop=" + this._stop + "}";
        }
      };
      ParserRuleContext2.EMPTY = new ParserRuleContext2();
      __decorate([
        Decorators_1.Override
      ], ParserRuleContext2.prototype, "parent", null);
      __decorate([
        Decorators_1.Override
      ], ParserRuleContext2.prototype, "childCount", null);
      __decorate([
        Decorators_1.Override
      ], ParserRuleContext2.prototype, "sourceInterval", null);
      exports.ParserRuleContext = ParserRuleContext2;
    }
  });

  // node_modules/antlr4ts/atn/PredictionMode.js
  var require_PredictionMode = __commonJS({
    "node_modules/antlr4ts/atn/PredictionMode.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PredictionMode = void 0;
      var Array2DHashMap_1 = require_Array2DHashMap();
      var MurmurHash_1 = require_MurmurHash();
      var Decorators_1 = require_Decorators();
      var RuleStopState_1 = require_RuleStopState();
      var PredictionMode;
      (function(PredictionMode2) {
        PredictionMode2[PredictionMode2["SLL"] = 0] = "SLL";
        PredictionMode2[PredictionMode2["LL"] = 1] = "LL";
        PredictionMode2[PredictionMode2["LL_EXACT_AMBIG_DETECTION"] = 2] = "LL_EXACT_AMBIG_DETECTION";
      })(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));
      (function(PredictionMode2) {
        class AltAndContextMap extends Array2DHashMap_1.Array2DHashMap {
          constructor() {
            super(AltAndContextConfigEqualityComparator.INSTANCE);
          }
        }
        class AltAndContextConfigEqualityComparator {
          AltAndContextConfigEqualityComparator() {
          }
          /**
           * The hash code is only a function of the {@link ATNState#stateNumber}
           * and {@link ATNConfig#context}.
           */
          hashCode(o) {
            let hashCode = MurmurHash_1.MurmurHash.initialize(7);
            hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.state.stateNumber);
            hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.context);
            hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 2);
            return hashCode;
          }
          equals(a, b) {
            if (a === b) {
              return true;
            }
            if (a == null || b == null) {
              return false;
            }
            return a.state.stateNumber === b.state.stateNumber && a.context.equals(b.context);
          }
        }
        AltAndContextConfigEqualityComparator.INSTANCE = new AltAndContextConfigEqualityComparator();
        __decorate([
          Decorators_1.Override
        ], AltAndContextConfigEqualityComparator.prototype, "hashCode", null);
        __decorate([
          Decorators_1.Override
        ], AltAndContextConfigEqualityComparator.prototype, "equals", null);
        function hasConfigInRuleStopState(configs) {
          for (let c of configs) {
            if (c.state instanceof RuleStopState_1.RuleStopState) {
              return true;
            }
          }
          return false;
        }
        PredictionMode2.hasConfigInRuleStopState = hasConfigInRuleStopState;
        function allConfigsInRuleStopStates(configs) {
          for (let config2 of configs) {
            if (!(config2.state instanceof RuleStopState_1.RuleStopState)) {
              return false;
            }
          }
          return true;
        }
        PredictionMode2.allConfigsInRuleStopStates = allConfigsInRuleStopStates;
      })(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));
    }
  });

  // node_modules/antlr4ts/atn/SimulatorState.js
  var require_SimulatorState = __commonJS({
    "node_modules/antlr4ts/atn/SimulatorState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SimulatorState = void 0;
      var Decorators_1 = require_Decorators();
      var ParserRuleContext_1 = require_ParserRuleContext();
      var SimulatorState = class SimulatorState {
        constructor(outerContext, s0, useContext, remainingOuterContext) {
          this.outerContext = outerContext != null ? outerContext : ParserRuleContext_1.ParserRuleContext.emptyContext();
          this.s0 = s0;
          this.useContext = useContext;
          this.remainingOuterContext = remainingOuterContext;
        }
      };
      SimulatorState = __decorate([
        __param(1, Decorators_1.NotNull)
      ], SimulatorState);
      exports.SimulatorState = SimulatorState;
    }
  });

  // node_modules/antlr4ts/atn/ParserATNSimulator.js
  var require_ParserATNSimulator = __commonJS({
    "node_modules/antlr4ts/atn/ParserATNSimulator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParserATNSimulator = void 0;
      var AcceptStateInfo_1 = require_AcceptStateInfo();
      var ActionTransition_1 = require_ActionTransition();
      var Array2DHashSet_1 = require_Array2DHashSet();
      var Arrays_1 = require_Arrays();
      var ATN_1 = require_ATN();
      var ATNConfig_1 = require_ATNConfig();
      var ATNConfigSet_1 = require_ATNConfigSet();
      var ATNSimulator_1 = require_ATNSimulator();
      var ATNStateType_1 = require_ATNStateType();
      var AtomTransition_1 = require_AtomTransition();
      var BitSet_1 = require_BitSet();
      var ConflictInfo_1 = require_ConflictInfo();
      var DecisionState_1 = require_DecisionState();
      var DFAState_1 = require_DFAState();
      var IntegerList_1 = require_IntegerList();
      var Interval_1 = require_Interval();
      var IntStream_1 = require_IntStream();
      var Decorators_1 = require_Decorators();
      var NotSetTransition_1 = require_NotSetTransition();
      var NoViableAltException_1 = require_NoViableAltException();
      var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
      var ParserRuleContext_1 = require_ParserRuleContext();
      var PredictionContext_1 = require_PredictionContext();
      var PredictionContextCache_1 = require_PredictionContextCache();
      var PredictionMode_1 = require_PredictionMode();
      var RuleStopState_1 = require_RuleStopState();
      var RuleTransition_1 = require_RuleTransition();
      var SemanticContext_1 = require_SemanticContext();
      var SetTransition_1 = require_SetTransition();
      var SimulatorState_1 = require_SimulatorState();
      var Token_1 = require_Token();
      var VocabularyImpl_1 = require_VocabularyImpl();
      var assert2 = require_assert();
      var MAX_SHORT_VALUE = 65535;
      var MIN_INTEGER_VALUE = -(1 << 31 >>> 0);
      var ParserATNSimulator2 = class ParserATNSimulator3 extends ATNSimulator_1.ATNSimulator {
        constructor(atn, parser) {
          super(atn);
          this.predictionMode = PredictionMode_1.PredictionMode.LL;
          this.force_global_context = false;
          this.always_try_local_context = true;
          this.enable_global_context_dfa = false;
          this.optimize_unique_closure = true;
          this.optimize_ll1 = true;
          this.optimize_tail_calls = true;
          this.tail_call_preserves_sll = true;
          this.treat_sllk1_conflict_as_ambiguity = false;
          this.reportAmbiguities = false;
          this.userWantsCtxSensitive = true;
          this._parser = parser;
        }
        getPredictionMode() {
          return this.predictionMode;
        }
        setPredictionMode(predictionMode) {
          this.predictionMode = predictionMode;
        }
        reset() {
        }
        adaptivePredict(input, decision, outerContext, useContext) {
          if (useContext === void 0) {
            useContext = false;
          }
          let dfa = this.atn.decisionToDFA[decision];
          assert2(dfa != null);
          if (this.optimize_ll1 && !dfa.isPrecedenceDfa && !dfa.isEmpty) {
            let ll_1 = input.LA(1);
            if (ll_1 >= 0 && ll_1 <= 65535) {
              let key = (decision << 16 >>> 0) + ll_1;
              let alt = this.atn.LL1Table.get(key);
              if (alt != null) {
                return alt;
              }
            }
          }
          this.dfa = dfa;
          if (this.force_global_context) {
            useContext = true;
          } else if (!this.always_try_local_context) {
            useContext = useContext || dfa.isContextSensitive;
          }
          this.userWantsCtxSensitive = useContext || this.predictionMode !== PredictionMode_1.PredictionMode.SLL && outerContext != null && !this.atn.decisionToState[decision].sll;
          if (outerContext == null) {
            outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
          }
          let state;
          if (!dfa.isEmpty) {
            state = this.getStartState(dfa, input, outerContext, useContext);
          }
          if (state == null) {
            if (outerContext == null) {
              outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
            }
            if (ParserATNSimulator3.debug) {
              console.log("ATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
            }
            state = this.computeStartState(dfa, outerContext, useContext);
          }
          let m = input.mark();
          let index = input.index;
          try {
            let alt = this.execDFA(dfa, input, index, state);
            if (ParserATNSimulator3.debug) {
              console.log("DFA after predictATN: " + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
            }
            return alt;
          } finally {
            this.dfa = void 0;
            input.seek(index);
            input.release(m);
          }
        }
        getStartState(dfa, input, outerContext, useContext) {
          if (!useContext) {
            if (dfa.isPrecedenceDfa) {
              let state = dfa.getPrecedenceStartState(this._parser.precedence, false);
              if (state == null) {
                return void 0;
              }
              return new SimulatorState_1.SimulatorState(outerContext, state, false, outerContext);
            } else {
              if (dfa.s0 == null) {
                return void 0;
              }
              return new SimulatorState_1.SimulatorState(outerContext, dfa.s0, false, outerContext);
            }
          }
          if (!this.enable_global_context_dfa) {
            return void 0;
          }
          let remainingContext = outerContext;
          assert2(outerContext != null);
          let s0;
          if (dfa.isPrecedenceDfa) {
            s0 = dfa.getPrecedenceStartState(this._parser.precedence, true);
          } else {
            s0 = dfa.s0full;
          }
          while (remainingContext != null && s0 != null && s0.isContextSensitive) {
            remainingContext = this.skipTailCalls(remainingContext);
            s0 = s0.getContextTarget(this.getReturnState(remainingContext));
            if (remainingContext.isEmpty) {
              assert2(s0 == null || !s0.isContextSensitive);
            } else {
              remainingContext = remainingContext.parent;
            }
          }
          if (s0 == null) {
            return void 0;
          }
          return new SimulatorState_1.SimulatorState(outerContext, s0, useContext, remainingContext);
        }
        execDFA(dfa, input, startIndex, state) {
          let outerContext = state.outerContext;
          if (ParserATNSimulator3.dfa_debug) {
            console.log("DFA decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
          }
          if (ParserATNSimulator3.dfa_debug) {
            console.log(dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
          }
          let s = state.s0;
          let t = input.LA(1);
          let remainingOuterContext = state.remainingOuterContext;
          while (true) {
            if (ParserATNSimulator3.dfa_debug) {
              console.log("DFA state " + s.stateNumber + " LA(1)==" + this.getLookaheadName(input));
            }
            if (state.useContext) {
              while (s.isContextSymbol(t)) {
                let next;
                if (remainingOuterContext != null) {
                  remainingOuterContext = this.skipTailCalls(remainingOuterContext);
                  next = s.getContextTarget(this.getReturnState(remainingOuterContext));
                }
                if (next == null) {
                  let initialState = new SimulatorState_1.SimulatorState(state.outerContext, s, state.useContext, remainingOuterContext);
                  return this.execATN(dfa, input, startIndex, initialState);
                }
                assert2(remainingOuterContext != null);
                remainingOuterContext = remainingOuterContext.parent;
                s = next;
              }
            }
            if (this.isAcceptState(s, state.useContext)) {
              if (s.predicates != null) {
                if (ParserATNSimulator3.dfa_debug) {
                  console.log("accept " + s);
                }
              } else {
                if (ParserATNSimulator3.dfa_debug) {
                  console.log("accept; predict " + s.prediction + " in state " + s.stateNumber);
                }
              }
              break;
            }
            assert2(!this.isAcceptState(s, state.useContext));
            let target = this.getExistingTargetState(s, t);
            if (target == null) {
              if (ParserATNSimulator3.dfa_debug && t >= 0) {
                console.log("no edge for " + this._parser.vocabulary.getDisplayName(t));
              }
              let alt;
              if (ParserATNSimulator3.dfa_debug) {
                let interval = Interval_1.Interval.of(startIndex, this._parser.inputStream.index);
                console.log("ATN exec upon " + this._parser.inputStream.getText(interval) + " at DFA state " + s.stateNumber);
              }
              let initialState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
              alt = this.execATN(dfa, input, startIndex, initialState);
              if (ParserATNSimulator3.dfa_debug) {
                console.log("back from DFA update, alt=" + alt + ", dfa=\n" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
              }
              if (ParserATNSimulator3.dfa_debug) {
                console.log("DFA decision " + dfa.decision + " predicts " + alt);
              }
              return alt;
            } else if (target === ATNSimulator_1.ATNSimulator.ERROR) {
              let errorState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
              return this.handleNoViableAlt(input, startIndex, errorState);
            }
            s = target;
            if (!this.isAcceptState(s, state.useContext) && t !== IntStream_1.IntStream.EOF) {
              input.consume();
              t = input.LA(1);
            }
          }
          if (!state.useContext && s.configs.conflictInfo != null) {
            if (dfa.atnStartState instanceof DecisionState_1.DecisionState) {
              if (!this.userWantsCtxSensitive || !s.configs.dipsIntoOuterContext && s.configs.isExactConflict || this.treat_sllk1_conflict_as_ambiguity && input.index === startIndex) {
              } else {
                assert2(!state.useContext);
                let conflictingAlts;
                let predicates2 = s.predicates;
                if (predicates2 != null) {
                  let conflictIndex = input.index;
                  if (conflictIndex !== startIndex) {
                    input.seek(startIndex);
                  }
                  conflictingAlts = this.evalSemanticContext(predicates2, outerContext, true);
                  if (conflictingAlts.cardinality() === 1) {
                    return conflictingAlts.nextSetBit(0);
                  }
                  if (conflictIndex !== startIndex) {
                    input.seek(conflictIndex);
                  }
                }
                if (this.reportAmbiguities) {
                  let conflictState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
                  this.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, input.index);
                }
                input.seek(startIndex);
                return this.adaptivePredict(input, dfa.decision, outerContext, true);
              }
            }
          }
          let predicates = s.predicates;
          if (predicates != null) {
            let stopIndex = input.index;
            if (startIndex !== stopIndex) {
              input.seek(startIndex);
            }
            let alts = this.evalSemanticContext(predicates, outerContext, this.reportAmbiguities && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION);
            switch (alts.cardinality()) {
              case 0:
                throw this.noViableAlt(input, outerContext, s.configs, startIndex);
              case 1:
                return alts.nextSetBit(0);
              default:
                if (startIndex !== stopIndex) {
                  input.seek(stopIndex);
                }
                this.reportAmbiguity(dfa, s, startIndex, stopIndex, s.configs.isExactConflict, alts, s.configs);
                return alts.nextSetBit(0);
            }
          }
          if (ParserATNSimulator3.dfa_debug) {
            console.log("DFA decision " + dfa.decision + " predicts " + s.prediction);
          }
          return s.prediction;
        }
        /**
         * Determines if a particular DFA state should be treated as an accept state
         * for the current prediction mode. In addition to the `useContext`
         * parameter, the {@link #getPredictionMode()} method provides the
         * prediction mode controlling the prediction algorithm as a whole.
         *
         * The default implementation simply returns the value of
         * `DFAState.isAcceptState` except for conflict states when
         * `useContext` is `true` and {@link #getPredictionMode()} is
         * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}. In that case, only
         * conflict states where {@link ATNConfigSet#isExactConflict} is
         * `true` are considered accept states.
         *
         * @param state The DFA state to check.
         * @param useContext `true` if the prediction algorithm is currently
         * considering the full parser context; otherwise, `false` if the
         * algorithm is currently performing a local context prediction.
         *
         * @returns `true` if the specified `state` is an accept state;
         * otherwise, `false`.
         */
        isAcceptState(state, useContext) {
          if (!state.isAcceptState) {
            return false;
          }
          if (state.configs.conflictingAlts == null) {
            return true;
          }
          if (useContext && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION) {
            return state.configs.isExactConflict;
          }
          return true;
        }
        /** Performs ATN simulation to compute a predicted alternative based
         *  upon the remaining input, but also updates the DFA cache to avoid
         *  having to traverse the ATN again for the same input sequence.
         *
         * There are some key conditions we're looking for after computing a new
         * set of ATN configs (proposed DFA state):
         *
         * * if the set is empty, there is no viable alternative for current symbol
         * * does the state uniquely predict an alternative?
         * * does the state have a conflict that would prevent us from
         *   putting it on the work list?
         * * if in non-greedy decision is there a config at a rule stop state?
         *
         * We also have some key operations to do:
         *
         * * add an edge from previous DFA state to potentially new DFA state, D,
         *   upon current symbol but only if adding to work list, which means in all
         *   cases except no viable alternative (and possibly non-greedy decisions?)
         * * collecting predicates and adding semantic context to DFA accept states
         * * adding rule context to context-sensitive DFA accept states
         * * consuming an input symbol
         * * reporting a conflict
         * * reporting an ambiguity
         * * reporting a context sensitivity
         * * reporting insufficient predicates
         *
         * We should isolate those operations, which are side-effecting, to the
         * main work loop. We can isolate lots of code into other functions, but
         * they should be side effect free. They can return package that
         * indicates whether we should report something, whether we need to add a
         * DFA edge, whether we need to augment accept state with semantic
         * context or rule invocation context. Actually, it seems like we always
         * add predicates if they exist, so that can simply be done in the main
         * loop for any accept state creation or modification request.
         *
         * cover these cases:
         *   dead end
         *   single alt
         *   single alt + preds
         *   conflict
         *   conflict + preds
         *
         * TODO: greedy + those
         */
        execATN(dfa, input, startIndex, initialState) {
          if (ParserATNSimulator3.debug) {
            console.log("execATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input));
          }
          let outerContext = initialState.outerContext;
          let useContext = initialState.useContext;
          let t = input.LA(1);
          let previous = initialState;
          let contextCache = new PredictionContextCache_1.PredictionContextCache();
          while (true) {
            let nextState = this.computeReachSet(dfa, previous, t, contextCache);
            if (nextState == null) {
              this.setDFAEdge(previous.s0, input.LA(1), ATNSimulator_1.ATNSimulator.ERROR);
              return this.handleNoViableAlt(input, startIndex, previous);
            }
            let D = nextState.s0;
            assert2(D.isAcceptState || D.prediction === ATN_1.ATN.INVALID_ALT_NUMBER);
            assert2(D.isAcceptState || D.configs.conflictInfo == null);
            if (this.isAcceptState(D, useContext)) {
              let conflictingAlts = D.configs.conflictingAlts;
              let predictedAlt = conflictingAlts == null ? D.prediction : ATN_1.ATN.INVALID_ALT_NUMBER;
              if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                if (this.optimize_ll1 && input.index === startIndex && !dfa.isPrecedenceDfa && nextState.outerContext === nextState.remainingOuterContext && dfa.decision >= 0 && !D.configs.hasSemanticContext) {
                  if (t >= 0 && t <= MAX_SHORT_VALUE) {
                    let key = (dfa.decision << 16 >>> 0) + t;
                    this.atn.LL1Table.set(key, predictedAlt);
                  }
                }
                if (useContext && this.always_try_local_context) {
                  this.reportContextSensitivity(dfa, predictedAlt, nextState, startIndex, input.index);
                }
              }
              predictedAlt = D.prediction;
              let attemptFullContext = conflictingAlts != null && this.userWantsCtxSensitive;
              if (attemptFullContext) {
                attemptFullContext = !useContext && (D.configs.dipsIntoOuterContext || !D.configs.isExactConflict) && (!this.treat_sllk1_conflict_as_ambiguity || input.index !== startIndex);
              }
              if (D.configs.hasSemanticContext) {
                let predPredictions = D.predicates;
                if (predPredictions != null) {
                  let conflictIndex = input.index;
                  if (conflictIndex !== startIndex) {
                    input.seek(startIndex);
                  }
                  conflictingAlts = this.evalSemanticContext(predPredictions, outerContext, attemptFullContext || this.reportAmbiguities);
                  switch (conflictingAlts.cardinality()) {
                    case 0:
                      throw this.noViableAlt(input, outerContext, D.configs, startIndex);
                    case 1:
                      return conflictingAlts.nextSetBit(0);
                    default:
                      break;
                  }
                  if (conflictIndex !== startIndex) {
                    input.seek(conflictIndex);
                  }
                }
              }
              if (!attemptFullContext) {
                if (conflictingAlts != null) {
                  if (this.reportAmbiguities && conflictingAlts.cardinality() > 1) {
                    this.reportAmbiguity(dfa, D, startIndex, input.index, D.configs.isExactConflict, conflictingAlts, D.configs);
                  }
                  predictedAlt = conflictingAlts.nextSetBit(0);
                }
                return predictedAlt;
              } else {
                assert2(!useContext);
                assert2(this.isAcceptState(D, false));
                if (ParserATNSimulator3.debug) {
                  console.log("RETRY with outerContext=" + outerContext);
                }
                let fullContextState = this.computeStartState(dfa, outerContext, true);
                if (this.reportAmbiguities) {
                  this.reportAttemptingFullContext(dfa, conflictingAlts, nextState, startIndex, input.index);
                }
                input.seek(startIndex);
                return this.execATN(dfa, input, startIndex, fullContextState);
              }
            }
            previous = nextState;
            if (t !== IntStream_1.IntStream.EOF) {
              input.consume();
              t = input.LA(1);
            }
          }
        }
        /**
         * This method is used to improve the localization of error messages by
         * choosing an alternative rather than throwing a
         * {@link NoViableAltException} in particular prediction scenarios where the
         * {@link #ERROR} state was reached during ATN simulation.
         *
         * The default implementation of this method uses the following
         * algorithm to identify an ATN configuration which successfully parsed the
         * decision entry rule. Choosing such an alternative ensures that the
         * {@link ParserRuleContext} returned by the calling rule will be complete
         * and valid, and the syntax error will be reported later at a more
         * localized location.
         *
         * * If no configuration in `configs` reached the end of the
         *   decision rule, return {@link ATN#INVALID_ALT_NUMBER}.
         * * If all configurations in `configs` which reached the end of the
         *   decision rule predict the same alternative, return that alternative.
         * * If the configurations in `configs` which reached the end of the
         *   decision rule predict multiple alternatives (call this *S*),
         *   choose an alternative in the following order.
         *
         *     1. Filter the configurations in `configs` to only those
         *        configurations which remain viable after evaluating semantic predicates.
         *        If the set of these filtered configurations which also reached the end of
         *        the decision rule is not empty, return the minimum alternative
         *        represented in this set.
         *     1. Otherwise, choose the minimum alternative in *S*.
         *
         * In some scenarios, the algorithm described above could predict an
         * alternative which will result in a {@link FailedPredicateException} in
         * parser. Specifically, this could occur if the *only* configuration
         * capable of successfully parsing to the end of the decision rule is
         * blocked by a semantic predicate. By choosing this alternative within
         * {@link #adaptivePredict} instead of throwing a
         * {@link NoViableAltException}, the resulting
         * {@link FailedPredicateException} in the parser will identify the specific
         * predicate which is preventing the parser from successfully parsing the
         * decision rule, which helps developers identify and correct logic errors
         * in semantic predicates.
         *
         * @param input The input {@link TokenStream}
         * @param startIndex The start index for the current prediction, which is
         * the input index where any semantic context in `configs` should be
         * evaluated
         * @param previous The ATN simulation state immediately before the
         * {@link #ERROR} state was reached
         *
         * @returns The value to return from {@link #adaptivePredict}, or
         * {@link ATN#INVALID_ALT_NUMBER} if a suitable alternative was not
         * identified and {@link #adaptivePredict} should report an error instead.
         */
        handleNoViableAlt(input, startIndex, previous) {
          if (previous.s0 != null) {
            let alts = new BitSet_1.BitSet();
            let maxAlt = 0;
            for (let config2 of previous.s0.configs) {
              if (config2.reachesIntoOuterContext || config2.state instanceof RuleStopState_1.RuleStopState) {
                alts.set(config2.alt);
                maxAlt = Math.max(maxAlt, config2.alt);
              }
            }
            switch (alts.cardinality()) {
              case 0:
                break;
              case 1:
                return alts.nextSetBit(0);
              default:
                if (!previous.s0.configs.hasSemanticContext) {
                  return alts.nextSetBit(0);
                }
                let filteredConfigs = new ATNConfigSet_1.ATNConfigSet();
                for (let config2 of previous.s0.configs) {
                  if (config2.reachesIntoOuterContext || config2.state instanceof RuleStopState_1.RuleStopState) {
                    filteredConfigs.add(config2);
                  }
                }
                let altToPred = this.getPredsForAmbigAlts(alts, filteredConfigs, maxAlt);
                if (altToPred != null) {
                  let predicates = this.getPredicatePredictions(alts, altToPred);
                  if (predicates != null) {
                    let stopIndex = input.index;
                    try {
                      input.seek(startIndex);
                      let filteredAlts = this.evalSemanticContext(predicates, previous.outerContext, false);
                      if (!filteredAlts.isEmpty) {
                        return filteredAlts.nextSetBit(0);
                      }
                    } finally {
                      input.seek(stopIndex);
                    }
                  }
                }
                return alts.nextSetBit(0);
            }
          }
          throw this.noViableAlt(input, previous.outerContext, previous.s0.configs, startIndex);
        }
        computeReachSet(dfa, previous, t, contextCache) {
          let useContext = previous.useContext;
          let remainingGlobalContext = previous.remainingOuterContext;
          let s = previous.s0;
          if (useContext) {
            while (s.isContextSymbol(t)) {
              let next;
              if (remainingGlobalContext != null) {
                remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
                next = s.getContextTarget(this.getReturnState(remainingGlobalContext));
              }
              if (next == null) {
                break;
              }
              assert2(remainingGlobalContext != null);
              remainingGlobalContext = remainingGlobalContext.parent;
              s = next;
            }
          }
          assert2(!this.isAcceptState(s, useContext));
          if (this.isAcceptState(s, useContext)) {
            return new SimulatorState_1.SimulatorState(previous.outerContext, s, useContext, remainingGlobalContext);
          }
          let s0 = s;
          let target = this.getExistingTargetState(s0, t);
          if (target == null) {
            let result = this.computeTargetState(dfa, s0, remainingGlobalContext, t, useContext, contextCache);
            target = result[0];
            remainingGlobalContext = result[1];
          }
          if (target === ATNSimulator_1.ATNSimulator.ERROR) {
            return void 0;
          }
          assert2(!useContext || !target.configs.dipsIntoOuterContext);
          return new SimulatorState_1.SimulatorState(previous.outerContext, target, useContext, remainingGlobalContext);
        }
        /**
         * Get an existing target state for an edge in the DFA. If the target state
         * for the edge has not yet been computed or is otherwise not available,
         * this method returns `undefined`.
         *
         * @param s The current DFA state
         * @param t The next input symbol
         * @returns The existing target DFA state for the given input symbol
         * `t`, or `undefined` if the target state for this edge is not
         * already cached
         */
        getExistingTargetState(s, t) {
          return s.getTarget(t);
        }
        /**
         * Compute a target state for an edge in the DFA, and attempt to add the
         * computed state and corresponding edge to the DFA.
         *
         * @param dfa
         * @param s The current DFA state
         * @param remainingGlobalContext
         * @param t The next input symbol
         * @param useContext
         * @param contextCache
         *
         * @returns The computed target DFA state for the given input symbol
         * `t`. If `t` does not lead to a valid DFA state, this method
         * returns {@link #ERROR}.
         */
        computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
          let closureConfigs = s.configs.toArray();
          let contextElements;
          let reach = new ATNConfigSet_1.ATNConfigSet();
          let stepIntoGlobal;
          do {
            let hasMoreContext = !useContext || remainingGlobalContext != null;
            if (!hasMoreContext) {
              reach.isOutermostConfigSet = true;
            }
            let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
            let skippedStopStates;
            for (let c of closureConfigs) {
              if (ParserATNSimulator3.debug) {
                console.log("testing " + this.getTokenName(t) + " at " + c.toString());
              }
              if (c.state instanceof RuleStopState_1.RuleStopState) {
                assert2(c.context.isEmpty);
                if (useContext && !c.reachesIntoOuterContext || t === IntStream_1.IntStream.EOF) {
                  if (skippedStopStates == null) {
                    skippedStopStates = [];
                  }
                  skippedStopStates.push(c);
                }
                continue;
              }
              let n = c.state.numberOfOptimizedTransitions;
              for (let ti = 0; ti < n; ti++) {
                let trans = c.state.getOptimizedTransition(ti);
                let target = this.getReachableTarget(c, trans, t);
                if (target != null) {
                  reachIntermediate.add(c.transform(target, false), contextCache);
                }
              }
            }
            if (this.optimize_unique_closure && skippedStopStates == null && t !== Token_1.Token.EOF && reachIntermediate.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              reachIntermediate.isOutermostConfigSet = reach.isOutermostConfigSet;
              reach = reachIntermediate;
              break;
            }
            let collectPredicates = false;
            let treatEofAsEpsilon = t === Token_1.Token.EOF;
            this.closure(reachIntermediate, reach, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon);
            stepIntoGlobal = reach.dipsIntoOuterContext;
            if (t === IntStream_1.IntStream.EOF) {
              reach = this.removeAllConfigsNotInRuleStopState(reach, contextCache);
            }
            if (skippedStopStates != null && (!useContext || !PredictionMode_1.PredictionMode.hasConfigInRuleStopState(reach))) {
              assert2(skippedStopStates.length > 0);
              for (let c of skippedStopStates) {
                reach.add(c, contextCache);
              }
            }
            if (useContext && stepIntoGlobal) {
              reach.clear();
              remainingGlobalContext = remainingGlobalContext;
              remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
              let nextContextElement = this.getReturnState(remainingGlobalContext);
              if (contextElements == null) {
                contextElements = new IntegerList_1.IntegerList();
              }
              if (remainingGlobalContext.isEmpty) {
                remainingGlobalContext = void 0;
              } else {
                remainingGlobalContext = remainingGlobalContext.parent;
              }
              contextElements.add(nextContextElement);
              if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                for (let i = 0; i < closureConfigs.length; i++) {
                  closureConfigs[i] = closureConfigs[i].appendContext(nextContextElement, contextCache);
                }
              }
            }
          } while (useContext && stepIntoGlobal);
          if (reach.isEmpty) {
            this.setDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
            return [ATNSimulator_1.ATNSimulator.ERROR, remainingGlobalContext];
          }
          let result = this.addDFAEdge(dfa, s, t, contextElements, reach, contextCache);
          return [result, remainingGlobalContext];
        }
        /**
         * Return a configuration set containing only the configurations from
         * `configs` which are in a {@link RuleStopState}. If all
         * configurations in `configs` are already in a rule stop state, this
         * method simply returns `configs`.
         *
         * @param configs the configuration set to update
         * @param contextCache the {@link PredictionContext} cache
         *
         * @returns `configs` if all configurations in `configs` are in a
         * rule stop state, otherwise return a new configuration set containing only
         * the configurations from `configs` which are in a rule stop state
         */
        removeAllConfigsNotInRuleStopState(configs, contextCache) {
          if (PredictionMode_1.PredictionMode.allConfigsInRuleStopStates(configs)) {
            return configs;
          }
          let result = new ATNConfigSet_1.ATNConfigSet();
          for (let config2 of configs) {
            if (!(config2.state instanceof RuleStopState_1.RuleStopState)) {
              continue;
            }
            result.add(config2, contextCache);
          }
          return result;
        }
        computeStartState(dfa, globalContext, useContext) {
          let s0 = dfa.isPrecedenceDfa ? dfa.getPrecedenceStartState(this._parser.precedence, useContext) : useContext ? dfa.s0full : dfa.s0;
          if (s0 != null) {
            if (!useContext) {
              return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, globalContext);
            }
            s0.setContextSensitive(this.atn);
          }
          let decision = dfa.decision;
          let p = dfa.atnStartState;
          let previousContext = 0;
          let remainingGlobalContext = globalContext;
          let initialContext = useContext ? PredictionContext_1.PredictionContext.EMPTY_FULL : PredictionContext_1.PredictionContext.EMPTY_LOCAL;
          let contextCache = new PredictionContextCache_1.PredictionContextCache();
          if (useContext) {
            if (!this.enable_global_context_dfa) {
              while (remainingGlobalContext != null) {
                if (remainingGlobalContext.isEmpty) {
                  previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
                  remainingGlobalContext = void 0;
                } else {
                  previousContext = this.getReturnState(remainingGlobalContext);
                  initialContext = initialContext.appendSingleContext(previousContext, contextCache);
                  remainingGlobalContext = remainingGlobalContext.parent;
                }
              }
            }
            while (s0 != null && s0.isContextSensitive && remainingGlobalContext != null) {
              let next;
              remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
              if (remainingGlobalContext.isEmpty) {
                next = s0.getContextTarget(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY);
                previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
                remainingGlobalContext = void 0;
              } else {
                previousContext = this.getReturnState(remainingGlobalContext);
                next = s0.getContextTarget(previousContext);
                initialContext = initialContext.appendSingleContext(previousContext, contextCache);
                remainingGlobalContext = remainingGlobalContext.parent;
              }
              if (next == null) {
                break;
              }
              s0 = next;
            }
          }
          if (s0 != null && !s0.isContextSensitive) {
            return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
          }
          let configs = new ATNConfigSet_1.ATNConfigSet();
          while (true) {
            let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
            let n = p.numberOfTransitions;
            for (let ti = 0; ti < n; ti++) {
              let target = p.transition(ti).target;
              reachIntermediate.add(ATNConfig_1.ATNConfig.create(target, ti + 1, initialContext));
            }
            let hasMoreContext = remainingGlobalContext != null;
            if (!hasMoreContext) {
              configs.isOutermostConfigSet = true;
            }
            let collectPredicates = true;
            this.closure(reachIntermediate, configs, collectPredicates, hasMoreContext, contextCache, false);
            let stepIntoGlobal = configs.dipsIntoOuterContext;
            let next;
            if (useContext && !this.enable_global_context_dfa) {
              s0 = this.addDFAState(dfa, configs, contextCache);
              break;
            } else if (s0 == null) {
              if (!dfa.isPrecedenceDfa) {
                next = this.addDFAState(dfa, configs, contextCache);
                if (useContext) {
                  if (!dfa.s0full) {
                    dfa.s0full = next;
                  } else {
                    next = dfa.s0full;
                  }
                } else {
                  if (!dfa.s0) {
                    dfa.s0 = next;
                  } else {
                    next = dfa.s0;
                  }
                }
              } else {
                configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
                next = this.addDFAState(dfa, configs, contextCache);
                dfa.setPrecedenceStartState(this._parser.precedence, useContext, next);
              }
            } else {
              if (dfa.isPrecedenceDfa) {
                configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
              }
              next = this.addDFAState(dfa, configs, contextCache);
              s0.setContextTarget(previousContext, next);
            }
            s0 = next;
            if (!useContext || !stepIntoGlobal) {
              break;
            }
            next.setContextSensitive(this.atn);
            remainingGlobalContext = remainingGlobalContext;
            configs.clear();
            remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
            let nextContextElement = this.getReturnState(remainingGlobalContext);
            if (remainingGlobalContext.isEmpty) {
              remainingGlobalContext = void 0;
            } else {
              remainingGlobalContext = remainingGlobalContext.parent;
            }
            if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              initialContext = initialContext.appendSingleContext(nextContextElement, contextCache);
            }
            previousContext = nextContextElement;
          }
          return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
        }
        /**
         * This method transforms the start state computed by
         * {@link #computeStartState} to the special start state used by a
         * precedence DFA for a particular precedence value. The transformation
         * process applies the following changes to the start state's configuration
         * set.
         *
         * 1. Evaluate the precedence predicates for each configuration using
         *    {@link SemanticContext#evalPrecedence}.
         * 1. When {@link ATNConfig#isPrecedenceFilterSuppressed} is `false`,
         *    remove all configurations which predict an alternative greater than 1,
         *    for which another configuration that predicts alternative 1 is in the
         *    same ATN state with the same prediction context. This transformation is
         *    valid for the following reasons:
         *
         *     * The closure block cannot contain any epsilon transitions which bypass
         *       the body of the closure, so all states reachable via alternative 1 are
         *       part of the precedence alternatives of the transformed left-recursive
         *       rule.
         *     * The "primary" portion of a left recursive rule cannot contain an
         *       epsilon transition, so the only way an alternative other than 1 can exist
         *       in a state that is also reachable via alternative 1 is by nesting calls
         *       to the left-recursive rule, with the outer calls not being at the
         *       preferred precedence level. The
         *       {@link ATNConfig#isPrecedenceFilterSuppressed} property marks ATN
         *       configurations which do not meet this condition, and therefore are not
         *       eligible for elimination during the filtering process.
         *
         * The prediction context must be considered by this filter to address
         * situations like the following.
         *
         * ```antlr
         * grammar TA;
         * prog: statement* EOF;
         * statement: letterA | statement letterA 'b' ;
         * letterA: 'a';
         * ```
         *
         * If the above grammar, the ATN state immediately before the token
         * reference `'a'` in `letterA` is reachable from the left edge
         * of both the primary and closure blocks of the left-recursive rule
         * `statement`. The prediction context associated with each of these
         * configurations distinguishes between them, and prevents the alternative
         * which stepped out to `prog` (and then back in to `statement`
         * from being eliminated by the filter.
         *
         * @param configs The configuration set computed by
         * {@link #computeStartState} as the start state for the DFA.
         * @returns The transformed configuration set representing the start state
         * for a precedence DFA at a particular precedence level (determined by
         * calling {@link Parser#getPrecedence}).
         */
        applyPrecedenceFilter(configs, globalContext, contextCache) {
          let statesFromAlt1 = /* @__PURE__ */ new Map();
          let configSet = new ATNConfigSet_1.ATNConfigSet();
          for (let config2 of configs) {
            if (config2.alt !== 1) {
              continue;
            }
            let updatedContext = config2.semanticContext.evalPrecedence(this._parser, globalContext);
            if (updatedContext == null) {
              continue;
            }
            statesFromAlt1.set(config2.state.stateNumber, config2.context);
            if (updatedContext !== config2.semanticContext) {
              configSet.add(config2.transform(config2.state, false, updatedContext), contextCache);
            } else {
              configSet.add(config2, contextCache);
            }
          }
          for (let config2 of configs) {
            if (config2.alt === 1) {
              continue;
            }
            if (!config2.isPrecedenceFilterSuppressed) {
              let context = statesFromAlt1.get(config2.state.stateNumber);
              if (context != null && context.equals(config2.context)) {
                continue;
              }
            }
            configSet.add(config2, contextCache);
          }
          return configSet;
        }
        getReachableTarget(source, trans, ttype) {
          if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
            return trans.target;
          }
          return void 0;
        }
        /** collect and set D's semantic context */
        predicateDFAState(D, configs, nalts) {
          let conflictingAlts = this.getConflictingAltsFromConfigSet(configs);
          if (!conflictingAlts) {
            throw new Error("This unhandled scenario is intended to be unreachable, but I'm currently not sure of why we know that's the case.");
          }
          if (ParserATNSimulator3.debug) {
            console.log("predicateDFAState " + D);
          }
          let altToPred = this.getPredsForAmbigAlts(conflictingAlts, configs, nalts);
          let predPredictions;
          if (altToPred != null) {
            predPredictions = this.getPredicatePredictions(conflictingAlts, altToPred);
            D.predicates = predPredictions;
          }
          return predPredictions;
        }
        getPredsForAmbigAlts(ambigAlts, configs, nalts) {
          let altToPred = new Array(nalts + 1);
          let n = altToPred.length;
          for (let c of configs) {
            if (ambigAlts.get(c.alt)) {
              altToPred[c.alt] = SemanticContext_1.SemanticContext.or(altToPred[c.alt], c.semanticContext);
            }
          }
          let nPredAlts = 0;
          for (let i = 0; i < n; i++) {
            if (altToPred[i] == null) {
              altToPred[i] = SemanticContext_1.SemanticContext.NONE;
            } else if (altToPred[i] !== SemanticContext_1.SemanticContext.NONE) {
              nPredAlts++;
            }
          }
          let result = altToPred;
          if (nPredAlts === 0) {
            result = void 0;
          }
          if (ParserATNSimulator3.debug) {
            console.log("getPredsForAmbigAlts result " + (result ? Arrays_1.Arrays.toString(result) : "undefined"));
          }
          return result;
        }
        getPredicatePredictions(ambigAlts, altToPred) {
          let pairs = [];
          let containsPredicate = false;
          for (let i = 1; i < altToPred.length; i++) {
            let pred = altToPred[i];
            assert2(pred != null);
            if (ambigAlts != null && ambigAlts.get(i) && pred === SemanticContext_1.SemanticContext.NONE) {
              pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));
            } else if (pred !== SemanticContext_1.SemanticContext.NONE) {
              containsPredicate = true;
              pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));
            }
          }
          if (!containsPredicate) {
            return void 0;
          }
          return pairs;
        }
        /** Look through a list of predicate/alt pairs, returning alts for the
         *  pairs that win. An `undefined` predicate indicates an alt containing an
         *  unpredicated config which behaves as "always true."
         */
        evalSemanticContext(predPredictions, outerContext, complete) {
          let predictions = new BitSet_1.BitSet();
          for (let pair of predPredictions) {
            if (pair.pred === SemanticContext_1.SemanticContext.NONE) {
              predictions.set(pair.alt);
              if (!complete) {
                break;
              }
              continue;
            }
            let evaluatedResult = this.evalSemanticContextImpl(pair.pred, outerContext, pair.alt);
            if (ParserATNSimulator3.debug || ParserATNSimulator3.dfa_debug) {
              console.log("eval pred " + pair + "=" + evaluatedResult);
            }
            if (evaluatedResult) {
              if (ParserATNSimulator3.debug || ParserATNSimulator3.dfa_debug) {
                console.log("PREDICT " + pair.alt);
              }
              predictions.set(pair.alt);
              if (!complete) {
                break;
              }
            }
          }
          return predictions;
        }
        /**
         * Evaluate a semantic context within a specific parser context.
         *
         * This method might not be called for every semantic context evaluated
         * during the prediction process. In particular, we currently do not
         * evaluate the following but it may change in the future:
         *
         * * Precedence predicates (represented by
         *   {@link SemanticContext.PrecedencePredicate}) are not currently evaluated
         *   through this method.
         * * Operator predicates (represented by {@link SemanticContext.AND} and
         *   {@link SemanticContext.OR}) are evaluated as a single semantic
         *   context, rather than evaluating the operands individually.
         *   Implementations which require evaluation results from individual
         *   predicates should override this method to explicitly handle evaluation of
         *   the operands within operator predicates.
         *
         * @param pred The semantic context to evaluate
         * @param parserCallStack The parser context in which to evaluate the
         * semantic context
         * @param alt The alternative which is guarded by `pred`
         *
         * @since 4.3
         */
        evalSemanticContextImpl(pred, parserCallStack, alt) {
          return pred.eval(this._parser, parserCallStack);
        }
        /* TODO: If we are doing predicates, there is no point in pursuing
             closure operations if we reach a DFA state that uniquely predicts
             alternative. We will not be caching that DFA state and it is a
             waste to pursue the closure. Might have to advance when we do
             ambig detection thought :(
              */
        closure(sourceConfigs, configs, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon) {
          if (contextCache == null) {
            contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
          }
          let currentConfigs = sourceConfigs;
          let closureBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          while (currentConfigs.size > 0) {
            let intermediate = new ATNConfigSet_1.ATNConfigSet();
            for (let config2 of currentConfigs) {
              this.closureImpl(config2, configs, intermediate, closureBusy, collectPredicates, hasMoreContext, contextCache, 0, treatEofAsEpsilon);
            }
            currentConfigs = intermediate;
          }
        }
        closureImpl(config2, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth, treatEofAsEpsilon) {
          if (ParserATNSimulator3.debug) {
            console.log("closure(" + config2.toString(this._parser, true) + ")");
          }
          if (config2.state instanceof RuleStopState_1.RuleStopState) {
            if (!config2.context.isEmpty) {
              let hasEmpty = config2.context.hasEmpty;
              let nonEmptySize = config2.context.size - (hasEmpty ? 1 : 0);
              for (let i = 0; i < nonEmptySize; i++) {
                let newContext = config2.context.getParent(i);
                let returnState = this.atn.states[config2.context.getReturnState(i)];
                let c = ATNConfig_1.ATNConfig.create(returnState, config2.alt, newContext, config2.semanticContext);
                c.outerContextDepth = config2.outerContextDepth;
                c.isPrecedenceFilterSuppressed = config2.isPrecedenceFilterSuppressed;
                assert2(depth > MIN_INTEGER_VALUE);
                this.closureImpl(c, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth - 1, treatEofAsEpsilon);
              }
              if (!hasEmpty || !hasMoreContexts) {
                return;
              }
              config2 = config2.transform(config2.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
            } else if (!hasMoreContexts) {
              configs.add(config2, contextCache);
              return;
            } else {
              if (ParserATNSimulator3.debug) {
                console.log("FALLING off rule " + this.getRuleName(config2.state.ruleIndex));
              }
              if (config2.context === PredictionContext_1.PredictionContext.EMPTY_FULL) {
                config2 = config2.transform(config2.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
              } else if (!config2.reachesIntoOuterContext && PredictionContext_1.PredictionContext.isEmptyLocal(config2.context)) {
                configs.add(config2, contextCache);
              }
            }
          }
          let p = config2.state;
          if (!p.onlyHasEpsilonTransitions) {
            configs.add(config2, contextCache);
            if (ParserATNSimulator3.debug) {
              console.log("added config " + configs);
            }
          }
          for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {
            if (i === 0 && p.stateType === ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY && p.precedenceRuleDecision && !config2.context.hasEmpty) {
              let precedenceDecision = p;
              let suppress = true;
              for (let j = 0; j < config2.context.size; j++) {
                if (!precedenceDecision.precedenceLoopbackStates.get(config2.context.getReturnState(j))) {
                  suppress = false;
                  break;
                }
              }
              if (suppress) {
                continue;
              }
            }
            let t = p.getOptimizedTransition(i);
            let continueCollecting = !(t instanceof ActionTransition_1.ActionTransition) && collectPredicates;
            let c = this.getEpsilonTarget(config2, t, continueCollecting, depth === 0, contextCache, treatEofAsEpsilon);
            if (c != null) {
              if (t instanceof RuleTransition_1.RuleTransition) {
                if (intermediate != null && !collectPredicates) {
                  intermediate.add(c, contextCache);
                  continue;
                }
              }
              let newDepth = depth;
              if (config2.state instanceof RuleStopState_1.RuleStopState) {
                if (this.dfa != null && this.dfa.isPrecedenceDfa) {
                  let outermostPrecedenceReturn = t.outermostPrecedenceReturn;
                  if (outermostPrecedenceReturn === this.dfa.atnStartState.ruleIndex) {
                    c.isPrecedenceFilterSuppressed = true;
                  }
                }
                c.outerContextDepth = c.outerContextDepth + 1;
                if (!closureBusy.add(c)) {
                  continue;
                }
                assert2(newDepth > MIN_INTEGER_VALUE);
                newDepth--;
                if (ParserATNSimulator3.debug) {
                  console.log("dips into outer ctx: " + c);
                }
              } else if (t instanceof RuleTransition_1.RuleTransition) {
                if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config2.context))) {
                  assert2(c.context === config2.context);
                  if (newDepth === 0) {
                    newDepth--;
                    if (!this.tail_call_preserves_sll && PredictionContext_1.PredictionContext.isEmptyLocal(config2.context)) {
                      c.outerContextDepth = c.outerContextDepth + 1;
                    }
                  }
                } else {
                  if (newDepth >= 0) {
                    newDepth++;
                  }
                }
              } else {
                if (!t.isEpsilon && !closureBusy.add(c)) {
                  continue;
                }
              }
              this.closureImpl(c, configs, intermediate, closureBusy, continueCollecting, hasMoreContexts, contextCache, newDepth, treatEofAsEpsilon);
            }
          }
        }
        getRuleName(index) {
          if (this._parser != null && index >= 0) {
            return this._parser.ruleNames[index];
          }
          return "<rule " + index + ">";
        }
        getEpsilonTarget(config2, t, collectPredicates, inContext, contextCache, treatEofAsEpsilon) {
          switch (t.serializationType) {
            case 3:
              return this.ruleTransition(config2, t, contextCache);
            case 10:
              return this.precedenceTransition(config2, t, collectPredicates, inContext);
            case 4:
              return this.predTransition(config2, t, collectPredicates, inContext);
            case 6:
              return this.actionTransition(config2, t);
            case 1:
              return config2.transform(t.target, false);
            case 5:
            case 2:
            case 7:
              if (treatEofAsEpsilon) {
                if (t.matches(Token_1.Token.EOF, 0, 1)) {
                  return config2.transform(t.target, false);
                }
              }
              return void 0;
            default:
              return void 0;
          }
        }
        actionTransition(config2, t) {
          if (ParserATNSimulator3.debug) {
            console.log("ACTION edge " + t.ruleIndex + ":" + t.actionIndex);
          }
          return config2.transform(t.target, false);
        }
        precedenceTransition(config2, pt, collectPredicates, inContext) {
          if (ParserATNSimulator3.debug) {
            console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.precedence + ">=_p, ctx dependent=true");
            if (this._parser != null) {
              console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
            }
          }
          let c;
          if (collectPredicates && inContext) {
            let newSemCtx = SemanticContext_1.SemanticContext.and(config2.semanticContext, pt.predicate);
            c = config2.transform(pt.target, false, newSemCtx);
          } else {
            c = config2.transform(pt.target, false);
          }
          if (ParserATNSimulator3.debug) {
            console.log("config from pred transition=" + c);
          }
          return c;
        }
        predTransition(config2, pt, collectPredicates, inContext) {
          if (ParserATNSimulator3.debug) {
            console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex + ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
            if (this._parser != null) {
              console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
            }
          }
          let c;
          if (collectPredicates && (!pt.isCtxDependent || pt.isCtxDependent && inContext)) {
            let newSemCtx = SemanticContext_1.SemanticContext.and(config2.semanticContext, pt.predicate);
            c = config2.transform(pt.target, false, newSemCtx);
          } else {
            c = config2.transform(pt.target, false);
          }
          if (ParserATNSimulator3.debug) {
            console.log("config from pred transition=" + c);
          }
          return c;
        }
        ruleTransition(config2, t, contextCache) {
          if (ParserATNSimulator3.debug) {
            console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config2.context);
          }
          let returnState = t.followState;
          let newContext;
          if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config2.context))) {
            newContext = config2.context;
          } else if (contextCache != null) {
            newContext = contextCache.getChild(config2.context, returnState.stateNumber);
          } else {
            newContext = config2.context.getChild(returnState.stateNumber);
          }
          return config2.transform(t.target, false, newContext);
        }
        isConflicted(configset, contextCache) {
          if (configset.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER || configset.size <= 1) {
            return void 0;
          }
          let configs = configset.toArray();
          configs.sort(ParserATNSimulator3.STATE_ALT_SORT_COMPARATOR);
          let exact = !configset.dipsIntoOuterContext;
          let alts = new BitSet_1.BitSet();
          let minAlt = configs[0].alt;
          alts.set(minAlt);
          let currentState = configs[0].state.nonStopStateNumber;
          for (let config2 of configs) {
            let stateNumber = config2.state.nonStopStateNumber;
            if (stateNumber !== currentState) {
              if (config2.alt !== minAlt) {
                return void 0;
              }
              currentState = stateNumber;
            }
          }
          let representedAlts;
          if (exact) {
            currentState = configs[0].state.nonStopStateNumber;
            representedAlts = new BitSet_1.BitSet();
            let maxAlt = minAlt;
            for (let config2 of configs) {
              if (config2.state.nonStopStateNumber !== currentState) {
                break;
              }
              let alt = config2.alt;
              representedAlts.set(alt);
              maxAlt = alt;
            }
            currentState = configs[0].state.nonStopStateNumber;
            let currentAlt = minAlt;
            for (let config2 of configs) {
              let stateNumber = config2.state.nonStopStateNumber;
              let alt = config2.alt;
              if (stateNumber !== currentState) {
                if (currentAlt !== maxAlt) {
                  exact = false;
                  break;
                }
                currentState = stateNumber;
                currentAlt = minAlt;
              } else if (alt !== currentAlt) {
                if (alt !== representedAlts.nextSetBit(currentAlt + 1)) {
                  exact = false;
                  break;
                }
                currentAlt = alt;
              }
            }
          }
          currentState = configs[0].state.nonStopStateNumber;
          let firstIndexCurrentState = 0;
          let lastIndexCurrentStateMinAlt = 0;
          let joinedCheckContext = configs[0].context;
          for (let i = 1; i < configs.length; i++) {
            let config2 = configs[i];
            if (config2.alt !== minAlt) {
              break;
            }
            if (config2.state.nonStopStateNumber !== currentState) {
              break;
            }
            lastIndexCurrentStateMinAlt = i;
            joinedCheckContext = contextCache.join(joinedCheckContext, configs[i].context);
          }
          for (let i = lastIndexCurrentStateMinAlt + 1; i < configs.length; i++) {
            let config2 = configs[i];
            let state = config2.state;
            alts.set(config2.alt);
            if (state.nonStopStateNumber !== currentState) {
              currentState = state.nonStopStateNumber;
              firstIndexCurrentState = i;
              lastIndexCurrentStateMinAlt = i;
              joinedCheckContext = config2.context;
              for (let j = firstIndexCurrentState + 1; j < configs.length; j++) {
                let config22 = configs[j];
                if (config22.alt !== minAlt) {
                  break;
                }
                if (config22.state.nonStopStateNumber !== currentState) {
                  break;
                }
                lastIndexCurrentStateMinAlt = j;
                joinedCheckContext = contextCache.join(joinedCheckContext, config22.context);
              }
              i = lastIndexCurrentStateMinAlt;
              continue;
            }
            let joinedCheckContext2 = config2.context;
            let currentAlt = config2.alt;
            let lastIndexCurrentStateCurrentAlt = i;
            for (let j = lastIndexCurrentStateCurrentAlt + 1; j < configs.length; j++) {
              let config22 = configs[j];
              if (config22.alt !== currentAlt) {
                break;
              }
              if (config22.state.nonStopStateNumber !== currentState) {
                break;
              }
              lastIndexCurrentStateCurrentAlt = j;
              joinedCheckContext2 = contextCache.join(joinedCheckContext2, config22.context);
            }
            i = lastIndexCurrentStateCurrentAlt;
            let check2 = contextCache.join(joinedCheckContext, joinedCheckContext2);
            if (!joinedCheckContext.equals(check2)) {
              return void 0;
            }
            exact = exact && joinedCheckContext.equals(joinedCheckContext2);
          }
          return new ConflictInfo_1.ConflictInfo(alts, exact);
        }
        getConflictingAltsFromConfigSet(configs) {
          let conflictingAlts = configs.conflictingAlts;
          if (conflictingAlts == null && configs.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            conflictingAlts = new BitSet_1.BitSet();
            conflictingAlts.set(configs.uniqueAlt);
          }
          return conflictingAlts;
        }
        getTokenName(t) {
          if (t === Token_1.Token.EOF) {
            return "EOF";
          }
          let vocabulary = this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
          let displayName = vocabulary.getDisplayName(t);
          if (displayName === String(t)) {
            return displayName;
          }
          return displayName + "<" + t + ">";
        }
        getLookaheadName(input) {
          return this.getTokenName(input.LA(1));
        }
        dumpDeadEndConfigs(nvae) {
          console.log("dead end configs: ");
          let deadEndConfigs = nvae.deadEndConfigs;
          if (!deadEndConfigs) {
            return;
          }
          for (let c of deadEndConfigs) {
            let trans = "no edges";
            if (c.state.numberOfOptimizedTransitions > 0) {
              let t = c.state.getOptimizedTransition(0);
              if (t instanceof AtomTransition_1.AtomTransition) {
                trans = "Atom " + this.getTokenName(t._label);
              } else if (t instanceof SetTransition_1.SetTransition) {
                let not2 = t instanceof NotSetTransition_1.NotSetTransition;
                trans = (not2 ? "~" : "") + "Set " + t.set.toString();
              }
            }
            console.log(c.toString(this._parser, true) + ":" + trans);
          }
        }
        noViableAlt(input, outerContext, configs, startIndex) {
          return new NoViableAltException_1.NoViableAltException(this._parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
        }
        getUniqueAlt(configs) {
          let alt = ATN_1.ATN.INVALID_ALT_NUMBER;
          for (let c of configs) {
            if (alt === ATN_1.ATN.INVALID_ALT_NUMBER) {
              alt = c.alt;
            } else if (c.alt !== alt) {
              return ATN_1.ATN.INVALID_ALT_NUMBER;
            }
          }
          return alt;
        }
        configWithAltAtStopState(configs, alt) {
          for (let c of configs) {
            if (c.alt === alt) {
              if (c.state instanceof RuleStopState_1.RuleStopState) {
                return true;
              }
            }
          }
          return false;
        }
        addDFAEdge(dfa, fromState, t, contextTransitions, toConfigs, contextCache) {
          assert2(contextTransitions == null || contextTransitions.isEmpty || dfa.isContextSensitive);
          let from = fromState;
          let to = this.addDFAState(dfa, toConfigs, contextCache);
          if (contextTransitions != null) {
            for (let context of contextTransitions.toArray()) {
              if (context === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                if (from.configs.isOutermostConfigSet) {
                  continue;
                }
              }
              from.setContextSensitive(this.atn);
              from.setContextSymbol(t);
              let next = from.getContextTarget(context);
              if (next != null) {
                from = next;
                continue;
              }
              next = this.addDFAContextState(dfa, from.configs, context, contextCache);
              assert2(context !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY || next.configs.isOutermostConfigSet);
              from.setContextTarget(context, next);
              from = next;
            }
          }
          if (ParserATNSimulator3.debug) {
            console.log("EDGE " + from + " -> " + to + " upon " + this.getTokenName(t));
          }
          this.setDFAEdge(from, t, to);
          if (ParserATNSimulator3.debug) {
            console.log("DFA=\n" + dfa.toString(this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY, this._parser != null ? this._parser.ruleNames : void 0));
          }
          return to;
        }
        setDFAEdge(p, t, q) {
          if (p != null) {
            p.setTarget(t, q);
          }
        }
        /** See comment on LexerInterpreter.addDFAState. */
        addDFAContextState(dfa, configs, returnContext, contextCache) {
          if (returnContext !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            let contextConfigs = new ATNConfigSet_1.ATNConfigSet();
            for (let config2 of configs) {
              contextConfigs.add(config2.appendContext(returnContext, contextCache));
            }
            return this.addDFAState(dfa, contextConfigs, contextCache);
          } else {
            assert2(!configs.isOutermostConfigSet, "Shouldn't be adding a duplicate edge.");
            configs = configs.clone(true);
            configs.isOutermostConfigSet = true;
            return this.addDFAState(dfa, configs, contextCache);
          }
        }
        /** See comment on LexerInterpreter.addDFAState. */
        addDFAState(dfa, configs, contextCache) {
          let enableDfa = this.enable_global_context_dfa || !configs.isOutermostConfigSet;
          if (enableDfa) {
            if (!configs.isReadOnly) {
              configs.optimizeConfigs(this);
            }
            let proposed = this.createDFAState(dfa, configs);
            let existing = dfa.states.get(proposed);
            if (existing != null) {
              return existing;
            }
          }
          if (!configs.isReadOnly) {
            if (configs.conflictInfo == null) {
              configs.conflictInfo = this.isConflicted(configs, contextCache);
            }
          }
          let newState = this.createDFAState(dfa, configs.clone(true));
          let decisionState = this.atn.getDecisionState(dfa.decision);
          let predictedAlt = this.getUniqueAlt(configs);
          if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(predictedAlt);
          } else if (configs.conflictingAlts != null) {
            let conflictingAlts = configs.conflictingAlts;
            if (conflictingAlts) {
              newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(conflictingAlts.nextSetBit(0));
            }
          }
          if (newState.isAcceptState && configs.hasSemanticContext) {
            this.predicateDFAState(newState, configs, decisionState.numberOfTransitions);
          }
          if (!enableDfa) {
            return newState;
          }
          let added = dfa.addState(newState);
          if (ParserATNSimulator3.debug && added === newState) {
            console.log("adding new DFA state: " + newState);
          }
          return added;
        }
        createDFAState(dfa, configs) {
          return new DFAState_1.DFAState(configs);
        }
        reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
          if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
            let interval = Interval_1.Interval.of(startIndex, stopIndex);
            console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + conflictState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
          }
          if (this._parser != null) {
            let listener = this._parser.getErrorListenerDispatch();
            if (listener.reportAttemptingFullContext) {
              listener.reportAttemptingFullContext(this._parser, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
            }
          }
        }
        reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
          if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
            let interval = Interval_1.Interval.of(startIndex, stopIndex);
            console.log("reportContextSensitivity decision=" + dfa.decision + ":" + acceptState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
          }
          if (this._parser != null) {
            let listener = this._parser.getErrorListenerDispatch();
            if (listener.reportContextSensitivity) {
              listener.reportContextSensitivity(this._parser, dfa, startIndex, stopIndex, prediction, acceptState);
            }
          }
        }
        /** If context sensitive parsing, we know it's ambiguity not conflict */
        reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
          if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
            let interval = Interval_1.Interval.of(startIndex, stopIndex);
            console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this._parser.inputStream.getText(interval));
          }
          if (this._parser != null) {
            let listener = this._parser.getErrorListenerDispatch();
            if (listener.reportAmbiguity) {
              listener.reportAmbiguity(this._parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
            }
          }
        }
        getReturnState(context) {
          if (context.isEmpty) {
            return PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
          }
          let state = this.atn.states[context.invokingState];
          let transition = state.transition(0);
          return transition.followState.stateNumber;
        }
        skipTailCalls(context) {
          if (!this.optimize_tail_calls) {
            return context;
          }
          while (!context.isEmpty) {
            let state = this.atn.states[context.invokingState];
            assert2(
              state.numberOfTransitions === 1 && state.transition(0).serializationType === 3
              /* RULE */
            );
            let transition = state.transition(0);
            if (!transition.tailCall) {
              break;
            }
            context = context.parent;
          }
          return context;
        }
        /**
         * @since 4.3
         */
        get parser() {
          return this._parser;
        }
      };
      ParserATNSimulator2.debug = false;
      ParserATNSimulator2.dfa_debug = false;
      ParserATNSimulator2.retry_debug = false;
      ParserATNSimulator2.STATE_ALT_SORT_COMPARATOR = (o1, o2) => {
        let diff = o1.state.nonStopStateNumber - o2.state.nonStopStateNumber;
        if (diff !== 0) {
          return diff;
        }
        diff = o1.alt - o2.alt;
        if (diff !== 0) {
          return diff;
        }
        return 0;
      };
      __decorate([
        Decorators_1.NotNull
      ], ParserATNSimulator2.prototype, "predictionMode", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ParserATNSimulator2.prototype, "getPredictionMode", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "setPredictionMode", null);
      __decorate([
        Decorators_1.Override
      ], ParserATNSimulator2.prototype, "reset", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "adaptivePredict", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "getStartState", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(3, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "execDFA", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(3, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "execATN", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "handleNoViableAlt", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "getExistingTargetState", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "computeTargetState", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "removeAllConfigsNotInRuleStopState", null);
      __decorate([
        Decorators_1.NotNull
      ], ParserATNSimulator2.prototype, "computeStartState", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "applyPrecedenceFilter", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "getReachableTarget", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "getPredsForAmbigAlts", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "evalSemanticContext", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "evalSemanticContextImpl", null);
      __decorate([
        __param(1, Decorators_1.NotNull),
        __param(4, Decorators_1.Nullable)
      ], ParserATNSimulator2.prototype, "closure", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.Nullable),
        __param(3, Decorators_1.NotNull),
        __param(6, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "closureImpl", null);
      __decorate([
        Decorators_1.NotNull
      ], ParserATNSimulator2.prototype, "getRuleName", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "getEpsilonTarget", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "actionTransition", null);
      __decorate([
        Decorators_1.Nullable,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "precedenceTransition", null);
      __decorate([
        Decorators_1.Nullable,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "predTransition", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.Nullable)
      ], ParserATNSimulator2.prototype, "ruleTransition", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "isConflicted", null);
      __decorate([
        Decorators_1.NotNull
      ], ParserATNSimulator2.prototype, "getTokenName", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "dumpDeadEndConfigs", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "noViableAlt", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "getUniqueAlt", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "configWithAltAtStopState", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(4, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "addDFAEdge", null);
      __decorate([
        __param(0, Decorators_1.Nullable),
        __param(2, Decorators_1.Nullable)
      ], ParserATNSimulator2.prototype, "setDFAEdge", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "addDFAContextState", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "addDFAState", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "createDFAState", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "reportAttemptingFullContext", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "reportContextSensitivity", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(5, Decorators_1.NotNull),
        __param(6, Decorators_1.NotNull)
      ], ParserATNSimulator2.prototype, "reportAmbiguity", null);
      ParserATNSimulator2 = __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParserATNSimulator2);
      exports.ParserATNSimulator = ParserATNSimulator2;
    }
  });

  // node_modules/antlr4ts/atn/PlusBlockStartState.js
  var require_PlusBlockStartState = __commonJS({
    "node_modules/antlr4ts/atn/PlusBlockStartState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PlusBlockStartState = void 0;
      var ATNStateType_1 = require_ATNStateType();
      var BlockStartState_1 = require_BlockStartState();
      var Decorators_1 = require_Decorators();
      var PlusBlockStartState = class extends BlockStartState_1.BlockStartState {
        get stateType() {
          return ATNStateType_1.ATNStateType.PLUS_BLOCK_START;
        }
      };
      __decorate([
        Decorators_1.Override
      ], PlusBlockStartState.prototype, "stateType", null);
      exports.PlusBlockStartState = PlusBlockStartState;
    }
  });

  // node_modules/antlr4ts/atn/PlusLoopbackState.js
  var require_PlusLoopbackState = __commonJS({
    "node_modules/antlr4ts/atn/PlusLoopbackState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PlusLoopbackState = void 0;
      var ATNStateType_1 = require_ATNStateType();
      var DecisionState_1 = require_DecisionState();
      var Decorators_1 = require_Decorators();
      var PlusLoopbackState = class extends DecisionState_1.DecisionState {
        get stateType() {
          return ATNStateType_1.ATNStateType.PLUS_LOOP_BACK;
        }
      };
      __decorate([
        Decorators_1.Override
      ], PlusLoopbackState.prototype, "stateType", null);
      exports.PlusLoopbackState = PlusLoopbackState;
    }
  });

  // node_modules/antlr4ts/atn/PrecedencePredicateTransition.js
  var require_PrecedencePredicateTransition = __commonJS({
    "node_modules/antlr4ts/atn/PrecedencePredicateTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PrecedencePredicateTransition = void 0;
      var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
      var Decorators_1 = require_Decorators();
      var SemanticContext_1 = require_SemanticContext();
      var PrecedencePredicateTransition = class PrecedencePredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {
        constructor(target, precedence) {
          super(target);
          this.precedence = precedence;
        }
        get serializationType() {
          return 10;
        }
        get isEpsilon() {
          return true;
        }
        matches(symbol2, minVocabSymbol, maxVocabSymbol) {
          return false;
        }
        get predicate() {
          return new SemanticContext_1.SemanticContext.PrecedencePredicate(this.precedence);
        }
        toString() {
          return this.precedence + " >= _p";
        }
      };
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicateTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicateTransition.prototype, "isEpsilon", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicateTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicateTransition.prototype, "toString", null);
      PrecedencePredicateTransition = __decorate([
        __param(0, Decorators_1.NotNull)
      ], PrecedencePredicateTransition);
      exports.PrecedencePredicateTransition = PrecedencePredicateTransition;
    }
  });

  // node_modules/antlr4ts/atn/RangeTransition.js
  var require_RangeTransition = __commonJS({
    "node_modules/antlr4ts/atn/RangeTransition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RangeTransition = void 0;
      var IntervalSet_1 = require_IntervalSet();
      var Decorators_1 = require_Decorators();
      var Transition_1 = require_Transition();
      var RangeTransition = class RangeTransition extends Transition_1.Transition {
        constructor(target, from, to) {
          super(target);
          this.from = from;
          this.to = to;
        }
        get serializationType() {
          return 2;
        }
        get label() {
          return IntervalSet_1.IntervalSet.of(this.from, this.to);
        }
        matches(symbol2, minVocabSymbol, maxVocabSymbol) {
          return symbol2 >= this.from && symbol2 <= this.to;
        }
        toString() {
          return "'" + String.fromCodePoint(this.from) + "'..'" + String.fromCodePoint(this.to) + "'";
        }
      };
      __decorate([
        Decorators_1.Override
      ], RangeTransition.prototype, "serializationType", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], RangeTransition.prototype, "label", null);
      __decorate([
        Decorators_1.Override
      ], RangeTransition.prototype, "matches", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull
      ], RangeTransition.prototype, "toString", null);
      RangeTransition = __decorate([
        __param(0, Decorators_1.NotNull)
      ], RangeTransition);
      exports.RangeTransition = RangeTransition;
    }
  });

  // node_modules/antlr4ts/atn/RuleStartState.js
  var require_RuleStartState = __commonJS({
    "node_modules/antlr4ts/atn/RuleStartState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleStartState = void 0;
      var ATNState_1 = require_ATNState();
      var ATNStateType_1 = require_ATNStateType();
      var Decorators_1 = require_Decorators();
      var RuleStartState = class extends ATNState_1.ATNState {
        constructor() {
          super(...arguments);
          this.isPrecedenceRule = false;
          this.leftFactored = false;
        }
        get stateType() {
          return ATNStateType_1.ATNStateType.RULE_START;
        }
      };
      __decorate([
        Decorators_1.Override
      ], RuleStartState.prototype, "stateType", null);
      exports.RuleStartState = RuleStartState;
    }
  });

  // node_modules/antlr4ts/atn/StarBlockStartState.js
  var require_StarBlockStartState = __commonJS({
    "node_modules/antlr4ts/atn/StarBlockStartState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StarBlockStartState = void 0;
      var ATNStateType_1 = require_ATNStateType();
      var BlockStartState_1 = require_BlockStartState();
      var Decorators_1 = require_Decorators();
      var StarBlockStartState = class extends BlockStartState_1.BlockStartState {
        get stateType() {
          return ATNStateType_1.ATNStateType.STAR_BLOCK_START;
        }
      };
      __decorate([
        Decorators_1.Override
      ], StarBlockStartState.prototype, "stateType", null);
      exports.StarBlockStartState = StarBlockStartState;
    }
  });

  // node_modules/antlr4ts/atn/StarLoopbackState.js
  var require_StarLoopbackState = __commonJS({
    "node_modules/antlr4ts/atn/StarLoopbackState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StarLoopbackState = void 0;
      var ATNState_1 = require_ATNState();
      var ATNStateType_1 = require_ATNStateType();
      var Decorators_1 = require_Decorators();
      var StarLoopbackState = class extends ATNState_1.ATNState {
        get loopEntryState() {
          return this.transition(0).target;
        }
        get stateType() {
          return ATNStateType_1.ATNStateType.STAR_LOOP_BACK;
        }
      };
      __decorate([
        Decorators_1.Override
      ], StarLoopbackState.prototype, "stateType", null);
      exports.StarLoopbackState = StarLoopbackState;
    }
  });

  // node_modules/antlr4ts/atn/TokensStartState.js
  var require_TokensStartState = __commonJS({
    "node_modules/antlr4ts/atn/TokensStartState.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TokensStartState = void 0;
      var ATNStateType_1 = require_ATNStateType();
      var DecisionState_1 = require_DecisionState();
      var Decorators_1 = require_Decorators();
      var TokensStartState = class extends DecisionState_1.DecisionState {
        get stateType() {
          return ATNStateType_1.ATNStateType.TOKEN_START;
        }
      };
      __decorate([
        Decorators_1.Override
      ], TokensStartState.prototype, "stateType", null);
      exports.TokensStartState = TokensStartState;
    }
  });

  // node_modules/antlr4ts/misc/UUID.js
  var require_UUID = __commonJS({
    "node_modules/antlr4ts/misc/UUID.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UUID = void 0;
      var MurmurHash_1 = require_MurmurHash();
      var UUID = class _UUID {
        constructor(mostSigBits, moreSigBits, lessSigBits, leastSigBits) {
          this.data = new Uint32Array(4);
          this.data[0] = mostSigBits;
          this.data[1] = moreSigBits;
          this.data[2] = lessSigBits;
          this.data[3] = leastSigBits;
        }
        static fromString(data) {
          if (!/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(data)) {
            throw new Error("Incorrectly formatted UUID");
          }
          let segments = data.split("-");
          let mostSigBits = parseInt(segments[0], 16);
          let moreSigBits = (parseInt(segments[1], 16) << 16 >>> 0) + parseInt(segments[2], 16);
          let lessSigBits = (parseInt(segments[3], 16) << 16 >>> 0) + parseInt(segments[4].substr(0, 4), 16);
          let leastSigBits = parseInt(segments[4].substr(-8), 16);
          return new _UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
        }
        hashCode() {
          return MurmurHash_1.MurmurHash.hashCode([this.data[0], this.data[1], this.data[2], this.data[3]]);
        }
        equals(obj) {
          if (obj === this) {
            return true;
          } else if (!(obj instanceof _UUID)) {
            return false;
          }
          return this.data[0] === obj.data[0] && this.data[1] === obj.data[1] && this.data[2] === obj.data[2] && this.data[3] === obj.data[3];
        }
        toString() {
          return ("00000000" + this.data[0].toString(16)).substr(-8) + "-" + ("0000" + (this.data[1] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[1].toString(16)).substr(-4) + "-" + ("0000" + (this.data[2] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[2].toString(16)).substr(-4) + ("00000000" + this.data[3].toString(16)).substr(-8);
        }
      };
      exports.UUID = UUID;
    }
  });

  // node_modules/antlr4ts/atn/ATNDeserializer.js
  var require_ATNDeserializer = __commonJS({
    "node_modules/antlr4ts/atn/ATNDeserializer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATNDeserializer = void 0;
      var ActionTransition_1 = require_ActionTransition();
      var Array2DHashSet_1 = require_Array2DHashSet();
      var ATN_1 = require_ATN();
      var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();
      var ATNStateType_1 = require_ATNStateType();
      var AtomTransition_1 = require_AtomTransition();
      var BasicBlockStartState_1 = require_BasicBlockStartState();
      var BasicState_1 = require_BasicState();
      var BitSet_1 = require_BitSet();
      var BlockEndState_1 = require_BlockEndState();
      var BlockStartState_1 = require_BlockStartState();
      var DecisionState_1 = require_DecisionState();
      var DFA_1 = require_DFA();
      var EpsilonTransition_1 = require_EpsilonTransition();
      var IntervalSet_1 = require_IntervalSet();
      var InvalidState_1 = require_InvalidState();
      var LexerChannelAction_1 = require_LexerChannelAction();
      var LexerCustomAction_1 = require_LexerCustomAction();
      var LexerModeAction_1 = require_LexerModeAction();
      var LexerMoreAction_1 = require_LexerMoreAction();
      var LexerPopModeAction_1 = require_LexerPopModeAction();
      var LexerPushModeAction_1 = require_LexerPushModeAction();
      var LexerSkipAction_1 = require_LexerSkipAction();
      var LexerTypeAction_1 = require_LexerTypeAction();
      var LoopEndState_1 = require_LoopEndState();
      var Decorators_1 = require_Decorators();
      var NotSetTransition_1 = require_NotSetTransition();
      var ParserATNSimulator_1 = require_ParserATNSimulator();
      var PlusBlockStartState_1 = require_PlusBlockStartState();
      var PlusLoopbackState_1 = require_PlusLoopbackState();
      var PrecedencePredicateTransition_1 = require_PrecedencePredicateTransition();
      var PredicateTransition_1 = require_PredicateTransition();
      var RangeTransition_1 = require_RangeTransition();
      var RuleStartState_1 = require_RuleStartState();
      var RuleStopState_1 = require_RuleStopState();
      var RuleTransition_1 = require_RuleTransition();
      var SetTransition_1 = require_SetTransition();
      var StarBlockStartState_1 = require_StarBlockStartState();
      var StarLoopbackState_1 = require_StarLoopbackState();
      var StarLoopEntryState_1 = require_StarLoopEntryState();
      var Token_1 = require_Token();
      var TokensStartState_1 = require_TokensStartState();
      var UUID_1 = require_UUID();
      var WildcardTransition_1 = require_WildcardTransition();
      var UnicodeDeserializingMode;
      (function(UnicodeDeserializingMode2) {
        UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_BMP"] = 0] = "UNICODE_BMP";
        UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_SMP"] = 1] = "UNICODE_SMP";
      })(UnicodeDeserializingMode || (UnicodeDeserializingMode = {}));
      var ATNDeserializer3 = class _ATNDeserializer {
        constructor(deserializationOptions) {
          if (deserializationOptions === void 0) {
            deserializationOptions = ATNDeserializationOptions_1.ATNDeserializationOptions.defaultOptions;
          }
          this.deserializationOptions = deserializationOptions;
        }
        static get SERIALIZED_VERSION() {
          return 3;
        }
        /**
         * Determines if a particular serialized representation of an ATN supports
         * a particular feature, identified by the {@link UUID} used for serializing
         * the ATN at the time the feature was first introduced.
         *
         * @param feature The {@link UUID} marking the first time the feature was
         * supported in the serialized ATN.
         * @param actualUuid The {@link UUID} of the actual serialized ATN which is
         * currently being deserialized.
         * @returns `true` if the `actualUuid` value represents a
         * serialized ATN at or after the feature identified by `feature` was
         * introduced; otherwise, `false`.
         */
        static isFeatureSupported(feature, actualUuid) {
          let featureIndex = _ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(feature));
          if (featureIndex < 0) {
            return false;
          }
          return _ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(actualUuid)) >= featureIndex;
        }
        static getUnicodeDeserializer(mode) {
          if (mode === 0) {
            return {
              readUnicode: (data, p) => {
                return _ATNDeserializer.toInt(data[p]);
              },
              size: 1
            };
          } else {
            return {
              readUnicode: (data, p) => {
                return _ATNDeserializer.toInt32(data, p);
              },
              size: 2
            };
          }
        }
        deserialize(data) {
          data = data.slice(0);
          for (let i = 1; i < data.length; i++) {
            data[i] = data[i] - 2 & 65535;
          }
          let p = 0;
          let version2 = _ATNDeserializer.toInt(data[p++]);
          if (version2 !== _ATNDeserializer.SERIALIZED_VERSION) {
            let reason = `Could not deserialize ATN with version ${version2} (expected ${_ATNDeserializer.SERIALIZED_VERSION}).`;
            throw new Error(reason);
          }
          let uuid3 = _ATNDeserializer.toUUID(data, p);
          p += 8;
          if (_ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(uuid3)) < 0) {
            let reason = `Could not deserialize ATN with UUID ${uuid3} (expected ${_ATNDeserializer.SERIALIZED_UUID} or a legacy UUID).`;
            throw new Error(reason);
          }
          let supportsLexerActions = _ATNDeserializer.isFeatureSupported(_ATNDeserializer.ADDED_LEXER_ACTIONS, uuid3);
          let grammarType = _ATNDeserializer.toInt(data[p++]);
          let maxTokenType = _ATNDeserializer.toInt(data[p++]);
          let atn = new ATN_1.ATN(grammarType, maxTokenType);
          let loopBackStateNumbers = [];
          let endStateNumbers = [];
          let nstates = _ATNDeserializer.toInt(data[p++]);
          for (let i = 0; i < nstates; i++) {
            let stype = _ATNDeserializer.toInt(data[p++]);
            if (stype === ATNStateType_1.ATNStateType.INVALID_TYPE) {
              atn.addState(new InvalidState_1.InvalidState());
              continue;
            }
            let ruleIndex = _ATNDeserializer.toInt(data[p++]);
            if (ruleIndex === 65535) {
              ruleIndex = -1;
            }
            let s = this.stateFactory(stype, ruleIndex);
            if (stype === ATNStateType_1.ATNStateType.LOOP_END) {
              let loopBackStateNumber = _ATNDeserializer.toInt(data[p++]);
              loopBackStateNumbers.push([s, loopBackStateNumber]);
            } else if (s instanceof BlockStartState_1.BlockStartState) {
              let endStateNumber = _ATNDeserializer.toInt(data[p++]);
              endStateNumbers.push([s, endStateNumber]);
            }
            atn.addState(s);
          }
          for (let pair of loopBackStateNumbers) {
            pair[0].loopBackState = atn.states[pair[1]];
          }
          for (let pair of endStateNumbers) {
            pair[0].endState = atn.states[pair[1]];
          }
          let numNonGreedyStates = _ATNDeserializer.toInt(data[p++]);
          for (let i = 0; i < numNonGreedyStates; i++) {
            let stateNumber = _ATNDeserializer.toInt(data[p++]);
            atn.states[stateNumber].nonGreedy = true;
          }
          let numSllDecisions = _ATNDeserializer.toInt(data[p++]);
          for (let i = 0; i < numSllDecisions; i++) {
            let stateNumber = _ATNDeserializer.toInt(data[p++]);
            atn.states[stateNumber].sll = true;
          }
          let numPrecedenceStates = _ATNDeserializer.toInt(data[p++]);
          for (let i = 0; i < numPrecedenceStates; i++) {
            let stateNumber = _ATNDeserializer.toInt(data[p++]);
            atn.states[stateNumber].isPrecedenceRule = true;
          }
          let nrules = _ATNDeserializer.toInt(data[p++]);
          if (atn.grammarType === 0) {
            atn.ruleToTokenType = new Int32Array(nrules);
          }
          atn.ruleToStartState = new Array(nrules);
          for (let i = 0; i < nrules; i++) {
            let s = _ATNDeserializer.toInt(data[p++]);
            let startState = atn.states[s];
            startState.leftFactored = _ATNDeserializer.toInt(data[p++]) !== 0;
            atn.ruleToStartState[i] = startState;
            if (atn.grammarType === 0) {
              let tokenType = _ATNDeserializer.toInt(data[p++]);
              if (tokenType === 65535) {
                tokenType = Token_1.Token.EOF;
              }
              atn.ruleToTokenType[i] = tokenType;
              if (!_ATNDeserializer.isFeatureSupported(_ATNDeserializer.ADDED_LEXER_ACTIONS, uuid3)) {
                let actionIndexIgnored = _ATNDeserializer.toInt(data[p++]);
                if (actionIndexIgnored === 65535) {
                  actionIndexIgnored = -1;
                }
              }
            }
          }
          atn.ruleToStopState = new Array(nrules);
          for (let state of atn.states) {
            if (!(state instanceof RuleStopState_1.RuleStopState)) {
              continue;
            }
            atn.ruleToStopState[state.ruleIndex] = state;
            atn.ruleToStartState[state.ruleIndex].stopState = state;
          }
          let nmodes = _ATNDeserializer.toInt(data[p++]);
          for (let i = 0; i < nmodes; i++) {
            let s = _ATNDeserializer.toInt(data[p++]);
            atn.modeToStartState.push(atn.states[s]);
          }
          atn.modeToDFA = new Array(nmodes);
          for (let i = 0; i < nmodes; i++) {
            atn.modeToDFA[i] = new DFA_1.DFA(atn.modeToStartState[i]);
          }
          let sets = [];
          p = this.deserializeSets(data, p, sets, _ATNDeserializer.getUnicodeDeserializer(
            0
            /* UNICODE_BMP */
          ));
          if (_ATNDeserializer.isFeatureSupported(_ATNDeserializer.ADDED_UNICODE_SMP, uuid3)) {
            p = this.deserializeSets(data, p, sets, _ATNDeserializer.getUnicodeDeserializer(
              1
              /* UNICODE_SMP */
            ));
          }
          let nedges = _ATNDeserializer.toInt(data[p++]);
          for (let i = 0; i < nedges; i++) {
            let src = _ATNDeserializer.toInt(data[p]);
            let trg = _ATNDeserializer.toInt(data[p + 1]);
            let ttype = _ATNDeserializer.toInt(data[p + 2]);
            let arg1 = _ATNDeserializer.toInt(data[p + 3]);
            let arg2 = _ATNDeserializer.toInt(data[p + 4]);
            let arg3 = _ATNDeserializer.toInt(data[p + 5]);
            let trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
            let srcState = atn.states[src];
            srcState.addTransition(trans);
            p += 6;
          }
          let returnTransitionsSet = new Array2DHashSet_1.Array2DHashSet({
            hashCode: (o) => o.stopState ^ o.returnState ^ o.outermostPrecedenceReturn,
            equals: (a, b) => {
              return a.stopState === b.stopState && a.returnState === b.returnState && a.outermostPrecedenceReturn === b.outermostPrecedenceReturn;
            }
          });
          let returnTransitions = [];
          for (let state of atn.states) {
            let returningToLeftFactored = state.ruleIndex >= 0 && atn.ruleToStartState[state.ruleIndex].leftFactored;
            for (let i = 0; i < state.numberOfTransitions; i++) {
              let t = state.transition(i);
              if (!(t instanceof RuleTransition_1.RuleTransition)) {
                continue;
              }
              let ruleTransition = t;
              let returningFromLeftFactored = atn.ruleToStartState[ruleTransition.target.ruleIndex].leftFactored;
              if (!returningFromLeftFactored && returningToLeftFactored) {
                continue;
              }
              let outermostPrecedenceReturn = -1;
              if (atn.ruleToStartState[ruleTransition.target.ruleIndex].isPrecedenceRule) {
                if (ruleTransition.precedence === 0) {
                  outermostPrecedenceReturn = ruleTransition.target.ruleIndex;
                }
              }
              let current = { stopState: ruleTransition.target.ruleIndex, returnState: ruleTransition.followState.stateNumber, outermostPrecedenceReturn };
              if (returnTransitionsSet.add(current)) {
                returnTransitions.push(current);
              }
            }
          }
          for (let returnTransition of returnTransitions) {
            let transition = new EpsilonTransition_1.EpsilonTransition(atn.states[returnTransition.returnState], returnTransition.outermostPrecedenceReturn);
            atn.ruleToStopState[returnTransition.stopState].addTransition(transition);
          }
          for (let state of atn.states) {
            if (state instanceof BlockStartState_1.BlockStartState) {
              if (state.endState === void 0) {
                throw new Error("IllegalStateException");
              }
              if (state.endState.startState !== void 0) {
                throw new Error("IllegalStateException");
              }
              state.endState.startState = state;
            }
            if (state instanceof PlusLoopbackState_1.PlusLoopbackState) {
              let loopbackState = state;
              for (let i = 0; i < loopbackState.numberOfTransitions; i++) {
                let target = loopbackState.transition(i).target;
                if (target instanceof PlusBlockStartState_1.PlusBlockStartState) {
                  target.loopBackState = loopbackState;
                }
              }
            } else if (state instanceof StarLoopbackState_1.StarLoopbackState) {
              let loopbackState = state;
              for (let i = 0; i < loopbackState.numberOfTransitions; i++) {
                let target = loopbackState.transition(i).target;
                if (target instanceof StarLoopEntryState_1.StarLoopEntryState) {
                  target.loopBackState = loopbackState;
                }
              }
            }
          }
          let ndecisions = _ATNDeserializer.toInt(data[p++]);
          for (let i = 1; i <= ndecisions; i++) {
            let s = _ATNDeserializer.toInt(data[p++]);
            let decState = atn.states[s];
            atn.decisionToState.push(decState);
            decState.decision = i - 1;
          }
          if (atn.grammarType === 0) {
            if (supportsLexerActions) {
              atn.lexerActions = new Array(_ATNDeserializer.toInt(data[p++]));
              for (let i = 0; i < atn.lexerActions.length; i++) {
                let actionType = _ATNDeserializer.toInt(data[p++]);
                let data1 = _ATNDeserializer.toInt(data[p++]);
                if (data1 === 65535) {
                  data1 = -1;
                }
                let data2 = _ATNDeserializer.toInt(data[p++]);
                if (data2 === 65535) {
                  data2 = -1;
                }
                let lexerAction = this.lexerActionFactory(actionType, data1, data2);
                atn.lexerActions[i] = lexerAction;
              }
            } else {
              let legacyLexerActions = [];
              for (let state of atn.states) {
                for (let i = 0; i < state.numberOfTransitions; i++) {
                  let transition = state.transition(i);
                  if (!(transition instanceof ActionTransition_1.ActionTransition)) {
                    continue;
                  }
                  let ruleIndex = transition.ruleIndex;
                  let actionIndex = transition.actionIndex;
                  let lexerAction = new LexerCustomAction_1.LexerCustomAction(ruleIndex, actionIndex);
                  state.setTransition(i, new ActionTransition_1.ActionTransition(transition.target, ruleIndex, legacyLexerActions.length, false));
                  legacyLexerActions.push(lexerAction);
                }
              }
              atn.lexerActions = legacyLexerActions;
            }
          }
          this.markPrecedenceDecisions(atn);
          atn.decisionToDFA = new Array(ndecisions);
          for (let i = 0; i < ndecisions; i++) {
            atn.decisionToDFA[i] = new DFA_1.DFA(atn.decisionToState[i], i);
          }
          if (this.deserializationOptions.isVerifyATN) {
            this.verifyATN(atn);
          }
          if (this.deserializationOptions.isGenerateRuleBypassTransitions && atn.grammarType === 1) {
            atn.ruleToTokenType = new Int32Array(atn.ruleToStartState.length);
            for (let i = 0; i < atn.ruleToStartState.length; i++) {
              atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
            }
            for (let i = 0; i < atn.ruleToStartState.length; i++) {
              let bypassStart = new BasicBlockStartState_1.BasicBlockStartState();
              bypassStart.ruleIndex = i;
              atn.addState(bypassStart);
              let bypassStop = new BlockEndState_1.BlockEndState();
              bypassStop.ruleIndex = i;
              atn.addState(bypassStop);
              bypassStart.endState = bypassStop;
              atn.defineDecisionState(bypassStart);
              bypassStop.startState = bypassStart;
              let endState;
              let excludeTransition;
              if (atn.ruleToStartState[i].isPrecedenceRule) {
                endState = void 0;
                for (let state of atn.states) {
                  if (state.ruleIndex !== i) {
                    continue;
                  }
                  if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
                    continue;
                  }
                  let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
                  if (!(maybeLoopEndState instanceof LoopEndState_1.LoopEndState)) {
                    continue;
                  }
                  if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                    endState = state;
                    break;
                  }
                }
                if (!endState) {
                  throw new Error("Couldn't identify final state of the precedence rule prefix section.");
                }
                excludeTransition = endState.loopBackState.transition(0);
              } else {
                endState = atn.ruleToStopState[i];
              }
              for (let state of atn.states) {
                for (let i2 = 0; i2 < state.numberOfTransitions; i2++) {
                  let transition = state.transition(i2);
                  if (transition === excludeTransition) {
                    continue;
                  }
                  if (transition.target === endState) {
                    transition.target = bypassStop;
                  }
                }
              }
              while (atn.ruleToStartState[i].numberOfTransitions > 0) {
                let transition = atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].numberOfTransitions - 1);
                bypassStart.addTransition(transition);
              }
              atn.ruleToStartState[i].addTransition(new EpsilonTransition_1.EpsilonTransition(bypassStart));
              bypassStop.addTransition(new EpsilonTransition_1.EpsilonTransition(endState));
              let matchState = new BasicState_1.BasicState();
              atn.addState(matchState);
              matchState.addTransition(new AtomTransition_1.AtomTransition(bypassStop, atn.ruleToTokenType[i]));
              bypassStart.addTransition(new EpsilonTransition_1.EpsilonTransition(matchState));
            }
            if (this.deserializationOptions.isVerifyATN) {
              this.verifyATN(atn);
            }
          }
          if (this.deserializationOptions.isOptimize) {
            while (true) {
              let optimizationCount = 0;
              optimizationCount += _ATNDeserializer.inlineSetRules(atn);
              optimizationCount += _ATNDeserializer.combineChainedEpsilons(atn);
              let preserveOrder = atn.grammarType === 0;
              optimizationCount += _ATNDeserializer.optimizeSets(atn, preserveOrder);
              if (optimizationCount === 0) {
                break;
              }
            }
            if (this.deserializationOptions.isVerifyATN) {
              this.verifyATN(atn);
            }
          }
          _ATNDeserializer.identifyTailCalls(atn);
          return atn;
        }
        deserializeSets(data, p, sets, unicodeDeserializer) {
          let nsets = _ATNDeserializer.toInt(data[p++]);
          for (let i = 0; i < nsets; i++) {
            let nintervals = _ATNDeserializer.toInt(data[p]);
            p++;
            let set2 = new IntervalSet_1.IntervalSet();
            sets.push(set2);
            let containsEof = _ATNDeserializer.toInt(data[p++]) !== 0;
            if (containsEof) {
              set2.add(-1);
            }
            for (let j = 0; j < nintervals; j++) {
              let a = unicodeDeserializer.readUnicode(data, p);
              p += unicodeDeserializer.size;
              let b = unicodeDeserializer.readUnicode(data, p);
              p += unicodeDeserializer.size;
              set2.add(a, b);
            }
          }
          return p;
        }
        /**
         * Analyze the {@link StarLoopEntryState} states in the specified ATN to set
         * the {@link StarLoopEntryState#precedenceRuleDecision} field to the
         * correct value.
         *
         * @param atn The ATN.
         */
        markPrecedenceDecisions(atn) {
          let rulePrecedenceDecisions = /* @__PURE__ */ new Map();
          for (let state of atn.states) {
            if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
              continue;
            }
            if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
              let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
              if (maybeLoopEndState instanceof LoopEndState_1.LoopEndState) {
                if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                  rulePrecedenceDecisions.set(state.ruleIndex, state);
                  state.precedenceRuleDecision = true;
                  state.precedenceLoopbackStates = new BitSet_1.BitSet(atn.states.length);
                }
              }
            }
          }
          for (let precedenceDecision of rulePrecedenceDecisions) {
            for (let transition of atn.ruleToStopState[precedenceDecision[0]].getTransitions()) {
              if (transition.serializationType !== 1) {
                continue;
              }
              let epsilonTransition = transition;
              if (epsilonTransition.outermostPrecedenceReturn !== -1) {
                continue;
              }
              precedenceDecision[1].precedenceLoopbackStates.set(transition.target.stateNumber);
            }
          }
        }
        verifyATN(atn) {
          for (let state of atn.states) {
            this.checkCondition(state !== void 0, "ATN states should not be undefined.");
            if (state.stateType === ATNStateType_1.ATNStateType.INVALID_TYPE) {
              continue;
            }
            this.checkCondition(state.onlyHasEpsilonTransitions || state.numberOfTransitions <= 1);
            if (state instanceof PlusBlockStartState_1.PlusBlockStartState) {
              this.checkCondition(state.loopBackState !== void 0);
            }
            if (state instanceof StarLoopEntryState_1.StarLoopEntryState) {
              let starLoopEntryState = state;
              this.checkCondition(starLoopEntryState.loopBackState !== void 0);
              this.checkCondition(starLoopEntryState.numberOfTransitions === 2);
              if (starLoopEntryState.transition(0).target instanceof StarBlockStartState_1.StarBlockStartState) {
                this.checkCondition(starLoopEntryState.transition(1).target instanceof LoopEndState_1.LoopEndState);
                this.checkCondition(!starLoopEntryState.nonGreedy);
              } else if (starLoopEntryState.transition(0).target instanceof LoopEndState_1.LoopEndState) {
                this.checkCondition(starLoopEntryState.transition(1).target instanceof StarBlockStartState_1.StarBlockStartState);
                this.checkCondition(starLoopEntryState.nonGreedy);
              } else {
                throw new Error("IllegalStateException");
              }
            }
            if (state instanceof StarLoopbackState_1.StarLoopbackState) {
              this.checkCondition(state.numberOfTransitions === 1);
              this.checkCondition(state.transition(0).target instanceof StarLoopEntryState_1.StarLoopEntryState);
            }
            if (state instanceof LoopEndState_1.LoopEndState) {
              this.checkCondition(state.loopBackState !== void 0);
            }
            if (state instanceof RuleStartState_1.RuleStartState) {
              this.checkCondition(state.stopState !== void 0);
            }
            if (state instanceof BlockStartState_1.BlockStartState) {
              this.checkCondition(state.endState !== void 0);
            }
            if (state instanceof BlockEndState_1.BlockEndState) {
              this.checkCondition(state.startState !== void 0);
            }
            if (state instanceof DecisionState_1.DecisionState) {
              let decisionState = state;
              this.checkCondition(decisionState.numberOfTransitions <= 1 || decisionState.decision >= 0);
            } else {
              this.checkCondition(state.numberOfTransitions <= 1 || state instanceof RuleStopState_1.RuleStopState);
            }
          }
        }
        checkCondition(condition, message) {
          if (!condition) {
            throw new Error("IllegalStateException: " + message);
          }
        }
        static inlineSetRules(atn) {
          let inlinedCalls = 0;
          let ruleToInlineTransition = new Array(atn.ruleToStartState.length);
          for (let i = 0; i < atn.ruleToStartState.length; i++) {
            let startState = atn.ruleToStartState[i];
            let middleState = startState;
            while (middleState.onlyHasEpsilonTransitions && middleState.numberOfOptimizedTransitions === 1 && middleState.getOptimizedTransition(0).serializationType === 1) {
              middleState = middleState.getOptimizedTransition(0).target;
            }
            if (middleState.numberOfOptimizedTransitions !== 1) {
              continue;
            }
            let matchTransition = middleState.getOptimizedTransition(0);
            let matchTarget = matchTransition.target;
            if (matchTransition.isEpsilon || !matchTarget.onlyHasEpsilonTransitions || matchTarget.numberOfOptimizedTransitions !== 1 || !(matchTarget.getOptimizedTransition(0).target instanceof RuleStopState_1.RuleStopState)) {
              continue;
            }
            switch (matchTransition.serializationType) {
              case 5:
              case 2:
              case 7:
                ruleToInlineTransition[i] = matchTransition;
                break;
              case 8:
              case 9:
                continue;
              default:
                continue;
            }
          }
          for (let state of atn.states) {
            if (state.ruleIndex < 0) {
              continue;
            }
            let optimizedTransitions;
            for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
              let transition = state.getOptimizedTransition(i);
              if (!(transition instanceof RuleTransition_1.RuleTransition)) {
                if (optimizedTransitions !== void 0) {
                  optimizedTransitions.push(transition);
                }
                continue;
              }
              let ruleTransition = transition;
              let effective = ruleToInlineTransition[ruleTransition.target.ruleIndex];
              if (effective === void 0) {
                if (optimizedTransitions !== void 0) {
                  optimizedTransitions.push(transition);
                }
                continue;
              }
              if (optimizedTransitions === void 0) {
                optimizedTransitions = [];
                for (let j = 0; j < i; j++) {
                  optimizedTransitions.push(state.getOptimizedTransition(i));
                }
              }
              inlinedCalls++;
              let target = ruleTransition.followState;
              let intermediateState = new BasicState_1.BasicState();
              intermediateState.setRuleIndex(target.ruleIndex);
              atn.addState(intermediateState);
              optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(intermediateState));
              switch (effective.serializationType) {
                case 5:
                  intermediateState.addTransition(new AtomTransition_1.AtomTransition(target, effective._label));
                  break;
                case 2:
                  intermediateState.addTransition(new RangeTransition_1.RangeTransition(target, effective.from, effective.to));
                  break;
                case 7:
                  intermediateState.addTransition(new SetTransition_1.SetTransition(target, effective.label));
                  break;
                default:
                  throw new Error("UnsupportedOperationException");
              }
            }
            if (optimizedTransitions !== void 0) {
              if (state.isOptimized) {
                while (state.numberOfOptimizedTransitions > 0) {
                  state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
                }
              }
              for (let transition of optimizedTransitions) {
                state.addOptimizedTransition(transition);
              }
            }
          }
          if (ParserATNSimulator_1.ParserATNSimulator.debug) {
            console.log("ATN runtime optimizer removed " + inlinedCalls + " rule invocations by inlining sets.");
          }
          return inlinedCalls;
        }
        static combineChainedEpsilons(atn) {
          let removedEdges = 0;
          for (let state of atn.states) {
            if (!state.onlyHasEpsilonTransitions || state instanceof RuleStopState_1.RuleStopState) {
              continue;
            }
            let optimizedTransitions;
            nextTransition: for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
              let transition = state.getOptimizedTransition(i);
              let intermediate = transition.target;
              if (transition.serializationType !== 1 || transition.outermostPrecedenceReturn !== -1 || intermediate.stateType !== ATNStateType_1.ATNStateType.BASIC || !intermediate.onlyHasEpsilonTransitions) {
                if (optimizedTransitions !== void 0) {
                  optimizedTransitions.push(transition);
                }
                continue nextTransition;
              }
              for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
                if (intermediate.getOptimizedTransition(j).serializationType !== 1 || intermediate.getOptimizedTransition(j).outermostPrecedenceReturn !== -1) {
                  if (optimizedTransitions !== void 0) {
                    optimizedTransitions.push(transition);
                  }
                  continue nextTransition;
                }
              }
              removedEdges++;
              if (optimizedTransitions === void 0) {
                optimizedTransitions = [];
                for (let j = 0; j < i; j++) {
                  optimizedTransitions.push(state.getOptimizedTransition(j));
                }
              }
              for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
                let target = intermediate.getOptimizedTransition(j).target;
                optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(target));
              }
            }
            if (optimizedTransitions !== void 0) {
              if (state.isOptimized) {
                while (state.numberOfOptimizedTransitions > 0) {
                  state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
                }
              }
              for (let transition of optimizedTransitions) {
                state.addOptimizedTransition(transition);
              }
            }
          }
          if (ParserATNSimulator_1.ParserATNSimulator.debug) {
            console.log("ATN runtime optimizer removed " + removedEdges + " transitions by combining chained epsilon transitions.");
          }
          return removedEdges;
        }
        static optimizeSets(atn, preserveOrder) {
          if (preserveOrder) {
            return 0;
          }
          let removedPaths = 0;
          let decisions = atn.decisionToState;
          for (let decision of decisions) {
            let setTransitions = new IntervalSet_1.IntervalSet();
            for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {
              let epsTransition = decision.getOptimizedTransition(i);
              if (!(epsTransition instanceof EpsilonTransition_1.EpsilonTransition)) {
                continue;
              }
              if (epsTransition.target.numberOfOptimizedTransitions !== 1) {
                continue;
              }
              let transition = epsTransition.target.getOptimizedTransition(0);
              if (!(transition.target instanceof BlockEndState_1.BlockEndState)) {
                continue;
              }
              if (transition instanceof NotSetTransition_1.NotSetTransition) {
                continue;
              }
              if (transition instanceof AtomTransition_1.AtomTransition || transition instanceof RangeTransition_1.RangeTransition || transition instanceof SetTransition_1.SetTransition) {
                setTransitions.add(i);
              }
            }
            if (setTransitions.size <= 1) {
              continue;
            }
            let optimizedTransitions = [];
            for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {
              if (!setTransitions.contains(i)) {
                optimizedTransitions.push(decision.getOptimizedTransition(i));
              }
            }
            let blockEndState = decision.getOptimizedTransition(setTransitions.minElement).target.getOptimizedTransition(0).target;
            let matchSet = new IntervalSet_1.IntervalSet();
            for (let interval of setTransitions.intervals) {
              for (let j = interval.a; j <= interval.b; j++) {
                let matchTransition = decision.getOptimizedTransition(j).target.getOptimizedTransition(0);
                if (matchTransition instanceof NotSetTransition_1.NotSetTransition) {
                  throw new Error("Not yet implemented.");
                } else {
                  matchSet.addAll(matchTransition.label);
                }
              }
            }
            let newTransition;
            if (matchSet.intervals.length === 1) {
              if (matchSet.size === 1) {
                newTransition = new AtomTransition_1.AtomTransition(blockEndState, matchSet.minElement);
              } else {
                let matchInterval = matchSet.intervals[0];
                newTransition = new RangeTransition_1.RangeTransition(blockEndState, matchInterval.a, matchInterval.b);
              }
            } else {
              newTransition = new SetTransition_1.SetTransition(blockEndState, matchSet);
            }
            let setOptimizedState = new BasicState_1.BasicState();
            setOptimizedState.setRuleIndex(decision.ruleIndex);
            atn.addState(setOptimizedState);
            setOptimizedState.addTransition(newTransition);
            optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(setOptimizedState));
            removedPaths += decision.numberOfOptimizedTransitions - optimizedTransitions.length;
            if (decision.isOptimized) {
              while (decision.numberOfOptimizedTransitions > 0) {
                decision.removeOptimizedTransition(decision.numberOfOptimizedTransitions - 1);
              }
            }
            for (let transition of optimizedTransitions) {
              decision.addOptimizedTransition(transition);
            }
          }
          if (ParserATNSimulator_1.ParserATNSimulator.debug) {
            console.log("ATN runtime optimizer removed " + removedPaths + " paths by collapsing sets.");
          }
          return removedPaths;
        }
        static identifyTailCalls(atn) {
          for (let state of atn.states) {
            for (let i = 0; i < state.numberOfTransitions; i++) {
              let transition = state.transition(i);
              if (!(transition instanceof RuleTransition_1.RuleTransition)) {
                continue;
              }
              transition.tailCall = this.testTailCall(atn, transition, false);
              transition.optimizedTailCall = this.testTailCall(atn, transition, true);
            }
            if (!state.isOptimized) {
              continue;
            }
            for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
              let transition = state.getOptimizedTransition(i);
              if (!(transition instanceof RuleTransition_1.RuleTransition)) {
                continue;
              }
              transition.tailCall = this.testTailCall(atn, transition, false);
              transition.optimizedTailCall = this.testTailCall(atn, transition, true);
            }
          }
        }
        static testTailCall(atn, transition, optimizedPath) {
          if (!optimizedPath && transition.tailCall) {
            return true;
          }
          if (optimizedPath && transition.optimizedTailCall) {
            return true;
          }
          let reachable = new BitSet_1.BitSet(atn.states.length);
          let worklist = [];
          worklist.push(transition.followState);
          while (true) {
            let state = worklist.pop();
            if (!state) {
              break;
            }
            if (reachable.get(state.stateNumber)) {
              continue;
            }
            if (state instanceof RuleStopState_1.RuleStopState) {
              continue;
            }
            if (!state.onlyHasEpsilonTransitions) {
              return false;
            }
            let transitionCount = optimizedPath ? state.numberOfOptimizedTransitions : state.numberOfTransitions;
            for (let i = 0; i < transitionCount; i++) {
              let t = optimizedPath ? state.getOptimizedTransition(i) : state.transition(i);
              if (t.serializationType !== 1) {
                return false;
              }
              worklist.push(t.target);
            }
          }
          return true;
        }
        static toInt(c) {
          return c;
        }
        static toInt32(data, offset) {
          return (data[offset] | data[offset + 1] << 16) >>> 0;
        }
        static toUUID(data, offset) {
          let leastSigBits = _ATNDeserializer.toInt32(data, offset);
          let lessSigBits = _ATNDeserializer.toInt32(data, offset + 2);
          let moreSigBits = _ATNDeserializer.toInt32(data, offset + 4);
          let mostSigBits = _ATNDeserializer.toInt32(data, offset + 6);
          return new UUID_1.UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
        }
        edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {
          let target = atn.states[trg];
          switch (type) {
            case 1:
              return new EpsilonTransition_1.EpsilonTransition(target);
            case 2:
              if (arg3 !== 0) {
                return new RangeTransition_1.RangeTransition(target, Token_1.Token.EOF, arg2);
              } else {
                return new RangeTransition_1.RangeTransition(target, arg1, arg2);
              }
            case 3:
              let rt = new RuleTransition_1.RuleTransition(atn.states[arg1], arg2, arg3, target);
              return rt;
            case 4:
              let pt = new PredicateTransition_1.PredicateTransition(target, arg1, arg2, arg3 !== 0);
              return pt;
            case 10:
              return new PrecedencePredicateTransition_1.PrecedencePredicateTransition(target, arg1);
            case 5:
              if (arg3 !== 0) {
                return new AtomTransition_1.AtomTransition(target, Token_1.Token.EOF);
              } else {
                return new AtomTransition_1.AtomTransition(target, arg1);
              }
            case 6:
              let a = new ActionTransition_1.ActionTransition(target, arg1, arg2, arg3 !== 0);
              return a;
            case 7:
              return new SetTransition_1.SetTransition(target, sets[arg1]);
            case 8:
              return new NotSetTransition_1.NotSetTransition(target, sets[arg1]);
            case 9:
              return new WildcardTransition_1.WildcardTransition(target);
          }
          throw new Error("The specified transition type is not valid.");
        }
        stateFactory(type, ruleIndex) {
          let s;
          switch (type) {
            case ATNStateType_1.ATNStateType.INVALID_TYPE:
              return new InvalidState_1.InvalidState();
            case ATNStateType_1.ATNStateType.BASIC:
              s = new BasicState_1.BasicState();
              break;
            case ATNStateType_1.ATNStateType.RULE_START:
              s = new RuleStartState_1.RuleStartState();
              break;
            case ATNStateType_1.ATNStateType.BLOCK_START:
              s = new BasicBlockStartState_1.BasicBlockStartState();
              break;
            case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
              s = new PlusBlockStartState_1.PlusBlockStartState();
              break;
            case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
              s = new StarBlockStartState_1.StarBlockStartState();
              break;
            case ATNStateType_1.ATNStateType.TOKEN_START:
              s = new TokensStartState_1.TokensStartState();
              break;
            case ATNStateType_1.ATNStateType.RULE_STOP:
              s = new RuleStopState_1.RuleStopState();
              break;
            case ATNStateType_1.ATNStateType.BLOCK_END:
              s = new BlockEndState_1.BlockEndState();
              break;
            case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
              s = new StarLoopbackState_1.StarLoopbackState();
              break;
            case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
              s = new StarLoopEntryState_1.StarLoopEntryState();
              break;
            case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
              s = new PlusLoopbackState_1.PlusLoopbackState();
              break;
            case ATNStateType_1.ATNStateType.LOOP_END:
              s = new LoopEndState_1.LoopEndState();
              break;
            default:
              let message = `The specified state type ${type} is not valid.`;
              throw new Error(message);
          }
          s.ruleIndex = ruleIndex;
          return s;
        }
        lexerActionFactory(type, data1, data2) {
          switch (type) {
            case 0:
              return new LexerChannelAction_1.LexerChannelAction(data1);
            case 1:
              return new LexerCustomAction_1.LexerCustomAction(data1, data2);
            case 2:
              return new LexerModeAction_1.LexerModeAction(data1);
            case 3:
              return LexerMoreAction_1.LexerMoreAction.INSTANCE;
            case 4:
              return LexerPopModeAction_1.LexerPopModeAction.INSTANCE;
            case 5:
              return new LexerPushModeAction_1.LexerPushModeAction(data1);
            case 6:
              return LexerSkipAction_1.LexerSkipAction.INSTANCE;
            case 7:
              return new LexerTypeAction_1.LexerTypeAction(data1);
            default:
              let message = `The specified lexer action type ${type} is not valid.`;
              throw new Error(message);
          }
        }
      };
      ATNDeserializer3.BASE_SERIALIZED_UUID = UUID_1.UUID.fromString("E4178468-DF95-44D0-AD87-F22A5D5FB6D3");
      ATNDeserializer3.ADDED_LEXER_ACTIONS = UUID_1.UUID.fromString("AB35191A-1603-487E-B75A-479B831EAF6D");
      ATNDeserializer3.ADDED_UNICODE_SMP = UUID_1.UUID.fromString("C23FEA89-0605-4f51-AFB8-058BCAB8C91B");
      ATNDeserializer3.SUPPORTED_UUIDS = [
        ATNDeserializer3.BASE_SERIALIZED_UUID,
        ATNDeserializer3.ADDED_LEXER_ACTIONS,
        ATNDeserializer3.ADDED_UNICODE_SMP
      ];
      ATNDeserializer3.SERIALIZED_UUID = ATNDeserializer3.ADDED_UNICODE_SMP;
      __decorate([
        Decorators_1.NotNull
      ], ATNDeserializer3.prototype, "deserializationOptions", void 0);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ATNDeserializer3.prototype, "deserialize", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ATNDeserializer3.prototype, "markPrecedenceDecisions", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], ATNDeserializer3.prototype, "edgeFactory", null);
      exports.ATNDeserializer = ATNDeserializer3;
    }
  });

  // node_modules/antlr4ts/atn/ParseInfo.js
  var require_ParseInfo = __commonJS({
    "node_modules/antlr4ts/atn/ParseInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParseInfo = void 0;
      var Decorators_1 = require_Decorators();
      var ParseInfo = class ParseInfo {
        constructor(atnSimulator) {
          this.atnSimulator = atnSimulator;
        }
        /**
         * Gets an array of {@link DecisionInfo} instances containing the profiling
         * information gathered for each decision in the ATN.
         *
         * @returns An array of {@link DecisionInfo} instances, indexed by decision
         * number.
         */
        getDecisionInfo() {
          return this.atnSimulator.getDecisionInfo();
        }
        /**
         * Gets the decision numbers for decisions that required one or more
         * full-context predictions during parsing. These are decisions for which
         * {@link DecisionInfo#LL_Fallback} is non-zero.
         *
         * @returns A list of decision numbers which required one or more
         * full-context predictions during parsing.
         */
        getLLDecisions() {
          let decisions = this.atnSimulator.getDecisionInfo();
          let LL = [];
          for (let i = 0; i < decisions.length; i++) {
            let fallBack = decisions[i].LL_Fallback;
            if (fallBack > 0) {
              LL.push(i);
            }
          }
          return LL;
        }
        /**
         * Gets the total time spent during prediction across all decisions made
         * during parsing. This value is the sum of
         * {@link DecisionInfo#timeInPrediction} for all decisions.
         */
        getTotalTimeInPrediction() {
          let decisions = this.atnSimulator.getDecisionInfo();
          let t = 0;
          for (let decision of decisions) {
            t += decision.timeInPrediction;
          }
          return t;
        }
        /**
         * Gets the total number of SLL lookahead operations across all decisions
         * made during parsing. This value is the sum of
         * {@link DecisionInfo#SLL_TotalLook} for all decisions.
         */
        getTotalSLLLookaheadOps() {
          let decisions = this.atnSimulator.getDecisionInfo();
          let k = 0;
          for (let decision of decisions) {
            k += decision.SLL_TotalLook;
          }
          return k;
        }
        /**
         * Gets the total number of LL lookahead operations across all decisions
         * made during parsing. This value is the sum of
         * {@link DecisionInfo#LL_TotalLook} for all decisions.
         */
        getTotalLLLookaheadOps() {
          let decisions = this.atnSimulator.getDecisionInfo();
          let k = 0;
          for (let decision of decisions) {
            k += decision.LL_TotalLook;
          }
          return k;
        }
        /**
         * Gets the total number of ATN lookahead operations for SLL prediction
         * across all decisions made during parsing.
         */
        getTotalSLLATNLookaheadOps() {
          let decisions = this.atnSimulator.getDecisionInfo();
          let k = 0;
          for (let decision of decisions) {
            k += decision.SLL_ATNTransitions;
          }
          return k;
        }
        /**
         * Gets the total number of ATN lookahead operations for LL prediction
         * across all decisions made during parsing.
         */
        getTotalLLATNLookaheadOps() {
          let decisions = this.atnSimulator.getDecisionInfo();
          let k = 0;
          for (let decision of decisions) {
            k += decision.LL_ATNTransitions;
          }
          return k;
        }
        /**
         * Gets the total number of ATN lookahead operations for SLL and LL
         * prediction across all decisions made during parsing.
         *
         * This value is the sum of {@link #getTotalSLLATNLookaheadOps} and
         * {@link #getTotalLLATNLookaheadOps}.
         */
        getTotalATNLookaheadOps() {
          let decisions = this.atnSimulator.getDecisionInfo();
          let k = 0;
          for (let decision of decisions) {
            k += decision.SLL_ATNTransitions;
            k += decision.LL_ATNTransitions;
          }
          return k;
        }
        getDFASize(decision) {
          if (decision) {
            let decisionToDFA = this.atnSimulator.atn.decisionToDFA[decision];
            return decisionToDFA.states.size;
          } else {
            let n = 0;
            let decisionToDFA = this.atnSimulator.atn.decisionToDFA;
            for (let i = 0; i < decisionToDFA.length; i++) {
              n += this.getDFASize(i);
            }
            return n;
          }
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ParseInfo.prototype, "getDecisionInfo", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseInfo.prototype, "getLLDecisions", null);
      ParseInfo = __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParseInfo);
      exports.ParseInfo = ParseInfo;
    }
  });

  // node_modules/antlr4ts/ProxyParserErrorListener.js
  var require_ProxyParserErrorListener = __commonJS({
    "node_modules/antlr4ts/ProxyParserErrorListener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProxyParserErrorListener = void 0;
      var ProxyErrorListener_1 = require_ProxyErrorListener();
      var Decorators_1 = require_Decorators();
      var ProxyParserErrorListener = class extends ProxyErrorListener_1.ProxyErrorListener {
        constructor(delegates) {
          super(delegates);
        }
        reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
          this.getDelegates().forEach((listener) => {
            if (listener.reportAmbiguity) {
              listener.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
            }
          });
        }
        reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
          this.getDelegates().forEach((listener) => {
            if (listener.reportAttemptingFullContext) {
              listener.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
            }
          });
        }
        reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
          this.getDelegates().forEach((listener) => {
            if (listener.reportContextSensitivity) {
              listener.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState);
            }
          });
        }
      };
      __decorate([
        Decorators_1.Override
      ], ProxyParserErrorListener.prototype, "reportAmbiguity", null);
      __decorate([
        Decorators_1.Override
      ], ProxyParserErrorListener.prototype, "reportAttemptingFullContext", null);
      __decorate([
        Decorators_1.Override
      ], ProxyParserErrorListener.prototype, "reportContextSensitivity", null);
      exports.ProxyParserErrorListener = ProxyParserErrorListener;
    }
  });

  // node_modules/antlr4ts/misc/Character.js
  var require_Character = __commonJS({
    "node_modules/antlr4ts/misc/Character.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isSupplementaryCodePoint = exports.isLowSurrogate = exports.isHighSurrogate = void 0;
      function isHighSurrogate(ch) {
        return ch >= 55296 && ch <= 56319;
      }
      exports.isHighSurrogate = isHighSurrogate;
      function isLowSurrogate(ch) {
        return ch >= 56320 && ch <= 57343;
      }
      exports.isLowSurrogate = isLowSurrogate;
      function isSupplementaryCodePoint(ch) {
        return ch >= 65536;
      }
      exports.isSupplementaryCodePoint = isSupplementaryCodePoint;
    }
  });

  // node_modules/antlr4ts/CodePointBuffer.js
  var require_CodePointBuffer = __commonJS({
    "node_modules/antlr4ts/CodePointBuffer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CodePointBuffer = void 0;
      var assert2 = require_assert();
      var Character = require_Character();
      var CodePointBuffer = class _CodePointBuffer {
        constructor(buffer, size) {
          this.buffer = buffer;
          this._position = 0;
          this._size = size;
        }
        static withArray(buffer) {
          return new _CodePointBuffer(buffer, buffer.length);
        }
        get position() {
          return this._position;
        }
        set position(newPosition) {
          if (newPosition < 0 || newPosition > this._size) {
            throw new RangeError();
          }
          this._position = newPosition;
        }
        get remaining() {
          return this._size - this.position;
        }
        get(offset) {
          return this.buffer[offset];
        }
        array() {
          return this.buffer.slice(0, this._size);
        }
        static builder(initialBufferSize) {
          return new _CodePointBuffer.Builder(initialBufferSize);
        }
      };
      exports.CodePointBuffer = CodePointBuffer;
      (function(CodePointBuffer2) {
        let Type;
        (function(Type2) {
          Type2[Type2["BYTE"] = 0] = "BYTE";
          Type2[Type2["CHAR"] = 1] = "CHAR";
          Type2[Type2["INT"] = 2] = "INT";
        })(Type || (Type = {}));
        class Builder {
          constructor(initialBufferSize) {
            this.type = 0;
            this.buffer = new Uint8Array(initialBufferSize);
            this.prevHighSurrogate = -1;
            this.position = 0;
          }
          build() {
            return new CodePointBuffer2(this.buffer, this.position);
          }
          static roundUpToNextPowerOfTwo(i) {
            let nextPowerOfTwo = 32 - Math.clz32(i - 1);
            return Math.pow(2, nextPowerOfTwo);
          }
          ensureRemaining(remainingNeeded) {
            switch (this.type) {
              case 0:
                if (this.buffer.length - this.position < remainingNeeded) {
                  let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                  let newBuffer = new Uint8Array(newCapacity);
                  newBuffer.set(this.buffer.subarray(0, this.position), 0);
                  this.buffer = newBuffer;
                }
                break;
              case 1:
                if (this.buffer.length - this.position < remainingNeeded) {
                  let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                  let newBuffer = new Uint16Array(newCapacity);
                  newBuffer.set(this.buffer.subarray(0, this.position), 0);
                  this.buffer = newBuffer;
                }
                break;
              case 2:
                if (this.buffer.length - this.position < remainingNeeded) {
                  let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                  let newBuffer = new Int32Array(newCapacity);
                  newBuffer.set(this.buffer.subarray(0, this.position), 0);
                  this.buffer = newBuffer;
                }
                break;
            }
          }
          append(utf16In) {
            this.ensureRemaining(utf16In.length);
            this.appendArray(utf16In);
          }
          appendArray(utf16In) {
            switch (this.type) {
              case 0:
                this.appendArrayByte(utf16In);
                break;
              case 1:
                this.appendArrayChar(utf16In);
                break;
              case 2:
                this.appendArrayInt(utf16In);
                break;
            }
          }
          appendArrayByte(utf16In) {
            assert2(this.prevHighSurrogate === -1);
            let input = utf16In;
            let inOffset = 0;
            let inLimit = utf16In.length;
            let outByte = this.buffer;
            let outOffset = this.position;
            while (inOffset < inLimit) {
              let c = input[inOffset];
              if (c <= 255) {
                outByte[outOffset] = c;
              } else {
                utf16In = utf16In.subarray(inOffset, inLimit);
                this.position = outOffset;
                if (!Character.isHighSurrogate(c)) {
                  this.byteToCharBuffer(utf16In.length);
                  this.appendArrayChar(utf16In);
                  return;
                } else {
                  this.byteToIntBuffer(utf16In.length);
                  this.appendArrayInt(utf16In);
                  return;
                }
              }
              inOffset++;
              outOffset++;
            }
            this.position = outOffset;
          }
          appendArrayChar(utf16In) {
            assert2(this.prevHighSurrogate === -1);
            let input = utf16In;
            let inOffset = 0;
            let inLimit = utf16In.length;
            let outChar = this.buffer;
            let outOffset = this.position;
            while (inOffset < inLimit) {
              let c = input[inOffset];
              if (!Character.isHighSurrogate(c)) {
                outChar[outOffset] = c;
              } else {
                utf16In = utf16In.subarray(inOffset, inLimit);
                this.position = outOffset;
                this.charToIntBuffer(utf16In.length);
                this.appendArrayInt(utf16In);
                return;
              }
              inOffset++;
              outOffset++;
            }
            this.position = outOffset;
          }
          appendArrayInt(utf16In) {
            let input = utf16In;
            let inOffset = 0;
            let inLimit = utf16In.length;
            let outInt = this.buffer;
            let outOffset = this.position;
            while (inOffset < inLimit) {
              let c = input[inOffset];
              inOffset++;
              if (this.prevHighSurrogate !== -1) {
                if (Character.isLowSurrogate(c)) {
                  outInt[outOffset] = String.fromCharCode(this.prevHighSurrogate, c).codePointAt(0);
                  outOffset++;
                  this.prevHighSurrogate = -1;
                } else {
                  outInt[outOffset] = this.prevHighSurrogate;
                  outOffset++;
                  if (Character.isHighSurrogate(c)) {
                    this.prevHighSurrogate = c;
                  } else {
                    outInt[outOffset] = c;
                    outOffset++;
                    this.prevHighSurrogate = -1;
                  }
                }
              } else if (Character.isHighSurrogate(c)) {
                this.prevHighSurrogate = c;
              } else {
                outInt[outOffset] = c;
                outOffset++;
              }
            }
            if (this.prevHighSurrogate !== -1) {
              outInt[outOffset] = this.prevHighSurrogate;
              outOffset++;
            }
            this.position = outOffset;
          }
          byteToCharBuffer(toAppend) {
            let newBuffer = new Uint16Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
            newBuffer.set(this.buffer.subarray(0, this.position), 0);
            this.type = 1;
            this.buffer = newBuffer;
          }
          byteToIntBuffer(toAppend) {
            let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 2));
            newBuffer.set(this.buffer.subarray(0, this.position), 0);
            this.type = 2;
            this.buffer = newBuffer;
          }
          charToIntBuffer(toAppend) {
            let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
            newBuffer.set(this.buffer.subarray(0, this.position), 0);
            this.type = 2;
            this.buffer = newBuffer;
          }
        }
        CodePointBuffer2.Builder = Builder;
      })(CodePointBuffer = exports.CodePointBuffer || (exports.CodePointBuffer = {}));
    }
  });

  // node_modules/antlr4ts/CodePointCharStream.js
  var require_CodePointCharStream = __commonJS({
    "node_modules/antlr4ts/CodePointCharStream.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CodePointCharStream = void 0;
      var assert2 = require_assert();
      var IntStream_1 = require_IntStream();
      var Interval_1 = require_Interval();
      var Decorators_1 = require_Decorators();
      var CodePointCharStream = class _CodePointCharStream {
        // Use the factory method {@link #fromBuffer(CodePointBuffer)} to
        // construct instances of this type.
        constructor(array3, position, remaining, name) {
          assert2(position === 0);
          this._array = array3;
          this._size = remaining;
          this._name = name;
          this._position = 0;
        }
        get internalStorage() {
          return this._array;
        }
        static fromBuffer(codePointBuffer, name) {
          if (name === void 0 || name.length === 0) {
            name = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
          }
          return new _CodePointCharStream(codePointBuffer.array(), codePointBuffer.position, codePointBuffer.remaining, name);
        }
        consume() {
          if (this._size - this._position === 0) {
            assert2(this.LA(1) === IntStream_1.IntStream.EOF);
            throw new RangeError("cannot consume EOF");
          }
          this._position++;
        }
        get index() {
          return this._position;
        }
        get size() {
          return this._size;
        }
        /** mark/release do nothing; we have entire buffer */
        mark() {
          return -1;
        }
        release(marker) {
        }
        seek(index) {
          this._position = index;
        }
        get sourceName() {
          return this._name;
        }
        toString() {
          return this.getText(Interval_1.Interval.of(0, this.size - 1));
        }
        LA(i) {
          let offset;
          switch (Math.sign(i)) {
            case -1:
              offset = this.index + i;
              if (offset < 0) {
                return IntStream_1.IntStream.EOF;
              }
              return this._array[offset];
            case 0:
              return 0;
            case 1:
              offset = this.index + i - 1;
              if (offset >= this.size) {
                return IntStream_1.IntStream.EOF;
              }
              return this._array[offset];
          }
          throw new RangeError("Not reached");
        }
        /** Return the UTF-16 encoded string for the given interval */
        getText(interval) {
          const startIdx = Math.min(interval.a, this.size);
          const len = Math.min(interval.b - interval.a + 1, this.size - startIdx);
          if (this._array instanceof Int32Array) {
            return String.fromCodePoint(...Array.from(this._array.subarray(startIdx, startIdx + len)));
          } else {
            return String.fromCharCode(...Array.from(this._array.subarray(startIdx, startIdx + len)));
          }
        }
      };
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "consume", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "index", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "mark", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "release", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "seek", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "sourceName", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "toString", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "LA", null);
      __decorate([
        Decorators_1.Override
      ], CodePointCharStream.prototype, "getText", null);
      exports.CodePointCharStream = CodePointCharStream;
    }
  });

  // node_modules/antlr4ts/CharStreams.js
  var require_CharStreams = __commonJS({
    "node_modules/antlr4ts/CharStreams.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CharStreams = void 0;
      var CodePointBuffer_1 = require_CodePointBuffer();
      var CodePointCharStream_1 = require_CodePointCharStream();
      var IntStream_1 = require_IntStream();
      var CharStreams2;
      (function(CharStreams3) {
        function fromString2(s, sourceName) {
          if (sourceName === void 0 || sourceName.length === 0) {
            sourceName = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
          }
          let codePointBufferBuilder = CodePointBuffer_1.CodePointBuffer.builder(s.length);
          let cb = new Uint16Array(s.length);
          for (let i = 0; i < s.length; i++) {
            cb[i] = s.charCodeAt(i);
          }
          codePointBufferBuilder.append(cb);
          return CodePointCharStream_1.CodePointCharStream.fromBuffer(codePointBufferBuilder.build(), sourceName);
        }
        CharStreams3.fromString = fromString2;
      })(CharStreams2 = exports.CharStreams || (exports.CharStreams = {}));
    }
  });

  // node_modules/antlr4ts/BufferedTokenStream.js
  var require_BufferedTokenStream = __commonJS({
    "node_modules/antlr4ts/BufferedTokenStream.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BufferedTokenStream = void 0;
      var assert2 = require_assert();
      var CommonToken_1 = require_CommonToken();
      var Interval_1 = require_Interval();
      var Lexer_1 = require_Lexer();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var BufferedTokenStream = class BufferedTokenStream {
        constructor(tokenSource) {
          this.tokens = [];
          this.p = -1;
          this.fetchedEOF = false;
          if (tokenSource == null) {
            throw new Error("tokenSource cannot be null");
          }
          this._tokenSource = tokenSource;
        }
        get tokenSource() {
          return this._tokenSource;
        }
        /** Reset this token stream by setting its token source. */
        set tokenSource(tokenSource) {
          this._tokenSource = tokenSource;
          this.tokens.length = 0;
          this.p = -1;
          this.fetchedEOF = false;
        }
        get index() {
          return this.p;
        }
        mark() {
          return 0;
        }
        release(marker) {
        }
        seek(index) {
          this.lazyInit();
          this.p = this.adjustSeekIndex(index);
        }
        get size() {
          return this.tokens.length;
        }
        consume() {
          let skipEofCheck;
          if (this.p >= 0) {
            if (this.fetchedEOF) {
              skipEofCheck = this.p < this.tokens.length - 1;
            } else {
              skipEofCheck = this.p < this.tokens.length;
            }
          } else {
            skipEofCheck = false;
          }
          if (!skipEofCheck && this.LA(1) === Token_1.Token.EOF) {
            throw new Error("cannot consume EOF");
          }
          if (this.sync(this.p + 1)) {
            this.p = this.adjustSeekIndex(this.p + 1);
          }
        }
        /** Make sure index `i` in tokens has a token.
         *
         * @returns `true` if a token is located at index `i`, otherwise
         *    `false`.
         * @see #get(int i)
         */
        sync(i) {
          assert2(i >= 0);
          let n = i - this.tokens.length + 1;
          if (n > 0) {
            let fetched = this.fetch(n);
            return fetched >= n;
          }
          return true;
        }
        /** Add `n` elements to buffer.
         *
         * @returns The actual number of elements added to the buffer.
         */
        fetch(n) {
          if (this.fetchedEOF) {
            return 0;
          }
          for (let i = 0; i < n; i++) {
            let t = this.tokenSource.nextToken();
            if (this.isWritableToken(t)) {
              t.tokenIndex = this.tokens.length;
            }
            this.tokens.push(t);
            if (t.type === Token_1.Token.EOF) {
              this.fetchedEOF = true;
              return i + 1;
            }
          }
          return n;
        }
        get(i) {
          if (i < 0 || i >= this.tokens.length) {
            throw new RangeError("token index " + i + " out of range 0.." + (this.tokens.length - 1));
          }
          return this.tokens[i];
        }
        /** Get all tokens from start..stop inclusively. */
        getRange(start, stop) {
          if (start < 0 || stop < 0) {
            return [];
          }
          this.lazyInit();
          let subset = new Array();
          if (stop >= this.tokens.length) {
            stop = this.tokens.length - 1;
          }
          for (let i = start; i <= stop; i++) {
            let t = this.tokens[i];
            if (t.type === Token_1.Token.EOF) {
              break;
            }
            subset.push(t);
          }
          return subset;
        }
        LA(i) {
          let token = this.LT(i);
          if (!token) {
            return Token_1.Token.INVALID_TYPE;
          }
          return token.type;
        }
        tryLB(k) {
          if (this.p - k < 0) {
            return void 0;
          }
          return this.tokens[this.p - k];
        }
        LT(k) {
          let result = this.tryLT(k);
          if (result === void 0) {
            throw new RangeError("requested lookback index out of range");
          }
          return result;
        }
        tryLT(k) {
          this.lazyInit();
          if (k === 0) {
            throw new RangeError("0 is not a valid lookahead index");
          }
          if (k < 0) {
            return this.tryLB(-k);
          }
          let i = this.p + k - 1;
          this.sync(i);
          if (i >= this.tokens.length) {
            return this.tokens[this.tokens.length - 1];
          }
          return this.tokens[i];
        }
        /**
         * Allowed derived classes to modify the behavior of operations which change
         * the current stream position by adjusting the target token index of a seek
         * operation. The default implementation simply returns `i`. If an
         * exception is thrown in this method, the current stream index should not be
         * changed.
         *
         * For example, {@link CommonTokenStream} overrides this method to ensure that
         * the seek target is always an on-channel token.
         *
         * @param i The target token index.
         * @returns The adjusted target token index.
         */
        adjustSeekIndex(i) {
          return i;
        }
        lazyInit() {
          if (this.p === -1) {
            this.setup();
          }
        }
        setup() {
          this.sync(0);
          this.p = this.adjustSeekIndex(0);
        }
        /** Given a start and stop index, return a `List` of all tokens in
         *  the token type `BitSet`.  Return an empty array if no tokens were found.  This
         *  method looks at both on and off channel tokens.
         */
        getTokens(start, stop, types) {
          this.lazyInit();
          if (start === void 0) {
            assert2(stop === void 0 && types === void 0);
            return this.tokens;
          } else if (stop === void 0) {
            stop = this.tokens.length - 1;
          }
          if (start < 0 || stop >= this.tokens.length || stop < 0 || start >= this.tokens.length) {
            throw new RangeError("start " + start + " or stop " + stop + " not in 0.." + (this.tokens.length - 1));
          }
          if (start > stop) {
            return [];
          }
          if (types === void 0) {
            return this.tokens.slice(start, stop + 1);
          } else if (typeof types === "number") {
            types = (/* @__PURE__ */ new Set()).add(types);
          }
          let typesSet = types;
          let filteredTokens = this.tokens.slice(start, stop + 1);
          filteredTokens = filteredTokens.filter((value) => typesSet.has(value.type));
          return filteredTokens;
        }
        /**
         * Given a starting index, return the index of the next token on channel.
         * Return `i` if `tokens[i]` is on channel. Return the index of
         * the EOF token if there are no tokens on channel between `i` and
         * EOF.
         */
        nextTokenOnChannel(i, channel) {
          this.sync(i);
          if (i >= this.size) {
            return this.size - 1;
          }
          let token = this.tokens[i];
          while (token.channel !== channel) {
            if (token.type === Token_1.Token.EOF) {
              return i;
            }
            i++;
            this.sync(i);
            token = this.tokens[i];
          }
          return i;
        }
        /**
         * Given a starting index, return the index of the previous token on
         * channel. Return `i` if `tokens[i]` is on channel. Return -1
         * if there are no tokens on channel between `i` and 0.
         *
         * If `i` specifies an index at or after the EOF token, the EOF token
         * index is returned. This is due to the fact that the EOF token is treated
         * as though it were on every channel.
         */
        previousTokenOnChannel(i, channel) {
          this.sync(i);
          if (i >= this.size) {
            return this.size - 1;
          }
          while (i >= 0) {
            let token = this.tokens[i];
            if (token.type === Token_1.Token.EOF || token.channel === channel) {
              return i;
            }
            i--;
          }
          return i;
        }
        /** Collect all tokens on specified channel to the right of
         *  the current token up until we see a token on {@link Lexer#DEFAULT_TOKEN_CHANNEL} or
         *  EOF. If `channel` is `-1`, find any non default channel token.
         */
        getHiddenTokensToRight(tokenIndex, channel = -1) {
          this.lazyInit();
          if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
            throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
          }
          let nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
          let to;
          let from = tokenIndex + 1;
          if (nextOnChannel === -1) {
            to = this.size - 1;
          } else {
            to = nextOnChannel;
          }
          return this.filterForChannel(from, to, channel);
        }
        /** Collect all tokens on specified channel to the left of
         *  the current token up until we see a token on {@link Lexer#DEFAULT_TOKEN_CHANNEL}.
         *  If `channel` is `-1`, find any non default channel token.
         */
        getHiddenTokensToLeft(tokenIndex, channel = -1) {
          this.lazyInit();
          if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
            throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
          }
          if (tokenIndex === 0) {
            return [];
          }
          let prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
          if (prevOnChannel === tokenIndex - 1) {
            return [];
          }
          let from = prevOnChannel + 1;
          let to = tokenIndex - 1;
          return this.filterForChannel(from, to, channel);
        }
        filterForChannel(from, to, channel) {
          let hidden = new Array();
          for (let i = from; i <= to; i++) {
            let t = this.tokens[i];
            if (channel === -1) {
              if (t.channel !== Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL) {
                hidden.push(t);
              }
            } else {
              if (t.channel === channel) {
                hidden.push(t);
              }
            }
          }
          return hidden;
        }
        get sourceName() {
          return this.tokenSource.sourceName;
        }
        getText(interval) {
          if (interval === void 0) {
            interval = Interval_1.Interval.of(0, this.size - 1);
          } else if (!(interval instanceof Interval_1.Interval)) {
            interval = interval.sourceInterval;
          }
          let start = interval.a;
          let stop = interval.b;
          if (start < 0 || stop < 0) {
            return "";
          }
          this.fill();
          if (stop >= this.tokens.length) {
            stop = this.tokens.length - 1;
          }
          let buf = "";
          for (let i = start; i <= stop; i++) {
            let t = this.tokens[i];
            if (t.type === Token_1.Token.EOF) {
              break;
            }
            buf += t.text;
          }
          return buf.toString();
        }
        getTextFromRange(start, stop) {
          if (this.isToken(start) && this.isToken(stop)) {
            return this.getText(Interval_1.Interval.of(start.tokenIndex, stop.tokenIndex));
          }
          return "";
        }
        /** Get all tokens from lexer until EOF. */
        fill() {
          this.lazyInit();
          const blockSize = 1e3;
          while (true) {
            let fetched = this.fetch(blockSize);
            if (fetched < blockSize) {
              return;
            }
          }
        }
        // TODO: Figure out a way to make this more flexible?
        isWritableToken(t) {
          return t instanceof CommonToken_1.CommonToken;
        }
        // TODO: Figure out a way to make this more flexible?
        isToken(t) {
          return t instanceof CommonToken_1.CommonToken;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], BufferedTokenStream.prototype, "_tokenSource", void 0);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "tokenSource", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "index", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "mark", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "release", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "seek", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "size", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "consume", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "get", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "LA", null);
      __decorate([
        Decorators_1.NotNull,
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "LT", null);
      __decorate([
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "sourceName", null);
      __decorate([
        Decorators_1.NotNull,
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "getText", null);
      __decorate([
        Decorators_1.NotNull,
        Decorators_1.Override
      ], BufferedTokenStream.prototype, "getTextFromRange", null);
      BufferedTokenStream = __decorate([
        __param(0, Decorators_1.NotNull)
      ], BufferedTokenStream);
      exports.BufferedTokenStream = BufferedTokenStream;
    }
  });

  // node_modules/antlr4ts/CommonTokenStream.js
  var require_CommonTokenStream = __commonJS({
    "node_modules/antlr4ts/CommonTokenStream.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommonTokenStream = void 0;
      var BufferedTokenStream_1 = require_BufferedTokenStream();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var CommonTokenStream2 = class CommonTokenStream extends BufferedTokenStream_1.BufferedTokenStream {
        /**
         * Constructs a new {@link CommonTokenStream} using the specified token
         * source and filtering tokens to the specified channel. Only tokens whose
         * {@link Token#getChannel} matches `channel` or have the
         * `Token.type` equal to {@link Token#EOF} will be returned by the
         * token stream lookahead methods.
         *
         * @param tokenSource The token source.
         * @param channel The channel to use for filtering tokens.
         */
        constructor(tokenSource, channel = Token_1.Token.DEFAULT_CHANNEL) {
          super(tokenSource);
          this.channel = channel;
        }
        adjustSeekIndex(i) {
          return this.nextTokenOnChannel(i, this.channel);
        }
        tryLB(k) {
          if (this.p - k < 0) {
            return void 0;
          }
          let i = this.p;
          let n = 1;
          while (n <= k && i > 0) {
            i = this.previousTokenOnChannel(i - 1, this.channel);
            n++;
          }
          if (i < 0) {
            return void 0;
          }
          return this.tokens[i];
        }
        tryLT(k) {
          this.lazyInit();
          if (k === 0) {
            throw new RangeError("0 is not a valid lookahead index");
          }
          if (k < 0) {
            return this.tryLB(-k);
          }
          let i = this.p;
          let n = 1;
          while (n < k) {
            if (this.sync(i + 1)) {
              i = this.nextTokenOnChannel(i + 1, this.channel);
            }
            n++;
          }
          return this.tokens[i];
        }
        /** Count EOF just once. */
        getNumberOfOnChannelTokens() {
          let n = 0;
          this.fill();
          for (let t of this.tokens) {
            if (t.channel === this.channel) {
              n++;
            }
            if (t.type === Token_1.Token.EOF) {
              break;
            }
          }
          return n;
        }
      };
      __decorate([
        Decorators_1.Override
      ], CommonTokenStream2.prototype, "adjustSeekIndex", null);
      __decorate([
        Decorators_1.Override
      ], CommonTokenStream2.prototype, "tryLB", null);
      __decorate([
        Decorators_1.Override
      ], CommonTokenStream2.prototype, "tryLT", null);
      CommonTokenStream2 = __decorate([
        __param(0, Decorators_1.NotNull)
      ], CommonTokenStream2);
      exports.CommonTokenStream = CommonTokenStream2;
    }
  });

  // node_modules/antlr4ts/ListTokenSource.js
  var require_ListTokenSource = __commonJS({
    "node_modules/antlr4ts/ListTokenSource.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ListTokenSource = void 0;
      var CommonTokenFactory_1 = require_CommonTokenFactory();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var ListTokenSource = class ListTokenSource {
        /**
         * Constructs a new {@link ListTokenSource} instance from the specified
         * collection of {@link Token} objects and source name.
         *
         * @param tokens The collection of {@link Token} objects to provide as a
         * {@link TokenSource}.
         * @param sourceName The name of the {@link TokenSource}. If this value is
         * `undefined`, {@link #getSourceName} will attempt to infer the name from
         * the next {@link Token} (or the previous token if the end of the input has
         * been reached).
         *
         * @exception NullPointerException if `tokens` is `undefined`
         */
        constructor(tokens, sourceName) {
          this.i = 0;
          this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
          if (tokens == null) {
            throw new Error("tokens cannot be null");
          }
          this.tokens = tokens;
          this._sourceName = sourceName;
        }
        /**
         * {@inheritDoc}
         */
        get charPositionInLine() {
          if (this.i < this.tokens.length) {
            return this.tokens[this.i].charPositionInLine;
          } else if (this.eofToken != null) {
            return this.eofToken.charPositionInLine;
          } else if (this.tokens.length > 0) {
            let lastToken = this.tokens[this.tokens.length - 1];
            let tokenText = lastToken.text;
            if (tokenText != null) {
              let lastNewLine = tokenText.lastIndexOf("\n");
              if (lastNewLine >= 0) {
                return tokenText.length - lastNewLine - 1;
              }
            }
            return lastToken.charPositionInLine + lastToken.stopIndex - lastToken.startIndex + 1;
          }
          return 0;
        }
        /**
         * {@inheritDoc}
         */
        nextToken() {
          if (this.i >= this.tokens.length) {
            if (this.eofToken == null) {
              let start = -1;
              if (this.tokens.length > 0) {
                let previousStop = this.tokens[this.tokens.length - 1].stopIndex;
                if (previousStop !== -1) {
                  start = previousStop + 1;
                }
              }
              let stop = Math.max(-1, start - 1);
              this.eofToken = this._factory.create({ source: this, stream: this.inputStream }, Token_1.Token.EOF, "EOF", Token_1.Token.DEFAULT_CHANNEL, start, stop, this.line, this.charPositionInLine);
            }
            return this.eofToken;
          }
          let t = this.tokens[this.i];
          if (this.i === this.tokens.length - 1 && t.type === Token_1.Token.EOF) {
            this.eofToken = t;
          }
          this.i++;
          return t;
        }
        /**
         * {@inheritDoc}
         */
        get line() {
          if (this.i < this.tokens.length) {
            return this.tokens[this.i].line;
          } else if (this.eofToken != null) {
            return this.eofToken.line;
          } else if (this.tokens.length > 0) {
            let lastToken = this.tokens[this.tokens.length - 1];
            let line = lastToken.line;
            let tokenText = lastToken.text;
            if (tokenText != null) {
              for (let i = 0; i < tokenText.length; i++) {
                if (tokenText.charAt(i) === "\n") {
                  line++;
                }
              }
            }
            return line;
          }
          return 1;
        }
        /**
         * {@inheritDoc}
         */
        get inputStream() {
          if (this.i < this.tokens.length) {
            return this.tokens[this.i].inputStream;
          } else if (this.eofToken != null) {
            return this.eofToken.inputStream;
          } else if (this.tokens.length > 0) {
            return this.tokens[this.tokens.length - 1].inputStream;
          }
          return void 0;
        }
        /**
         * {@inheritDoc}
         */
        get sourceName() {
          if (this._sourceName) {
            return this._sourceName;
          }
          let inputStream = this.inputStream;
          if (inputStream != null) {
            return inputStream.sourceName;
          }
          return "List";
        }
        /**
         * {@inheritDoc}
         */
        // @Override
        set tokenFactory(factory) {
          this._factory = factory;
        }
        /**
         * {@inheritDoc}
         */
        get tokenFactory() {
          return this._factory;
        }
      };
      __decorate([
        Decorators_1.Override
      ], ListTokenSource.prototype, "charPositionInLine", null);
      __decorate([
        Decorators_1.Override
      ], ListTokenSource.prototype, "nextToken", null);
      __decorate([
        Decorators_1.Override
      ], ListTokenSource.prototype, "line", null);
      __decorate([
        Decorators_1.Override
      ], ListTokenSource.prototype, "inputStream", null);
      __decorate([
        Decorators_1.Override
      ], ListTokenSource.prototype, "sourceName", null);
      __decorate([
        Decorators_1.Override,
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], ListTokenSource.prototype, "tokenFactory", null);
      ListTokenSource = __decorate([
        __param(0, Decorators_1.NotNull)
      ], ListTokenSource);
      exports.ListTokenSource = ListTokenSource;
    }
  });

  // node_modules/antlr4ts/misc/MultiMap.js
  var require_MultiMap = __commonJS({
    "node_modules/antlr4ts/misc/MultiMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MultiMap = void 0;
      var MultiMap = class extends Map {
        constructor() {
          super();
        }
        map(key, value) {
          let elementsForKey = super.get(key);
          if (!elementsForKey) {
            elementsForKey = [];
            super.set(key, elementsForKey);
          }
          elementsForKey.push(value);
        }
        getPairs() {
          let pairs = [];
          this.forEach((values, key) => {
            values.forEach((v) => {
              pairs.push([key, v]);
            });
          });
          return pairs;
        }
      };
      exports.MultiMap = MultiMap;
    }
  });

  // node_modules/antlr4ts/misc/ParseCancellationException.js
  var require_ParseCancellationException = __commonJS({
    "node_modules/antlr4ts/misc/ParseCancellationException.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParseCancellationException = void 0;
      var ParseCancellationException = class extends Error {
        constructor(cause) {
          super(cause.message);
          this.cause = cause;
          this.stack = cause.stack;
        }
        getCause() {
          return this.cause;
        }
      };
      exports.ParseCancellationException = ParseCancellationException;
    }
  });

  // node_modules/antlr4ts/InterpreterRuleContext.js
  var require_InterpreterRuleContext = __commonJS({
    "node_modules/antlr4ts/InterpreterRuleContext.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InterpreterRuleContext = void 0;
      var Decorators_1 = require_Decorators();
      var ParserRuleContext_1 = require_ParserRuleContext();
      var InterpreterRuleContext = class extends ParserRuleContext_1.ParserRuleContext {
        constructor(ruleIndex, parent, invokingStateNumber) {
          if (invokingStateNumber !== void 0) {
            super(parent, invokingStateNumber);
          } else {
            super();
          }
          this._ruleIndex = ruleIndex;
        }
        get ruleIndex() {
          return this._ruleIndex;
        }
      };
      __decorate([
        Decorators_1.Override
      ], InterpreterRuleContext.prototype, "ruleIndex", null);
      exports.InterpreterRuleContext = InterpreterRuleContext;
    }
  });

  // node_modules/antlr4ts/ParserInterpreter.js
  var require_ParserInterpreter = __commonJS({
    "node_modules/antlr4ts/ParserInterpreter.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParserInterpreter = void 0;
      var ATNState_1 = require_ATNState();
      var ATNStateType_1 = require_ATNStateType();
      var BitSet_1 = require_BitSet();
      var FailedPredicateException_1 = require_FailedPredicateException();
      var InputMismatchException_1 = require_InputMismatchException();
      var InterpreterRuleContext_1 = require_InterpreterRuleContext();
      var LoopEndState_1 = require_LoopEndState();
      var Decorators_1 = require_Decorators();
      var Decorators_2 = require_Decorators();
      var Parser_1 = require_Parser();
      var ParserATNSimulator_1 = require_ParserATNSimulator();
      var RecognitionException_1 = require_RecognitionException();
      var StarLoopEntryState_1 = require_StarLoopEntryState();
      var Token_1 = require_Token();
      var ParserInterpreter = class ParserInterpreter2 extends Parser_1.Parser {
        constructor(grammarFileName, vocabulary, ruleNames, atn, input) {
          super(grammarFileName instanceof ParserInterpreter2 ? grammarFileName.inputStream : input);
          this._parentContextStack = [];
          this.overrideDecision = -1;
          this.overrideDecisionInputIndex = -1;
          this.overrideDecisionAlt = -1;
          this.overrideDecisionReached = false;
          this._overrideDecisionRoot = void 0;
          if (grammarFileName instanceof ParserInterpreter2) {
            let old = grammarFileName;
            this._grammarFileName = old._grammarFileName;
            this._atn = old._atn;
            this.pushRecursionContextStates = old.pushRecursionContextStates;
            this._ruleNames = old._ruleNames;
            this._vocabulary = old._vocabulary;
            this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this._atn, this);
          } else {
            vocabulary = vocabulary;
            ruleNames = ruleNames;
            atn = atn;
            this._grammarFileName = grammarFileName;
            this._atn = atn;
            this._ruleNames = ruleNames.slice(0);
            this._vocabulary = vocabulary;
            this.pushRecursionContextStates = new BitSet_1.BitSet(atn.states.length);
            for (let state of atn.states) {
              if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
                continue;
              }
              if (state.precedenceRuleDecision) {
                this.pushRecursionContextStates.set(state.stateNumber);
              }
            }
            this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(atn, this);
          }
        }
        reset(resetInput) {
          if (resetInput === void 0) {
            super.reset();
          } else {
            super.reset(resetInput);
          }
          this.overrideDecisionReached = false;
          this._overrideDecisionRoot = void 0;
        }
        get atn() {
          return this._atn;
        }
        get vocabulary() {
          return this._vocabulary;
        }
        get ruleNames() {
          return this._ruleNames;
        }
        get grammarFileName() {
          return this._grammarFileName;
        }
        /** Begin parsing at startRuleIndex */
        parse(startRuleIndex) {
          let startRuleStartState = this._atn.ruleToStartState[startRuleIndex];
          this._rootContext = this.createInterpreterRuleContext(void 0, ATNState_1.ATNState.INVALID_STATE_NUMBER, startRuleIndex);
          if (startRuleStartState.isPrecedenceRule) {
            this.enterRecursionRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);
          } else {
            this.enterRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex);
          }
          while (true) {
            let p = this.atnState;
            switch (p.stateType) {
              case ATNStateType_1.ATNStateType.RULE_STOP:
                if (this._ctx.isEmpty) {
                  if (startRuleStartState.isPrecedenceRule) {
                    let result = this._ctx;
                    let parentContext = this._parentContextStack.pop();
                    this.unrollRecursionContexts(parentContext[0]);
                    return result;
                  } else {
                    this.exitRule();
                    return this._rootContext;
                  }
                }
                this.visitRuleStopState(p);
                break;
              default:
                try {
                  this.visitState(p);
                } catch (e) {
                  if (e instanceof RecognitionException_1.RecognitionException) {
                    this.state = this._atn.ruleToStopState[p.ruleIndex].stateNumber;
                    this.context.exception = e;
                    this.errorHandler.reportError(this, e);
                    this.recover(e);
                  } else {
                    throw e;
                  }
                }
                break;
            }
          }
        }
        enterRecursionRule(localctx, state, ruleIndex, precedence) {
          this._parentContextStack.push([this._ctx, localctx.invokingState]);
          super.enterRecursionRule(localctx, state, ruleIndex, precedence);
        }
        get atnState() {
          return this._atn.states[this.state];
        }
        visitState(p) {
          let predictedAlt = 1;
          if (p.numberOfTransitions > 1) {
            predictedAlt = this.visitDecisionState(p);
          }
          let transition = p.transition(predictedAlt - 1);
          switch (transition.serializationType) {
            case 1:
              if (this.pushRecursionContextStates.get(p.stateNumber) && !(transition.target instanceof LoopEndState_1.LoopEndState)) {
                let parentContext = this._parentContextStack[this._parentContextStack.length - 1];
                let localctx = this.createInterpreterRuleContext(parentContext[0], parentContext[1], this._ctx.ruleIndex);
                this.pushNewRecursionContext(localctx, this._atn.ruleToStartState[p.ruleIndex].stateNumber, this._ctx.ruleIndex);
              }
              break;
            case 5:
              this.match(transition._label);
              break;
            case 2:
            case 7:
            case 8:
              if (!transition.matches(this._input.LA(1), Token_1.Token.MIN_USER_TOKEN_TYPE, 65535)) {
                this.recoverInline();
              }
              this.matchWildcard();
              break;
            case 9:
              this.matchWildcard();
              break;
            case 3:
              let ruleStartState = transition.target;
              let ruleIndex = ruleStartState.ruleIndex;
              let newctx = this.createInterpreterRuleContext(this._ctx, p.stateNumber, ruleIndex);
              if (ruleStartState.isPrecedenceRule) {
                this.enterRecursionRule(newctx, ruleStartState.stateNumber, ruleIndex, transition.precedence);
              } else {
                this.enterRule(newctx, transition.target.stateNumber, ruleIndex);
              }
              break;
            case 4:
              let predicateTransition = transition;
              if (!this.sempred(this._ctx, predicateTransition.ruleIndex, predicateTransition.predIndex)) {
                throw new FailedPredicateException_1.FailedPredicateException(this);
              }
              break;
            case 6:
              let actionTransition = transition;
              this.action(this._ctx, actionTransition.ruleIndex, actionTransition.actionIndex);
              break;
            case 10:
              if (!this.precpred(this._ctx, transition.precedence)) {
                let precedence = transition.precedence;
                throw new FailedPredicateException_1.FailedPredicateException(this, `precpred(_ctx, ${precedence})`);
              }
              break;
            default:
              throw new Error("UnsupportedOperationException: Unrecognized ATN transition type.");
          }
          this.state = transition.target.stateNumber;
        }
        /** Method visitDecisionState() is called when the interpreter reaches
         *  a decision state (instance of DecisionState). It gives an opportunity
         *  for subclasses to track interesting things.
         */
        visitDecisionState(p) {
          let predictedAlt;
          this.errorHandler.sync(this);
          let decision = p.decision;
          if (decision === this.overrideDecision && this._input.index === this.overrideDecisionInputIndex && !this.overrideDecisionReached) {
            predictedAlt = this.overrideDecisionAlt;
            this.overrideDecisionReached = true;
          } else {
            predictedAlt = this.interpreter.adaptivePredict(this._input, decision, this._ctx);
          }
          return predictedAlt;
        }
        /** Provide simple "factory" for InterpreterRuleContext's.
         *  @since 4.5.1
         */
        createInterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {
          return new InterpreterRuleContext_1.InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);
        }
        visitRuleStopState(p) {
          let ruleStartState = this._atn.ruleToStartState[p.ruleIndex];
          if (ruleStartState.isPrecedenceRule) {
            let parentContext = this._parentContextStack.pop();
            this.unrollRecursionContexts(parentContext[0]);
            this.state = parentContext[1];
          } else {
            this.exitRule();
          }
          let ruleTransition = this._atn.states[this.state].transition(0);
          this.state = ruleTransition.followState.stateNumber;
        }
        /** Override this parser interpreters normal decision-making process
         *  at a particular decision and input token index. Instead of
         *  allowing the adaptive prediction mechanism to choose the
         *  first alternative within a block that leads to a successful parse,
         *  force it to take the alternative, 1..n for n alternatives.
         *
         *  As an implementation limitation right now, you can only specify one
         *  override. This is sufficient to allow construction of different
         *  parse trees for ambiguous input. It means re-parsing the entire input
         *  in general because you're never sure where an ambiguous sequence would
         *  live in the various parse trees. For example, in one interpretation,
         *  an ambiguous input sequence would be matched completely in expression
         *  but in another it could match all the way back to the root.
         *
         *  s : e '!'? ;
         *  e : ID
         *    | ID '!'
         *    ;
         *
         *  Here, x! can be matched as (s (e ID) !) or (s (e ID !)). In the first
         *  case, the ambiguous sequence is fully contained only by the root.
         *  In the second case, the ambiguous sequences fully contained within just
         *  e, as in: (e ID !).
         *
         *  Rather than trying to optimize this and make
         *  some intelligent decisions for optimization purposes, I settled on
         *  just re-parsing the whole input and then using
         *  {link Trees#getRootOfSubtreeEnclosingRegion} to find the minimal
         *  subtree that contains the ambiguous sequence. I originally tried to
         *  record the call stack at the point the parser detected and ambiguity but
         *  left recursive rules create a parse tree stack that does not reflect
         *  the actual call stack. That impedance mismatch was enough to make
         *  it it challenging to restart the parser at a deeply nested rule
         *  invocation.
         *
         *  Only parser interpreters can override decisions so as to avoid inserting
         *  override checking code in the critical ALL(*) prediction execution path.
         *
         *  @since 4.5
         */
        addDecisionOverride(decision, tokenIndex, forcedAlt) {
          this.overrideDecision = decision;
          this.overrideDecisionInputIndex = tokenIndex;
          this.overrideDecisionAlt = forcedAlt;
        }
        get overrideDecisionRoot() {
          return this._overrideDecisionRoot;
        }
        /** Rely on the error handler for this parser but, if no tokens are consumed
         *  to recover, add an error node. Otherwise, nothing is seen in the parse
         *  tree.
         */
        recover(e) {
          let i = this._input.index;
          this.errorHandler.recover(this, e);
          if (this._input.index === i) {
            let tok = e.getOffendingToken();
            if (!tok) {
              throw new Error("Expected exception to have an offending token");
            }
            let source = tok.tokenSource;
            let stream = source !== void 0 ? source.inputStream : void 0;
            let sourcePair = { source, stream };
            if (e instanceof InputMismatchException_1.InputMismatchException) {
              let expectedTokens = e.expectedTokens;
              if (expectedTokens === void 0) {
                throw new Error("Expected the exception to provide expected tokens");
              }
              let expectedTokenType = Token_1.Token.INVALID_TYPE;
              if (!expectedTokens.isNil) {
                expectedTokenType = expectedTokens.minElement;
              }
              let errToken = this.tokenFactory.create(
                sourcePair,
                expectedTokenType,
                tok.text,
                Token_1.Token.DEFAULT_CHANNEL,
                -1,
                -1,
                // invalid start/stop
                tok.line,
                tok.charPositionInLine
              );
              this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
            } else {
              let source2 = tok.tokenSource;
              let errToken = this.tokenFactory.create(
                sourcePair,
                Token_1.Token.INVALID_TYPE,
                tok.text,
                Token_1.Token.DEFAULT_CHANNEL,
                -1,
                -1,
                // invalid start/stop
                tok.line,
                tok.charPositionInLine
              );
              this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
            }
          }
        }
        recoverInline() {
          return this._errHandler.recoverInline(this);
        }
        /** Return the root of the parse, which can be useful if the parser
         *  bails out. You still can access the top node. Note that,
         *  because of the way left recursive rules add children, it's possible
         *  that the root will not have any children if the start rule immediately
         *  called and left recursive rule that fails.
         *
         * @since 4.5.1
         */
        get rootContext() {
          return this._rootContext;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ParserInterpreter.prototype, "_vocabulary", void 0);
      __decorate([
        Decorators_2.Override
      ], ParserInterpreter.prototype, "reset", null);
      __decorate([
        Decorators_2.Override
      ], ParserInterpreter.prototype, "atn", null);
      __decorate([
        Decorators_2.Override
      ], ParserInterpreter.prototype, "vocabulary", null);
      __decorate([
        Decorators_2.Override
      ], ParserInterpreter.prototype, "ruleNames", null);
      __decorate([
        Decorators_2.Override
      ], ParserInterpreter.prototype, "grammarFileName", null);
      __decorate([
        Decorators_2.Override
      ], ParserInterpreter.prototype, "enterRecursionRule", null);
      ParserInterpreter = __decorate([
        __param(1, Decorators_1.NotNull)
      ], ParserInterpreter);
      exports.ParserInterpreter = ParserInterpreter;
    }
  });

  // node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js
  var require_ParseTreeMatch = __commonJS({
    "node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParseTreeMatch = void 0;
      var Decorators_1 = require_Decorators();
      var ParseTreeMatch = class ParseTreeMatch {
        /**
         * Constructs a new instance of {@link ParseTreeMatch} from the specified
         * parse tree and pattern.
         *
         * @param tree The parse tree to match against the pattern.
         * @param pattern The parse tree pattern.
         * @param labels A mapping from label names to collections of
         * {@link ParseTree} objects located by the tree pattern matching process.
         * @param mismatchedNode The first node which failed to match the tree
         * pattern during the matching process.
         *
         * @throws {@link Error} if `tree` is not defined
         * @throws {@link Error} if `pattern` is not defined
         * @throws {@link Error} if `labels` is not defined
         */
        constructor(tree, pattern, labels, mismatchedNode) {
          if (!tree) {
            throw new Error("tree cannot be null");
          }
          if (!pattern) {
            throw new Error("pattern cannot be null");
          }
          if (!labels) {
            throw new Error("labels cannot be null");
          }
          this._tree = tree;
          this._pattern = pattern;
          this._labels = labels;
          this._mismatchedNode = mismatchedNode;
        }
        /**
         * Get the last node associated with a specific `label`.
         *
         * For example, for pattern `<id:ID>`, `get("id")` returns the
         * node matched for that `ID`. If more than one node
         * matched the specified label, only the last is returned. If there is
         * no node associated with the label, this returns `undefined`.
         *
         * Pattern tags like `<ID>` and `<expr>` without labels are
         * considered to be labeled with `ID` and `expr`, respectively.
         *
         * @param label The label to check.
         *
         * @returns The last {@link ParseTree} to match a tag with the specified
         * label, or `undefined` if no parse tree matched a tag with the label.
         */
        get(label) {
          let parseTrees = this._labels.get(label);
          if (!parseTrees || parseTrees.length === 0) {
            return void 0;
          }
          return parseTrees[parseTrees.length - 1];
        }
        /**
         * Return all nodes matching a rule or token tag with the specified label.
         *
         * If the `label` is the name of a parser rule or token in the
         * grammar, the resulting list will contain both the parse trees matching
         * rule or tags explicitly labeled with the label and the complete set of
         * parse trees matching the labeled and unlabeled tags in the pattern for
         * the parser rule or token. For example, if `label` is `"foo"`,
         * the result will contain *all* of the following.
         *
         * * Parse tree nodes matching tags of the form `<foo:anyRuleName>` and
         *   `<foo:AnyTokenName>`.
         * * Parse tree nodes matching tags of the form `<anyLabel:foo>`.
         * * Parse tree nodes matching tags of the form `<foo>`.
         *
         * @param label The label.
         *
         * @returns A collection of all {@link ParseTree} nodes matching tags with
         * the specified `label`. If no nodes matched the label, an empty list
         * is returned.
         */
        getAll(label) {
          const nodes = this._labels.get(label);
          if (!nodes) {
            return [];
          }
          return nodes;
        }
        /**
         * Return a mapping from label &rarr; [list of nodes].
         *
         * The map includes special entries corresponding to the names of rules and
         * tokens referenced in tags in the original pattern. For additional
         * information, see the description of {@link #getAll(String)}.
         *
         * @returns A mapping from labels to parse tree nodes. If the parse tree
         * pattern did not contain any rule or token tags, this map will be empty.
         */
        get labels() {
          return this._labels;
        }
        /**
         * Get the node at which we first detected a mismatch.
         *
         * @returns the node at which we first detected a mismatch, or `undefined`
         * if the match was successful.
         */
        get mismatchedNode() {
          return this._mismatchedNode;
        }
        /**
         * Gets a value indicating whether the match operation succeeded.
         *
         * @returns `true` if the match operation succeeded; otherwise,
         * `false`.
         */
        get succeeded() {
          return !this._mismatchedNode;
        }
        /**
         * Get the tree pattern we are matching against.
         *
         * @returns The tree pattern we are matching against.
         */
        get pattern() {
          return this._pattern;
        }
        /**
         * Get the parse tree we are trying to match to a pattern.
         *
         * @returns The {@link ParseTree} we are trying to match to a pattern.
         */
        get tree() {
          return this._tree;
        }
        /**
         * {@inheritDoc}
         */
        toString() {
          return `Match ${this.succeeded ? "succeeded" : "failed"}; found ${this.labels.size} labels`;
        }
      };
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], ParseTreeMatch.prototype, "getAll", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreeMatch.prototype, "labels", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreeMatch.prototype, "pattern", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreeMatch.prototype, "tree", null);
      __decorate([
        Decorators_1.Override
      ], ParseTreeMatch.prototype, "toString", null);
      ParseTreeMatch = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ParseTreeMatch);
      exports.ParseTreeMatch = ParseTreeMatch;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathLexer.js
  var require_XPathLexer = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathLexer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathLexer = void 0;
      var ATNDeserializer_1 = require_ATNDeserializer();
      var Lexer_1 = require_Lexer();
      var LexerATNSimulator_1 = require_LexerATNSimulator();
      var VocabularyImpl_1 = require_VocabularyImpl();
      var Utils3 = require_Utils();
      var XPathLexer = class _XPathLexer extends Lexer_1.Lexer {
        // tslint:enable:no-trailing-whitespace
        constructor(input) {
          super(input);
          this._interp = new LexerATNSimulator_1.LexerATNSimulator(_XPathLexer._ATN, this);
        }
        // @Override
        // @NotNull
        get vocabulary() {
          return _XPathLexer.VOCABULARY;
        }
        // @Override
        get grammarFileName() {
          return "XPathLexer.g4";
        }
        // @Override
        get ruleNames() {
          return _XPathLexer.ruleNames;
        }
        // @Override
        get serializedATN() {
          return _XPathLexer._serializedATN;
        }
        // @Override
        get channelNames() {
          return _XPathLexer.channelNames;
        }
        // @Override
        get modeNames() {
          return _XPathLexer.modeNames;
        }
        // @Override
        action(_localctx, ruleIndex, actionIndex) {
          switch (ruleIndex) {
            case 4:
              this.ID_action(_localctx, actionIndex);
              break;
          }
        }
        ID_action(_localctx, actionIndex) {
          switch (actionIndex) {
            case 0:
              let text = this.text;
              if (text.charAt(0) === text.charAt(0).toUpperCase()) {
                this.type = _XPathLexer.TOKEN_REF;
              } else {
                this.type = _XPathLexer.RULE_REF;
              }
              break;
          }
        }
        static get _ATN() {
          if (!_XPathLexer.__ATN) {
            _XPathLexer.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils3.toCharArray(_XPathLexer._serializedATN));
          }
          return _XPathLexer.__ATN;
        }
      };
      exports.XPathLexer = XPathLexer;
      XPathLexer.TOKEN_REF = 1;
      XPathLexer.RULE_REF = 2;
      XPathLexer.ANYWHERE = 3;
      XPathLexer.ROOT = 4;
      XPathLexer.WILDCARD = 5;
      XPathLexer.BANG = 6;
      XPathLexer.ID = 7;
      XPathLexer.STRING = 8;
      XPathLexer.channelNames = [
        "DEFAULT_TOKEN_CHANNEL",
        "HIDDEN"
      ];
      XPathLexer.modeNames = [
        "DEFAULT_MODE"
      ];
      XPathLexer.ruleNames = [
        "ANYWHERE",
        "ROOT",
        "WILDCARD",
        "BANG",
        "ID",
        "NameChar",
        "NameStartChar",
        "STRING"
      ];
      XPathLexer._LITERAL_NAMES = [
        void 0,
        void 0,
        void 0,
        "'//'",
        "'/'",
        "'*'",
        "'!'"
      ];
      XPathLexer._SYMBOLIC_NAMES = [
        void 0,
        "TOKEN_REF",
        "RULE_REF",
        "ANYWHERE",
        "ROOT",
        "WILDCARD",
        "BANG",
        "ID",
        "STRING"
      ];
      XPathLexer.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(XPathLexer._LITERAL_NAMES, XPathLexer._SYMBOLIC_NAMES, []);
      XPathLexer._serializedATNSegments = 2;
      XPathLexer._serializedATNSegment0 = '\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\n2\b					\x07	\x07\b	\b			\x07\n\f"\v\x07\x07\b\b		\x07	,\n	\f		/\v			-\n\x07\x07	\b\v	\r\n\u02B6\n2;C\\aac|\x81\xA1\xAC\xAC\xAF\xAF\xB7\xB7\xBC\xBC\xC2\xD8\xDA\xF8\xFA\u02C3\u02C8\u02D3\u02E2\u02E6\u02EE\u02EE\u02F0\u02F0\u0302\u0376\u0378\u0379\u037C\u037F\u0381\u0381\u0388\u0388\u038A\u038C\u038E\u038E\u0390\u03A3\u03A5\u03F7\u03F9\u0483\u0485\u0489\u048C\u0531\u0533\u0558\u055B\u055B\u0563\u0589\u0593\u05BF\u05C1\u05C1\u05C3\u05C4\u05C6\u05C7\u05C9\u05C9\u05D2\u05EC\u05F2\u05F4\u0602\u0607\u0612\u061C\u061E\u061E\u0622\u066B\u0670\u06D5\u06D7\u06DF\u06E1\u06EA\u06EC\u06FE\u0701\u0701\u0711\u074C\u074F\u07B3\u07C2\u07F7\u07FC\u07FC\u0802\u082F\u0842\u085D\u08A2\u08B6\u08B8\u08BF\u08D6\u0965\u0968\u0971\u0973\u0985\u0987\u098E\u0991\u0992\u0995\u09AA\u09AC\u09B2\u09B4\u09B4\u09B8\u09BB\u09BE\u09C6\u09C9\u09CA\u09CD\u09D0\u09D9\u09D9\u09DE\u09DF\u09E1\u09E5\u09E8\u09F3\u0A03\u0A05\u0A07\u0A0C\u0A11\u0A12\u0A15\u0A2A\u0A2C\u0A32\u0A34\u0A35\u0A37\u0A38\u0A3A\u0A3B\u0A3E\u0A3E\u0A40\u0A44\u0A49\u0A4A\u0A4D\u0A4F\u0A53\u0A53\u0A5B\u0A5E\u0A60\u0A60\u0A68\u0A77\u0A83\u0A85\u0A87\u0A8F\u0A91\u0A93\u0A95\u0AAA\u0AAC\u0AB2\u0AB4\u0AB5\u0AB7\u0ABB\u0ABE\u0AC7\u0AC9\u0ACB\u0ACD\u0ACF\u0AD2\u0AD2\u0AE2\u0AE5\u0AE8\u0AF1\u0AFB\u0AFB\u0B03\u0B05\u0B07\u0B0E\u0B11\u0B12\u0B15\u0B2A\u0B2C\u0B32\u0B34\u0B35\u0B37\u0B3B\u0B3E\u0B46\u0B49\u0B4A\u0B4D\u0B4F\u0B58\u0B59\u0B5E\u0B5F\u0B61\u0B65\u0B68\u0B71\u0B73\u0B73\u0B84\u0B85\u0B87\u0B8C\u0B90\u0B92\u0B94\u0B97\u0B9B\u0B9C\u0B9E\u0B9E\u0BA0\u0BA1\u0BA5\u0BA6\u0BAA\u0BAC\u0BB0\u0BBB\u0BC0\u0BC4\u0BC8\u0BCA\u0BCC\u0BCF\u0BD2\u0BD2\u0BD9\u0BD9\u0BE8\u0BF1\u0C02\u0C05\u0C07\u0C0E\u0C10\u0C12\u0C14\u0C2A\u0C2C\u0C3B\u0C3F\u0C46\u0C48\u0C4A\u0C4C\u0C4F\u0C57\u0C58\u0C5A\u0C5C\u0C62\u0C65\u0C68\u0C71\u0C82\u0C85\u0C87\u0C8E\u0C90\u0C92\u0C94\u0CAA\u0CAC\u0CB5\u0CB7\u0CBB\u0CBE\u0CC6\u0CC8\u0CCA\u0CCC\u0CCF\u0CD7\u0CD8\u0CE0\u0CE0\u0CE2\u0CE5\u0CE8\u0CF1\u0CF3\u0CF4\u0D03\u0D05\u0D07\u0D0E\u0D10\u0D12\u0D14\u0D3C\u0D3F\u0D46\u0D48\u0D4A\u0D4C\u0D50\u0D56\u0D59\u0D61\u0D65\u0D68\u0D71\u0D7C\u0D81\u0D84\u0D85\u0D87\u0D98\u0D9C\u0DB3\u0DB5\u0DBD\u0DBF\u0DBF\u0DC2\u0DC8\u0DCC\u0DCC\u0DD1\u0DD6\u0DD8\u0DD8\u0DDA\u0DE1\u0DE8\u0DF1\u0DF4\u0DF5\u0E03\u0E3C\u0E42\u0E50\u0E52\u0E5B\u0E83\u0E84\u0E86\u0E86\u0E89\u0E8A\u0E8C\u0E8C\u0E8F\u0E8F\u0E96\u0E99\u0E9B\u0EA1\u0EA3\u0EA5\u0EA7\u0EA7\u0EA9\u0EA9\u0EAC\u0EAD\u0EAF\u0EBB\u0EBD\u0EBF\u0EC2\u0EC6\u0EC8\u0EC8\u0ECA\u0ECF\u0ED2\u0EDB\u0EDE\u0EE1\u0F02\u0F02\u0F1A\u0F1B\u0F22\u0F2B\u0F37\u0F37\u0F39\u0F39\u0F3B\u0F3B\u0F40\u0F49\u0F4B\u0F6E\u0F73\u0F86\u0F88\u0F99\u0F9B\u0FBE\u0FC8\u0FC8\u1002\u104B\u1052\u109F\u10A2\u10C7\u10C9\u10C9\u10CF\u10CF\u10D2\u10FC\u10FE\u124A\u124C\u124F\u1252\u1258\u125A\u125A\u125C\u125F\u1262\u128A\u128C\u128F\u1292\u12B2\u12B4\u12B7\u12BA\u12C0\u12C2\u12C2\u12C4\u12C7\u12CA\u12D8\u12DA\u1312\u1314\u1317\u131A\u135C\u135F\u1361\u1382\u1391\u13A2\u13F7\u13FA\u13FF\u1403\u166E\u1671\u1681\u1683\u169C\u16A2\u16EC\u16F0\u16FA\u1702\u170E\u1710\u1716\u1722\u1736\u1742\u1755\u1762\u176E\u1770\u1772\u1774\u1775\u1782\u17D5\u17D9\u17D9\u17DE\u17DF\u17E2\u17EB\u180D\u1810\u1812\u181B\u1822\u1879\u1882\u18AC\u18B2\u18F7\u1902\u1920\u1922\u192D\u1932\u193D\u1948\u196F\u1972\u1976\u1982\u19AD\u19B2\u19CB\u19D2\u19DB\u1A02\u1A1D\u1A22\u1A60\u1A62\u1A7E\u1A81\u1A8B\u1A92\u1A9B\u1AA9\u1AA9\u1AB2\u1ABF\u1B02\u1B4D\u1B52\u1B5B\u1B6D\u1B75\u1B82\u1BF5\u1C02\u1C39\u1C42\u1C4B\u1C4F\u1C7F\u1C82\u1C8A\u1CD2\u1CD4\u1CD6\u1CF8\u1CFA\u1CFB\u1D02\u1DF7\u1DFD\u1F17\u1F1A\u1F1F\u1F22\u1F47\u1F4A\u1F4F\u1F52\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F5F\u1F61\u1F7F\u1F82\u1FB6\u1FB8\u1FBE\u1FC0\u1FC0\u1FC4\u1FC6\u1FC8\u1FCE\u1FD2\u1FD5\u1FD8\u1FDD\u1FE2\u1FEE\u1FF4\u1FF6\u1FF8\u1FFE\u200D\u2011\u202C\u2030\u2041\u2042\u2056\u2056\u2062\u2066\u2068\u2071\u2073\u2073\u2081\u2081\u2092\u209E\u20D2\u20DE\u20E3\u20E3\u20E7\u20F2\u2104\u2104\u2109\u2109\u210C\u2115\u2117\u2117\u211B\u211F\u2126\u2126\u2128\u2128\u212A\u212A\u212C\u212F\u2131\u213B\u213E\u2141\u2147\u214B\u2150\u2150\u2162\u218A\u2C02\u2C30\u2C32\u2C60\u2C62\u2CE6\u2CED\u2CF5\u2D02\u2D27\u2D29\u2D29\u2D2F\u2D2F\u2D32\u2D69\u2D71\u2D71\u2D81\u2D98\u2DA2\u2DA8\u2DAA\u2DB0\u2DB2\u2DB8\u2DBA\u2DC0\u2DC2\u2DC8\u2DCA\u2DD0\u2DD2\u2DD8\u2DDA\u2DE0\u2DE2\u2E01\u2E31\u2E31\u3007\u3009\u3023\u3031\u3033\u3037\u303A\u303E\u3043\u3098\u309B\u309C\u309F\u30A1\u30A3\u30FC\u30FE\u3101\u3107\u312F\u3133\u3190\u31A2\u31BC\u31F2\u3201\u3402\u4DB7\u4E02\u9FD7\uA002\uA48E\uA4D2\uA4FF\uA502\uA60E\uA612\uA62D\uA642\uA671\uA676\uA67F\uA681\uA6F3\uA719\uA721\uA724\uA78A\uA78D\uA7B0\uA7B2\uA7B9\uA7F9\uA829\uA842\uA875\uA882\uA8C7\uA8D2\uA8DB\uA8E2\uA8F9\uA8FD\uA8FD\uA8FF\uA8FF\uA902\uA92F\uA932\uA955\uA962\uA97E\uA982\uA9C2\uA9D1\uA9DB\uA9E2\uAA00\uAA02\uAA38\uAA42\uAA4F\uAA52\uAA5B\uAA62\uAA78\uAA7C\uAAC4\uAADD\uAADF\uAAE2\uAAF1\uAAF4\uAAF8\uAB03\uAB08\uAB0B\uAB10\uAB13\uAB18\uAB22\uAB28\uAB2A\uAB30\uAB32\uAB5C\uAB5E\uAB67\uAB72\uABEC\uABEE\uABEF\uABF2\uABFB\uAC02\uD7A5\uD7B2\uD7C8\uD7CD\uD7FD\uF902\uFA6F\uFA72\uFADB\uFB02\uFB08\uFB15\uFB19\uFB1F\uFB2A\uFB2C\uFB38\uFB3A\uFB3E\uFB40\uFB40\uFB42\uFB43\uFB45\uFB46\uFB48\uFBB3\uFBD5\uFD3F\uFD52\uFD91\uFD94\uFDC9\uFDF2\uFDFD\uFE02\uFE11\uFE22\uFE31\uFE35\uFE36\uFE4F\uFE51\uFE72\uFE76\uFE78\uFEFE\uFF01\uFF01\uFF12\uFF1B\uFF23\uFF3C\uFF41\uFF41\uFF43\uFF5C\uFF68\uFFC0\uFFC4\uFFC9\uFFCC\uFFD1\uFFD4\uFFD9\uFFDC\uFFDE\uFFFB\uFFFD\r(*<>?AOR_\x82\xFC\u0142\u0176\u01FF\u01FF\u0282\u029E\u02A2\u02D2\u02E2\u02E2\u0302\u0321\u0332\u034C\u0352\u037C\u0382\u039F\u03A2\u03C5\u03CA\u03D1\u03D3\u03D7\u0402\u049F\u04A2\u04AB\u04B2\u04D5\u04DA\u04FD\u0502\u0529\u0532\u0565\u0602\u0738\u0742\u0757\u0762\u0769\u0802\u0807\u080A\u080A\u080C\u0837\u0839\u083A\u083E\u083E\u0841\u0857\u0862\u0878\u0882\u08A0\u08E2\u08F4\u08F6\u08F7\u0902\u0917\u0922\u093B\u0982\u09B9\u09C0\u09C1\u0A02\u0A05\u0A07\u0A08\u0A0E\u0A15\u0A17\u0A19\u0A1B\u0A35\u0A3A\u0A3C\u0A41\u0A41\u0A62\u0A7E\u0A82\u0A9E\u0AC2\u0AC9\u0ACB\u0AE8\u0B02\u0B37\u0B42\u0B57\u0B62\u0B74\u0B82\u0B93\u0C02\u0C4A\u0C82\u0CB4\u0CC2\u0CF4\u1002\u1048\u1068\u1071\u1081\u10BC\u10BF\u10BF\u10D2\u10EA\u10F2\u10FB\u1102\u1136\u1138\u1141\u1152\u1175\u1178\u1178\u1182\u11C6\u11CC\u11CE\u11D2\u11DC\u11DE\u11DE\u1202\u1213\u1215\u1239\u1240\u1240\u1282\u1288\u128A\u128A\u128C\u128F\u1291\u129F\u12A1\u12AA\u12B2\u12EC\u12F2\u12FB\u1302\u1305\u1307\u130E\u1311\u1312\u1315\u132A\u132C\u1332\u1334\u1335\u1337\u133B\u133E\u1346\u1349\u134A\u134D\u134F\u1352\u1352\u1359\u1359\u135F\u1365\u1368\u136E\u1372\u1376\u1402\u144C\u1452\u145B\u1482\u14C7\u14C9\u14C9\u14D2\u14DB\u1582\u15B7\u15BA\u15C2\u15DA\u15DF\u1602\u1642\u1646\u1646\u1652\u165B\u1682\u16B9\u16C2\u16CB\u1702\u171B\u171F\u172D\u1732\u173B\u18A2\u18EB\u1901\u1901\u1AC2\u1AFA\u1C02\u1C0A\u1C0C\u1C38\u1C3A\u1C42\u1C52\u1C5B\u1C74\u1C91\u1C94\u1CA9\u1CAB\u1CB8\u2002\u239B\u2402\u2470\u2482\u2545\u3002\u3430\u4402\u4648\u6802\u6A3A\u6A42\u6A60\u6A62\u6A6B\u6AD2\u6AEF\u6AF2\u6AF6\u6B02\u6B38\u6B42\u6B45\u6B52\u6B5B\u6B65\u6B79\u6B7F\u6B91\u6F02\u6F46\u6F52\u6F80\u6F91\u6FA1\u6FE2\u6FE2\u7002\u87EE\u8802\u8AF4\uB002\uB003\uBC02\uBC6C\uBC72\uBC7E\uBC82\uBC8A\uBC92\uBC9B\uBC9F\uBCA0\uBCA2\uBCA5\uD167\uD16B\uD16F\uD184\uD187\uD18D\uD1AC\uD1AF\uD244\uD246\uD402\uD456\uD458\uD49E\uD4A0\uD4A1\uD4A4\uD4A4\uD4A7\uD4A8\uD4AB\uD4AE\uD4B0\uD4BB\uD4BD\uD4BD\uD4BF\uD4C5\uD4C7\uD507\uD509\uD50C\uD50F\uD516\uD518\uD51E\uD520\uD53B\uD53D\uD540\uD542\uD546\uD548\uD548\uD54C\uD552\uD554\uD6A7\uD6AA\uD6C2\uD6C4\uD6DC\uD6DE\uD6FC\uD6FE\uD716\uD718\uD736\uD738\uD750\uD752\uD770\uD772\uD78A\uD78C\uD7AA\uD7AC\uD7C4\uD7C6\uD7CD\uD7D0\uD801\uDA02\uDA38\uDA3D\uDA6E\uDA77\uDA77\uDA86\uDA86\uDA9D\uDAA1\uDAA3\uDAB1\uE002\uE008\uE00A\uE01A\uE01D\uE023\uE025\uE026\uE028\uE02C\uE802\uE8C6\uE8D2\uE8D8\uE902\uE94C\uE952\uE95B\uEE02\uEE05\uEE07\uEE21\uEE23\uEE24\uEE26\uEE26\uEE29\uEE29\uEE2B\uEE34\uEE36\uEE39\uEE3B\uEE3B\uEE3D\uEE3D\uEE44\uEE44\uEE49\uEE49\uEE4B\uEE4B\uEE4D\uEE4D\uEE4F\uEE51\uEE53\uEE54\uEE56\uEE56\uEE59\uEE59\uEE5B\uEE5B\uEE5D\uEE5D\uEE5F\uEE5F\uEE61\uEE61\uEE63\uEE64\uEE66\uEE66\uEE69\uEE6C\uEE6E\uEE74\uEE76\uEE79\uEE7B\uEE7E\uEE80\uEE80\uEE82\uEE8B\uEE8D\uEE9D\uEEA3\uEEA5\uEEA7\uEEAB\uEEAD\uEEBD\uA6D8\uA702\uB736\uB742\uB81F\uB822\uCEA3\uF802\uFA1F"\x81\u0102\u01F1\u0240C\\c|\xAC\xAC\xB7\xB7\xBC\xBC\xC2\xD8\xDA\xF8\xFA\u02C3\u02C8\u02D3\u02E2\u02E6\u02EE\u02EE\u02F0\u02F0\u0372\u0376\u0378\u0379\u037C\u037F\u0381\u0381\u0388\u0388\u038A\u038C\u038E\u038E\u0390\u03A3\u03A5\u03F7\u03F9\u0483\u048C\u0531\u0533\u0558\u055B\u055B\u0563\u0589\u05D2\u05EC\u05F2\u05F4\u0622\u064C\u0670\u0671\u0673\u06D5\u06D7\u06D7\u06E7\u06E8\u06F0\u06F1\u06FC\u06FE\u0701\u0701\u0712\u0712\u0714\u0731\u074F\u07A7\u07B3\u07B3\u07CC\u07EC\u07F6\u07F7\u07FC\u07FC\u0802\u0817\u081C\u081C\u0826\u0826\u082A\u082A\u0842\u085A\u08A2\u08B6\u08B8\u08BF\u0906\u093B\u093F\u093F\u0952\u0952\u095A\u0963\u0973\u0982\u0987\u098E\u0991\u0992\u0995\u09AA\u09AC\u09B2\u09B4\u09B4\u09B8\u09BB\u09BF\u09BF\u09D0\u09D0\u09DE\u09DF\u09E1\u09E3\u09F2\u09F3\u0A07\u0A0C\u0A11\u0A12\u0A15\u0A2A\u0A2C\u0A32\u0A34\u0A35\u0A37\u0A38\u0A3A\u0A3B\u0A5B\u0A5E\u0A60\u0A60\u0A74\u0A76\u0A87\u0A8F\u0A91\u0A93\u0A95\u0AAA\u0AAC\u0AB2\u0AB4\u0AB5\u0AB7\u0ABB\u0ABF\u0ABF\u0AD2\u0AD2\u0AE2\u0AE3\u0AFB\u0AFB\u0B07\u0B0E\u0B11\u0B12\u0B15\u0B2A\u0B2C\u0B32\u0B34\u0B35\u0B37\u0B3B\u0B3F\u0B3F\u0B5E\u0B5F\u0B61\u0B63\u0B73\u0B73\u0B85\u0B85\u0B87\u0B8C\u0B90\u0B92\u0B94\u0B97\u0B9B\u0B9C\u0B9E\u0B9E\u0BA0\u0BA1\u0BA5\u0BA6\u0BAA\u0BAC\u0BB0\u0BBB\u0BD2\u0BD2\u0C07\u0C0E\u0C10\u0C12\u0C14\u0C2A\u0C2C\u0C3B\u0C3F\u0C3F\u0C5A\u0C5C\u0C62\u0C63\u0C82\u0C82\u0C87\u0C8E\u0C90\u0C92\u0C94\u0CAA\u0CAC\u0CB5\u0CB7\u0CBB\u0CBF\u0CBF\u0CE0\u0CE0\u0CE2\u0CE3\u0CF3\u0CF4\u0D07\u0D0E\u0D10\u0D12\u0D14\u0D3C\u0D3F\u0D3F\u0D50\u0D50\u0D56\u0D58\u0D61\u0D63\u0D7C\u0D81\u0D87\u0D98\u0D9C\u0DB3\u0DB5\u0DBD\u0DBF\u0DBF\u0DC2\u0DC8\u0E03\u0E32\u0E34\u0E35\u0E42\u0E48\u0E83\u0E84\u0E86\u0E86\u0E89\u0E8A\u0E8C\u0E8C\u0E8F\u0E8F\u0E96\u0E99\u0E9B\u0EA1\u0EA3\u0EA5\u0EA7\u0EA7\u0EA9\u0EA9\u0EAC\u0EAD\u0EAF\u0EB2\u0EB4\u0EB5\u0EBF\u0EBF\u0EC2\u0EC6\u0EC8\u0EC8\u0EDE\u0EE1\u0F02\u0F02\u0F42\u0F49\u0F4B\u0F6E\u0F8A\u0F8E\u1002\u102C\u1041\u1041\u1052\u1057\u105C\u105F\u1063\u1063\u1067\u1068\u1070\u1072\u1077\u1083\u1090\u1090\u10A2\u10C7\u10C9\u10C9\u10CF\u10CF\u10D2\u10FC\u10FE\u124A\u124C\u124F\u1252\u1258\u125A\u125A\u125C\u125F\u1262\u128A\u128C\u128F\u1292\u12B2\u12B4\u12B7\u12BA\u12C0\u12C2\u12C2\u12C4\u12C7\u12CA\u12D8\u12DA\u1312\u1314\u1317\u131A\u135C\u1382\u1391\u13A2\u13F7\u13FA\u13FF\u1403\u166E\u1671\u1681\u1683\u169C\u16A2\u16EC\u16F0\u16FA\u1702\u170E\u1710\u1713\u1722\u1733\u1742\u1753\u1762\u176E\u1770\u1772\u1782\u17B5\u17D9\u17D9\u17DE\u17DE\u1822\u1879\u1882\u1886\u1889\u18AA\u18AC\u18AC\u18B2\u18F7\u1902\u1920\u1952\u196F\u1972\u1976\u1982\u19AD\u19B2\u19CB\u1A02\u1A18\u1A22\u1A56\u1AA9\u1AA9\u1B07\u1B35\u1B47\u1B4D\u1B85\u1BA2\u1BB0\u1BB1\u1BBC\u1BE7\u1C02\u1C25\u1C4F\u1C51\u1C5C\u1C7F\u1C82\u1C8A\u1CEB\u1CEE\u1CF0\u1CF3\u1CF7\u1CF8\u1D02\u1DC1\u1E02\u1F17\u1F1A\u1F1F\u1F22\u1F47\u1F4A\u1F4F\u1F52\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F5F\u1F61\u1F7F\u1F82\u1FB6\u1FB8\u1FBE\u1FC0\u1FC0\u1FC4\u1FC6\u1FC8\u1FCE\u1FD2\u1FD5\u1FD8\u1FDD\u1FE2\u1FEE\u1FF4\u1FF6\u1FF8\u1FFE\u2073\u2073\u2081\u2081\u2092\u209E\u2104\u2104\u2109\u2109\u210C\u2115\u2117\u2117\u211B\u211F\u2126\u2126\u2128\u2128\u212A\u212A\u212C\u212F\u2131\u213B\u213E\u2141\u2147\u214B\u2150\u2150\u2162\u218A\u2C02\u2C30\u2C32\u2C60\u2C62\u2CE6\u2CED\u2CF0\u2CF4\u2CF5\u2D02\u2D27\u2D29\u2D29\u2D2F\u2D2F\u2D32\u2D69\u2D71\u2D71\u2D82\u2D98\u2DA2\u2DA8\u2DAA\u2DB0\u2DB2\u2DB8\u2DBA\u2DC0\u2DC2\u2DC8\u2DCA\u2DD0\u2DD2\u2DD8\u2DDA\u2DE0\u2E31\u2E31\u3007\u3009\u3023\u302B\u3033\u3037\u303A\u303E\u3043\u3098\u309F\u30A1\u30A3\u30FC\u30FE\u3101\u3107\u312F\u3133\u3190\u31A2\u31BC\u31F2\u3201\u3402\u4DB7\u4E02\u9FD7\uA002\uA48E\uA4D2\uA4FF\uA502\uA60E\uA612\uA621\uA62C\uA62D\uA642\uA670\uA681\uA69F\uA6A2\uA6F1\uA719\uA721\uA724\uA78A\uA78D\uA7B0\uA7B2\uA7B9\uA7F9\uA803\uA805\uA807\uA809\uA80C\uA80E\uA824\uA842\uA875\uA884\uA8B5\uA8F4\uA8F9\uA8FD\uA8FD\uA8FF\uA8FF\uA90C\uA927\uA932\uA948\uA962\uA97E\uA986\uA9B4\uA9D1\uA9D1\uA9E2\uA9E6\uA9E8\uA9F1\uA9FC\uAA00\uAA02\uAA2A\uAA42\uAA44\uAA46\uAA4D\uAA62\uAA78\uAA7C\uAA7C\uAA80\uAAB1\uAAB3\uAAB3\uAAB7\uAAB8\uAABB\uAABF\uAAC2\uAAC2\uAAC4\uAAC4\uAADD\uAADF\uAAE2\uAAEC\uAAF4\uAAF6\uAB03\uAB08\uAB0B\uAB10\uAB13\uAB18\uAB22\uAB28\uAB2A\uAB30\uAB32\uAB5C\uAB5E\uAB67\uAB72\uABE4\uAC02\uD7A5\uD7B2\uD7C8\uD7CD\uD7FD\uF902\uFA6F\uFA72\uFADB\uFB02\uFB08\uFB15\uFB19\uFB1F\uFB1F\uFB21\uFB2A\uFB2C\uFB38\uFB3A\uFB3E\uFB40\uFB40\uFB42\uFB43\uFB45\uFB46\uFB48\uFBB3\uFBD5\uFD3F\uFD52\uFD91\uFD94\uFDC9\uFDF2\uFDFD\uFE72\uFE76\uFE78\uFEFE\uFF23\uFF3C\uFF43\uFF5C\uFF68\uFFC0\uFFC4\uFFC9\uFFCC\uFFD1\uFFD4\uFFD9\uFFDC\uFFDE\r(*<>?AOR_\x82\xFC\u0142\u0176\u0282\u029E\u02A2\u02D2\u0302\u0321\u0332\u034C\u0352\u0377\u0382\u039F\u03A2\u03C5\u03CA\u03D1\u03D3\u03D7\u0402\u049F\u04B2\u04D5\u04DA\u04FD\u0502\u0529\u0532\u0565\u0602\u0738\u0742\u0757\u0762\u0769\u0802\u0807\u080A\u080A\u080C\u0837\u0839\u083A\u083E\u083E\u0841\u0857\u0862\u0878\u0882\u08A0\u08E2\u08F4\u08F6\u08F7\u0902\u0917\u0922\u093B\u0982\u09B9\u09C0\u09C1\u0A02\u0A02\u0A12\u0A15\u0A17\u0A19\u0A1B\u0A35\u0A62\u0A7E\u0A82\u0A9E\u0AC2\u0AC9\u0ACB\u0AE6\u0B02\u0B37\u0B42\u0B57\u0B62\u0B74\u0B82\u0B93\u0C02\u0C4A\u0C82\u0CB4\u0CC2\u0CF4\u1005\u1039\u1085\u10B1\u10D2\u10EA\u1105\u1128\u1152\u1174\u1178\u1178\u1185\u11B4\u11C3\u11C6\u11DC\u11DC\u11DE\u11DE\u1202\u1213\u1215\u122D\u1282\u1288\u128A\u128A\u128C\u128F\u1291\u129F\u12A1\u12AA\u12B2\u12E0\u1307\u130E\u1311\u1312\u1315\u132A\u132C\u1332\u1334\u1335\u1337\u133B\u133F\u133F\u1352\u1352\u135F\u1363\u1402\u1436\u1449\u144C\u1482\u14B1\u14C6\u14C7\u14C9\u14C9\u1582\u15B0\u15DA\u15DD\u1602\u1631\u1646\u1646\u1682\u16AC\u1702\u171B\u18A2\u18E1\u1901\u1901\u1AC2\u1AFA\u1C02\u1C0A\u1C0C\u1C30\u1C42\u1C42\u1C74\u1C91\u2002\u239B\u2402\u2470\u2482\u2545\u3002\u3430\u4402\u4648\u6802\u6A3A\u6A42\u6A60\u6AD2\u6AEF\u6B02\u6B31\u6B42\u6B45\u6B65\u6B79\u6B7F\u6B91\u6F02\u6F46\u6F52\u6F52\u6F95\u6FA1\u6FE2\u6FE2\u7002\u87EE\u8802\u8AF4\uB002\uB003\uBC02\uBC6C\uBC72\uBC7E\uBC82\uBC8A\uBC92\uBC9B\uD402\uD456\uD458\uD49E\uD4A0\uD4A1\uD4A4\uD4A4\uD4A7\uD4A8\uD4AB\uD4AE\uD4B0\uD4BB\uD4BD\uD4BD\uD4BF\uD4C5\uD4C7\uD507\uD509\uD50C\uD50F\uD516\uD518\uD51E\uD520\uD53B\uD53D\uD540\uD542\uD546\uD548\uD548';
      XPathLexer._serializedATNSegment1 = `\uD54C\uD552\uD554\uD6A7\uD6AA\uD6C2\uD6C4\uD6DC\uD6DE\uD6FC\uD6FE\uD716\uD718\uD736\uD738\uD750\uD752\uD770\uD772\uD78A\uD78C\uD7AA\uD7AC\uD7C4\uD7C6\uD7CD\uE802\uE8C6\uE902\uE945\uEE02\uEE05\uEE07\uEE21\uEE23\uEE24\uEE26\uEE26\uEE29\uEE29\uEE2B\uEE34\uEE36\uEE39\uEE3B\uEE3B\uEE3D\uEE3D\uEE44\uEE44\uEE49\uEE49\uEE4B\uEE4B\uEE4D\uEE4D\uEE4F\uEE51\uEE53\uEE54\uEE56\uEE56\uEE59\uEE59\uEE5B\uEE5B\uEE5D\uEE5D\uEE5F\uEE5F\uEE61\uEE61\uEE63\uEE64\uEE66\uEE66\uEE69\uEE6C\uEE6E\uEE74\uEE76\uEE79\uEE7B\uEE7E\uEE80\uEE80\uEE82\uEE8B\uEE8D\uEE9D\uEEA3\uEEA5\uEEA7\uEEAB\uEEAD\uEEBD\uA6D8\uA702\uB736\uB742\uB81F\uB822\uCEA3\uF802\uFA1F1\x07	\v\x07	\v\r%')\x071\x071\x071\x07,\b\x1B\x07#\x1B
 \b\r\x07"  !!#" #$\b$\f%&	&'(	()-\x07)*,\v+*,/-.-+.0/-01\x07)1 -`;
      XPathLexer._serializedATN = Utils3.join([
        XPathLexer._serializedATNSegment0,
        XPathLexer._serializedATNSegment1
      ], "");
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js
  var require_XPathLexerErrorListener = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathLexerErrorListener = void 0;
      var Decorators_1 = require_Decorators();
      var XPathLexerErrorListener = class {
        syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
        }
      };
      __decorate([
        Decorators_1.Override
      ], XPathLexerErrorListener.prototype, "syntaxError", null);
      exports.XPathLexerErrorListener = XPathLexerErrorListener;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathElement.js
  var require_XPathElement = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathElement.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathElement = void 0;
      var Decorators_1 = require_Decorators();
      var XPathElement = class {
        /** Construct element like `/ID` or `ID` or `/*` etc...
         *  op is null if just node
         */
        constructor(nodeName) {
          this.nodeName = nodeName;
          this.invert = false;
        }
        toString() {
          let inv = this.invert ? "!" : "";
          let className = Object.constructor.name;
          return className + "[" + inv + this.nodeName + "]";
        }
      };
      __decorate([
        Decorators_1.Override
      ], XPathElement.prototype, "toString", null);
      exports.XPathElement = XPathElement;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js
  var require_XPathRuleAnywhereElement = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathRuleAnywhereElement = void 0;
      var Decorators_1 = require_Decorators();
      var Trees_1 = require_Trees();
      var XPathElement_1 = require_XPathElement();
      var XPathRuleAnywhereElement = class extends XPathElement_1.XPathElement {
        constructor(ruleName, ruleIndex) {
          super(ruleName);
          this.ruleIndex = ruleIndex;
        }
        evaluate(t) {
          return Trees_1.Trees.findAllRuleNodes(t, this.ruleIndex);
        }
      };
      __decorate([
        Decorators_1.Override
      ], XPathRuleAnywhereElement.prototype, "evaluate", null);
      exports.XPathRuleAnywhereElement = XPathRuleAnywhereElement;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathRuleElement.js
  var require_XPathRuleElement = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathRuleElement.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathRuleElement = void 0;
      var ParserRuleContext_1 = require_ParserRuleContext();
      var Decorators_1 = require_Decorators();
      var Trees_1 = require_Trees();
      var XPathElement_1 = require_XPathElement();
      var XPathRuleElement = class extends XPathElement_1.XPathElement {
        constructor(ruleName, ruleIndex) {
          super(ruleName);
          this.ruleIndex = ruleIndex;
        }
        evaluate(t) {
          let nodes = [];
          for (let c of Trees_1.Trees.getChildren(t)) {
            if (c instanceof ParserRuleContext_1.ParserRuleContext) {
              if (c.ruleIndex === this.ruleIndex && !this.invert || c.ruleIndex !== this.ruleIndex && this.invert) {
                nodes.push(c);
              }
            }
          }
          return nodes;
        }
      };
      __decorate([
        Decorators_1.Override
      ], XPathRuleElement.prototype, "evaluate", null);
      exports.XPathRuleElement = XPathRuleElement;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js
  var require_XPathTokenAnywhereElement = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathTokenAnywhereElement = void 0;
      var Decorators_1 = require_Decorators();
      var Trees_1 = require_Trees();
      var XPathElement_1 = require_XPathElement();
      var XPathTokenAnywhereElement = class extends XPathElement_1.XPathElement {
        constructor(tokenName, tokenType) {
          super(tokenName);
          this.tokenType = tokenType;
        }
        evaluate(t) {
          return Trees_1.Trees.findAllTokenNodes(t, this.tokenType);
        }
      };
      __decorate([
        Decorators_1.Override
      ], XPathTokenAnywhereElement.prototype, "evaluate", null);
      exports.XPathTokenAnywhereElement = XPathTokenAnywhereElement;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathTokenElement.js
  var require_XPathTokenElement = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathTokenElement.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathTokenElement = void 0;
      var Decorators_1 = require_Decorators();
      var TerminalNode_1 = require_TerminalNode();
      var Trees_1 = require_Trees();
      var XPathElement_1 = require_XPathElement();
      var XPathTokenElement = class extends XPathElement_1.XPathElement {
        constructor(tokenName, tokenType) {
          super(tokenName);
          this.tokenType = tokenType;
        }
        evaluate(t) {
          let nodes = [];
          for (let c of Trees_1.Trees.getChildren(t)) {
            if (c instanceof TerminalNode_1.TerminalNode) {
              if (c.symbol.type === this.tokenType && !this.invert || c.symbol.type !== this.tokenType && this.invert) {
                nodes.push(c);
              }
            }
          }
          return nodes;
        }
      };
      __decorate([
        Decorators_1.Override
      ], XPathTokenElement.prototype, "evaluate", null);
      exports.XPathTokenElement = XPathTokenElement;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js
  var require_XPathWildcardAnywhereElement = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathWildcardAnywhereElement = void 0;
      var Decorators_1 = require_Decorators();
      var Trees_1 = require_Trees();
      var XPath_1 = require_XPath();
      var XPathElement_1 = require_XPathElement();
      var XPathWildcardAnywhereElement = class extends XPathElement_1.XPathElement {
        constructor() {
          super(XPath_1.XPath.WILDCARD);
        }
        evaluate(t) {
          if (this.invert) {
            return [];
          }
          return Trees_1.Trees.getDescendants(t);
        }
      };
      __decorate([
        Decorators_1.Override
      ], XPathWildcardAnywhereElement.prototype, "evaluate", null);
      exports.XPathWildcardAnywhereElement = XPathWildcardAnywhereElement;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js
  var require_XPathWildcardElement = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPathWildcardElement = void 0;
      var Decorators_1 = require_Decorators();
      var Trees_1 = require_Trees();
      var XPath_1 = require_XPath();
      var XPathElement_1 = require_XPathElement();
      var XPathWildcardElement = class extends XPathElement_1.XPathElement {
        constructor() {
          super(XPath_1.XPath.WILDCARD);
        }
        evaluate(t) {
          let kids = [];
          if (this.invert) {
            return kids;
          }
          for (let c of Trees_1.Trees.getChildren(t)) {
            kids.push(c);
          }
          return kids;
        }
      };
      __decorate([
        Decorators_1.Override
      ], XPathWildcardElement.prototype, "evaluate", null);
      exports.XPathWildcardElement = XPathWildcardElement;
    }
  });

  // node_modules/antlr4ts/tree/xpath/XPath.js
  var require_XPath = __commonJS({
    "node_modules/antlr4ts/tree/xpath/XPath.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XPath = void 0;
      var CharStreams_1 = require_CharStreams();
      var CommonTokenStream_1 = require_CommonTokenStream();
      var LexerNoViableAltException_1 = require_LexerNoViableAltException();
      var ParserRuleContext_1 = require_ParserRuleContext();
      var Token_1 = require_Token();
      var XPathLexer_1 = require_XPathLexer();
      var XPathLexerErrorListener_1 = require_XPathLexerErrorListener();
      var XPathRuleAnywhereElement_1 = require_XPathRuleAnywhereElement();
      var XPathRuleElement_1 = require_XPathRuleElement();
      var XPathTokenAnywhereElement_1 = require_XPathTokenAnywhereElement();
      var XPathTokenElement_1 = require_XPathTokenElement();
      var XPathWildcardAnywhereElement_1 = require_XPathWildcardAnywhereElement();
      var XPathWildcardElement_1 = require_XPathWildcardElement();
      var XPath = class _XPath {
        constructor(parser, path) {
          this.parser = parser;
          this.path = path;
          this.elements = this.split(path);
        }
        // TODO: check for invalid token/rule names, bad syntax
        split(path) {
          let lexer = new XPathLexer_1.XPathLexer(CharStreams_1.CharStreams.fromString(path));
          lexer.recover = (e) => {
            throw e;
          };
          lexer.removeErrorListeners();
          lexer.addErrorListener(new XPathLexerErrorListener_1.XPathLexerErrorListener());
          let tokenStream = new CommonTokenStream_1.CommonTokenStream(lexer);
          try {
            tokenStream.fill();
          } catch (e) {
            if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
              let pos = lexer.charPositionInLine;
              let msg = "Invalid tokens or characters at index " + pos + " in path '" + path + "' -- " + e.message;
              throw new RangeError(msg);
            }
            throw e;
          }
          let tokens = tokenStream.getTokens();
          let elements = [];
          let n = tokens.length;
          let i = 0;
          loop: while (i < n) {
            let el = tokens[i];
            let next;
            switch (el.type) {
              case XPathLexer_1.XPathLexer.ROOT:
              case XPathLexer_1.XPathLexer.ANYWHERE:
                let anywhere = el.type === XPathLexer_1.XPathLexer.ANYWHERE;
                i++;
                next = tokens[i];
                let invert = next.type === XPathLexer_1.XPathLexer.BANG;
                if (invert) {
                  i++;
                  next = tokens[i];
                }
                let pathElement = this.getXPathElement(next, anywhere);
                pathElement.invert = invert;
                elements.push(pathElement);
                i++;
                break;
              case XPathLexer_1.XPathLexer.TOKEN_REF:
              case XPathLexer_1.XPathLexer.RULE_REF:
              case XPathLexer_1.XPathLexer.WILDCARD:
                elements.push(this.getXPathElement(el, false));
                i++;
                break;
              case Token_1.Token.EOF:
                break loop;
              default:
                throw new Error("Unknowth path element " + el);
            }
          }
          return elements;
        }
        /**
         * Convert word like `*` or `ID` or `expr` to a path
         * element. `anywhere` is `true` if `//` precedes the
         * word.
         */
        getXPathElement(wordToken, anywhere) {
          if (wordToken.type === Token_1.Token.EOF) {
            throw new Error("Missing path element at end of path");
          }
          let word = wordToken.text;
          if (word == null) {
            throw new Error("Expected wordToken to have text content.");
          }
          let ttype = this.parser.getTokenType(word);
          let ruleIndex = this.parser.getRuleIndex(word);
          switch (wordToken.type) {
            case XPathLexer_1.XPathLexer.WILDCARD:
              return anywhere ? new XPathWildcardAnywhereElement_1.XPathWildcardAnywhereElement() : new XPathWildcardElement_1.XPathWildcardElement();
            case XPathLexer_1.XPathLexer.TOKEN_REF:
            case XPathLexer_1.XPathLexer.STRING:
              if (ttype === Token_1.Token.INVALID_TYPE) {
                throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid token name");
              }
              return anywhere ? new XPathTokenAnywhereElement_1.XPathTokenAnywhereElement(word, ttype) : new XPathTokenElement_1.XPathTokenElement(word, ttype);
            default:
              if (ruleIndex === -1) {
                throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid rule name");
              }
              return anywhere ? new XPathRuleAnywhereElement_1.XPathRuleAnywhereElement(word, ruleIndex) : new XPathRuleElement_1.XPathRuleElement(word, ruleIndex);
          }
        }
        static findAll(tree, xpath, parser) {
          let p = new _XPath(parser, xpath);
          return p.evaluate(tree);
        }
        /**
         * Return a list of all nodes starting at `t` as root that satisfy the
         * path. The root `/` is relative to the node passed to {@link evaluate}.
         */
        evaluate(t) {
          let dummyRoot = new ParserRuleContext_1.ParserRuleContext();
          dummyRoot.addChild(t);
          let work = /* @__PURE__ */ new Set([dummyRoot]);
          let i = 0;
          while (i < this.elements.length) {
            let next = /* @__PURE__ */ new Set();
            for (let node of work) {
              if (node.childCount > 0) {
                let matching = this.elements[i].evaluate(node);
                matching.forEach(next.add, next);
              }
            }
            i++;
            work = next;
          }
          return work;
        }
      };
      exports.XPath = XPath;
      XPath.WILDCARD = "*";
      XPath.NOT = "!";
    }
  });

  // node_modules/antlr4ts/tree/pattern/ParseTreePattern.js
  var require_ParseTreePattern = __commonJS({
    "node_modules/antlr4ts/tree/pattern/ParseTreePattern.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParseTreePattern = void 0;
      var Decorators_1 = require_Decorators();
      var XPath_1 = require_XPath();
      var ParseTreePattern = class ParseTreePattern {
        /**
         * Construct a new instance of the {@link ParseTreePattern} class.
         *
         * @param matcher The {@link ParseTreePatternMatcher} which created this
         * tree pattern.
         * @param pattern The tree pattern in concrete syntax form.
         * @param patternRuleIndex The parser rule which serves as the root of the
         * tree pattern.
         * @param patternTree The tree pattern in {@link ParseTree} form.
         */
        constructor(matcher, pattern, patternRuleIndex, patternTree) {
          this._matcher = matcher;
          this._patternRuleIndex = patternRuleIndex;
          this._pattern = pattern;
          this._patternTree = patternTree;
        }
        /**
         * Match a specific parse tree against this tree pattern.
         *
         * @param tree The parse tree to match against this tree pattern.
         * @returns A {@link ParseTreeMatch} object describing the result of the
         * match operation. The `ParseTreeMatch.succeeded` method can be
         * used to determine whether or not the match was successful.
         */
        match(tree) {
          return this._matcher.match(tree, this);
        }
        /**
         * Determine whether or not a parse tree matches this tree pattern.
         *
         * @param tree The parse tree to match against this tree pattern.
         * @returns `true` if `tree` is a match for the current tree
         * pattern; otherwise, `false`.
         */
        matches(tree) {
          return this._matcher.match(tree, this).succeeded;
        }
        /**
         * Find all nodes using XPath and then try to match those subtrees against
         * this tree pattern.
         *
         * @param tree The {@link ParseTree} to match against this pattern.
         * @param xpath An expression matching the nodes
         *
         * @returns A collection of {@link ParseTreeMatch} objects describing the
         * successful matches. Unsuccessful matches are omitted from the result,
         * regardless of the reason for the failure.
         */
        findAll(tree, xpath) {
          let subtrees = XPath_1.XPath.findAll(tree, xpath, this._matcher.parser);
          let matches = [];
          for (let t of subtrees) {
            let match = this.match(t);
            if (match.succeeded) {
              matches.push(match);
            }
          }
          return matches;
        }
        /**
         * Get the {@link ParseTreePatternMatcher} which created this tree pattern.
         *
         * @returns The {@link ParseTreePatternMatcher} which created this tree
         * pattern.
         */
        get matcher() {
          return this._matcher;
        }
        /**
         * Get the tree pattern in concrete syntax form.
         *
         * @returns The tree pattern in concrete syntax form.
         */
        get pattern() {
          return this._pattern;
        }
        /**
         * Get the parser rule which serves as the outermost rule for the tree
         * pattern.
         *
         * @returns The parser rule which serves as the outermost rule for the tree
         * pattern.
         */
        get patternRuleIndex() {
          return this._patternRuleIndex;
        }
        /**
         * Get the tree pattern as a {@link ParseTree}. The rule and token tags from
         * the pattern are present in the parse tree as terminal nodes with a symbol
         * of type {@link RuleTagToken} or {@link TokenTagToken}.
         *
         * @returns The tree pattern as a {@link ParseTree}.
         */
        get patternTree() {
          return this._patternTree;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], ParseTreePattern.prototype, "_pattern", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreePattern.prototype, "_patternTree", void 0);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreePattern.prototype, "_matcher", void 0);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], ParseTreePattern.prototype, "match", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], ParseTreePattern.prototype, "matches", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], ParseTreePattern.prototype, "findAll", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreePattern.prototype, "matcher", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreePattern.prototype, "pattern", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreePattern.prototype, "patternTree", null);
      ParseTreePattern = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(3, Decorators_1.NotNull)
      ], ParseTreePattern);
      exports.ParseTreePattern = ParseTreePattern;
    }
  });

  // node_modules/antlr4ts/tree/pattern/RuleTagToken.js
  var require_RuleTagToken = __commonJS({
    "node_modules/antlr4ts/tree/pattern/RuleTagToken.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleTagToken = void 0;
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var RuleTagToken = class RuleTagToken {
        /**
         * Constructs a new instance of {@link RuleTagToken} with the specified rule
         * name, bypass token type, and label.
         *
         * @param ruleName The name of the parser rule this rule tag matches.
         * @param bypassTokenType The bypass token type assigned to the parser rule.
         * @param label The label associated with the rule tag, or `undefined` if
         * the rule tag is unlabeled.
         *
         * @exception IllegalArgumentException if `ruleName` is not defined
         * or empty.
         */
        constructor(ruleName, bypassTokenType, label) {
          if (ruleName == null || ruleName.length === 0) {
            throw new Error("ruleName cannot be null or empty.");
          }
          this._ruleName = ruleName;
          this.bypassTokenType = bypassTokenType;
          this._label = label;
        }
        /**
         * Gets the name of the rule associated with this rule tag.
         *
         * @returns The name of the parser rule associated with this rule tag.
         */
        get ruleName() {
          return this._ruleName;
        }
        /**
         * Gets the label associated with the rule tag.
         *
         * @returns The name of the label associated with the rule tag, or
         * `undefined` if this is an unlabeled rule tag.
         */
        get label() {
          return this._label;
        }
        /**
         * {@inheritDoc}
         *
         * Rule tag tokens are always placed on the {@link #DEFAULT_CHANNEL}.
         */
        get channel() {
          return Token_1.Token.DEFAULT_CHANNEL;
        }
        /**
         * {@inheritDoc}
         *
         * This method returns the rule tag formatted with `<` and `>`
         * delimiters.
         */
        get text() {
          if (this._label != null) {
            return "<" + this._label + ":" + this._ruleName + ">";
          }
          return "<" + this._ruleName + ">";
        }
        /**
         * {@inheritDoc}
         *
         * Rule tag tokens have types assigned according to the rule bypass
         * transitions created during ATN deserialization.
         */
        get type() {
          return this.bypassTokenType;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link RuleTagToken} always returns 0.
         */
        get line() {
          return 0;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link RuleTagToken} always returns -1.
         */
        get charPositionInLine() {
          return -1;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link RuleTagToken} always returns -1.
         */
        get tokenIndex() {
          return -1;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link RuleTagToken} always returns -1.
         */
        get startIndex() {
          return -1;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link RuleTagToken} always returns -1.
         */
        get stopIndex() {
          return -1;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link RuleTagToken} always returns `undefined`.
         */
        get tokenSource() {
          return void 0;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link RuleTagToken} always returns `undefined`.
         */
        get inputStream() {
          return void 0;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link RuleTagToken} returns a string of the form
         * `ruleName:bypassTokenType`.
         */
        toString() {
          return this._ruleName + ":" + this.bypassTokenType;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], RuleTagToken.prototype, "ruleName", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "channel", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "text", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "type", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "line", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "charPositionInLine", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "tokenIndex", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "startIndex", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "stopIndex", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "tokenSource", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "inputStream", null);
      __decorate([
        Decorators_1.Override
      ], RuleTagToken.prototype, "toString", null);
      RuleTagToken = __decorate([
        __param(0, Decorators_1.NotNull)
      ], RuleTagToken);
      exports.RuleTagToken = RuleTagToken;
    }
  });

  // node_modules/antlr4ts/tree/pattern/Chunk.js
  var require_Chunk = __commonJS({
    "node_modules/antlr4ts/tree/pattern/Chunk.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Chunk = void 0;
      var Chunk = class {
      };
      exports.Chunk = Chunk;
    }
  });

  // node_modules/antlr4ts/tree/pattern/TagChunk.js
  var require_TagChunk = __commonJS({
    "node_modules/antlr4ts/tree/pattern/TagChunk.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TagChunk = void 0;
      var Chunk_1 = require_Chunk();
      var Decorators_1 = require_Decorators();
      var TagChunk = class extends Chunk_1.Chunk {
        /**
         * Construct a new instance of {@link TagChunk} using the specified label
         * and tag.
         *
         * @param label The label for the tag. If this is `undefined`, the
         * {@link TagChunk} represents an unlabeled tag.
         * @param tag The tag, which should be the name of a parser rule or token
         * type.
         *
         * @exception IllegalArgumentException if `tag` is not defined or
         * empty.
         */
        constructor(tag, label) {
          super();
          if (tag == null || tag.length === 0) {
            throw new Error("tag cannot be null or empty");
          }
          this._tag = tag;
          this._label = label;
        }
        /**
         * Get the tag for this chunk.
         *
         * @returns The tag for the chunk.
         */
        get tag() {
          return this._tag;
        }
        /**
         * Get the label, if any, assigned to this chunk.
         *
         * @returns The label assigned to this chunk, or `undefined` if no label is
         * assigned to the chunk.
         */
        get label() {
          return this._label;
        }
        /**
         * This method returns a text representation of the tag chunk. Labeled tags
         * are returned in the form `label:tag`, and unlabeled tags are
         * returned as just the tag name.
         */
        toString() {
          if (this._label != null) {
            return this._label + ":" + this._tag;
          }
          return this._tag;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], TagChunk.prototype, "tag", null);
      __decorate([
        Decorators_1.Override
      ], TagChunk.prototype, "toString", null);
      exports.TagChunk = TagChunk;
    }
  });

  // node_modules/antlr4ts/tree/pattern/TextChunk.js
  var require_TextChunk = __commonJS({
    "node_modules/antlr4ts/tree/pattern/TextChunk.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TextChunk = void 0;
      var Chunk_1 = require_Chunk();
      var Decorators_1 = require_Decorators();
      var TextChunk = class TextChunk extends Chunk_1.Chunk {
        /**
         * Constructs a new instance of {@link TextChunk} with the specified text.
         *
         * @param text The text of this chunk.
         * @exception IllegalArgumentException if `text` is not defined.
         */
        constructor(text) {
          super();
          if (text == null) {
            throw new Error("text cannot be null");
          }
          this._text = text;
        }
        /**
         * Gets the raw text of this chunk.
         *
         * @returns The text of the chunk.
         */
        get text() {
          return this._text;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link TextChunk} returns the result of
         * `text` in single quotes.
         */
        toString() {
          return "'" + this._text + "'";
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], TextChunk.prototype, "_text", void 0);
      __decorate([
        Decorators_1.NotNull
      ], TextChunk.prototype, "text", null);
      __decorate([
        Decorators_1.Override
      ], TextChunk.prototype, "toString", null);
      TextChunk = __decorate([
        __param(0, Decorators_1.NotNull)
      ], TextChunk);
      exports.TextChunk = TextChunk;
    }
  });

  // node_modules/antlr4ts/tree/pattern/TokenTagToken.js
  var require_TokenTagToken = __commonJS({
    "node_modules/antlr4ts/tree/pattern/TokenTagToken.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TokenTagToken = void 0;
      var CommonToken_1 = require_CommonToken();
      var Decorators_1 = require_Decorators();
      var TokenTagToken = class TokenTagToken extends CommonToken_1.CommonToken {
        /**
         * Constructs a new instance of {@link TokenTagToken} with the specified
         * token name, type, and label.
         *
         * @param tokenName The token name.
         * @param type The token type.
         * @param label The label associated with the token tag, or `undefined` if
         * the token tag is unlabeled.
         */
        constructor(tokenName, type, label) {
          super(type);
          this._tokenName = tokenName;
          this._label = label;
        }
        /**
         * Gets the token name.
         * @returns The token name.
         */
        get tokenName() {
          return this._tokenName;
        }
        /**
         * Gets the label associated with the rule tag.
         *
         * @returns The name of the label associated with the rule tag, or
         * `undefined` if this is an unlabeled rule tag.
         */
        get label() {
          return this._label;
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link TokenTagToken} returns the token tag
         * formatted with `<` and `>` delimiters.
         */
        get text() {
          if (this._label != null) {
            return "<" + this._label + ":" + this._tokenName + ">";
          }
          return "<" + this._tokenName + ">";
        }
        /**
         * {@inheritDoc}
         *
         * The implementation for {@link TokenTagToken} returns a string of the form
         * `tokenName:type`.
         */
        toString() {
          return this._tokenName + ":" + this.type;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], TokenTagToken.prototype, "_tokenName", void 0);
      __decorate([
        Decorators_1.NotNull
      ], TokenTagToken.prototype, "tokenName", null);
      __decorate([
        Decorators_1.Override
      ], TokenTagToken.prototype, "text", null);
      __decorate([
        Decorators_1.Override
      ], TokenTagToken.prototype, "toString", null);
      TokenTagToken = __decorate([
        __param(0, Decorators_1.NotNull)
      ], TokenTagToken);
      exports.TokenTagToken = TokenTagToken;
    }
  });

  // node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js
  var require_ParseTreePatternMatcher = __commonJS({
    "node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParseTreePatternMatcher = void 0;
      var BailErrorStrategy_1 = require_BailErrorStrategy();
      var CharStreams_1 = require_CharStreams();
      var CommonTokenStream_1 = require_CommonTokenStream();
      var ListTokenSource_1 = require_ListTokenSource();
      var MultiMap_1 = require_MultiMap();
      var Decorators_1 = require_Decorators();
      var ParseCancellationException_1 = require_ParseCancellationException();
      var ParserInterpreter_1 = require_ParserInterpreter();
      var ParserRuleContext_1 = require_ParserRuleContext();
      var ParseTreeMatch_1 = require_ParseTreeMatch();
      var ParseTreePattern_1 = require_ParseTreePattern();
      var RecognitionException_1 = require_RecognitionException();
      var RuleNode_1 = require_RuleNode();
      var RuleTagToken_1 = require_RuleTagToken();
      var TagChunk_1 = require_TagChunk();
      var TerminalNode_1 = require_TerminalNode();
      var TextChunk_1 = require_TextChunk();
      var Token_1 = require_Token();
      var TokenTagToken_1 = require_TokenTagToken();
      var ParseTreePatternMatcher = class _ParseTreePatternMatcher {
        /**
         * Constructs a {@link ParseTreePatternMatcher} or from a {@link Lexer} and
         * {@link Parser} object. The lexer input stream is altered for tokenizing
         * the tree patterns. The parser is used as a convenient mechanism to get
         * the grammar name, plus token, rule names.
         */
        constructor(lexer, parser) {
          this.start = "<";
          this.stop = ">";
          this.escape = "\\";
          this.escapeRE = /\\/g;
          this._lexer = lexer;
          this._parser = parser;
        }
        /**
         * Set the delimiters used for marking rule and token tags within concrete
         * syntax used by the tree pattern parser.
         *
         * @param start The start delimiter.
         * @param stop The stop delimiter.
         * @param escapeLeft The escape sequence to use for escaping a start or stop delimiter.
         *
         * @throws {@link Error} if `start` is not defined or empty.
         * @throws {@link Error} if `stop` is not defined or empty.
         */
        setDelimiters(start, stop, escapeLeft) {
          if (!start) {
            throw new Error("start cannot be null or empty");
          }
          if (!stop) {
            throw new Error("stop cannot be null or empty");
          }
          this.start = start;
          this.stop = stop;
          this.escape = escapeLeft;
          this.escapeRE = new RegExp(escapeLeft.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g");
        }
        matches(tree, pattern, patternRuleIndex = 0) {
          if (typeof pattern === "string") {
            let p = this.compile(pattern, patternRuleIndex);
            return this.matches(tree, p);
          } else {
            let labels = new MultiMap_1.MultiMap();
            let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
            return !mismatchedNode;
          }
        }
        // Implementation of match
        match(tree, pattern, patternRuleIndex = 0) {
          if (typeof pattern === "string") {
            let p = this.compile(pattern, patternRuleIndex);
            return this.match(tree, p);
          } else {
            let labels = new MultiMap_1.MultiMap();
            let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
            return new ParseTreeMatch_1.ParseTreeMatch(tree, pattern, labels, mismatchedNode);
          }
        }
        /**
         * For repeated use of a tree pattern, compile it to a
         * {@link ParseTreePattern} using this method.
         */
        compile(pattern, patternRuleIndex) {
          let tokenList = this.tokenize(pattern);
          let tokenSrc = new ListTokenSource_1.ListTokenSource(tokenList);
          let tokens = new CommonTokenStream_1.CommonTokenStream(tokenSrc);
          const parser = this._parser;
          let parserInterp = new ParserInterpreter_1.ParserInterpreter(parser.grammarFileName, parser.vocabulary, parser.ruleNames, parser.getATNWithBypassAlts(), tokens);
          let tree;
          try {
            parserInterp.errorHandler = new BailErrorStrategy_1.BailErrorStrategy();
            tree = parserInterp.parse(patternRuleIndex);
          } catch (e) {
            if (e instanceof ParseCancellationException_1.ParseCancellationException) {
              throw e.getCause();
            } else if (e instanceof RecognitionException_1.RecognitionException) {
              throw e;
            } else if (e instanceof Error) {
              throw new _ParseTreePatternMatcher.CannotInvokeStartRule(e);
            } else {
              throw e;
            }
          }
          if (tokens.LA(1) !== Token_1.Token.EOF) {
            throw new _ParseTreePatternMatcher.StartRuleDoesNotConsumeFullPattern();
          }
          return new ParseTreePattern_1.ParseTreePattern(this, pattern, patternRuleIndex, tree);
        }
        /**
         * Used to convert the tree pattern string into a series of tokens. The
         * input stream is reset.
         */
        get lexer() {
          return this._lexer;
        }
        /**
         * Used to collect to the grammar file name, token names, rule names for
         * used to parse the pattern into a parse tree.
         */
        get parser() {
          return this._parser;
        }
        // ---- SUPPORT CODE ----
        /**
         * Recursively walk `tree` against `patternTree`, filling
         * `match.`{@link ParseTreeMatch#labels labels}.
         *
         * @returns the first node encountered in `tree` which does not match
         * a corresponding node in `patternTree`, or `undefined` if the match
         * was successful. The specific node returned depends on the matching
         * algorithm used by the implementation, and may be overridden.
         */
        matchImpl(tree, patternTree, labels) {
          if (!tree) {
            throw new TypeError("tree cannot be null");
          }
          if (!patternTree) {
            throw new TypeError("patternTree cannot be null");
          }
          if (tree instanceof TerminalNode_1.TerminalNode && patternTree instanceof TerminalNode_1.TerminalNode) {
            let mismatchedNode;
            if (tree.symbol.type === patternTree.symbol.type) {
              if (patternTree.symbol instanceof TokenTagToken_1.TokenTagToken) {
                let tokenTagToken = patternTree.symbol;
                labels.map(tokenTagToken.tokenName, tree);
                const l = tokenTagToken.label;
                if (l) {
                  labels.map(l, tree);
                }
              } else if (tree.text === patternTree.text) {
              } else {
                if (!mismatchedNode) {
                  mismatchedNode = tree;
                }
              }
            } else {
              if (!mismatchedNode) {
                mismatchedNode = tree;
              }
            }
            return mismatchedNode;
          }
          if (tree instanceof ParserRuleContext_1.ParserRuleContext && patternTree instanceof ParserRuleContext_1.ParserRuleContext) {
            let mismatchedNode;
            let ruleTagToken = this.getRuleTagToken(patternTree);
            if (ruleTagToken) {
              let m;
              if (tree.ruleContext.ruleIndex === patternTree.ruleContext.ruleIndex) {
                labels.map(ruleTagToken.ruleName, tree);
                const l = ruleTagToken.label;
                if (l) {
                  labels.map(l, tree);
                }
              } else {
                if (!mismatchedNode) {
                  mismatchedNode = tree;
                }
              }
              return mismatchedNode;
            }
            if (tree.childCount !== patternTree.childCount) {
              if (!mismatchedNode) {
                mismatchedNode = tree;
              }
              return mismatchedNode;
            }
            let n = tree.childCount;
            for (let i = 0; i < n; i++) {
              let childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);
              if (childMatch) {
                return childMatch;
              }
            }
            return mismatchedNode;
          }
          return tree;
        }
        /** Is `t` `(expr <expr>)` subtree? */
        getRuleTagToken(t) {
          if (t instanceof RuleNode_1.RuleNode) {
            if (t.childCount === 1 && t.getChild(0) instanceof TerminalNode_1.TerminalNode) {
              let c = t.getChild(0);
              if (c.symbol instanceof RuleTagToken_1.RuleTagToken) {
                return c.symbol;
              }
            }
          }
          return void 0;
        }
        tokenize(pattern) {
          let chunks = this.split(pattern);
          let tokens = [];
          for (let chunk of chunks) {
            if (chunk instanceof TagChunk_1.TagChunk) {
              let tagChunk = chunk;
              const firstChar = tagChunk.tag.substr(0, 1);
              if (firstChar === firstChar.toUpperCase()) {
                let ttype = this._parser.getTokenType(tagChunk.tag);
                if (ttype === Token_1.Token.INVALID_TYPE) {
                  throw new Error("Unknown token " + tagChunk.tag + " in pattern: " + pattern);
                }
                let t = new TokenTagToken_1.TokenTagToken(tagChunk.tag, ttype, tagChunk.label);
                tokens.push(t);
              } else if (firstChar === firstChar.toLowerCase()) {
                let ruleIndex = this._parser.getRuleIndex(tagChunk.tag);
                if (ruleIndex === -1) {
                  throw new Error("Unknown rule " + tagChunk.tag + " in pattern: " + pattern);
                }
                let ruleImaginaryTokenType = this._parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];
                tokens.push(new RuleTagToken_1.RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));
              } else {
                throw new Error("invalid tag: " + tagChunk.tag + " in pattern: " + pattern);
              }
            } else {
              let textChunk = chunk;
              this._lexer.inputStream = CharStreams_1.CharStreams.fromString(textChunk.text);
              let t = this._lexer.nextToken();
              while (t.type !== Token_1.Token.EOF) {
                tokens.push(t);
                t = this._lexer.nextToken();
              }
            }
          }
          return tokens;
        }
        /** Split `<ID> = <e:expr> ;` into 4 chunks for tokenizing by {@link #tokenize}. */
        split(pattern) {
          let p = 0;
          let n = pattern.length;
          let chunks = [];
          let buf;
          let starts = [];
          let stops = [];
          while (p < n) {
            if (p === pattern.indexOf(this.escape + this.start, p)) {
              p += this.escape.length + this.start.length;
            } else if (p === pattern.indexOf(this.escape + this.stop, p)) {
              p += this.escape.length + this.stop.length;
            } else if (p === pattern.indexOf(this.start, p)) {
              starts.push(p);
              p += this.start.length;
            } else if (p === pattern.indexOf(this.stop, p)) {
              stops.push(p);
              p += this.stop.length;
            } else {
              p++;
            }
          }
          if (starts.length > stops.length) {
            throw new Error("unterminated tag in pattern: " + pattern);
          }
          if (starts.length < stops.length) {
            throw new Error("missing start tag in pattern: " + pattern);
          }
          let ntags = starts.length;
          for (let i = 0; i < ntags; i++) {
            if (starts[i] >= stops[i]) {
              throw new Error("tag delimiters out of order in pattern: " + pattern);
            }
          }
          if (ntags === 0) {
            let text = pattern.substring(0, n);
            chunks.push(new TextChunk_1.TextChunk(text));
          }
          if (ntags > 0 && starts[0] > 0) {
            let text = pattern.substring(0, starts[0]);
            chunks.push(new TextChunk_1.TextChunk(text));
          }
          for (let i = 0; i < ntags; i++) {
            let tag = pattern.substring(starts[i] + this.start.length, stops[i]);
            let ruleOrToken = tag;
            let label;
            let colon = tag.indexOf(":");
            if (colon >= 0) {
              label = tag.substring(0, colon);
              ruleOrToken = tag.substring(colon + 1, tag.length);
            }
            chunks.push(new TagChunk_1.TagChunk(ruleOrToken, label));
            if (i + 1 < ntags) {
              let text = pattern.substring(stops[i] + this.stop.length, starts[i + 1]);
              chunks.push(new TextChunk_1.TextChunk(text));
            }
          }
          if (ntags > 0) {
            let afterLastTag = stops[ntags - 1] + this.stop.length;
            if (afterLastTag < n) {
              let text = pattern.substring(afterLastTag, n);
              chunks.push(new TextChunk_1.TextChunk(text));
            }
          }
          for (let i = 0; i < chunks.length; i++) {
            let c = chunks[i];
            if (c instanceof TextChunk_1.TextChunk) {
              let unescaped = c.text.replace(this.escapeRE, "");
              if (unescaped.length < c.text.length) {
                chunks[i] = new TextChunk_1.TextChunk(unescaped);
              }
            }
          }
          return chunks;
        }
      };
      __decorate([
        Decorators_1.NotNull,
        __param(1, Decorators_1.NotNull)
      ], ParseTreePatternMatcher.prototype, "match", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreePatternMatcher.prototype, "lexer", null);
      __decorate([
        Decorators_1.NotNull
      ], ParseTreePatternMatcher.prototype, "parser", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ParseTreePatternMatcher.prototype, "matchImpl", null);
      exports.ParseTreePatternMatcher = ParseTreePatternMatcher;
      (function(ParseTreePatternMatcher2) {
        class CannotInvokeStartRule extends Error {
          constructor(error48) {
            super(`CannotInvokeStartRule: ${error48}`);
            this.error = error48;
          }
        }
        ParseTreePatternMatcher2.CannotInvokeStartRule = CannotInvokeStartRule;
        class StartRuleDoesNotConsumeFullPattern extends Error {
          constructor() {
            super("StartRuleDoesNotConsumeFullPattern");
          }
        }
        ParseTreePatternMatcher2.StartRuleDoesNotConsumeFullPattern = StartRuleDoesNotConsumeFullPattern;
      })(ParseTreePatternMatcher = exports.ParseTreePatternMatcher || (exports.ParseTreePatternMatcher = {}));
    }
  });

  // node_modules/antlr4ts/atn/DecisionEventInfo.js
  var require_DecisionEventInfo = __commonJS({
    "node_modules/antlr4ts/atn/DecisionEventInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DecisionEventInfo = void 0;
      var Decorators_1 = require_Decorators();
      var DecisionEventInfo = class DecisionEventInfo {
        constructor(decision, state, input, startIndex, stopIndex, fullCtx) {
          this.decision = decision;
          this.fullCtx = fullCtx;
          this.stopIndex = stopIndex;
          this.input = input;
          this.startIndex = startIndex;
          this.state = state;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], DecisionEventInfo.prototype, "input", void 0);
      DecisionEventInfo = __decorate([
        __param(2, Decorators_1.NotNull)
      ], DecisionEventInfo);
      exports.DecisionEventInfo = DecisionEventInfo;
    }
  });

  // node_modules/antlr4ts/atn/AmbiguityInfo.js
  var require_AmbiguityInfo = __commonJS({
    "node_modules/antlr4ts/atn/AmbiguityInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AmbiguityInfo = void 0;
      var DecisionEventInfo_1 = require_DecisionEventInfo();
      var Decorators_1 = require_Decorators();
      var AmbiguityInfo = class AmbiguityInfo extends DecisionEventInfo_1.DecisionEventInfo {
        /**
         * Constructs a new instance of the {@link AmbiguityInfo} class with the
         * specified detailed ambiguity information.
         *
         * @param decision The decision number
         * @param state The final simulator state identifying the ambiguous
         * alternatives for the current input
         * @param ambigAlts The set of alternatives in the decision that lead to a valid parse.
         *                  The predicted alt is the min(ambigAlts)
         * @param input The input token stream
         * @param startIndex The start index for the current prediction
         * @param stopIndex The index at which the ambiguity was identified during
         * prediction
         */
        constructor(decision, state, ambigAlts, input, startIndex, stopIndex) {
          super(decision, state, input, startIndex, stopIndex, state.useContext);
          this.ambigAlts = ambigAlts;
        }
        /**
         * Gets the set of alternatives in the decision that lead to a valid parse.
         *
         * @since 4.5
         */
        get ambiguousAlternatives() {
          return this.ambigAlts;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], AmbiguityInfo.prototype, "ambigAlts", void 0);
      __decorate([
        Decorators_1.NotNull
      ], AmbiguityInfo.prototype, "ambiguousAlternatives", null);
      AmbiguityInfo = __decorate([
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull),
        __param(3, Decorators_1.NotNull)
      ], AmbiguityInfo);
      exports.AmbiguityInfo = AmbiguityInfo;
    }
  });

  // node_modules/antlr4ts/atn/ContextSensitivityInfo.js
  var require_ContextSensitivityInfo = __commonJS({
    "node_modules/antlr4ts/atn/ContextSensitivityInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ContextSensitivityInfo = void 0;
      var DecisionEventInfo_1 = require_DecisionEventInfo();
      var Decorators_1 = require_Decorators();
      var ContextSensitivityInfo = class ContextSensitivityInfo extends DecisionEventInfo_1.DecisionEventInfo {
        /**
         * Constructs a new instance of the {@link ContextSensitivityInfo} class
         * with the specified detailed context sensitivity information.
         *
         * @param decision The decision number
         * @param state The final simulator state containing the unique
         * alternative identified by full-context prediction
         * @param input The input token stream
         * @param startIndex The start index for the current prediction
         * @param stopIndex The index at which the context sensitivity was
         * identified during full-context prediction
         */
        constructor(decision, state, input, startIndex, stopIndex) {
          super(decision, state, input, startIndex, stopIndex, true);
        }
      };
      ContextSensitivityInfo = __decorate([
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ContextSensitivityInfo);
      exports.ContextSensitivityInfo = ContextSensitivityInfo;
    }
  });

  // node_modules/antlr4ts/atn/DecisionInfo.js
  var require_DecisionInfo = __commonJS({
    "node_modules/antlr4ts/atn/DecisionInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DecisionInfo = void 0;
      var Decorators_1 = require_Decorators();
      var DecisionInfo = class {
        /**
         * Constructs a new instance of the {@link DecisionInfo} class to contain
         * statistics for a particular decision.
         *
         * @param decision The decision number
         */
        constructor(decision) {
          this.invocations = 0;
          this.timeInPrediction = 0;
          this.SLL_TotalLook = 0;
          this.SLL_MinLook = 0;
          this.SLL_MaxLook = 0;
          this.LL_TotalLook = 0;
          this.LL_MinLook = 0;
          this.LL_MaxLook = 0;
          this.contextSensitivities = [];
          this.errors = [];
          this.ambiguities = [];
          this.predicateEvals = [];
          this.SLL_ATNTransitions = 0;
          this.SLL_DFATransitions = 0;
          this.LL_Fallback = 0;
          this.LL_ATNTransitions = 0;
          this.LL_DFATransitions = 0;
          this.decision = decision;
        }
        toString() {
          return "{decision=" + this.decision + ", contextSensitivities=" + this.contextSensitivities.length + ", errors=" + this.errors.length + ", ambiguities=" + this.ambiguities.length + ", SLL_lookahead=" + this.SLL_TotalLook + ", SLL_ATNTransitions=" + this.SLL_ATNTransitions + ", SLL_DFATransitions=" + this.SLL_DFATransitions + ", LL_Fallback=" + this.LL_Fallback + ", LL_lookahead=" + this.LL_TotalLook + ", LL_ATNTransitions=" + this.LL_ATNTransitions + "}";
        }
      };
      __decorate([
        Decorators_1.Override
      ], DecisionInfo.prototype, "toString", null);
      exports.DecisionInfo = DecisionInfo;
    }
  });

  // node_modules/antlr4ts/atn/ErrorInfo.js
  var require_ErrorInfo = __commonJS({
    "node_modules/antlr4ts/atn/ErrorInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ErrorInfo = void 0;
      var DecisionEventInfo_1 = require_DecisionEventInfo();
      var Decorators_1 = require_Decorators();
      var ErrorInfo = class ErrorInfo extends DecisionEventInfo_1.DecisionEventInfo {
        /**
         * Constructs a new instance of the {@link ErrorInfo} class with the
         * specified detailed syntax error information.
         *
         * @param decision The decision number
         * @param state The final simulator state reached during prediction
         * prior to reaching the {@link ATNSimulator#ERROR} state
         * @param input The input token stream
         * @param startIndex The start index for the current prediction
         * @param stopIndex The index at which the syntax error was identified
         */
        constructor(decision, state, input, startIndex, stopIndex) {
          super(decision, state, input, startIndex, stopIndex, state.useContext);
        }
      };
      ErrorInfo = __decorate([
        __param(1, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull)
      ], ErrorInfo);
      exports.ErrorInfo = ErrorInfo;
    }
  });

  // node_modules/antlr4ts/atn/LookaheadEventInfo.js
  var require_LookaheadEventInfo = __commonJS({
    "node_modules/antlr4ts/atn/LookaheadEventInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LookaheadEventInfo = void 0;
      var DecisionEventInfo_1 = require_DecisionEventInfo();
      var Decorators_1 = require_Decorators();
      var LookaheadEventInfo = class LookaheadEventInfo extends DecisionEventInfo_1.DecisionEventInfo {
        /**
         * Constructs a new instance of the {@link LookaheadEventInfo} class with
         * the specified detailed lookahead information.
         *
         * @param decision The decision number
         * @param state The final simulator state containing the necessary
         * information to determine the result of a prediction, or `undefined` if
         * the final state is not available
         * @param input The input token stream
         * @param startIndex The start index for the current prediction
         * @param stopIndex The index at which the prediction was finally made
         * @param fullCtx `true` if the current lookahead is part of an LL
         * prediction; otherwise, `false` if the current lookahead is part of
         * an SLL prediction
         */
        constructor(decision, state, predictedAlt, input, startIndex, stopIndex, fullCtx) {
          super(decision, state, input, startIndex, stopIndex, fullCtx);
          this.predictedAlt = predictedAlt;
        }
      };
      LookaheadEventInfo = __decorate([
        __param(3, Decorators_1.NotNull)
      ], LookaheadEventInfo);
      exports.LookaheadEventInfo = LookaheadEventInfo;
    }
  });

  // node_modules/antlr4ts/atn/PredicateEvalInfo.js
  var require_PredicateEvalInfo = __commonJS({
    "node_modules/antlr4ts/atn/PredicateEvalInfo.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PredicateEvalInfo = void 0;
      var DecisionEventInfo_1 = require_DecisionEventInfo();
      var Decorators_1 = require_Decorators();
      var PredicateEvalInfo = class PredicateEvalInfo extends DecisionEventInfo_1.DecisionEventInfo {
        /**
         * Constructs a new instance of the {@link PredicateEvalInfo} class with the
         * specified detailed predicate evaluation information.
         *
         * @param state The simulator state
         * @param decision The decision number
         * @param input The input token stream
         * @param startIndex The start index for the current prediction
         * @param stopIndex The index at which the predicate evaluation was
         * triggered. Note that the input stream may be reset to other positions for
         * the actual evaluation of individual predicates.
         * @param semctx The semantic context which was evaluated
         * @param evalResult The results of evaluating the semantic context
         * @param predictedAlt The alternative number for the decision which is
         * guarded by the semantic context `semctx`. See {@link #predictedAlt}
         * for more information.
         *
         * @see ParserATNSimulator#evalSemanticContext(SemanticContext, ParserRuleContext, int)
         * @see SemanticContext#eval(Recognizer, RuleContext)
         */
        constructor(state, decision, input, startIndex, stopIndex, semctx, evalResult, predictedAlt) {
          super(decision, state, input, startIndex, stopIndex, state.useContext);
          this.semctx = semctx;
          this.evalResult = evalResult;
          this.predictedAlt = predictedAlt;
        }
      };
      PredicateEvalInfo = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(2, Decorators_1.NotNull),
        __param(5, Decorators_1.NotNull)
      ], PredicateEvalInfo);
      exports.PredicateEvalInfo = PredicateEvalInfo;
    }
  });

  // node_modules/antlr4ts/atn/ProfilingATNSimulator.js
  var require_ProfilingATNSimulator = __commonJS({
    "node_modules/antlr4ts/atn/ProfilingATNSimulator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProfilingATNSimulator = void 0;
      var AmbiguityInfo_1 = require_AmbiguityInfo();
      var ATN_1 = require_ATN();
      var ATNSimulator_1 = require_ATNSimulator();
      var ContextSensitivityInfo_1 = require_ContextSensitivityInfo();
      var DecisionInfo_1 = require_DecisionInfo();
      var ErrorInfo_1 = require_ErrorInfo();
      var Decorators_1 = require_Decorators();
      var LookaheadEventInfo_1 = require_LookaheadEventInfo();
      var ParserATNSimulator_1 = require_ParserATNSimulator();
      var PredicateEvalInfo_1 = require_PredicateEvalInfo();
      var SemanticContext_1 = require_SemanticContext();
      var SimulatorState_1 = require_SimulatorState();
      var ProfilingATNSimulator = class extends ParserATNSimulator_1.ParserATNSimulator {
        constructor(parser) {
          super(parser.interpreter.atn, parser);
          this._startIndex = 0;
          this._sllStopIndex = 0;
          this._llStopIndex = 0;
          this.currentDecision = 0;
          this.conflictingAltResolvedBySLL = 0;
          this.optimize_ll1 = false;
          this.reportAmbiguities = true;
          this.numDecisions = this.atn.decisionToState.length;
          this.decisions = [];
          for (let i = 0; i < this.numDecisions; i++) {
            this.decisions.push(new DecisionInfo_1.DecisionInfo(i));
          }
        }
        adaptivePredict(input, decision, outerContext, useContext) {
          if (useContext !== void 0) {
            return super.adaptivePredict(input, decision, outerContext, useContext);
          }
          try {
            this._input = input;
            this._startIndex = input.index;
            this._sllStopIndex = this._startIndex - 1;
            this._llStopIndex = -1;
            this.currentDecision = decision;
            this.currentState = void 0;
            this.conflictingAltResolvedBySLL = ATN_1.ATN.INVALID_ALT_NUMBER;
            let start = process.hrtime();
            let alt = super.adaptivePredict(input, decision, outerContext);
            let stop = process.hrtime();
            let nanoseconds = (stop[0] - start[0]) * 1e9;
            if (nanoseconds === 0) {
              nanoseconds = stop[1] - start[1];
            } else {
              nanoseconds += 1e9 - start[1] + stop[1];
            }
            this.decisions[decision].timeInPrediction += nanoseconds;
            this.decisions[decision].invocations++;
            let SLL_k = this._sllStopIndex - this._startIndex + 1;
            this.decisions[decision].SLL_TotalLook += SLL_k;
            this.decisions[decision].SLL_MinLook = this.decisions[decision].SLL_MinLook === 0 ? SLL_k : Math.min(this.decisions[decision].SLL_MinLook, SLL_k);
            if (SLL_k > this.decisions[decision].SLL_MaxLook) {
              this.decisions[decision].SLL_MaxLook = SLL_k;
              this.decisions[decision].SLL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._sllStopIndex, false);
            }
            if (this._llStopIndex >= 0) {
              let LL_k = this._llStopIndex - this._startIndex + 1;
              this.decisions[decision].LL_TotalLook += LL_k;
              this.decisions[decision].LL_MinLook = this.decisions[decision].LL_MinLook === 0 ? LL_k : Math.min(this.decisions[decision].LL_MinLook, LL_k);
              if (LL_k > this.decisions[decision].LL_MaxLook) {
                this.decisions[decision].LL_MaxLook = LL_k;
                this.decisions[decision].LL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._llStopIndex, true);
              }
            }
            return alt;
          } finally {
            this._input = void 0;
            this.currentDecision = -1;
          }
        }
        getStartState(dfa, input, outerContext, useContext) {
          let state = super.getStartState(dfa, input, outerContext, useContext);
          this.currentState = state;
          return state;
        }
        computeStartState(dfa, globalContext, useContext) {
          let state = super.computeStartState(dfa, globalContext, useContext);
          this.currentState = state;
          return state;
        }
        computeReachSet(dfa, previous, t, contextCache) {
          if (this._input === void 0) {
            throw new Error("Invalid state");
          }
          let reachState = super.computeReachSet(dfa, previous, t, contextCache);
          if (reachState == null) {
            this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, previous, this._input, this._startIndex, this._input.index));
          }
          this.currentState = reachState;
          return reachState;
        }
        getExistingTargetState(previousD, t) {
          if (this.currentState === void 0 || this._input === void 0) {
            throw new Error("Invalid state");
          }
          if (this.currentState.useContext) {
            this._llStopIndex = this._input.index;
          } else {
            this._sllStopIndex = this._input.index;
          }
          let existingTargetState = super.getExistingTargetState(previousD, t);
          if (existingTargetState != null) {
            this.currentState = new SimulatorState_1.SimulatorState(this.currentState.outerContext, existingTargetState, this.currentState.useContext, this.currentState.remainingOuterContext);
            if (this.currentState.useContext) {
              this.decisions[this.currentDecision].LL_DFATransitions++;
            } else {
              this.decisions[this.currentDecision].SLL_DFATransitions++;
            }
            if (existingTargetState === ATNSimulator_1.ATNSimulator.ERROR) {
              let state = new SimulatorState_1.SimulatorState(this.currentState.outerContext, previousD, this.currentState.useContext, this.currentState.remainingOuterContext);
              this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, state, this._input, this._startIndex, this._input.index));
            }
          }
          return existingTargetState;
        }
        computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
          let targetState = super.computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache);
          if (useContext) {
            this.decisions[this.currentDecision].LL_ATNTransitions++;
          } else {
            this.decisions[this.currentDecision].SLL_ATNTransitions++;
          }
          return targetState;
        }
        evalSemanticContextImpl(pred, parserCallStack, alt) {
          if (this.currentState === void 0 || this._input === void 0) {
            throw new Error("Invalid state");
          }
          let result = super.evalSemanticContextImpl(pred, parserCallStack, alt);
          if (!(pred instanceof SemanticContext_1.SemanticContext.PrecedencePredicate)) {
            let fullContext = this._llStopIndex >= 0;
            let stopIndex = fullContext ? this._llStopIndex : this._sllStopIndex;
            this.decisions[this.currentDecision].predicateEvals.push(new PredicateEvalInfo_1.PredicateEvalInfo(this.currentState, this.currentDecision, this._input, this._startIndex, stopIndex, pred, result, alt));
          }
          return result;
        }
        reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
          if (this._input === void 0) {
            throw new Error("Invalid state");
          }
          if (prediction !== this.conflictingAltResolvedBySLL) {
            this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, acceptState, this._input, startIndex, stopIndex));
          }
          super.reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex);
        }
        reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
          if (conflictingAlts != null) {
            this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);
          } else {
            this.conflictingAltResolvedBySLL = conflictState.s0.configs.getRepresentedAlternatives().nextSetBit(0);
          }
          this.decisions[this.currentDecision].LL_Fallback++;
          super.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex);
        }
        reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
          if (this.currentState === void 0 || this._input === void 0) {
            throw new Error("Invalid state");
          }
          let prediction;
          if (ambigAlts != null) {
            prediction = ambigAlts.nextSetBit(0);
          } else {
            prediction = configs.getRepresentedAlternatives().nextSetBit(0);
          }
          if (this.conflictingAltResolvedBySLL !== ATN_1.ATN.INVALID_ALT_NUMBER && prediction !== this.conflictingAltResolvedBySLL) {
            this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, this.currentState, this._input, startIndex, stopIndex));
          }
          this.decisions[this.currentDecision].ambiguities.push(new AmbiguityInfo_1.AmbiguityInfo(this.currentDecision, this.currentState, ambigAlts, this._input, startIndex, stopIndex));
          super.reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs);
        }
        // ---------------------------------------------------------------------
        getDecisionInfo() {
          return this.decisions;
        }
        getCurrentState() {
          return this.currentState;
        }
      };
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull)
      ], ProfilingATNSimulator.prototype, "adaptivePredict", null);
      __decorate([
        Decorators_1.Override
      ], ProfilingATNSimulator.prototype, "getStartState", null);
      __decorate([
        Decorators_1.Override
      ], ProfilingATNSimulator.prototype, "computeStartState", null);
      __decorate([
        Decorators_1.Override
      ], ProfilingATNSimulator.prototype, "computeReachSet", null);
      __decorate([
        Decorators_1.Override
      ], ProfilingATNSimulator.prototype, "getExistingTargetState", null);
      __decorate([
        Decorators_1.Override
      ], ProfilingATNSimulator.prototype, "computeTargetState", null);
      __decorate([
        Decorators_1.Override
      ], ProfilingATNSimulator.prototype, "evalSemanticContextImpl", null);
      __decorate([
        Decorators_1.Override
      ], ProfilingATNSimulator.prototype, "reportContextSensitivity", null);
      __decorate([
        Decorators_1.Override
      ], ProfilingATNSimulator.prototype, "reportAttemptingFullContext", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull),
        __param(5, Decorators_1.NotNull),
        __param(6, Decorators_1.NotNull)
      ], ProfilingATNSimulator.prototype, "reportAmbiguity", null);
      exports.ProfilingATNSimulator = ProfilingATNSimulator;
    }
  });

  // node_modules/antlr4ts/Parser.js
  var require_Parser = __commonJS({
    "node_modules/antlr4ts/Parser.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Parser = void 0;
      var Utils3 = require_Utils();
      var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();
      var ATNDeserializer_1 = require_ATNDeserializer();
      var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();
      var ErrorNode_1 = require_ErrorNode();
      var IntegerStack_1 = require_IntegerStack();
      var Lexer_1 = require_Lexer();
      var Decorators_1 = require_Decorators();
      var ParseInfo_1 = require_ParseInfo();
      var ParserATNSimulator_1 = require_ParserATNSimulator();
      var ProxyParserErrorListener_1 = require_ProxyParserErrorListener();
      var Recognizer_1 = require_Recognizer();
      var TerminalNode_1 = require_TerminalNode();
      var Token_1 = require_Token();
      var TraceListener = class {
        constructor(ruleNames, tokenStream) {
          this.ruleNames = ruleNames;
          this.tokenStream = tokenStream;
        }
        enterEveryRule(ctx) {
          console.log("enter   " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
        }
        exitEveryRule(ctx) {
          console.log("exit    " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
        }
        visitErrorNode(node) {
        }
        visitTerminal(node) {
          let parent = node.parent.ruleContext;
          let token = node.symbol;
          console.log("consume " + token + " rule " + this.ruleNames[parent.ruleIndex]);
        }
      };
      __decorate([
        Decorators_1.Override
      ], TraceListener.prototype, "enterEveryRule", null);
      __decorate([
        Decorators_1.Override
      ], TraceListener.prototype, "exitEveryRule", null);
      __decorate([
        Decorators_1.Override
      ], TraceListener.prototype, "visitErrorNode", null);
      __decorate([
        Decorators_1.Override
      ], TraceListener.prototype, "visitTerminal", null);
      var Parser2 = class _Parser extends Recognizer_1.Recognizer {
        constructor(input) {
          super();
          this._errHandler = new DefaultErrorStrategy_1.DefaultErrorStrategy();
          this._precedenceStack = new IntegerStack_1.IntegerStack();
          this._buildParseTrees = true;
          this._parseListeners = [];
          this._syntaxErrors = 0;
          this.matchedEOF = false;
          this._precedenceStack.push(0);
          this.inputStream = input;
        }
        reset(resetInput) {
          if (resetInput === void 0 || resetInput) {
            this.inputStream.seek(0);
          }
          this._errHandler.reset(this);
          this._ctx = void 0;
          this._syntaxErrors = 0;
          this.matchedEOF = false;
          this.isTrace = false;
          this._precedenceStack.clear();
          this._precedenceStack.push(0);
          let interpreter = this.interpreter;
          if (interpreter != null) {
            interpreter.reset();
          }
        }
        /**
         * Match current input symbol against `ttype`. If the symbol type
         * matches, {@link ANTLRErrorStrategy#reportMatch} and {@link #consume} are
         * called to complete the match process.
         *
         * If the symbol type does not match,
         * {@link ANTLRErrorStrategy#recoverInline} is called on the current error
         * strategy to attempt recovery. If {@link #getBuildParseTree} is
         * `true` and the token index of the symbol returned by
         * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to
         * the parse tree by calling {@link #createErrorNode(ParserRuleContext, Token)} then
         * {@link ParserRuleContext#addErrorNode(ErrorNode)}.
         *
         * @param ttype the token type to match
         * @returns the matched symbol
         * @ if the current input symbol did not match
         * `ttype` and the error strategy could not recover from the
         * mismatched symbol
         */
        match(ttype) {
          let t = this.currentToken;
          if (t.type === ttype) {
            if (ttype === Token_1.Token.EOF) {
              this.matchedEOF = true;
            }
            this._errHandler.reportMatch(this);
            this.consume();
          } else {
            t = this._errHandler.recoverInline(this);
            if (this._buildParseTrees && t.tokenIndex === -1) {
              this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
            }
          }
          return t;
        }
        /**
         * Match current input symbol as a wildcard. If the symbol type matches
         * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy#reportMatch}
         * and {@link #consume} are called to complete the match process.
         *
         * If the symbol type does not match,
         * {@link ANTLRErrorStrategy#recoverInline} is called on the current error
         * strategy to attempt recovery. If {@link #getBuildParseTree} is
         * `true` and the token index of the symbol returned by
         * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to
         * the parse tree by calling {@link Parser#createErrorNode(ParserRuleContext, Token)} then
         * {@link ParserRuleContext#addErrorNode(ErrorNode)}.
         *
         * @returns the matched symbol
         * @ if the current input symbol did not match
         * a wildcard and the error strategy could not recover from the mismatched
         * symbol
         */
        matchWildcard() {
          let t = this.currentToken;
          if (t.type > 0) {
            this._errHandler.reportMatch(this);
            this.consume();
          } else {
            t = this._errHandler.recoverInline(this);
            if (this._buildParseTrees && t.tokenIndex === -1) {
              this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
            }
          }
          return t;
        }
        /**
         * Track the {@link ParserRuleContext} objects during the parse and hook
         * them up using the {@link ParserRuleContext#children} list so that it
         * forms a parse tree. The {@link ParserRuleContext} returned from the start
         * rule represents the root of the parse tree.
         *
         * Note that if we are not building parse trees, rule contexts only point
         * upwards. When a rule exits, it returns the context but that gets garbage
         * collected if nobody holds a reference. It points upwards but nobody
         * points at it.
         *
         * When we build parse trees, we are adding all of these contexts to
         * {@link ParserRuleContext#children} list. Contexts are then not candidates
         * for garbage collection.
         */
        set buildParseTree(buildParseTrees) {
          this._buildParseTrees = buildParseTrees;
        }
        /**
         * Gets whether or not a complete parse tree will be constructed while
         * parsing. This property is `true` for a newly constructed parser.
         *
         * @returns `true` if a complete parse tree will be constructed while
         * parsing, otherwise `false`
         */
        get buildParseTree() {
          return this._buildParseTrees;
        }
        getParseListeners() {
          return this._parseListeners;
        }
        /**
         * Registers `listener` to receive events during the parsing process.
         *
         * To support output-preserving grammar transformations (including but not
         * limited to left-recursion removal, automated left-factoring, and
         * optimized code generation), calls to listener methods during the parse
         * may differ substantially from calls made by
         * {@link ParseTreeWalker#DEFAULT} used after the parse is complete. In
         * particular, rule entry and exit events may occur in a different order
         * during the parse than after the parser. In addition, calls to certain
         * rule entry methods may be omitted.
         *
         * With the following specific exceptions, calls to listener events are
         * *deterministic*, i.e. for identical input the calls to listener
         * methods will be the same.
         *
         * * Alterations to the grammar used to generate code may change the
         *   behavior of the listener calls.
         * * Alterations to the command line options passed to ANTLR 4 when
         *   generating the parser may change the behavior of the listener calls.
         * * Changing the version of the ANTLR Tool used to generate the parser
         *   may change the behavior of the listener calls.
         *
         * @param listener the listener to add
         *
         * @throws {@link TypeError} if `listener` is `undefined`
         */
        addParseListener(listener) {
          if (listener == null) {
            throw new TypeError("listener cannot be null");
          }
          this._parseListeners.push(listener);
        }
        /**
         * Remove `listener` from the list of parse listeners.
         *
         * If `listener` is `undefined` or has not been added as a parse
         * listener, this method does nothing.
         *
         * @see #addParseListener
         *
         * @param listener the listener to remove
         */
        removeParseListener(listener) {
          let index = this._parseListeners.findIndex((l) => l === listener);
          if (index !== -1) {
            this._parseListeners.splice(index, 1);
          }
        }
        /**
         * Remove all parse listeners.
         *
         * @see #addParseListener
         */
        removeParseListeners() {
          this._parseListeners.length = 0;
        }
        /**
         * Notify any parse listeners of an enter rule event.
         *
         * @see #addParseListener
         */
        triggerEnterRuleEvent() {
          for (let listener of this._parseListeners) {
            if (listener.enterEveryRule) {
              listener.enterEveryRule(this._ctx);
            }
            this._ctx.enterRule(listener);
          }
        }
        /**
         * Notify any parse listeners of an exit rule event.
         *
         * @see #addParseListener
         */
        triggerExitRuleEvent() {
          for (let i = this._parseListeners.length - 1; i >= 0; i--) {
            let listener = this._parseListeners[i];
            this._ctx.exitRule(listener);
            if (listener.exitEveryRule) {
              listener.exitEveryRule(this._ctx);
            }
          }
        }
        /**
         * Gets the number of syntax errors reported during parsing. This value is
         * incremented each time {@link #notifyErrorListeners} is called.
         *
         * @see #notifyErrorListeners
         */
        get numberOfSyntaxErrors() {
          return this._syntaxErrors;
        }
        get tokenFactory() {
          return this._input.tokenSource.tokenFactory;
        }
        /**
         * The ATN with bypass alternatives is expensive to create so we create it
         * lazily.
         *
         * @ if the current parser does not
         * implement the `serializedATN` property.
         */
        getATNWithBypassAlts() {
          let serializedAtn = this.serializedATN;
          if (serializedAtn == null) {
            throw new Error("The current parser does not support an ATN with bypass alternatives.");
          }
          let result = _Parser.bypassAltsAtnCache.get(serializedAtn);
          if (result == null) {
            let deserializationOptions = new ATNDeserializationOptions_1.ATNDeserializationOptions();
            deserializationOptions.isGenerateRuleBypassTransitions = true;
            result = new ATNDeserializer_1.ATNDeserializer(deserializationOptions).deserialize(Utils3.toCharArray(serializedAtn));
            _Parser.bypassAltsAtnCache.set(serializedAtn, result);
          }
          return result;
        }
        compileParseTreePattern(pattern, patternRuleIndex, lexer) {
          return __awaiter(this, void 0, void 0, function* () {
            if (!lexer) {
              if (this.inputStream) {
                let tokenSource = this.inputStream.tokenSource;
                if (tokenSource instanceof Lexer_1.Lexer) {
                  lexer = tokenSource;
                }
              }
              if (!lexer) {
                throw new Error("Parser can't discover a lexer to use");
              }
            }
            let currentLexer = lexer;
            let m = yield Promise.resolve().then(() => require_ParseTreePatternMatcher());
            let matcher = new m.ParseTreePatternMatcher(currentLexer, this);
            return matcher.compile(pattern, patternRuleIndex);
          });
        }
        get errorHandler() {
          return this._errHandler;
        }
        set errorHandler(handler) {
          this._errHandler = handler;
        }
        get inputStream() {
          return this._input;
        }
        /** Set the token stream and reset the parser. */
        set inputStream(input) {
          this.reset(false);
          this._input = input;
        }
        /** Match needs to return the current input symbol, which gets put
         *  into the label for the associated token ref; e.g., x=ID.
         */
        get currentToken() {
          return this._input.LT(1);
        }
        notifyErrorListeners(msg, offendingToken, e) {
          if (offendingToken === void 0) {
            offendingToken = this.currentToken;
          } else if (offendingToken === null) {
            offendingToken = void 0;
          }
          this._syntaxErrors++;
          let line = -1;
          let charPositionInLine = -1;
          if (offendingToken != null) {
            line = offendingToken.line;
            charPositionInLine = offendingToken.charPositionInLine;
          }
          let listener = this.getErrorListenerDispatch();
          if (listener.syntaxError) {
            listener.syntaxError(this, offendingToken, line, charPositionInLine, msg, e);
          }
        }
        /**
         * Consume and return the [current symbol](`currentToken`).
         *
         * E.g., given the following input with `A` being the current
         * lookahead symbol, this function moves the cursor to `B` and returns
         * `A`.
         *
         * ```
         * A B
         * ^
         * ```
         *
         * If the parser is not in error recovery mode, the consumed symbol is added
         * to the parse tree using {@link ParserRuleContext#addChild(TerminalNode)}, and
         * {@link ParseTreeListener#visitTerminal} is called on any parse listeners.
         * If the parser *is* in error recovery mode, the consumed symbol is
         * added to the parse tree using {@link #createErrorNode(ParserRuleContext, Token)} then
         * {@link ParserRuleContext#addErrorNode(ErrorNode)} and
         * {@link ParseTreeListener#visitErrorNode} is called on any parse
         * listeners.
         */
        consume() {
          let o = this.currentToken;
          if (o.type !== _Parser.EOF) {
            this.inputStream.consume();
          }
          let hasListener = this._parseListeners.length !== 0;
          if (this._buildParseTrees || hasListener) {
            if (this._errHandler.inErrorRecoveryMode(this)) {
              let node = this._ctx.addErrorNode(this.createErrorNode(this._ctx, o));
              if (hasListener) {
                for (let listener of this._parseListeners) {
                  if (listener.visitErrorNode) {
                    listener.visitErrorNode(node);
                  }
                }
              }
            } else {
              let node = this.createTerminalNode(this._ctx, o);
              this._ctx.addChild(node);
              if (hasListener) {
                for (let listener of this._parseListeners) {
                  if (listener.visitTerminal) {
                    listener.visitTerminal(node);
                  }
                }
              }
            }
          }
          return o;
        }
        /**
         * How to create a token leaf node associated with a parent.
         * Typically, the terminal node to create is not a function of the parent.
         *
         * @since 4.7
         */
        createTerminalNode(parent, t) {
          return new TerminalNode_1.TerminalNode(t);
        }
        /**
         * How to create an error node, given a token, associated with a parent.
         * Typically, the error node to create is not a function of the parent.
         *
         * @since 4.7
         */
        createErrorNode(parent, t) {
          return new ErrorNode_1.ErrorNode(t);
        }
        addContextToParseTree() {
          let parent = this._ctx._parent;
          if (parent != null) {
            parent.addChild(this._ctx);
          }
        }
        /**
         * Always called by generated parsers upon entry to a rule. Access field
         * {@link #_ctx} get the current context.
         */
        enterRule(localctx, state, ruleIndex) {
          this.state = state;
          this._ctx = localctx;
          this._ctx._start = this._input.LT(1);
          if (this._buildParseTrees) {
            this.addContextToParseTree();
          }
          this.triggerEnterRuleEvent();
        }
        enterLeftFactoredRule(localctx, state, ruleIndex) {
          this.state = state;
          if (this._buildParseTrees) {
            let factoredContext = this._ctx.getChild(this._ctx.childCount - 1);
            this._ctx.removeLastChild();
            factoredContext._parent = localctx;
            localctx.addChild(factoredContext);
          }
          this._ctx = localctx;
          this._ctx._start = this._input.LT(1);
          if (this._buildParseTrees) {
            this.addContextToParseTree();
          }
          this.triggerEnterRuleEvent();
        }
        exitRule() {
          if (this.matchedEOF) {
            this._ctx._stop = this._input.LT(1);
          } else {
            this._ctx._stop = this._input.tryLT(-1);
          }
          this.triggerExitRuleEvent();
          this.state = this._ctx.invokingState;
          this._ctx = this._ctx._parent;
        }
        enterOuterAlt(localctx, altNum) {
          localctx.altNumber = altNum;
          if (this._buildParseTrees && this._ctx !== localctx) {
            let parent = this._ctx._parent;
            if (parent != null) {
              parent.removeLastChild();
              parent.addChild(localctx);
            }
          }
          this._ctx = localctx;
        }
        /**
         * Get the precedence level for the top-most precedence rule.
         *
         * @returns The precedence level for the top-most precedence rule, or -1 if
         * the parser context is not nested within a precedence rule.
         */
        get precedence() {
          if (this._precedenceStack.isEmpty) {
            return -1;
          }
          return this._precedenceStack.peek();
        }
        enterRecursionRule(localctx, state, ruleIndex, precedence) {
          this.state = state;
          this._precedenceStack.push(precedence);
          this._ctx = localctx;
          this._ctx._start = this._input.LT(1);
          this.triggerEnterRuleEvent();
        }
        /** Like {@link #enterRule} but for recursive rules.
         *  Make the current context the child of the incoming localctx.
         */
        pushNewRecursionContext(localctx, state, ruleIndex) {
          let previous = this._ctx;
          previous._parent = localctx;
          previous.invokingState = state;
          previous._stop = this._input.tryLT(-1);
          this._ctx = localctx;
          this._ctx._start = previous._start;
          if (this._buildParseTrees) {
            this._ctx.addChild(previous);
          }
          this.triggerEnterRuleEvent();
        }
        unrollRecursionContexts(_parentctx) {
          this._precedenceStack.pop();
          this._ctx._stop = this._input.tryLT(-1);
          let retctx = this._ctx;
          if (this._parseListeners.length > 0) {
            while (this._ctx !== _parentctx) {
              this.triggerExitRuleEvent();
              this._ctx = this._ctx._parent;
            }
          } else {
            this._ctx = _parentctx;
          }
          retctx._parent = _parentctx;
          if (this._buildParseTrees && _parentctx != null) {
            _parentctx.addChild(retctx);
          }
        }
        getInvokingContext(ruleIndex) {
          let p = this._ctx;
          while (p && p.ruleIndex !== ruleIndex) {
            p = p._parent;
          }
          return p;
        }
        get context() {
          return this._ctx;
        }
        set context(ctx) {
          this._ctx = ctx;
        }
        precpred(localctx, precedence) {
          return precedence >= this._precedenceStack.peek();
        }
        getErrorListenerDispatch() {
          return new ProxyParserErrorListener_1.ProxyParserErrorListener(this.getErrorListeners());
        }
        inContext(context) {
          return false;
        }
        /**
         * Checks whether or not `symbol` can follow the current state in the
         * ATN. The behavior of this method is equivalent to the following, but is
         * implemented such that the complete context-sensitive follow set does not
         * need to be explicitly constructed.
         *
         * ```
         * return getExpectedTokens().contains(symbol);
         * ```
         *
         * @param symbol the symbol type to check
         * @returns `true` if `symbol` can follow the current state in
         * the ATN, otherwise `false`.
         */
        isExpectedToken(symbol2) {
          let atn = this.interpreter.atn;
          let ctx = this._ctx;
          let s = atn.states[this.state];
          let following = atn.nextTokens(s);
          if (following.contains(symbol2)) {
            return true;
          }
          if (!following.contains(Token_1.Token.EPSILON)) {
            return false;
          }
          while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
            let invokingState = atn.states[ctx.invokingState];
            let rt = invokingState.transition(0);
            following = atn.nextTokens(rt.followState);
            if (following.contains(symbol2)) {
              return true;
            }
            ctx = ctx._parent;
          }
          if (following.contains(Token_1.Token.EPSILON) && symbol2 === Token_1.Token.EOF) {
            return true;
          }
          return false;
        }
        get isMatchedEOF() {
          return this.matchedEOF;
        }
        /**
         * Computes the set of input symbols which could follow the current parser
         * state and context, as given by {@link #getState} and {@link #getContext},
         * respectively.
         *
         * @see ATN#getExpectedTokens(int, RuleContext)
         */
        getExpectedTokens() {
          return this.atn.getExpectedTokens(this.state, this.context);
        }
        getExpectedTokensWithinCurrentRule() {
          let atn = this.interpreter.atn;
          let s = atn.states[this.state];
          return atn.nextTokens(s);
        }
        /** Get a rule's index (i.e., `RULE_ruleName` field) or -1 if not found. */
        getRuleIndex(ruleName) {
          let ruleIndex = this.getRuleIndexMap().get(ruleName);
          if (ruleIndex != null) {
            return ruleIndex;
          }
          return -1;
        }
        get ruleContext() {
          return this._ctx;
        }
        /** Return List&lt;String&gt; of the rule names in your parser instance
         *  leading up to a call to the current rule.  You could override if
         *  you want more details such as the file/line info of where
         *  in the ATN a rule is invoked.
         *
         *  This is very useful for error messages.
         */
        getRuleInvocationStack(ctx = this._ctx) {
          let p = ctx;
          let ruleNames = this.ruleNames;
          let stack = [];
          while (p != null) {
            let ruleIndex = p.ruleIndex;
            if (ruleIndex < 0) {
              stack.push("n/a");
            } else {
              stack.push(ruleNames[ruleIndex]);
            }
            p = p._parent;
          }
          return stack;
        }
        /** For debugging and other purposes. */
        getDFAStrings() {
          let s = [];
          for (let dfa of this._interp.atn.decisionToDFA) {
            s.push(dfa.toString(this.vocabulary, this.ruleNames));
          }
          return s;
        }
        /** For debugging and other purposes. */
        dumpDFA() {
          let seenOne = false;
          for (let dfa of this._interp.atn.decisionToDFA) {
            if (!dfa.isEmpty) {
              if (seenOne) {
                console.log();
              }
              console.log("Decision " + dfa.decision + ":");
              process.stdout.write(dfa.toString(this.vocabulary, this.ruleNames));
              seenOne = true;
            }
          }
        }
        get sourceName() {
          return this._input.sourceName;
        }
        get parseInfo() {
          return Promise.resolve().then(() => require_ProfilingATNSimulator()).then((m) => {
            let interp = this.interpreter;
            if (interp instanceof m.ProfilingATNSimulator) {
              return new ParseInfo_1.ParseInfo(interp);
            }
            return void 0;
          });
        }
        /**
         * @since 4.3
         */
        setProfile(profile) {
          return __awaiter(this, void 0, void 0, function* () {
            let m = yield Promise.resolve().then(() => require_ProfilingATNSimulator());
            let interp = this.interpreter;
            if (profile) {
              if (!(interp instanceof m.ProfilingATNSimulator)) {
                this.interpreter = new m.ProfilingATNSimulator(this);
              }
            } else if (interp instanceof m.ProfilingATNSimulator) {
              this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this.atn, this);
            }
            this.interpreter.setPredictionMode(interp.getPredictionMode());
          });
        }
        /** During a parse is sometimes useful to listen in on the rule entry and exit
         *  events as well as token matches. This is for quick and dirty debugging.
         */
        set isTrace(trace) {
          if (!trace) {
            if (this._tracer) {
              this.removeParseListener(this._tracer);
              this._tracer = void 0;
            }
          } else {
            if (this._tracer) {
              this.removeParseListener(this._tracer);
            } else {
              this._tracer = new TraceListener(this.ruleNames, this._input);
            }
            this.addParseListener(this._tracer);
          }
        }
        /**
         * Gets whether a {@link TraceListener} is registered as a parse listener
         * for the parser.
         */
        get isTrace() {
          return this._tracer != null;
        }
      };
      Parser2.bypassAltsAtnCache = /* @__PURE__ */ new Map();
      __decorate([
        Decorators_1.NotNull
      ], Parser2.prototype, "_errHandler", void 0);
      __decorate([
        Decorators_1.NotNull
      ], Parser2.prototype, "match", null);
      __decorate([
        Decorators_1.NotNull
      ], Parser2.prototype, "matchWildcard", null);
      __decorate([
        Decorators_1.NotNull
      ], Parser2.prototype, "getParseListeners", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], Parser2.prototype, "addParseListener", null);
      __decorate([
        Decorators_1.NotNull
      ], Parser2.prototype, "getATNWithBypassAlts", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], Parser2.prototype, "errorHandler", null);
      __decorate([
        Decorators_1.Override
      ], Parser2.prototype, "inputStream", null);
      __decorate([
        Decorators_1.NotNull
      ], Parser2.prototype, "currentToken", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], Parser2.prototype, "enterRule", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.Nullable)
      ], Parser2.prototype, "precpred", null);
      __decorate([
        Decorators_1.Override
      ], Parser2.prototype, "getErrorListenerDispatch", null);
      __decorate([
        Decorators_1.NotNull
      ], Parser2.prototype, "getExpectedTokens", null);
      __decorate([
        Decorators_1.NotNull
      ], Parser2.prototype, "getExpectedTokensWithinCurrentRule", null);
      __decorate([
        Decorators_1.Override
      ], Parser2.prototype, "parseInfo", null);
      exports.Parser = Parser2;
    }
  });

  // node_modules/antlr4ts/NoViableAltException.js
  var require_NoViableAltException = __commonJS({
    "node_modules/antlr4ts/NoViableAltException.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NoViableAltException = void 0;
      var Parser_1 = require_Parser();
      var RecognitionException_1 = require_RecognitionException();
      var Decorators_1 = require_Decorators();
      var NoViableAltException2 = class extends RecognitionException_1.RecognitionException {
        constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
          if (recognizer instanceof Parser_1.Parser) {
            if (input === void 0) {
              input = recognizer.inputStream;
            }
            if (startToken === void 0) {
              startToken = recognizer.currentToken;
            }
            if (offendingToken === void 0) {
              offendingToken = recognizer.currentToken;
            }
            if (ctx === void 0) {
              ctx = recognizer.context;
            }
          }
          super(recognizer, input, ctx);
          this._deadEndConfigs = deadEndConfigs;
          this._startToken = startToken;
          this.setOffendingToken(recognizer, offendingToken);
        }
        get startToken() {
          return this._startToken;
        }
        get deadEndConfigs() {
          return this._deadEndConfigs;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], NoViableAltException2.prototype, "_startToken", void 0);
      exports.NoViableAltException = NoViableAltException2;
    }
  });

  // node_modules/antlr4ts/DefaultErrorStrategy.js
  var require_DefaultErrorStrategy = __commonJS({
    "node_modules/antlr4ts/DefaultErrorStrategy.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultErrorStrategy = void 0;
      var ATNState_1 = require_ATNState();
      var ATNStateType_1 = require_ATNStateType();
      var FailedPredicateException_1 = require_FailedPredicateException();
      var InputMismatchException_1 = require_InputMismatchException();
      var IntervalSet_1 = require_IntervalSet();
      var NoViableAltException_1 = require_NoViableAltException();
      var PredictionContext_1 = require_PredictionContext();
      var Token_1 = require_Token();
      var Decorators_1 = require_Decorators();
      var DefaultErrorStrategy = class {
        constructor() {
          this.errorRecoveryMode = false;
          this.lastErrorIndex = -1;
          this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
        }
        /**
         * {@inheritDoc}
         *
         * The default implementation simply calls {@link #endErrorCondition} to
         * ensure that the handler is not in error recovery mode.
         */
        reset(recognizer) {
          this.endErrorCondition(recognizer);
        }
        /**
         * This method is called to enter error recovery mode when a recognition
         * exception is reported.
         *
         * @param recognizer the parser instance
         */
        beginErrorCondition(recognizer) {
          this.errorRecoveryMode = true;
        }
        /**
         * {@inheritDoc}
         */
        inErrorRecoveryMode(recognizer) {
          return this.errorRecoveryMode;
        }
        /**
         * This method is called to leave error recovery mode after recovering from
         * a recognition exception.
         *
         * @param recognizer
         */
        endErrorCondition(recognizer) {
          this.errorRecoveryMode = false;
          this.lastErrorStates = void 0;
          this.lastErrorIndex = -1;
        }
        /**
         * {@inheritDoc}
         *
         * The default implementation simply calls {@link #endErrorCondition}.
         */
        reportMatch(recognizer) {
          this.endErrorCondition(recognizer);
        }
        /**
         * {@inheritDoc}
         *
         * The default implementation returns immediately if the handler is already
         * in error recovery mode. Otherwise, it calls {@link #beginErrorCondition}
         * and dispatches the reporting task based on the runtime type of `e`
         * according to the following table.
         *
         * * {@link NoViableAltException}: Dispatches the call to
         *   {@link #reportNoViableAlternative}
         * * {@link InputMismatchException}: Dispatches the call to
         *   {@link #reportInputMismatch}
         * * {@link FailedPredicateException}: Dispatches the call to
         *   {@link #reportFailedPredicate}
         * * All other types: calls {@link Parser#notifyErrorListeners} to report
         *   the exception
         */
        reportError(recognizer, e) {
          if (this.inErrorRecoveryMode(recognizer)) {
            return;
          }
          this.beginErrorCondition(recognizer);
          if (e instanceof NoViableAltException_1.NoViableAltException) {
            this.reportNoViableAlternative(recognizer, e);
          } else if (e instanceof InputMismatchException_1.InputMismatchException) {
            this.reportInputMismatch(recognizer, e);
          } else if (e instanceof FailedPredicateException_1.FailedPredicateException) {
            this.reportFailedPredicate(recognizer, e);
          } else {
            console.error(`unknown recognition error type: ${e}`);
            this.notifyErrorListeners(recognizer, e.toString(), e);
          }
        }
        notifyErrorListeners(recognizer, message, e) {
          let offendingToken = e.getOffendingToken(recognizer);
          if (offendingToken === void 0) {
            offendingToken = null;
          }
          recognizer.notifyErrorListeners(message, offendingToken, e);
        }
        /**
         * {@inheritDoc}
         *
         * The default implementation resynchronizes the parser by consuming tokens
         * until we find one in the resynchronization set--loosely the set of tokens
         * that can follow the current rule.
         */
        recover(recognizer, e) {
          if (this.lastErrorIndex === recognizer.inputStream.index && this.lastErrorStates && this.lastErrorStates.contains(recognizer.state)) {
            recognizer.consume();
          }
          this.lastErrorIndex = recognizer.inputStream.index;
          if (!this.lastErrorStates) {
            this.lastErrorStates = new IntervalSet_1.IntervalSet();
          }
          this.lastErrorStates.add(recognizer.state);
          let followSet = this.getErrorRecoverySet(recognizer);
          this.consumeUntil(recognizer, followSet);
        }
        /**
         * The default implementation of {@link ANTLRErrorStrategy#sync} makes sure
         * that the current lookahead symbol is consistent with what were expecting
         * at this point in the ATN. You can call this anytime but ANTLR only
         * generates code to check before subrules/loops and each iteration.
         *
         * Implements Jim Idle's magic sync mechanism in closures and optional
         * subrules. E.g.,
         *
         * ```antlr
         * a : sync ( stuff sync )* ;
         * sync : {consume to what can follow sync} ;
         * ```
         *
         * At the start of a sub rule upon error, {@link #sync} performs single
         * token deletion, if possible. If it can't do that, it bails on the current
         * rule and uses the default error recovery, which consumes until the
         * resynchronization set of the current rule.
         *
         * If the sub rule is optional (`(...)?`, `(...)*`, or block
         * with an empty alternative), then the expected set includes what follows
         * the subrule.
         *
         * During loop iteration, it consumes until it sees a token that can start a
         * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
         * stay in the loop as long as possible.
         *
         * **ORIGINS**
         *
         * Previous versions of ANTLR did a poor job of their recovery within loops.
         * A single mismatch token or missing token would force the parser to bail
         * out of the entire rules surrounding the loop. So, for rule
         *
         * ```antlr
         * classDef : 'class' ID '{' member* '}'
         * ```
         *
         * input with an extra token between members would force the parser to
         * consume until it found the next class definition rather than the next
         * member definition of the current class.
         *
         * This functionality cost a little bit of effort because the parser has to
         * compare token set at the start of the loop and at each iteration. If for
         * some reason speed is suffering for you, you can turn off this
         * functionality by simply overriding this method as a blank { }.
         */
        sync(recognizer) {
          let s = recognizer.interpreter.atn.states[recognizer.state];
          if (this.inErrorRecoveryMode(recognizer)) {
            return;
          }
          let tokens = recognizer.inputStream;
          let la = tokens.LA(1);
          let nextTokens = recognizer.atn.nextTokens(s);
          if (nextTokens.contains(la)) {
            this.nextTokensContext = void 0;
            this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
            return;
          }
          if (nextTokens.contains(Token_1.Token.EPSILON)) {
            if (this.nextTokensContext === void 0) {
              this.nextTokensContext = recognizer.context;
              this.nextTokensState = recognizer.state;
            }
            return;
          }
          switch (s.stateType) {
            case ATNStateType_1.ATNStateType.BLOCK_START:
            case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
            case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
            case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
              if (this.singleTokenDeletion(recognizer)) {
                return;
              }
              throw new InputMismatchException_1.InputMismatchException(recognizer);
            case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
            case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
              this.reportUnwantedToken(recognizer);
              let expecting = recognizer.getExpectedTokens();
              let whatFollowsLoopIterationOrRule = expecting.or(this.getErrorRecoverySet(recognizer));
              this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
              break;
            default:
              break;
          }
        }
        /**
         * This is called by {@link #reportError} when the exception is a
         * {@link NoViableAltException}.
         *
         * @see #reportError
         *
         * @param recognizer the parser instance
         * @param e the recognition exception
         */
        reportNoViableAlternative(recognizer, e) {
          let tokens = recognizer.inputStream;
          let input;
          if (tokens) {
            if (e.startToken.type === Token_1.Token.EOF) {
              input = "<EOF>";
            } else {
              input = tokens.getTextFromRange(e.startToken, e.getOffendingToken());
            }
          } else {
            input = "<unknown input>";
          }
          let msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
          this.notifyErrorListeners(recognizer, msg, e);
        }
        /**
         * This is called by {@link #reportError} when the exception is an
         * {@link InputMismatchException}.
         *
         * @see #reportError
         *
         * @param recognizer the parser instance
         * @param e the recognition exception
         */
        reportInputMismatch(recognizer, e) {
          let expected = e.expectedTokens;
          let expectedString = expected ? expected.toStringVocabulary(recognizer.vocabulary) : "";
          let msg = "mismatched input " + this.getTokenErrorDisplay(e.getOffendingToken(recognizer)) + " expecting " + expectedString;
          this.notifyErrorListeners(recognizer, msg, e);
        }
        /**
         * This is called by {@link #reportError} when the exception is a
         * {@link FailedPredicateException}.
         *
         * @see #reportError
         *
         * @param recognizer the parser instance
         * @param e the recognition exception
         */
        reportFailedPredicate(recognizer, e) {
          let ruleName = recognizer.ruleNames[recognizer.context.ruleIndex];
          let msg = "rule " + ruleName + " " + e.message;
          this.notifyErrorListeners(recognizer, msg, e);
        }
        /**
         * This method is called to report a syntax error which requires the removal
         * of a token from the input stream. At the time this method is called, the
         * erroneous symbol is current `LT(1)` symbol and has not yet been
         * removed from the input stream. When this method returns,
         * `recognizer` is in error recovery mode.
         *
         * This method is called when {@link #singleTokenDeletion} identifies
         * single-token deletion as a viable recovery strategy for a mismatched
         * input error.
         *
         * The default implementation simply returns if the handler is already in
         * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to
         * enter error recovery mode, followed by calling
         * {@link Parser#notifyErrorListeners}.
         *
         * @param recognizer the parser instance
         */
        reportUnwantedToken(recognizer) {
          if (this.inErrorRecoveryMode(recognizer)) {
            return;
          }
          this.beginErrorCondition(recognizer);
          let t = recognizer.currentToken;
          let tokenName = this.getTokenErrorDisplay(t);
          let expecting = this.getExpectedTokens(recognizer);
          let msg = "extraneous input " + tokenName + " expecting " + expecting.toStringVocabulary(recognizer.vocabulary);
          recognizer.notifyErrorListeners(msg, t, void 0);
        }
        /**
         * This method is called to report a syntax error which requires the
         * insertion of a missing token into the input stream. At the time this
         * method is called, the missing token has not yet been inserted. When this
         * method returns, `recognizer` is in error recovery mode.
         *
         * This method is called when {@link #singleTokenInsertion} identifies
         * single-token insertion as a viable recovery strategy for a mismatched
         * input error.
         *
         * The default implementation simply returns if the handler is already in
         * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to
         * enter error recovery mode, followed by calling
         * {@link Parser#notifyErrorListeners}.
         *
         * @param recognizer the parser instance
         */
        reportMissingToken(recognizer) {
          if (this.inErrorRecoveryMode(recognizer)) {
            return;
          }
          this.beginErrorCondition(recognizer);
          let t = recognizer.currentToken;
          let expecting = this.getExpectedTokens(recognizer);
          let msg = "missing " + expecting.toStringVocabulary(recognizer.vocabulary) + " at " + this.getTokenErrorDisplay(t);
          recognizer.notifyErrorListeners(msg, t, void 0);
        }
        /**
         * {@inheritDoc}
         *
         * The default implementation attempts to recover from the mismatched input
         * by using single token insertion and deletion as described below. If the
         * recovery attempt fails, this method
         * {@link InputMismatchException}.
         *
         * **EXTRA TOKEN** (single token deletion)
         *
         * `LA(1)` is not what we are looking for. If `LA(2)` has the
         * right token, however, then assume `LA(1)` is some extra spurious
         * token and delete it. Then consume and return the next token (which was
         * the `LA(2)` token) as the successful result of the match operation.
         *
         * This recovery strategy is implemented by {@link #singleTokenDeletion}.
         *
         * **MISSING TOKEN** (single token insertion)
         *
         * If current token (at `LA(1)`) is consistent with what could come
         * after the expected `LA(1)` token, then assume the token is missing
         * and use the parser's {@link TokenFactory} to create it on the fly. The
         * "insertion" is performed by returning the created token as the successful
         * result of the match operation.
         *
         * This recovery strategy is implemented by {@link #singleTokenInsertion}.
         *
         * **EXAMPLE**
         *
         * For example, Input `i=(3;` is clearly missing the `')'`. When
         * the parser returns from the nested call to `expr`, it will have
         * call chain:
         *
         * ```
         * stat  expr  atom
         * ```
         *
         * and it will be trying to match the `')'` at this point in the
         * derivation:
         *
         * ```
         * => ID '=' '(' INT ')' ('+' atom)* ';'
         *                    ^
         * ```
         *
         * The attempt to match `')'` will fail when it sees `';'` and
         * call {@link #recoverInline}. To recover, it sees that `LA(1)==';'`
         * is in the set of tokens that can follow the `')'` token reference
         * in rule `atom`. It can assume that you forgot the `')'`.
         */
        recoverInline(recognizer) {
          let matchedSymbol = this.singleTokenDeletion(recognizer);
          if (matchedSymbol) {
            recognizer.consume();
            return matchedSymbol;
          }
          if (this.singleTokenInsertion(recognizer)) {
            return this.getMissingSymbol(recognizer);
          }
          if (this.nextTokensContext === void 0) {
            throw new InputMismatchException_1.InputMismatchException(recognizer);
          } else {
            throw new InputMismatchException_1.InputMismatchException(recognizer, this.nextTokensState, this.nextTokensContext);
          }
        }
        /**
         * This method implements the single-token insertion inline error recovery
         * strategy. It is called by {@link #recoverInline} if the single-token
         * deletion strategy fails to recover from the mismatched input. If this
         * method returns `true`, `recognizer` will be in error recovery
         * mode.
         *
         * This method determines whether or not single-token insertion is viable by
         * checking if the `LA(1)` input symbol could be successfully matched
         * if it were instead the `LA(2)` symbol. If this method returns
         * `true`, the caller is responsible for creating and inserting a
         * token with the correct type to produce this behavior.
         *
         * @param recognizer the parser instance
         * @returns `true` if single-token insertion is a viable recovery
         * strategy for the current mismatched input, otherwise `false`
         */
        singleTokenInsertion(recognizer) {
          let currentSymbolType = recognizer.inputStream.LA(1);
          let currentState = recognizer.interpreter.atn.states[recognizer.state];
          let next = currentState.transition(0).target;
          let atn = recognizer.interpreter.atn;
          let expectingAtLL2 = atn.nextTokens(next, PredictionContext_1.PredictionContext.fromRuleContext(atn, recognizer.context));
          if (expectingAtLL2.contains(currentSymbolType)) {
            this.reportMissingToken(recognizer);
            return true;
          }
          return false;
        }
        /**
         * This method implements the single-token deletion inline error recovery
         * strategy. It is called by {@link #recoverInline} to attempt to recover
         * from mismatched input. If this method returns `undefined`, the parser and error
         * handler state will not have changed. If this method returns non-`undefined`,
         * `recognizer` will *not* be in error recovery mode since the
         * returned token was a successful match.
         *
         * If the single-token deletion is successful, this method calls
         * {@link #reportUnwantedToken} to report the error, followed by
         * {@link Parser#consume} to actually "delete" the extraneous token. Then,
         * before returning {@link #reportMatch} is called to signal a successful
         * match.
         *
         * @param recognizer the parser instance
         * @returns the successfully matched {@link Token} instance if single-token
         * deletion successfully recovers from the mismatched input, otherwise
         * `undefined`
         */
        singleTokenDeletion(recognizer) {
          let nextTokenType = recognizer.inputStream.LA(2);
          let expecting = this.getExpectedTokens(recognizer);
          if (expecting.contains(nextTokenType)) {
            this.reportUnwantedToken(recognizer);
            recognizer.consume();
            let matchedSymbol = recognizer.currentToken;
            this.reportMatch(recognizer);
            return matchedSymbol;
          }
          return void 0;
        }
        /** Conjure up a missing token during error recovery.
         *
         *  The recognizer attempts to recover from single missing
         *  symbols. But, actions might refer to that missing symbol.
         *  For example, x=ID {f($x);}. The action clearly assumes
         *  that there has been an identifier matched previously and that
         *  $x points at that token. If that token is missing, but
         *  the next token in the stream is what we want we assume that
         *  this token is missing and we keep going. Because we
         *  have to return some token to replace the missing token,
         *  we have to conjure one up. This method gives the user control
         *  over the tokens returned for missing tokens. Mostly,
         *  you will want to create something special for identifier
         *  tokens. For literals such as '{' and ',', the default
         *  action in the parser or tree parser works. It simply creates
         *  a CommonToken of the appropriate type. The text will be the token.
         *  If you change what tokens must be created by the lexer,
         *  override this method to create the appropriate tokens.
         */
        getMissingSymbol(recognizer) {
          let currentSymbol = recognizer.currentToken;
          let expecting = this.getExpectedTokens(recognizer);
          let expectedTokenType = Token_1.Token.INVALID_TYPE;
          if (!expecting.isNil) {
            expectedTokenType = expecting.minElement;
          }
          let tokenText;
          if (expectedTokenType === Token_1.Token.EOF) {
            tokenText = "<missing EOF>";
          } else {
            tokenText = "<missing " + recognizer.vocabulary.getDisplayName(expectedTokenType) + ">";
          }
          let current = currentSymbol;
          let lookback = recognizer.inputStream.tryLT(-1);
          if (current.type === Token_1.Token.EOF && lookback != null) {
            current = lookback;
          }
          return this.constructToken(recognizer.inputStream.tokenSource, expectedTokenType, tokenText, current);
        }
        constructToken(tokenSource, expectedTokenType, tokenText, current) {
          let factory = tokenSource.tokenFactory;
          let x = current.tokenSource;
          let stream = x ? x.inputStream : void 0;
          return factory.create({ source: tokenSource, stream }, expectedTokenType, tokenText, Token_1.Token.DEFAULT_CHANNEL, -1, -1, current.line, current.charPositionInLine);
        }
        getExpectedTokens(recognizer) {
          return recognizer.getExpectedTokens();
        }
        /** How should a token be displayed in an error message? The default
         *  is to display just the text, but during development you might
         *  want to have a lot of information spit out.  Override in that case
         *  to use t.toString() (which, for CommonToken, dumps everything about
         *  the token). This is better than forcing you to override a method in
         *  your token objects because you don't have to go modify your lexer
         *  so that it creates a new Java type.
         */
        getTokenErrorDisplay(t) {
          if (!t) {
            return "<no token>";
          }
          let s = this.getSymbolText(t);
          if (!s) {
            if (this.getSymbolType(t) === Token_1.Token.EOF) {
              s = "<EOF>";
            } else {
              s = `<${this.getSymbolType(t)}>`;
            }
          }
          return this.escapeWSAndQuote(s);
        }
        getSymbolText(symbol2) {
          return symbol2.text;
        }
        getSymbolType(symbol2) {
          return symbol2.type;
        }
        escapeWSAndQuote(s) {
          s = s.replace("\n", "\\n");
          s = s.replace("\r", "\\r");
          s = s.replace("	", "\\t");
          return "'" + s + "'";
        }
        /*  Compute the error recovery set for the current rule.  During
         *  rule invocation, the parser pushes the set of tokens that can
         *  follow that rule reference on the stack; this amounts to
         *  computing FIRST of what follows the rule reference in the
         *  enclosing rule. See LinearApproximator.FIRST().
         *  This local follow set only includes tokens
         *  from within the rule; i.e., the FIRST computation done by
         *  ANTLR stops at the end of a rule.
         *
         *  EXAMPLE
         *
         *  When you find a "no viable alt exception", the input is not
         *  consistent with any of the alternatives for rule r.  The best
         *  thing to do is to consume tokens until you see something that
         *  can legally follow a call to r *or* any rule that called r.
         *  You don't want the exact set of viable next tokens because the
         *  input might just be missing a token--you might consume the
         *  rest of the input looking for one of the missing tokens.
         *
         *  Consider grammar:
         *
         *  a : '[' b ']'
         *    | '(' b ')'
         *    ;
         *  b : c '^' INT ;
         *  c : ID
         *    | INT
         *    ;
         *
         *  At each rule invocation, the set of tokens that could follow
         *  that rule is pushed on a stack.  Here are the various
         *  context-sensitive follow sets:
         *
         *  FOLLOW(b1_in_a) = FIRST(']') = ']'
         *  FOLLOW(b2_in_a) = FIRST(')') = ')'
         *  FOLLOW(c_in_b) = FIRST('^') = '^'
         *
         *  Upon erroneous input "[]", the call chain is
         *
         *  a -> b -> c
         *
         *  and, hence, the follow context stack is:
         *
         *  depth     follow set       start of rule execution
         *    0         <EOF>                    a (from main())
         *    1          ']'                     b
         *    2          '^'                     c
         *
         *  Notice that ')' is not included, because b would have to have
         *  been called from a different context in rule a for ')' to be
         *  included.
         *
         *  For error recovery, we cannot consider FOLLOW(c)
         *  (context-sensitive or otherwise).  We need the combined set of
         *  all context-sensitive FOLLOW sets--the set of all tokens that
         *  could follow any reference in the call chain.  We need to
         *  resync to one of those tokens.  Note that FOLLOW(c)='^' and if
         *  we resync'd to that token, we'd consume until EOF.  We need to
         *  sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
         *  In this case, for input "[]", LA(1) is ']' and in the set, so we would
         *  not consume anything. After printing an error, rule c would
         *  return normally.  Rule b would not find the required '^' though.
         *  At this point, it gets a mismatched token error and
         *  exception (since LA(1) is not in the viable following token
         *  set).  The rule exception handler tries to recover, but finds
         *  the same recovery set and doesn't consume anything.  Rule b
         *  exits normally returning to rule a.  Now it finds the ']' (and
         *  with the successful match exits errorRecovery mode).
         *
         *  So, you can see that the parser walks up the call chain looking
         *  for the token that was a member of the recovery set.
         *
         *  Errors are not generated in errorRecovery mode.
         *
         *  ANTLR's error recovery mechanism is based upon original ideas:
         *
         *  "Algorithms + Data Structures = Programs" by Niklaus Wirth
         *
         *  and
         *
         *  "A note on error recovery in recursive descent parsers":
         *  http://portal.acm.org/citation.cfm?id=947902.947905
         *
         *  Later, Josef Grosch had some good ideas:
         *
         *  "Efficient and Comfortable Error Recovery in Recursive Descent
         *  Parsers":
         *  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
         *
         *  Like Grosch I implement context-sensitive FOLLOW sets that are combined
         *  at run-time upon error to avoid overhead during parsing.
         */
        getErrorRecoverySet(recognizer) {
          let atn = recognizer.interpreter.atn;
          let ctx = recognizer.context;
          let recoverSet = new IntervalSet_1.IntervalSet();
          while (ctx && ctx.invokingState >= 0) {
            let invokingState = atn.states[ctx.invokingState];
            let rt = invokingState.transition(0);
            let follow = atn.nextTokens(rt.followState);
            recoverSet.addAll(follow);
            ctx = ctx._parent;
          }
          recoverSet.remove(Token_1.Token.EPSILON);
          return recoverSet;
        }
        /** Consume tokens until one matches the given token set. */
        consumeUntil(recognizer, set2) {
          let ttype = recognizer.inputStream.LA(1);
          while (ttype !== Token_1.Token.EOF && !set2.contains(ttype)) {
            recognizer.consume();
            ttype = recognizer.inputStream.LA(1);
          }
        }
      };
      __decorate([
        Decorators_1.Override
      ], DefaultErrorStrategy.prototype, "reset", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "beginErrorCondition", null);
      __decorate([
        Decorators_1.Override
      ], DefaultErrorStrategy.prototype, "inErrorRecoveryMode", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "endErrorCondition", null);
      __decorate([
        Decorators_1.Override
      ], DefaultErrorStrategy.prototype, "reportMatch", null);
      __decorate([
        Decorators_1.Override
      ], DefaultErrorStrategy.prototype, "reportError", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "notifyErrorListeners", null);
      __decorate([
        Decorators_1.Override
      ], DefaultErrorStrategy.prototype, "recover", null);
      __decorate([
        Decorators_1.Override
      ], DefaultErrorStrategy.prototype, "sync", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "reportNoViableAlternative", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "reportInputMismatch", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "reportFailedPredicate", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "reportUnwantedToken", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "reportMissingToken", null);
      __decorate([
        Decorators_1.Override
      ], DefaultErrorStrategy.prototype, "recoverInline", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "singleTokenInsertion", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "singleTokenDeletion", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "getMissingSymbol", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "getExpectedTokens", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "getSymbolText", null);
      __decorate([
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "getSymbolType", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "escapeWSAndQuote", null);
      __decorate([
        Decorators_1.NotNull,
        __param(0, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "getErrorRecoverySet", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], DefaultErrorStrategy.prototype, "consumeUntil", null);
      exports.DefaultErrorStrategy = DefaultErrorStrategy;
    }
  });

  // node_modules/antlr4ts/BailErrorStrategy.js
  var require_BailErrorStrategy = __commonJS({
    "node_modules/antlr4ts/BailErrorStrategy.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BailErrorStrategy = void 0;
      var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();
      var InputMismatchException_1 = require_InputMismatchException();
      var Decorators_1 = require_Decorators();
      var ParseCancellationException_1 = require_ParseCancellationException();
      var BailErrorStrategy = class extends DefaultErrorStrategy_1.DefaultErrorStrategy {
        /** Instead of recovering from exception `e`, re-throw it wrapped
         *  in a {@link ParseCancellationException} so it is not caught by the
         *  rule function catches.  Use {@link Exception#getCause()} to get the
         *  original {@link RecognitionException}.
         */
        recover(recognizer, e) {
          for (let context = recognizer.context; context; context = context.parent) {
            context.exception = e;
          }
          throw new ParseCancellationException_1.ParseCancellationException(e);
        }
        /** Make sure we don't attempt to recover inline; if the parser
         *  successfully recovers, it won't throw an exception.
         */
        recoverInline(recognizer) {
          let e = new InputMismatchException_1.InputMismatchException(recognizer);
          for (let context = recognizer.context; context; context = context.parent) {
            context.exception = e;
          }
          throw new ParseCancellationException_1.ParseCancellationException(e);
        }
        /** Make sure we don't attempt to recover from problems in subrules. */
        sync(recognizer) {
        }
      };
      __decorate([
        Decorators_1.Override
      ], BailErrorStrategy.prototype, "recover", null);
      __decorate([
        Decorators_1.Override
      ], BailErrorStrategy.prototype, "recoverInline", null);
      __decorate([
        Decorators_1.Override
      ], BailErrorStrategy.prototype, "sync", null);
      exports.BailErrorStrategy = BailErrorStrategy;
    }
  });

  // node_modules/antlr4ts/CharStream.js
  var require_CharStream = __commonJS({
    "node_modules/antlr4ts/CharStream.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/antlr4ts/Dependents.js
  var require_Dependents = __commonJS({
    "node_modules/antlr4ts/Dependents.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Dependents = void 0;
      var Dependents;
      (function(Dependents2) {
        Dependents2[Dependents2["SELF"] = 0] = "SELF";
        Dependents2[Dependents2["PARENTS"] = 1] = "PARENTS";
        Dependents2[Dependents2["CHILDREN"] = 2] = "CHILDREN";
        Dependents2[Dependents2["ANCESTORS"] = 3] = "ANCESTORS";
        Dependents2[Dependents2["DESCENDANTS"] = 4] = "DESCENDANTS";
        Dependents2[Dependents2["SIBLINGS"] = 5] = "SIBLINGS";
        Dependents2[Dependents2["PRECEEDING_SIBLINGS"] = 6] = "PRECEEDING_SIBLINGS";
        Dependents2[Dependents2["FOLLOWING_SIBLINGS"] = 7] = "FOLLOWING_SIBLINGS";
        Dependents2[Dependents2["PRECEEDING"] = 8] = "PRECEEDING";
        Dependents2[Dependents2["FOLLOWING"] = 9] = "FOLLOWING";
      })(Dependents = exports.Dependents || (exports.Dependents = {}));
    }
  });

  // node_modules/antlr4ts/DiagnosticErrorListener.js
  var require_DiagnosticErrorListener = __commonJS({
    "node_modules/antlr4ts/DiagnosticErrorListener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiagnosticErrorListener = void 0;
      var BitSet_1 = require_BitSet();
      var Decorators_1 = require_Decorators();
      var Interval_1 = require_Interval();
      var DiagnosticErrorListener = class {
        /**
         * Initializes a new instance of {@link DiagnosticErrorListener}, specifying
         * whether all ambiguities or only exact ambiguities are reported.
         *
         * @param exactOnly `true` to report only exact ambiguities, otherwise
         * `false` to report all ambiguities.  Defaults to true.
         */
        constructor(exactOnly = true) {
          this.exactOnly = exactOnly;
          this.exactOnly = exactOnly;
        }
        syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
        }
        reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
          if (this.exactOnly && !exact) {
            return;
          }
          let decision = this.getDecisionDescription(recognizer, dfa);
          let conflictingAlts = this.getConflictingAlts(ambigAlts, configs);
          let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
          let message = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text}'`;
          recognizer.notifyErrorListeners(message);
        }
        reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
          let format = "reportAttemptingFullContext d=%s, input='%s'";
          let decision = this.getDecisionDescription(recognizer, dfa);
          let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
          let message = `reportAttemptingFullContext d=${decision}, input='${text}'`;
          recognizer.notifyErrorListeners(message);
        }
        reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
          let format = "reportContextSensitivity d=%s, input='%s'";
          let decision = this.getDecisionDescription(recognizer, dfa);
          let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
          let message = `reportContextSensitivity d=${decision}, input='${text}'`;
          recognizer.notifyErrorListeners(message);
        }
        getDecisionDescription(recognizer, dfa) {
          let decision = dfa.decision;
          let ruleIndex = dfa.atnStartState.ruleIndex;
          let ruleNames = recognizer.ruleNames;
          if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
            return decision.toString();
          }
          let ruleName = ruleNames[ruleIndex];
          if (!ruleName) {
            return decision.toString();
          }
          return `${decision} (${ruleName})`;
        }
        /**
         * Computes the set of conflicting or ambiguous alternatives from a
         * configuration set, if that information was not already provided by the
         * parser.
         *
         * @param reportedAlts The set of conflicting or ambiguous alternatives, as
         * reported by the parser.
         * @param configs The conflicting or ambiguous configuration set.
         * @returns Returns `reportedAlts` if it is not `undefined`, otherwise
         * returns the set of alternatives represented in `configs`.
         */
        getConflictingAlts(reportedAlts, configs) {
          if (reportedAlts != null) {
            return reportedAlts;
          }
          let result = new BitSet_1.BitSet();
          for (let config2 of configs) {
            result.set(config2.alt);
          }
          return result;
        }
      };
      __decorate([
        Decorators_1.Override
      ], DiagnosticErrorListener.prototype, "syntaxError", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(6, Decorators_1.NotNull)
      ], DiagnosticErrorListener.prototype, "reportAmbiguity", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(5, Decorators_1.NotNull)
      ], DiagnosticErrorListener.prototype, "reportAttemptingFullContext", null);
      __decorate([
        Decorators_1.Override,
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull),
        __param(5, Decorators_1.NotNull)
      ], DiagnosticErrorListener.prototype, "reportContextSensitivity", null);
      __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], DiagnosticErrorListener.prototype, "getDecisionDescription", null);
      __decorate([
        Decorators_1.NotNull,
        __param(1, Decorators_1.NotNull)
      ], DiagnosticErrorListener.prototype, "getConflictingAlts", null);
      exports.DiagnosticErrorListener = DiagnosticErrorListener;
    }
  });

  // node_modules/antlr4ts/LexerInterpreter.js
  var require_LexerInterpreter = __commonJS({
    "node_modules/antlr4ts/LexerInterpreter.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexerInterpreter = void 0;
      var Lexer_1 = require_Lexer();
      var LexerATNSimulator_1 = require_LexerATNSimulator();
      var Decorators_1 = require_Decorators();
      var Decorators_2 = require_Decorators();
      var LexerInterpreter = class LexerInterpreter extends Lexer_1.Lexer {
        constructor(grammarFileName, vocabulary, ruleNames, channelNames, modeNames, atn, input) {
          super(input);
          if (atn.grammarType !== 0) {
            throw new Error("IllegalArgumentException: The ATN must be a lexer ATN.");
          }
          this._grammarFileName = grammarFileName;
          this._atn = atn;
          this._ruleNames = ruleNames.slice(0);
          this._channelNames = channelNames.slice(0);
          this._modeNames = modeNames.slice(0);
          this._vocabulary = vocabulary;
          this._interp = new LexerATNSimulator_1.LexerATNSimulator(atn, this);
        }
        get atn() {
          return this._atn;
        }
        get grammarFileName() {
          return this._grammarFileName;
        }
        get ruleNames() {
          return this._ruleNames;
        }
        get channelNames() {
          return this._channelNames;
        }
        get modeNames() {
          return this._modeNames;
        }
        get vocabulary() {
          return this._vocabulary;
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], LexerInterpreter.prototype, "_vocabulary", void 0);
      __decorate([
        Decorators_2.Override
      ], LexerInterpreter.prototype, "atn", null);
      __decorate([
        Decorators_2.Override
      ], LexerInterpreter.prototype, "grammarFileName", null);
      __decorate([
        Decorators_2.Override
      ], LexerInterpreter.prototype, "ruleNames", null);
      __decorate([
        Decorators_2.Override
      ], LexerInterpreter.prototype, "channelNames", null);
      __decorate([
        Decorators_2.Override
      ], LexerInterpreter.prototype, "modeNames", null);
      __decorate([
        Decorators_2.Override
      ], LexerInterpreter.prototype, "vocabulary", null);
      LexerInterpreter = __decorate([
        __param(1, Decorators_1.NotNull)
      ], LexerInterpreter);
      exports.LexerInterpreter = LexerInterpreter;
    }
  });

  // node_modules/antlr4ts/ParserErrorListener.js
  var require_ParserErrorListener = __commonJS({
    "node_modules/antlr4ts/ParserErrorListener.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/antlr4ts/RuleContextWithAltNum.js
  var require_RuleContextWithAltNum = __commonJS({
    "node_modules/antlr4ts/RuleContextWithAltNum.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleContextWithAltNum = void 0;
      var ATN_1 = require_ATN();
      var Decorators_1 = require_Decorators();
      var ParserRuleContext_1 = require_ParserRuleContext();
      var RuleContextWithAltNum = class extends ParserRuleContext_1.ParserRuleContext {
        constructor(parent, invokingStateNumber) {
          if (invokingStateNumber !== void 0) {
            super(parent, invokingStateNumber);
          } else {
            super();
          }
          this._altNumber = ATN_1.ATN.INVALID_ALT_NUMBER;
        }
        get altNumber() {
          return this._altNumber;
        }
        // @Override
        set altNumber(altNum) {
          this._altNumber = altNum;
        }
      };
      __decorate([
        Decorators_1.Override
      ], RuleContextWithAltNum.prototype, "altNumber", null);
      exports.RuleContextWithAltNum = RuleContextWithAltNum;
    }
  });

  // node_modules/antlr4ts/RuleDependency.js
  var require_RuleDependency = __commonJS({
    "node_modules/antlr4ts/RuleDependency.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleDependency = void 0;
      function RuleDependency(dependency) {
        return (target, propertyKey, propertyDescriptor) => {
        };
      }
      exports.RuleDependency = RuleDependency;
    }
  });

  // node_modules/antlr4ts/RuleVersion.js
  var require_RuleVersion = __commonJS({
    "node_modules/antlr4ts/RuleVersion.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleVersion = void 0;
      function RuleVersion(version2) {
        return (target, propertyKey, propertyDescriptor) => {
        };
      }
      exports.RuleVersion = RuleVersion;
    }
  });

  // node_modules/antlr4ts/TokenFactory.js
  var require_TokenFactory = __commonJS({
    "node_modules/antlr4ts/TokenFactory.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/antlr4ts/TokenSource.js
  var require_TokenSource = __commonJS({
    "node_modules/antlr4ts/TokenSource.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/antlr4ts/TokenStream.js
  var require_TokenStream = __commonJS({
    "node_modules/antlr4ts/TokenStream.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/antlr4ts/TokenStreamRewriter.js
  var require_TokenStreamRewriter = __commonJS({
    "node_modules/antlr4ts/TokenStreamRewriter.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RewriteOperation = exports.TokenStreamRewriter = void 0;
      var Interval_1 = require_Interval();
      var Decorators_1 = require_Decorators();
      var Token_1 = require_Token();
      var TokenStreamRewriter = class _TokenStreamRewriter {
        constructor(tokens) {
          this.tokens = tokens;
          this.programs = /* @__PURE__ */ new Map();
          this.programs.set(_TokenStreamRewriter.DEFAULT_PROGRAM_NAME, []);
          this.lastRewriteTokenIndexes = /* @__PURE__ */ new Map();
        }
        getTokenStream() {
          return this.tokens;
        }
        rollback(instructionIndex, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
          let is = this.programs.get(programName);
          if (is != null) {
            this.programs.set(programName, is.slice(_TokenStreamRewriter.MIN_TOKEN_INDEX, instructionIndex));
          }
        }
        deleteProgram(programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
          this.rollback(_TokenStreamRewriter.MIN_TOKEN_INDEX, programName);
        }
        insertAfter(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
          let index;
          if (typeof tokenOrIndex === "number") {
            index = tokenOrIndex;
          } else {
            index = tokenOrIndex.tokenIndex;
          }
          let rewrites = this.getProgram(programName);
          let op = new InsertAfterOp(this.tokens, index, rewrites.length, text);
          rewrites.push(op);
        }
        insertBefore(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
          let index;
          if (typeof tokenOrIndex === "number") {
            index = tokenOrIndex;
          } else {
            index = tokenOrIndex.tokenIndex;
          }
          let rewrites = this.getProgram(programName);
          let op = new InsertBeforeOp(this.tokens, index, rewrites.length, text);
          rewrites.push(op);
        }
        replaceSingle(index, text) {
          if (typeof index === "number") {
            this.replace(index, index, text);
          } else {
            this.replace(index, index, text);
          }
        }
        replace(from, to, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
          if (typeof from !== "number") {
            from = from.tokenIndex;
          }
          if (typeof to !== "number") {
            to = to.tokenIndex;
          }
          if (from > to || from < 0 || to < 0 || to >= this.tokens.size) {
            throw new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);
          }
          let rewrites = this.getProgram(programName);
          let op = new ReplaceOp(this.tokens, from, to, rewrites.length, text);
          rewrites.push(op);
        }
        delete(from, to, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
          if (to === void 0) {
            to = from;
          }
          if (typeof from === "number") {
            this.replace(from, to, "", programName);
          } else {
            this.replace(from, to, "", programName);
          }
        }
        getLastRewriteTokenIndex(programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
          let I = this.lastRewriteTokenIndexes.get(programName);
          if (I == null) {
            return -1;
          }
          return I;
        }
        setLastRewriteTokenIndex(programName, i) {
          this.lastRewriteTokenIndexes.set(programName, i);
        }
        getProgram(name) {
          let is = this.programs.get(name);
          if (is == null) {
            is = this.initializeProgram(name);
          }
          return is;
        }
        initializeProgram(name) {
          let is = [];
          this.programs.set(name, is);
          return is;
        }
        getText(intervalOrProgram, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
          let interval;
          if (intervalOrProgram instanceof Interval_1.Interval) {
            interval = intervalOrProgram;
          } else {
            interval = Interval_1.Interval.of(0, this.tokens.size - 1);
          }
          if (typeof intervalOrProgram === "string") {
            programName = intervalOrProgram;
          }
          let rewrites = this.programs.get(programName);
          let start = interval.a;
          let stop = interval.b;
          if (stop > this.tokens.size - 1) {
            stop = this.tokens.size - 1;
          }
          if (start < 0) {
            start = 0;
          }
          if (rewrites == null || rewrites.length === 0) {
            return this.tokens.getText(interval);
          }
          let buf = [];
          let indexToOp = this.reduceToSingleOperationPerIndex(rewrites);
          let i = start;
          while (i <= stop && i < this.tokens.size) {
            let op = indexToOp.get(i);
            indexToOp.delete(i);
            let t = this.tokens.get(i);
            if (op == null) {
              if (t.type !== Token_1.Token.EOF) {
                buf.push(String(t.text));
              }
              i++;
            } else {
              i = op.execute(buf);
            }
          }
          if (stop === this.tokens.size - 1) {
            for (let op of indexToOp.values()) {
              if (op.index >= this.tokens.size - 1) {
                buf.push(op.text.toString());
              }
            }
          }
          return buf.join("");
        }
        /** We need to combine operations and report invalid operations (like
         *  overlapping replaces that are not completed nested). Inserts to
         *  same index need to be combined etc...  Here are the cases:
         *
         *  I.i.u I.j.v								leave alone, nonoverlapping
         *  I.i.u I.i.v								combine: Iivu
         *
         *  R.i-j.u R.x-y.v	| i-j in x-y			delete first R
         *  R.i-j.u R.i-j.v							delete first R
         *  R.i-j.u R.x-y.v	| x-y in i-j			ERROR
         *  R.i-j.u R.x-y.v	| boundaries overlap	ERROR
         *
         *  Delete special case of replace (text==undefined):
         *  D.i-j.u D.x-y.v	| boundaries overlap	combine to max(min)..max(right)
         *
         *  I.i.u R.x-y.v | i in (x+1)-y			delete I (since insert before
         * 											we're not deleting i)
         *  I.i.u R.x-y.v | i not in (x+1)-y		leave alone, nonoverlapping
         *  R.x-y.v I.i.u | i in x-y				ERROR
         *  R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
         *  R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
         *
         *  I.i.u = insert u before op @ index i
         *  R.x-y.u = replace x-y indexed tokens with u
         *
         *  First we need to examine replaces. For any replace op:
         *
         * 		1. wipe out any insertions before op within that range.
         * 		2. Drop any replace op before that is contained completely within
         * 	 that range.
         * 		3. Throw exception upon boundary overlap with any previous replace.
         *
         *  Then we can deal with inserts:
         *
         * 		1. for any inserts to same index, combine even if not adjacent.
         * 		2. for any prior replace with same left boundary, combine this
         * 	 insert with replace and delete this replace.
         * 		3. throw exception if index in same range as previous replace
         *
         *  Don't actually delete; make op undefined in list. Easier to walk list.
         *  Later we can throw as we add to index &rarr; op map.
         *
         *  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
         *  inserted stuff would be before the replace range. But, if you
         *  add tokens in front of a method body '{' and then delete the method
         *  body, I think the stuff before the '{' you added should disappear too.
         *
         *  Return a map from token index to operation.
         */
        reduceToSingleOperationPerIndex(rewrites) {
          for (let i = 0; i < rewrites.length; i++) {
            let op = rewrites[i];
            if (op == null) {
              continue;
            }
            if (!(op instanceof ReplaceOp)) {
              continue;
            }
            let rop = op;
            let inserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
            for (let iop of inserts) {
              if (iop.index === rop.index) {
                rewrites[iop.instructionIndex] = void 0;
                rop.text = iop.text.toString() + (rop.text != null ? rop.text.toString() : "");
              } else if (iop.index > rop.index && iop.index <= rop.lastIndex) {
                rewrites[iop.instructionIndex] = void 0;
              }
            }
            let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
            for (let prevRop of prevReplaces) {
              if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {
                rewrites[prevRop.instructionIndex] = void 0;
                continue;
              }
              let disjoint = prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;
              if (prevRop.text == null && rop.text == null && !disjoint) {
                rewrites[prevRop.instructionIndex] = void 0;
                rop.index = Math.min(prevRop.index, rop.index);
                rop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);
              } else if (!disjoint) {
                throw new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);
              }
            }
          }
          for (let i = 0; i < rewrites.length; i++) {
            let op = rewrites[i];
            if (op == null) {
              continue;
            }
            if (!(op instanceof InsertBeforeOp)) {
              continue;
            }
            let iop = op;
            let prevInserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
            for (let prevIop of prevInserts) {
              if (prevIop.index === iop.index) {
                if (prevIop instanceof InsertAfterOp) {
                  iop.text = this.catOpText(prevIop.text, iop.text);
                  rewrites[prevIop.instructionIndex] = void 0;
                } else if (prevIop instanceof InsertBeforeOp) {
                  iop.text = this.catOpText(iop.text, prevIop.text);
                  rewrites[prevIop.instructionIndex] = void 0;
                }
              }
            }
            let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
            for (let rop of prevReplaces) {
              if (iop.index === rop.index) {
                rop.text = this.catOpText(iop.text, rop.text);
                rewrites[i] = void 0;
                continue;
              }
              if (iop.index >= rop.index && iop.index <= rop.lastIndex) {
                throw new Error(`insert op ${iop} within boundaries of previous ${rop}`);
              }
            }
          }
          let m = /* @__PURE__ */ new Map();
          for (let op of rewrites) {
            if (op == null) {
              continue;
            }
            if (m.get(op.index) != null) {
              throw new Error("should only be one op per index");
            }
            m.set(op.index, op);
          }
          return m;
        }
        catOpText(a, b) {
          let x = "";
          let y = "";
          if (a != null) {
            x = a.toString();
          }
          if (b != null) {
            y = b.toString();
          }
          return x + y;
        }
        /** Get all operations before an index of a particular kind */
        getKindOfOps(rewrites, kind, before) {
          let ops = [];
          for (let i = 0; i < before && i < rewrites.length; i++) {
            let op = rewrites[i];
            if (op == null) {
              continue;
            }
            if (op instanceof kind) {
              ops.push(op);
            }
          }
          return ops;
        }
      };
      exports.TokenStreamRewriter = TokenStreamRewriter;
      TokenStreamRewriter.DEFAULT_PROGRAM_NAME = "default";
      TokenStreamRewriter.PROGRAM_INIT_SIZE = 100;
      TokenStreamRewriter.MIN_TOKEN_INDEX = 0;
      var RewriteOperation = class {
        constructor(tokens, index, instructionIndex, text) {
          this.tokens = tokens;
          this.instructionIndex = instructionIndex;
          this.index = index;
          this.text = text === void 0 ? "" : text;
        }
        /** Execute the rewrite operation by possibly adding to the buffer.
         *  Return the index of the next token to operate on.
         */
        execute(buf) {
          return this.index;
        }
        toString() {
          let opName = this.constructor.name;
          let $index = opName.indexOf("$");
          opName = opName.substring($index + 1, opName.length);
          return "<" + opName + "@" + this.tokens.get(this.index) + ':"' + this.text + '">';
        }
      };
      __decorate([
        Decorators_1.Override
      ], RewriteOperation.prototype, "toString", null);
      exports.RewriteOperation = RewriteOperation;
      var InsertBeforeOp = class extends RewriteOperation {
        constructor(tokens, index, instructionIndex, text) {
          super(tokens, index, instructionIndex, text);
        }
        execute(buf) {
          buf.push(this.text.toString());
          if (this.tokens.get(this.index).type !== Token_1.Token.EOF) {
            buf.push(String(this.tokens.get(this.index).text));
          }
          return this.index + 1;
        }
      };
      __decorate([
        Decorators_1.Override
      ], InsertBeforeOp.prototype, "execute", null);
      var InsertAfterOp = class extends InsertBeforeOp {
        constructor(tokens, index, instructionIndex, text) {
          super(tokens, index + 1, instructionIndex, text);
        }
      };
      var ReplaceOp = class extends RewriteOperation {
        constructor(tokens, from, to, instructionIndex, text) {
          super(tokens, from, instructionIndex, text);
          this.lastIndex = to;
        }
        execute(buf) {
          if (this.text != null) {
            buf.push(this.text.toString());
          }
          return this.lastIndex + 1;
        }
        toString() {
          if (this.text == null) {
            return "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">";
          }
          return "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ':"' + this.text + '">';
        }
      };
      __decorate([
        Decorators_1.Override
      ], ReplaceOp.prototype, "execute", null);
      __decorate([
        Decorators_1.Override
      ], ReplaceOp.prototype, "toString", null);
    }
  });

  // node_modules/antlr4ts/Vocabulary.js
  var require_Vocabulary = __commonJS({
    "node_modules/antlr4ts/Vocabulary.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/antlr4ts/WritableToken.js
  var require_WritableToken = __commonJS({
    "node_modules/antlr4ts/WritableToken.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/antlr4ts/index.js
  var require_antlr4ts = __commonJS({
    "node_modules/antlr4ts/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_ANTLRErrorListener(), exports);
      __exportStar(require_ANTLRErrorStrategy(), exports);
      __exportStar(require_ANTLRInputStream(), exports);
      __exportStar(require_BailErrorStrategy(), exports);
      __exportStar(require_BufferedTokenStream(), exports);
      __exportStar(require_CharStream(), exports);
      __exportStar(require_CharStreams(), exports);
      __exportStar(require_CodePointBuffer(), exports);
      __exportStar(require_CodePointCharStream(), exports);
      __exportStar(require_CommonToken(), exports);
      __exportStar(require_CommonTokenFactory(), exports);
      __exportStar(require_CommonTokenStream(), exports);
      __exportStar(require_ConsoleErrorListener(), exports);
      __exportStar(require_DefaultErrorStrategy(), exports);
      __exportStar(require_Dependents(), exports);
      __exportStar(require_DiagnosticErrorListener(), exports);
      __exportStar(require_FailedPredicateException(), exports);
      __exportStar(require_InputMismatchException(), exports);
      __exportStar(require_InterpreterRuleContext(), exports);
      __exportStar(require_IntStream(), exports);
      __exportStar(require_Lexer(), exports);
      __exportStar(require_LexerInterpreter(), exports);
      __exportStar(require_LexerNoViableAltException(), exports);
      __exportStar(require_ListTokenSource(), exports);
      __exportStar(require_NoViableAltException(), exports);
      __exportStar(require_Parser(), exports);
      __exportStar(require_ParserErrorListener(), exports);
      __exportStar(require_ParserInterpreter(), exports);
      __exportStar(require_ParserRuleContext(), exports);
      __exportStar(require_ProxyErrorListener(), exports);
      __exportStar(require_ProxyParserErrorListener(), exports);
      __exportStar(require_RecognitionException(), exports);
      __exportStar(require_Recognizer(), exports);
      __exportStar(require_RuleContext(), exports);
      __exportStar(require_RuleContextWithAltNum(), exports);
      __exportStar(require_RuleDependency(), exports);
      __exportStar(require_RuleVersion(), exports);
      __exportStar(require_Token(), exports);
      __exportStar(require_TokenFactory(), exports);
      __exportStar(require_TokenSource(), exports);
      __exportStar(require_TokenStream(), exports);
      __exportStar(require_TokenStreamRewriter(), exports);
      __exportStar(require_Vocabulary(), exports);
      __exportStar(require_VocabularyImpl(), exports);
      __exportStar(require_WritableToken(), exports);
    }
  });

  // node_modules/antlr4ts/tree/ParseTree.js
  var require_ParseTree = __commonJS({
    "node_modules/antlr4ts/tree/ParseTree.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // source/gcs.ts
  var TARGET_PATH = "/api/v1/vault/mapview/gcs";
  function normalizeUrl(url2) {
    try {
      return new URL(url2, location.origin);
    } catch {
      return null;
    }
  }
  function injectGcsListener(listener) {
    const origOpen = XMLHttpRequest.prototype.open;
    const origSend = XMLHttpRequest.prototype.send;
    const isTargetSymbol = /* @__PURE__ */ Symbol("_isTarget");
    const urlObjSymbol = /* @__PURE__ */ Symbol("_urlObj");
    XMLHttpRequest.prototype.open = function(method, url2, ...rest) {
      const urlObj = normalizeUrl(url2);
      this[isTargetSymbol] = method === "GET" && urlObj?.pathname === TARGET_PATH;
      this[urlObjSymbol] = urlObj;
      return origOpen.call(this, method, url2, ...rest);
    };
    XMLHttpRequest.prototype.send = function(...args) {
      if (this[isTargetSymbol]) {
        this.addEventListener("load", function() {
          try {
            const ct = this.getResponseHeader("content-type") || "";
            if (!ct.includes("application/json")) return;
            listener(this[urlObjSymbol], this.responseText);
          } catch (e) {
            console.warn("[GCS LOGGER] Parse failed", e);
          }
        });
      }
      return origSend.apply(this, args);
    };
  }

  // source/environments.ts
  function isWebWorker() {
    return typeof window === "undefined" && typeof self !== "undefined";
  }

  // source/dom-extensions.ts
  function createSchedulerByAnimationFrame(signal, thresholdMs) {
    let startTime = performance.now();
    let lastHandle = null;
    signal.addEventListener(
      "abort",
      () => {
        if (lastHandle != null) {
          cancelAnimationFrame(lastHandle);
          lastHandle = null;
        }
      },
      { once: true }
    );
    return {
      get isYieldRequested() {
        if (navigator.scheduling?.isInputPending?.()) {
          return true;
        }
        const now = performance.now();
        return now - startTime >= thresholdMs;
      },
      yield() {
        if (!this.isYieldRequested) return null;
        return new Promise((resolve) => {
          lastHandle = requestAnimationFrame(() => {
            startTime = performance.now();
            resolve();
          });
        });
      }
    };
  }
  function createWorkerScheduler() {
    return {
      isYieldRequested: false,
      yield() {
        return null;
      }
    };
  }
  function createScheduler(signal, thresholdMs = 10) {
    if (isWebWorker()) return createWorkerScheduler();
    return createSchedulerByAnimationFrame(signal, thresholdMs);
  }
  function styleSetter(cssText13) {
    let done2 = false;
    return () => {
      if (!done2) {
        done2 = true;
        const sheet = new CSSStyleSheet();
        sheet.replaceSync(cssText13);
        document.adoptedStyleSheets.push(sheet);
      }
    };
  }

  // source/geometry.ts
  function toLatLngLiteral(latLng) {
    return { lat: latLng.lat(), lng: latLng.lng() };
  }
  function distance({ lat: lat1, lng: lng1 }, { lat: lat2, lng: lng2 }) {
    const R = 6371e3;
    const rLat1 = lat1 * Math.PI / 180;
    const rLat2 = lat2 * Math.PI / 180;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = Math.sin(dLat / 2) ** 2 + Math.cos(rLat1) * Math.cos(rLat2) * Math.sin(dLng / 2) ** 2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }
  function distanceSquared(a, b) {
    const dLat = b.lat - a.lat;
    const dLng = b.lng - a.lng;
    return dLat * dLat + dLng * dLng;
  }
  function padBounds(bounds, ratio) {
    const sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), swLat = sw.lat(), swLng = sw.lng(), neLat = ne.lat(), neLng = ne.lng();
    const height = Math.abs(swLat - neLat) * ratio;
    const width = Math.abs(swLng - neLng) * ratio;
    return new google.maps.LatLngBounds(
      { lat: swLat - height, lng: swLng - width },
      { lat: neLat + height, lng: neLng + width }
    );
  }
  function parseCoordinates(coordinatesText) {
    const tokens = coordinatesText.split(",");
    const result = [];
    for (let i = 1; i < tokens.length; i += 2) {
      result.push({ lat: Number(tokens[i - 1]), lng: Number(tokens[i]) });
    }
    if (result.length === 0) {
      throw new Error();
    }
    return result;
  }
  function coordinatesToString(coords) {
    return coords.map((ll) => `${ll.lat},${ll.lng}`).join(",");
  }

  // source/bounds.ts
  function createDefault() {
    return {
      sw: { lat: Infinity, lng: Infinity },
      ne: { lat: -Infinity, lng: -Infinity }
    };
  }
  function fromSwNeLatLng(swLat, swLng, neLat, neLng) {
    return {
      sw: { lat: swLat, lng: swLng },
      ne: { lat: neLat, lng: neLng }
    };
  }
  function getCenter(bounds) {
    return {
      lat: (bounds.sw.lat + bounds.ne.lat) / 2,
      lng: (bounds.sw.lng + bounds.ne.lng) / 2
    };
  }
  function toExtended(bounds, point) {
    return {
      sw: {
        lat: Math.min(bounds.sw.lat, point.lat),
        lng: Math.min(bounds.sw.lng, point.lng)
      },
      ne: {
        lat: Math.max(bounds.ne.lat, point.lat),
        lng: Math.max(bounds.ne.lng, point.lng)
      }
    };
  }
  function intersects(bounds, other) {
    return bounds.sw.lat <= other.ne.lat && bounds.ne.lat >= other.sw.lat && bounds.sw.lng <= other.ne.lng && bounds.ne.lng >= other.sw.lng;
  }
  function fromClass(object2) {
    const sw = object2.getSouthWest();
    const ne = object2.getNorthEast();
    return fromSwNeLatLng(sw.lat(), sw.lng(), ne.lat(), ne.lng());
  }

  // source/standard-extensions.ts
  function id(value) {
    return value;
  }
  function ignore(..._) {
  }
  function withTag(value) {
    return value;
  }
  async function awaitElement(get, options) {
    let currentInterval = 100;
    const maxInterval = 500;
    while (true) {
      const ref = get();
      if (ref) return ref;
      await sleep(Math.min(currentInterval *= 2, maxInterval), options);
    }
  }
  function sleep(ms, options) {
    return new Promise((resolve, reject) => {
      const signal = options?.signal;
      if (signal?.aborted) return reject(signal.reason);
      const handle = setTimeout(() => {
        cleanup();
        resolve();
      }, ms);
      function onAbort() {
        cleanup();
        queueMicrotask(
          () => reject(signal == null ? newAbortError() : signal.reason)
        );
      }
      function cleanup() {
        clearTimeout(handle);
        signal?.removeEventListener("abort", onAbort);
      }
      signal?.addEventListener("abort", onAbort);
    });
  }
  function raise(templateStringsArray, ...substitutions) {
    throw new Error(String.raw(templateStringsArray, ...substitutions));
  }
  var AbortError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "AbortError";
    }
  };
  function newAbortError(message = "The operation was aborted.") {
    if (typeof DOMException === "function") {
      return new DOMException(message, "AbortError");
    } else {
      return new AbortError(message);
    }
  }
  function isAbortError(e) {
    return e != null && typeof e === "object" && "name" in e && e.name === "AbortError";
  }
  function createAsyncCancelScope(onError) {
    let activeController;
    return (process3) => {
      activeController?.abort(newAbortError());
      activeController = new AbortController();
      process3(activeController.signal).catch((e) => {
        if (isAbortError(e)) return;
        onError(e);
      });
    };
  }
  function cached(f) {
    let hasValue = false;
    let value;
    return () => {
      if (!hasValue) {
        hasValue = true;
        value = f();
      }
      return value;
    };
  }
  function memoizeWith(getKey, f) {
    const memo = /* @__PURE__ */ new Map();
    return (...x) => {
      const k = getKey(...x);
      let r = memo.get(k);
      if (r === void 0) {
        r = f(k, ...x);
        memo.set(k, r);
      }
      return r;
    };
  }

  // source/typed-idb.ts
  function defineDatabase(database, schema) {
    for (const [storeName, storeSchema] of Object.entries(schema)) {
      const store = database.createObjectStore(storeName, {
        keyPath: storeSchema.key.slice()
      });
      for (const [indexName, options] of Object.entries(
        storeSchema.indexes
      )) {
        store.createIndex(indexName, options.key, options);
      }
    }
  }
  function openDatabase(databaseName2, databaseVersion2, databaseSchema2) {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(databaseName2, databaseVersion2);
      request.addEventListener(
        "upgradeneeded",
        () => defineDatabase(request.result, databaseSchema2)
      );
      request.addEventListener(
        "blocked",
        () => reject(new Error("database blocked"))
      );
      request.addEventListener("error", () => reject(request.error));
      request.addEventListener(
        "success",
        () => resolve(withTag(request.result))
      );
    });
  }
  var IterateValuesRequest = class {
    constructor(source, query, action) {
      this.source = source;
      this.query = query;
      this.action = action;
    }
  };
  function enterTransactionScope(database, {
    mode,
    signal
  }, scope, ...storeNames) {
    return new Promise((resolve, reject) => {
      if (signal?.aborted) {
        reject(newAbortError());
        return;
      }
      let hasResult = false;
      let result;
      const transaction = database.transaction(storeNames, mode);
      const onAbort = signal ? () => {
        if (!hasResult) {
          transaction.abort();
        }
      } : ignore;
      transaction.addEventListener("complete", () => {
        signal?.removeEventListener("abort", onAbort);
        if (hasResult) {
          resolve(result);
        } else {
          reject(new Error(`internal error`));
        }
      });
      transaction.addEventListener("error", (e) => {
        signal?.removeEventListener("abort", onAbort);
        reject(e.target.error);
      });
      signal?.addEventListener("abort", onAbort);
      const stores = {};
      for (const name of storeNames) {
        stores[name] = withTag(transaction.objectStore(name));
      }
      const iterator = scope(
        stores
      );
      let stateKind;
      let request_request;
      let waitRequests_results;
      let waitRequests_requests;
      let openCursor_request;
      let openCursor_action;
      function onResolved() {
        let r;
        switch (stateKind) {
          case void 0:
            r = iterator.next();
            break;
          case "Request": {
            const result2 = request_request.result;
            stateKind = void 0;
            request_request = void 0;
            r = iterator.next(result2);
            break;
          }
          case "WaitRequests": {
            const results = waitRequests_results;
            const requests = waitRequests_requests;
            const result2 = requests[results.length].result;
            results.push(result2);
            if (results.length !== requests.length) return;
            stateKind = void 0;
            waitRequests_requests = void 0;
            waitRequests_results = void 0;
            r = iterator.next(results);
            break;
          }
          case "OpenCursor": {
            const cursor = openCursor_request.result;
            if (cursor === null || openCursor_action(cursor.value) === "break") {
              stateKind = void 0;
              openCursor_request = void 0;
              openCursor_action = void 0;
              r = iterator.next(void 0);
            } else {
              cursor.continue();
              return;
            }
            break;
          }
          default: {
            reject(new Error(`Invalid resolving kind: ${stateKind}`));
            return;
          }
        }
        if (r.done) {
          hasResult = true;
          result = r.value;
          return;
        }
        const yieldValue = r.value;
        if (yieldValue instanceof IDBRequest) {
          stateKind = "Request";
          request_request = yieldValue;
          yieldValue.onsuccess = onResolved;
          return;
        }
        if (yieldValue instanceof IterateValuesRequest) {
          stateKind = "OpenCursor";
          openCursor_request = yieldValue.source.openCursor(
            yieldValue.query
          );
          openCursor_action = yieldValue.action;
          openCursor_request.onsuccess = onResolved;
          return;
        }
        stateKind = "WaitRequests";
        waitRequests_requests = yieldValue;
        waitRequests_results = [];
        for (const request of yieldValue) {
          request.onsuccess = onResolved;
        }
        return;
      }
      onResolved();
    });
  }
  function getIndex(store, indexName) {
    return withTag(store.index(indexName));
  }
  function* iterateValuesOfIndex(index, query, action) {
    yield new IterateValuesRequest(index, query, action);
    return;
  }

  // source/s2.ts
  function exposeS2Module(exports) {
    "use strict";
    var S22 = exports.S2 = {
      L: {}
    };
    S22.L.LatLng = function(rawLat, rawLng, noWrap) {
      var lat = parseFloat(rawLat, 10);
      var lng = parseFloat(rawLng, 10);
      if (isNaN(lat) || isNaN(lng)) {
        throw new Error(
          "Invalid LatLng object: (" + rawLat + ", " + rawLng + ")"
        );
      }
      if (noWrap !== true) {
        lat = Math.max(Math.min(lat, 90), -90);
        lng = (lng + 180) % 360 + (lng < -180 || lng === 180 ? 180 : -180);
      }
      return {
        lat,
        lng
      };
    };
    S22.L.LatLng.DEG_TO_RAD = Math.PI / 180;
    S22.L.LatLng.RAD_TO_DEG = 180 / Math.PI;
    S22.LatLngToXYZ = function(latLng) {
      var d2r = S22.L.LatLng.DEG_TO_RAD;
      var phi = latLng.lat * d2r;
      var theta = latLng.lng * d2r;
      var cosphi = Math.cos(phi);
      return [
        Math.cos(theta) * cosphi,
        Math.sin(theta) * cosphi,
        Math.sin(phi)
      ];
    };
    S22.XYZToLatLng = function(xyz) {
      var r2d = S22.L.LatLng.RAD_TO_DEG;
      var lat = Math.atan2(
        xyz[2],
        Math.sqrt(xyz[0] * xyz[0] + xyz[1] * xyz[1])
      );
      var lng = Math.atan2(xyz[1], xyz[0]);
      return S22.L.LatLng(lat * r2d, lng * r2d);
    };
    var largestAbsComponent = function(xyz) {
      var temp = [Math.abs(xyz[0]), Math.abs(xyz[1]), Math.abs(xyz[2])];
      if (temp[0] > temp[1]) {
        if (temp[0] > temp[2]) {
          return 0;
        } else {
          return 2;
        }
      } else {
        if (temp[1] > temp[2]) {
          return 1;
        } else {
          return 2;
        }
      }
    };
    var faceXYZToUV = function(face, xyz) {
      var u, v;
      switch (face) {
        case 0:
          u = xyz[1] / xyz[0];
          v = xyz[2] / xyz[0];
          break;
        case 1:
          u = -xyz[0] / xyz[1];
          v = xyz[2] / xyz[1];
          break;
        case 2:
          u = -xyz[0] / xyz[2];
          v = -xyz[1] / xyz[2];
          break;
        case 3:
          u = xyz[2] / xyz[0];
          v = xyz[1] / xyz[0];
          break;
        case 4:
          u = xyz[2] / xyz[1];
          v = -xyz[0] / xyz[1];
          break;
        case 5:
          u = -xyz[1] / xyz[2];
          v = -xyz[0] / xyz[2];
          break;
        default:
          throw {
            error: "Invalid face"
          };
      }
      return [u, v];
    };
    S22.XYZToFaceUV = function(xyz) {
      var face = largestAbsComponent(xyz);
      if (xyz[face] < 0) {
        face += 3;
      }
      var uv = faceXYZToUV(face, xyz);
      return [face, uv];
    };
    S22.FaceUVToXYZ = function(face, uv) {
      var u = uv[0];
      var v = uv[1];
      switch (face) {
        case 0:
          return [1, u, v];
        case 1:
          return [-u, 1, v];
        case 2:
          return [-u, -v, 1];
        case 3:
          return [-1, -v, -u];
        case 4:
          return [v, -1, -u];
        case 5:
          return [v, u, -1];
        default:
          throw {
            error: "Invalid face"
          };
      }
    };
    var singleSTtoUV = function(st) {
      if (st >= 0.5) {
        return 1 / 3 * (4 * st * st - 1);
      } else {
        return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
      }
    };
    S22.STToUV = function(st) {
      return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];
    };
    var singleUVtoST = function(uv) {
      if (uv >= 0) {
        return 0.5 * Math.sqrt(1 + 3 * uv);
      } else {
        return 1 - 0.5 * Math.sqrt(1 - 3 * uv);
      }
    };
    S22.UVToST = function(uv) {
      return [singleUVtoST(uv[0]), singleUVtoST(uv[1])];
    };
    S22.STToIJ = function(st, order) {
      var maxSize = 1 << order;
      var singleSTtoIJ = function(st2) {
        var ij = Math.floor(st2 * maxSize);
        return Math.max(0, Math.min(maxSize - 1, ij));
      };
      return [singleSTtoIJ(st[0]), singleSTtoIJ(st[1])];
    };
    S22.IJToST = function(ij, order, offsets) {
      var maxSize = 1 << order;
      return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
    };
    var rotateAndFlipQuadrant = function(n, point, rx, ry) {
      var newX, newY;
      if (ry == 0) {
        if (rx == 1) {
          point.x = n - 1 - point.x;
          point.y = n - 1 - point.y;
        }
        var x = point.x;
        point.x = point.y;
        point.y = x;
      }
    };
    var pointToHilbertQuadList = function(x, y, order, face) {
      var hilbertMap = {
        a: [
          [0, "d"],
          [1, "a"],
          [3, "b"],
          [2, "a"]
        ],
        b: [
          [2, "b"],
          [1, "b"],
          [3, "a"],
          [0, "c"]
        ],
        c: [
          [2, "c"],
          [3, "d"],
          [1, "c"],
          [0, "b"]
        ],
        d: [
          [0, "a"],
          [3, "c"],
          [1, "d"],
          [2, "d"]
        ]
      };
      if ("number" !== typeof face) {
        console.warn(
          new Error(
            "called pointToHilbertQuadList without face value, defaulting to '0'"
          ).stack
        );
      }
      var currentSquare = face % 2 ? "d" : "a";
      var positions = [];
      for (var i = order - 1; i >= 0; i--) {
        var mask = 1 << i;
        var quad_x = x & mask ? 1 : 0;
        var quad_y = y & mask ? 1 : 0;
        var t = hilbertMap[currentSquare][quad_x * 2 + quad_y];
        positions.push(t[0]);
        currentSquare = t[1];
      }
      return positions;
    };
    S22.S2Cell = function() {
    };
    S22.S2Cell.FromHilbertQuadKey = function(hilbertQuadkey) {
      var parts = hilbertQuadkey.split("/");
      var face = parseInt(parts[0]);
      var position = parts[1];
      var maxLevel = position.length;
      var point = {
        x: 0,
        y: 0
      };
      var i;
      var level;
      var bit;
      var rx, ry;
      var val;
      for (i = maxLevel - 1; i >= 0; i--) {
        level = maxLevel - i;
        bit = position[i];
        rx = 0;
        ry = 0;
        if (bit === "1") {
          ry = 1;
        } else if (bit === "2") {
          rx = 1;
          ry = 1;
        } else if (bit === "3") {
          rx = 1;
        }
        val = Math.pow(2, level - 1);
        rotateAndFlipQuadrant(val, point, rx, ry);
        point.x += val * rx;
        point.y += val * ry;
      }
      if (face % 2 === 1) {
        var t = point.x;
        point.x = point.y;
        point.y = t;
      }
      return S22.S2Cell.FromFaceIJ(parseInt(face), [point.x, point.y], level);
    };
    S22.S2Cell.FromLatLng = function(latLng, level) {
      if (!latLng.lat && latLng.lat !== 0 || !latLng.lng && latLng.lng !== 0) {
        throw new Error(
          "Pass { lat: lat, lng: lng } to S2.S2Cell.FromLatLng"
        );
      }
      var xyz = S22.LatLngToXYZ(latLng);
      var faceuv = S22.XYZToFaceUV(xyz);
      var st = S22.UVToST(faceuv[1]);
      var ij = S22.STToIJ(st, level);
      return S22.S2Cell.FromFaceIJ(faceuv[0], ij, level);
    };
    S22.S2Cell.FromFaceIJ = function(face, ij, level) {
      var cell = new S22.S2Cell();
      cell.face = face;
      cell.ij = ij;
      cell.level = level;
      return cell;
    };
    S22.S2Cell.prototype.toString = function() {
      return "F" + this.face + "ij[" + this.ij[0] + "," + this.ij[1] + "]@" + this.level;
    };
    S22.S2Cell.prototype.getLatLng = function() {
      var st = S22.IJToST(this.ij, this.level, [0.5, 0.5]);
      var uv = S22.STToUV(st);
      var xyz = S22.FaceUVToXYZ(this.face, uv);
      return S22.XYZToLatLng(xyz);
    };
    S22.S2Cell.prototype.getCornerLatLngs = function() {
      var result = [];
      var offsets = [
        [0, 0],
        [0, 1],
        [1, 1],
        [1, 0]
      ];
      for (var i = 0; i < 4; i++) {
        var st = S22.IJToST(this.ij, this.level, offsets[i]);
        var uv = S22.STToUV(st);
        var xyz = S22.FaceUVToXYZ(this.face, uv);
        result.push(S22.XYZToLatLng(xyz));
      }
      return result;
    };
    S22.S2Cell.prototype.getFaceAndQuads = function() {
      var quads = pointToHilbertQuadList(
        this.ij[0],
        this.ij[1],
        this.level,
        this.face
      );
      return [this.face, quads];
    };
    S22.S2Cell.prototype.toHilbertQuadkey = function() {
      var quads = pointToHilbertQuadList(
        this.ij[0],
        this.ij[1],
        this.level,
        this.face
      );
      return this.face.toString(10) + "/" + quads.join("");
    };
    S22.latLngToNeighborKeys = S22.S2Cell.latLngToNeighborKeys = function(lat, lng, level) {
      return S22.S2Cell.FromLatLng(
        {
          lat,
          lng
        },
        level
      ).getNeighbors().map(function(cell) {
        return cell.toHilbertQuadkey();
      });
    };
    S22.S2Cell.prototype.getNeighbors = function() {
      var fromFaceIJWrap = function(face2, ij, level2) {
        var maxSize = 1 << level2;
        if (ij[0] >= 0 && ij[1] >= 0 && ij[0] < maxSize && ij[1] < maxSize) {
          return S22.S2Cell.FromFaceIJ(face2, ij, level2);
        } else {
          var st = S22.IJToST(ij, level2, [0.5, 0.5]);
          var uv = S22.STToUV(st);
          var xyz = S22.FaceUVToXYZ(face2, uv);
          var faceuv = S22.XYZToFaceUV(xyz);
          face2 = faceuv[0];
          uv = faceuv[1];
          st = S22.UVToST(uv);
          ij = S22.STToIJ(st, level2);
          return S22.S2Cell.FromFaceIJ(face2, ij, level2);
        }
      };
      var face = this.face;
      var i = this.ij[0];
      var j = this.ij[1];
      var level = this.level;
      return [
        fromFaceIJWrap(face, [i - 1, j], level),
        fromFaceIJWrap(face, [i, j - 1], level),
        fromFaceIJWrap(face, [i + 1, j], level),
        fromFaceIJWrap(face, [i, j + 1], level)
      ];
    };
    S22.FACE_BITS = 3;
    S22.MAX_LEVEL = 30;
    S22.POS_BITS = 2 * S22.MAX_LEVEL + 1;
    S22.facePosLevelToId = S22.S2Cell.facePosLevelToId = S22.fromFacePosLevel = function(faceN, posS, levelN) {
      var Long = exports.dcodeIO && exports.dcodeIO.Long;
      var faceB;
      var posB;
      var bin;
      if (!levelN) {
        levelN = posS.length;
      }
      if (posS.length > levelN) {
        posS = posS.substr(0, levelN);
      }
      faceB = Long.fromString(faceN.toString(10), true, 10).toString(
        2
      );
      while (faceB.length < S22.FACE_BITS) {
        faceB = "0" + faceB;
      }
      posB = Long.fromString(posS, true, 4).toString(2);
      while (posB.length < 2 * levelN) {
        posB = "0" + posB;
      }
      bin = faceB + posB;
      bin += "1";
      while (bin.length < S22.FACE_BITS + S22.POS_BITS) {
        bin += "0";
      }
      return Long.fromString(bin, true, 2).toString(10);
    };
    S22.keyToId = S22.S2Cell.keyToId = S22.toId = S22.toCellId = S22.fromKey = function(key) {
      var parts = key.split("/");
      return S22.fromFacePosLevel(parts[0], parts[1], parts[1].length);
    };
    S22.idToKey = S22.S2Cell.idToKey = S22.S2Cell.toKey = S22.toKey = S22.fromId = S22.fromCellId = S22.S2Cell.toHilbertQuadkey = S22.toHilbertQuadkey = function(idS) {
      var Long = exports.dcodeIO && exports.dcodeIO.Long;
      var bin = Long.fromString(idS, true, 10).toString(2);
      while (bin.length < S22.FACE_BITS + S22.POS_BITS) {
        bin = "0" + bin;
      }
      var lsbIndex = bin.lastIndexOf("1");
      var faceB = bin.substring(0, 3);
      var posB = bin.substring(3, lsbIndex);
      var levelN = posB.length / 2;
      var faceS = Long.fromString(faceB, true, 2).toString(10);
      var posS = Long.fromString(posB, true, 2).toString(4);
      while (posS.length < levelN) {
        posS = "0" + posS;
      }
      return faceS + "/" + posS;
    };
    S22.keyToLatLng = S22.S2Cell.keyToLatLng = function(key) {
      var cell2 = S22.S2Cell.FromHilbertQuadKey(key);
      return cell2.getLatLng();
    };
    S22.idToLatLng = S22.S2Cell.idToLatLng = function(id2) {
      var key = S22.idToKey(id2);
      return S22.keyToLatLng(key);
    };
    S22.S2Cell.latLngToKey = S22.latLngToKey = S22.latLngToQuadkey = function(lat, lng, level) {
      if (isNaN(level) || level < 1 || level > 30) {
        throw new Error(
          "'level' is not a number between 1 and 30 (but it should be)"
        );
      }
      return S22.S2Cell.FromLatLng(
        {
          lat,
          lng
        },
        level
      ).toHilbertQuadkey();
    };
    S22.stepKey = function(key, num) {
      var Long = exports.dcodeIO && exports.dcodeIO.Long;
      var parts = key.split("/");
      var faceS = parts[0];
      var posS = parts[1];
      var level = parts[1].length;
      var posL = Long.fromString(posS, true, 4);
      var otherL;
      if (num > 0) {
        otherL = posL.add(Math.abs(num));
      } else if (num < 0) {
        otherL = posL.subtract(Math.abs(num));
      }
      var otherS = otherL.toString(4);
      if ("0" === otherS) {
        console.warning(
          new Error("face/position wrapping is not yet supported")
        );
      }
      while (otherS.length < level) {
        otherS = "0" + otherS;
      }
      return faceS + "/" + otherS;
    };
    S22.S2Cell.prevKey = S22.prevKey = function(key) {
      return S22.stepKey(key, -1);
    };
    S22.S2Cell.nextKey = S22.nextKey = function(key) {
      return S22.stepKey(key, 1);
    };
    return S22;
  }
  var S2 = exposeS2Module(
    typeof module !== "undefined" && module.exports ? module.exports : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : void 0
  );

  // source/typed-s2cell.ts
  function createCellFromCoordinates(latLng, level) {
    return S2.S2Cell.FromLatLng(latLng, level);
  }
  function getCellId(latLng, level) {
    return createCellFromCoordinates(latLng, level).toString();
  }
  var indexes = Object.freeze(["0", "1", "2", "3"]);
  var buffer64 = new BigUint64Array(1);
  var view32 = new Uint32Array(buffer64.buffer);

  // source/queue.ts
  function createQueue(initialCapacity = 1024) {
    const buf = new Array(initialCapacity);
    const mask = initialCapacity - 1;
    let head = 0;
    let tail = 0;
    return {
      enqueue(x) {
        buf[tail & mask] = x;
        tail++;
      },
      dequeue() {
        if (head === tail) return void 0;
        const x = buf[head & mask];
        head++;
        return x;
      }
    };
  }

  // source/async-queue.ts
  function createAsyncQueue(consume, handleAsyncError2, { batchSize = 10 } = {}) {
    const queue = [];
    let processing = false;
    let scheduled = false;
    function push(item) {
      queue.push(item);
      schedule();
    }
    function schedule() {
      if (scheduled) return;
      scheduled = true;
      queueMicrotask(() => {
        scheduled = false;
        void flush().catch(handleAsyncError2);
      });
    }
    async function flush() {
      if (processing) return;
      if (queue.length === 0) return;
      processing = true;
      const batch = queue.splice(0, batchSize);
      try {
        await consume(batch);
      } finally {
        processing = false;
        if (queue.length) {
          schedule();
        }
      }
    }
    function close() {
      queue.length = 0;
    }
    return { push, close };
  }

  // node_modules/zod/v4/classic/external.js
  var external_exports = {};
  __export(external_exports, {
    $brand: () => $brand,
    $input: () => $input,
    $output: () => $output,
    NEVER: () => NEVER,
    TimePrecision: () => TimePrecision,
    ZodAny: () => ZodAny,
    ZodArray: () => ZodArray,
    ZodBase64: () => ZodBase64,
    ZodBase64URL: () => ZodBase64URL,
    ZodBigInt: () => ZodBigInt,
    ZodBigIntFormat: () => ZodBigIntFormat,
    ZodBoolean: () => ZodBoolean,
    ZodCIDRv4: () => ZodCIDRv4,
    ZodCIDRv6: () => ZodCIDRv6,
    ZodCUID: () => ZodCUID,
    ZodCUID2: () => ZodCUID2,
    ZodCatch: () => ZodCatch,
    ZodCodec: () => ZodCodec,
    ZodCustom: () => ZodCustom,
    ZodCustomStringFormat: () => ZodCustomStringFormat,
    ZodDate: () => ZodDate,
    ZodDefault: () => ZodDefault,
    ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
    ZodE164: () => ZodE164,
    ZodEmail: () => ZodEmail,
    ZodEmoji: () => ZodEmoji,
    ZodEnum: () => ZodEnum,
    ZodError: () => ZodError,
    ZodExactOptional: () => ZodExactOptional,
    ZodFile: () => ZodFile,
    ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
    ZodFunction: () => ZodFunction,
    ZodGUID: () => ZodGUID,
    ZodIPv4: () => ZodIPv4,
    ZodIPv6: () => ZodIPv6,
    ZodISODate: () => ZodISODate,
    ZodISODateTime: () => ZodISODateTime,
    ZodISODuration: () => ZodISODuration,
    ZodISOTime: () => ZodISOTime,
    ZodIntersection: () => ZodIntersection,
    ZodIssueCode: () => ZodIssueCode,
    ZodJWT: () => ZodJWT,
    ZodKSUID: () => ZodKSUID,
    ZodLazy: () => ZodLazy,
    ZodLiteral: () => ZodLiteral,
    ZodMAC: () => ZodMAC,
    ZodMap: () => ZodMap,
    ZodNaN: () => ZodNaN,
    ZodNanoID: () => ZodNanoID,
    ZodNever: () => ZodNever,
    ZodNonOptional: () => ZodNonOptional,
    ZodNull: () => ZodNull,
    ZodNullable: () => ZodNullable,
    ZodNumber: () => ZodNumber,
    ZodNumberFormat: () => ZodNumberFormat,
    ZodObject: () => ZodObject,
    ZodOptional: () => ZodOptional,
    ZodPipe: () => ZodPipe,
    ZodPrefault: () => ZodPrefault,
    ZodPromise: () => ZodPromise,
    ZodReadonly: () => ZodReadonly,
    ZodRealError: () => ZodRealError,
    ZodRecord: () => ZodRecord,
    ZodSet: () => ZodSet,
    ZodString: () => ZodString,
    ZodStringFormat: () => ZodStringFormat,
    ZodSuccess: () => ZodSuccess,
    ZodSymbol: () => ZodSymbol,
    ZodTemplateLiteral: () => ZodTemplateLiteral,
    ZodTransform: () => ZodTransform,
    ZodTuple: () => ZodTuple,
    ZodType: () => ZodType,
    ZodULID: () => ZodULID,
    ZodURL: () => ZodURL,
    ZodUUID: () => ZodUUID,
    ZodUndefined: () => ZodUndefined,
    ZodUnion: () => ZodUnion,
    ZodUnknown: () => ZodUnknown,
    ZodVoid: () => ZodVoid,
    ZodXID: () => ZodXID,
    ZodXor: () => ZodXor,
    _ZodString: () => _ZodString,
    _default: () => _default2,
    _function: () => _function,
    any: () => any,
    array: () => array,
    base64: () => base642,
    base64url: () => base64url2,
    bigint: () => bigint2,
    boolean: () => boolean2,
    catch: () => _catch2,
    check: () => check,
    cidrv4: () => cidrv42,
    cidrv6: () => cidrv62,
    clone: () => clone,
    codec: () => codec,
    coerce: () => coerce_exports,
    config: () => config,
    core: () => core_exports2,
    cuid: () => cuid3,
    cuid2: () => cuid22,
    custom: () => custom,
    date: () => date3,
    decode: () => decode2,
    decodeAsync: () => decodeAsync2,
    describe: () => describe2,
    discriminatedUnion: () => discriminatedUnion,
    e164: () => e1642,
    email: () => email2,
    emoji: () => emoji2,
    encode: () => encode2,
    encodeAsync: () => encodeAsync2,
    endsWith: () => _endsWith,
    enum: () => _enum2,
    exactOptional: () => exactOptional,
    file: () => file,
    flattenError: () => flattenError,
    float32: () => float32,
    float64: () => float64,
    formatError: () => formatError,
    fromJSONSchema: () => fromJSONSchema,
    function: () => _function,
    getErrorMap: () => getErrorMap,
    globalRegistry: () => globalRegistry,
    gt: () => _gt,
    gte: () => _gte,
    guid: () => guid2,
    hash: () => hash,
    hex: () => hex2,
    hostname: () => hostname2,
    httpUrl: () => httpUrl,
    includes: () => _includes,
    instanceof: () => _instanceof,
    int: () => int,
    int32: () => int32,
    int64: () => int64,
    intersection: () => intersection,
    ipv4: () => ipv42,
    ipv6: () => ipv62,
    iso: () => iso_exports,
    json: () => json,
    jwt: () => jwt,
    keyof: () => keyof,
    ksuid: () => ksuid2,
    lazy: () => lazy,
    length: () => _length,
    literal: () => literal,
    locales: () => locales_exports,
    looseObject: () => looseObject,
    looseRecord: () => looseRecord,
    lowercase: () => _lowercase,
    lt: () => _lt,
    lte: () => _lte,
    mac: () => mac2,
    map: () => map,
    maxLength: () => _maxLength,
    maxSize: () => _maxSize,
    meta: () => meta2,
    mime: () => _mime,
    minLength: () => _minLength,
    minSize: () => _minSize,
    multipleOf: () => _multipleOf,
    nan: () => nan,
    nanoid: () => nanoid2,
    nativeEnum: () => nativeEnum,
    negative: () => _negative,
    never: () => never,
    nonnegative: () => _nonnegative,
    nonoptional: () => nonoptional,
    nonpositive: () => _nonpositive,
    normalize: () => _normalize,
    null: () => _null3,
    nullable: () => nullable,
    nullish: () => nullish2,
    number: () => number2,
    object: () => object,
    optional: () => optional,
    overwrite: () => _overwrite,
    parse: () => parse2,
    parseAsync: () => parseAsync2,
    partialRecord: () => partialRecord,
    pipe: () => pipe,
    positive: () => _positive,
    prefault: () => prefault,
    preprocess: () => preprocess,
    prettifyError: () => prettifyError,
    promise: () => promise,
    property: () => _property,
    readonly: () => readonly,
    record: () => record,
    refine: () => refine,
    regex: () => _regex,
    regexes: () => regexes_exports,
    registry: () => registry,
    safeDecode: () => safeDecode2,
    safeDecodeAsync: () => safeDecodeAsync2,
    safeEncode: () => safeEncode2,
    safeEncodeAsync: () => safeEncodeAsync2,
    safeParse: () => safeParse2,
    safeParseAsync: () => safeParseAsync2,
    set: () => set,
    setErrorMap: () => setErrorMap,
    size: () => _size,
    slugify: () => _slugify,
    startsWith: () => _startsWith,
    strictObject: () => strictObject,
    string: () => string2,
    stringFormat: () => stringFormat,
    stringbool: () => stringbool,
    success: () => success,
    superRefine: () => superRefine,
    symbol: () => symbol,
    templateLiteral: () => templateLiteral,
    toJSONSchema: () => toJSONSchema,
    toLowerCase: () => _toLowerCase,
    toUpperCase: () => _toUpperCase,
    transform: () => transform,
    treeifyError: () => treeifyError,
    trim: () => _trim,
    tuple: () => tuple,
    uint32: () => uint32,
    uint64: () => uint64,
    ulid: () => ulid2,
    undefined: () => _undefined3,
    union: () => union,
    unknown: () => unknown,
    uppercase: () => _uppercase,
    url: () => url,
    util: () => util_exports,
    uuid: () => uuid2,
    uuidv4: () => uuidv4,
    uuidv6: () => uuidv6,
    uuidv7: () => uuidv7,
    void: () => _void2,
    xid: () => xid2,
    xor: () => xor
  });

  // node_modules/zod/v4/core/index.js
  var core_exports2 = {};
  __export(core_exports2, {
    $ZodAny: () => $ZodAny,
    $ZodArray: () => $ZodArray,
    $ZodAsyncError: () => $ZodAsyncError,
    $ZodBase64: () => $ZodBase64,
    $ZodBase64URL: () => $ZodBase64URL,
    $ZodBigInt: () => $ZodBigInt,
    $ZodBigIntFormat: () => $ZodBigIntFormat,
    $ZodBoolean: () => $ZodBoolean,
    $ZodCIDRv4: () => $ZodCIDRv4,
    $ZodCIDRv6: () => $ZodCIDRv6,
    $ZodCUID: () => $ZodCUID,
    $ZodCUID2: () => $ZodCUID2,
    $ZodCatch: () => $ZodCatch,
    $ZodCheck: () => $ZodCheck,
    $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
    $ZodCheckEndsWith: () => $ZodCheckEndsWith,
    $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
    $ZodCheckIncludes: () => $ZodCheckIncludes,
    $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
    $ZodCheckLessThan: () => $ZodCheckLessThan,
    $ZodCheckLowerCase: () => $ZodCheckLowerCase,
    $ZodCheckMaxLength: () => $ZodCheckMaxLength,
    $ZodCheckMaxSize: () => $ZodCheckMaxSize,
    $ZodCheckMimeType: () => $ZodCheckMimeType,
    $ZodCheckMinLength: () => $ZodCheckMinLength,
    $ZodCheckMinSize: () => $ZodCheckMinSize,
    $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
    $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
    $ZodCheckOverwrite: () => $ZodCheckOverwrite,
    $ZodCheckProperty: () => $ZodCheckProperty,
    $ZodCheckRegex: () => $ZodCheckRegex,
    $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
    $ZodCheckStartsWith: () => $ZodCheckStartsWith,
    $ZodCheckStringFormat: () => $ZodCheckStringFormat,
    $ZodCheckUpperCase: () => $ZodCheckUpperCase,
    $ZodCodec: () => $ZodCodec,
    $ZodCustom: () => $ZodCustom,
    $ZodCustomStringFormat: () => $ZodCustomStringFormat,
    $ZodDate: () => $ZodDate,
    $ZodDefault: () => $ZodDefault,
    $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
    $ZodE164: () => $ZodE164,
    $ZodEmail: () => $ZodEmail,
    $ZodEmoji: () => $ZodEmoji,
    $ZodEncodeError: () => $ZodEncodeError,
    $ZodEnum: () => $ZodEnum,
    $ZodError: () => $ZodError,
    $ZodExactOptional: () => $ZodExactOptional,
    $ZodFile: () => $ZodFile,
    $ZodFunction: () => $ZodFunction,
    $ZodGUID: () => $ZodGUID,
    $ZodIPv4: () => $ZodIPv4,
    $ZodIPv6: () => $ZodIPv6,
    $ZodISODate: () => $ZodISODate,
    $ZodISODateTime: () => $ZodISODateTime,
    $ZodISODuration: () => $ZodISODuration,
    $ZodISOTime: () => $ZodISOTime,
    $ZodIntersection: () => $ZodIntersection,
    $ZodJWT: () => $ZodJWT,
    $ZodKSUID: () => $ZodKSUID,
    $ZodLazy: () => $ZodLazy,
    $ZodLiteral: () => $ZodLiteral,
    $ZodMAC: () => $ZodMAC,
    $ZodMap: () => $ZodMap,
    $ZodNaN: () => $ZodNaN,
    $ZodNanoID: () => $ZodNanoID,
    $ZodNever: () => $ZodNever,
    $ZodNonOptional: () => $ZodNonOptional,
    $ZodNull: () => $ZodNull,
    $ZodNullable: () => $ZodNullable,
    $ZodNumber: () => $ZodNumber,
    $ZodNumberFormat: () => $ZodNumberFormat,
    $ZodObject: () => $ZodObject,
    $ZodObjectJIT: () => $ZodObjectJIT,
    $ZodOptional: () => $ZodOptional,
    $ZodPipe: () => $ZodPipe,
    $ZodPrefault: () => $ZodPrefault,
    $ZodPromise: () => $ZodPromise,
    $ZodReadonly: () => $ZodReadonly,
    $ZodRealError: () => $ZodRealError,
    $ZodRecord: () => $ZodRecord,
    $ZodRegistry: () => $ZodRegistry,
    $ZodSet: () => $ZodSet,
    $ZodString: () => $ZodString,
    $ZodStringFormat: () => $ZodStringFormat,
    $ZodSuccess: () => $ZodSuccess,
    $ZodSymbol: () => $ZodSymbol,
    $ZodTemplateLiteral: () => $ZodTemplateLiteral,
    $ZodTransform: () => $ZodTransform,
    $ZodTuple: () => $ZodTuple,
    $ZodType: () => $ZodType,
    $ZodULID: () => $ZodULID,
    $ZodURL: () => $ZodURL,
    $ZodUUID: () => $ZodUUID,
    $ZodUndefined: () => $ZodUndefined,
    $ZodUnion: () => $ZodUnion,
    $ZodUnknown: () => $ZodUnknown,
    $ZodVoid: () => $ZodVoid,
    $ZodXID: () => $ZodXID,
    $ZodXor: () => $ZodXor,
    $brand: () => $brand,
    $constructor: () => $constructor,
    $input: () => $input,
    $output: () => $output,
    Doc: () => Doc,
    JSONSchema: () => json_schema_exports,
    JSONSchemaGenerator: () => JSONSchemaGenerator,
    NEVER: () => NEVER,
    TimePrecision: () => TimePrecision,
    _any: () => _any,
    _array: () => _array,
    _base64: () => _base64,
    _base64url: () => _base64url,
    _bigint: () => _bigint,
    _boolean: () => _boolean,
    _catch: () => _catch,
    _check: () => _check,
    _cidrv4: () => _cidrv4,
    _cidrv6: () => _cidrv6,
    _coercedBigint: () => _coercedBigint,
    _coercedBoolean: () => _coercedBoolean,
    _coercedDate: () => _coercedDate,
    _coercedNumber: () => _coercedNumber,
    _coercedString: () => _coercedString,
    _cuid: () => _cuid,
    _cuid2: () => _cuid2,
    _custom: () => _custom,
    _date: () => _date,
    _decode: () => _decode,
    _decodeAsync: () => _decodeAsync,
    _default: () => _default,
    _discriminatedUnion: () => _discriminatedUnion,
    _e164: () => _e164,
    _email: () => _email,
    _emoji: () => _emoji2,
    _encode: () => _encode,
    _encodeAsync: () => _encodeAsync,
    _endsWith: () => _endsWith,
    _enum: () => _enum,
    _file: () => _file,
    _float32: () => _float32,
    _float64: () => _float64,
    _gt: () => _gt,
    _gte: () => _gte,
    _guid: () => _guid,
    _includes: () => _includes,
    _int: () => _int,
    _int32: () => _int32,
    _int64: () => _int64,
    _intersection: () => _intersection,
    _ipv4: () => _ipv4,
    _ipv6: () => _ipv6,
    _isoDate: () => _isoDate,
    _isoDateTime: () => _isoDateTime,
    _isoDuration: () => _isoDuration,
    _isoTime: () => _isoTime,
    _jwt: () => _jwt,
    _ksuid: () => _ksuid,
    _lazy: () => _lazy,
    _length: () => _length,
    _literal: () => _literal,
    _lowercase: () => _lowercase,
    _lt: () => _lt,
    _lte: () => _lte,
    _mac: () => _mac,
    _map: () => _map,
    _max: () => _lte,
    _maxLength: () => _maxLength,
    _maxSize: () => _maxSize,
    _mime: () => _mime,
    _min: () => _gte,
    _minLength: () => _minLength,
    _minSize: () => _minSize,
    _multipleOf: () => _multipleOf,
    _nan: () => _nan,
    _nanoid: () => _nanoid,
    _nativeEnum: () => _nativeEnum,
    _negative: () => _negative,
    _never: () => _never,
    _nonnegative: () => _nonnegative,
    _nonoptional: () => _nonoptional,
    _nonpositive: () => _nonpositive,
    _normalize: () => _normalize,
    _null: () => _null2,
    _nullable: () => _nullable,
    _number: () => _number,
    _optional: () => _optional,
    _overwrite: () => _overwrite,
    _parse: () => _parse,
    _parseAsync: () => _parseAsync,
    _pipe: () => _pipe,
    _positive: () => _positive,
    _promise: () => _promise,
    _property: () => _property,
    _readonly: () => _readonly,
    _record: () => _record,
    _refine: () => _refine,
    _regex: () => _regex,
    _safeDecode: () => _safeDecode,
    _safeDecodeAsync: () => _safeDecodeAsync,
    _safeEncode: () => _safeEncode,
    _safeEncodeAsync: () => _safeEncodeAsync,
    _safeParse: () => _safeParse,
    _safeParseAsync: () => _safeParseAsync,
    _set: () => _set,
    _size: () => _size,
    _slugify: () => _slugify,
    _startsWith: () => _startsWith,
    _string: () => _string,
    _stringFormat: () => _stringFormat,
    _stringbool: () => _stringbool,
    _success: () => _success,
    _superRefine: () => _superRefine,
    _symbol: () => _symbol,
    _templateLiteral: () => _templateLiteral,
    _toLowerCase: () => _toLowerCase,
    _toUpperCase: () => _toUpperCase,
    _transform: () => _transform,
    _trim: () => _trim,
    _tuple: () => _tuple,
    _uint32: () => _uint32,
    _uint64: () => _uint64,
    _ulid: () => _ulid,
    _undefined: () => _undefined2,
    _union: () => _union,
    _unknown: () => _unknown,
    _uppercase: () => _uppercase,
    _url: () => _url,
    _uuid: () => _uuid,
    _uuidv4: () => _uuidv4,
    _uuidv6: () => _uuidv6,
    _uuidv7: () => _uuidv7,
    _void: () => _void,
    _xid: () => _xid,
    _xor: () => _xor,
    clone: () => clone,
    config: () => config,
    createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
    createToJSONSchemaMethod: () => createToJSONSchemaMethod,
    decode: () => decode,
    decodeAsync: () => decodeAsync,
    describe: () => describe,
    encode: () => encode,
    encodeAsync: () => encodeAsync,
    extractDefs: () => extractDefs,
    finalize: () => finalize,
    flattenError: () => flattenError,
    formatError: () => formatError,
    globalConfig: () => globalConfig,
    globalRegistry: () => globalRegistry,
    initializeContext: () => initializeContext,
    isValidBase64: () => isValidBase64,
    isValidBase64URL: () => isValidBase64URL,
    isValidJWT: () => isValidJWT,
    locales: () => locales_exports,
    meta: () => meta,
    parse: () => parse,
    parseAsync: () => parseAsync,
    prettifyError: () => prettifyError,
    process: () => process2,
    regexes: () => regexes_exports,
    registry: () => registry,
    safeDecode: () => safeDecode,
    safeDecodeAsync: () => safeDecodeAsync,
    safeEncode: () => safeEncode,
    safeEncodeAsync: () => safeEncodeAsync,
    safeParse: () => safeParse,
    safeParseAsync: () => safeParseAsync,
    toDotPath: () => toDotPath,
    toJSONSchema: () => toJSONSchema,
    treeifyError: () => treeifyError,
    util: () => util_exports,
    version: () => version
  });

  // node_modules/zod/v4/core/core.js
  var NEVER = Object.freeze({
    status: "aborted"
  });
  // @__NO_SIDE_EFFECTS__
  function $constructor(name, initializer3, params) {
    function init(inst, def) {
      if (!inst._zod) {
        Object.defineProperty(inst, "_zod", {
          value: {
            def,
            constr: _,
            traits: /* @__PURE__ */ new Set()
          },
          enumerable: false
        });
      }
      if (inst._zod.traits.has(name)) {
        return;
      }
      inst._zod.traits.add(name);
      initializer3(inst, def);
      const proto = _.prototype;
      const keys = Object.keys(proto);
      for (let i = 0; i < keys.length; i++) {
        const k = keys[i];
        if (!(k in inst)) {
          inst[k] = proto[k].bind(inst);
        }
      }
    }
    const Parent = params?.Parent ?? Object;
    class Definition extends Parent {
    }
    Object.defineProperty(Definition, "name", { value: name });
    function _(def) {
      var _a2;
      const inst = params?.Parent ? new Definition() : this;
      init(inst, def);
      (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
      for (const fn of inst._zod.deferred) {
        fn();
      }
      return inst;
    }
    Object.defineProperty(_, "init", { value: init });
    Object.defineProperty(_, Symbol.hasInstance, {
      value: (inst) => {
        if (params?.Parent && inst instanceof params.Parent)
          return true;
        return inst?._zod?.traits?.has(name);
      }
    });
    Object.defineProperty(_, "name", { value: name });
    return _;
  }
  var $brand = /* @__PURE__ */ Symbol("zod_brand");
  var $ZodAsyncError = class extends Error {
    constructor() {
      super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
    }
  };
  var $ZodEncodeError = class extends Error {
    constructor(name) {
      super(`Encountered unidirectional transform during encode: ${name}`);
      this.name = "ZodEncodeError";
    }
  };
  var globalConfig = {};
  function config(newConfig) {
    if (newConfig)
      Object.assign(globalConfig, newConfig);
    return globalConfig;
  }

  // node_modules/zod/v4/core/util.js
  var util_exports = {};
  __export(util_exports, {
    BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
    Class: () => Class,
    NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
    aborted: () => aborted,
    allowsEval: () => allowsEval,
    assert: () => assert,
    assertEqual: () => assertEqual,
    assertIs: () => assertIs,
    assertNever: () => assertNever,
    assertNotEqual: () => assertNotEqual,
    assignProp: () => assignProp,
    base64ToUint8Array: () => base64ToUint8Array,
    base64urlToUint8Array: () => base64urlToUint8Array,
    cached: () => cached2,
    captureStackTrace: () => captureStackTrace,
    cleanEnum: () => cleanEnum,
    cleanRegex: () => cleanRegex,
    clone: () => clone,
    cloneDef: () => cloneDef,
    createTransparentProxy: () => createTransparentProxy,
    defineLazy: () => defineLazy,
    esc: () => esc,
    escapeRegex: () => escapeRegex,
    extend: () => extend,
    finalizeIssue: () => finalizeIssue,
    floatSafeRemainder: () => floatSafeRemainder,
    getElementAtPath: () => getElementAtPath,
    getEnumValues: () => getEnumValues,
    getLengthableOrigin: () => getLengthableOrigin,
    getParsedType: () => getParsedType,
    getSizableOrigin: () => getSizableOrigin,
    hexToUint8Array: () => hexToUint8Array,
    isObject: () => isObject,
    isPlainObject: () => isPlainObject,
    issue: () => issue,
    joinValues: () => joinValues,
    jsonStringifyReplacer: () => jsonStringifyReplacer,
    merge: () => merge,
    mergeDefs: () => mergeDefs,
    normalizeParams: () => normalizeParams,
    nullish: () => nullish,
    numKeys: () => numKeys,
    objectClone: () => objectClone,
    omit: () => omit,
    optionalKeys: () => optionalKeys,
    parsedType: () => parsedType,
    partial: () => partial,
    pick: () => pick,
    prefixIssues: () => prefixIssues,
    primitiveTypes: () => primitiveTypes,
    promiseAllObject: () => promiseAllObject,
    propertyKeyTypes: () => propertyKeyTypes,
    randomString: () => randomString,
    required: () => required,
    safeExtend: () => safeExtend,
    shallowClone: () => shallowClone,
    slugify: () => slugify,
    stringifyPrimitive: () => stringifyPrimitive,
    uint8ArrayToBase64: () => uint8ArrayToBase64,
    uint8ArrayToBase64url: () => uint8ArrayToBase64url,
    uint8ArrayToHex: () => uint8ArrayToHex,
    unwrapMessage: () => unwrapMessage
  });
  function assertEqual(val) {
    return val;
  }
  function assertNotEqual(val) {
    return val;
  }
  function assertIs(_arg) {
  }
  function assertNever(_x) {
    throw new Error("Unexpected value in exhaustive check");
  }
  function assert(_) {
  }
  function getEnumValues(entries) {
    const numericValues = Object.values(entries).filter((v) => typeof v === "number");
    const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
    return values;
  }
  function joinValues(array3, separator = "|") {
    return array3.map((val) => stringifyPrimitive(val)).join(separator);
  }
  function jsonStringifyReplacer(_, value) {
    if (typeof value === "bigint")
      return value.toString();
    return value;
  }
  function cached2(getter) {
    const set2 = false;
    return {
      get value() {
        if (!set2) {
          const value = getter();
          Object.defineProperty(this, "value", { value });
          return value;
        }
        throw new Error("cached value already set");
      }
    };
  }
  function nullish(input) {
    return input === null || input === void 0;
  }
  function cleanRegex(source) {
    const start = source.startsWith("^") ? 1 : 0;
    const end = source.endsWith("$") ? source.length - 1 : source.length;
    return source.slice(start, end);
  }
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepString = step.toString();
    let stepDecCount = (stepString.split(".")[1] || "").length;
    if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
      const match = stepString.match(/\d?e-(\d?)/);
      if (match?.[1]) {
        stepDecCount = Number.parseInt(match[1]);
      }
    }
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
  }
  var EVALUATING = /* @__PURE__ */ Symbol("evaluating");
  function defineLazy(object2, key, getter) {
    let value = void 0;
    Object.defineProperty(object2, key, {
      get() {
        if (value === EVALUATING) {
          return void 0;
        }
        if (value === void 0) {
          value = EVALUATING;
          value = getter();
        }
        return value;
      },
      set(v) {
        Object.defineProperty(object2, key, {
          value: v
          // configurable: true,
        });
      },
      configurable: true
    });
  }
  function objectClone(obj) {
    return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
  }
  function assignProp(target, prop, value) {
    Object.defineProperty(target, prop, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
  }
  function mergeDefs(...defs) {
    const mergedDescriptors = {};
    for (const def of defs) {
      const descriptors = Object.getOwnPropertyDescriptors(def);
      Object.assign(mergedDescriptors, descriptors);
    }
    return Object.defineProperties({}, mergedDescriptors);
  }
  function cloneDef(schema) {
    return mergeDefs(schema._zod.def);
  }
  function getElementAtPath(obj, path) {
    if (!path)
      return obj;
    return path.reduce((acc, key) => acc?.[key], obj);
  }
  function promiseAllObject(promisesObj) {
    const keys = Object.keys(promisesObj);
    const promises = keys.map((key) => promisesObj[key]);
    return Promise.all(promises).then((results) => {
      const resolvedObj = {};
      for (let i = 0; i < keys.length; i++) {
        resolvedObj[keys[i]] = results[i];
      }
      return resolvedObj;
    });
  }
  function randomString(length = 10) {
    const chars = "abcdefghijklmnopqrstuvwxyz";
    let str = "";
    for (let i = 0; i < length; i++) {
      str += chars[Math.floor(Math.random() * chars.length)];
    }
    return str;
  }
  function esc(str) {
    return JSON.stringify(str);
  }
  function slugify(input) {
    return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
  }
  var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
  };
  function isObject(data) {
    return typeof data === "object" && data !== null && !Array.isArray(data);
  }
  var allowsEval = cached2(() => {
    if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
      return false;
    }
    try {
      const F = Function;
      new F("");
      return true;
    } catch (_) {
      return false;
    }
  });
  function isPlainObject(o) {
    if (isObject(o) === false)
      return false;
    const ctor = o.constructor;
    if (ctor === void 0)
      return true;
    if (typeof ctor !== "function")
      return true;
    const prot = ctor.prototype;
    if (isObject(prot) === false)
      return false;
    if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
      return false;
    }
    return true;
  }
  function shallowClone(o) {
    if (isPlainObject(o))
      return { ...o };
    if (Array.isArray(o))
      return [...o];
    return o;
  }
  function numKeys(data) {
    let keyCount = 0;
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        keyCount++;
      }
    }
    return keyCount;
  }
  var getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return "undefined";
      case "string":
        return "string";
      case "number":
        return Number.isNaN(data) ? "nan" : "number";
      case "boolean":
        return "boolean";
      case "function":
        return "function";
      case "bigint":
        return "bigint";
      case "symbol":
        return "symbol";
      case "object":
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return "promise";
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return "map";
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return "set";
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return "date";
        }
        if (typeof File !== "undefined" && data instanceof File) {
          return "file";
        }
        return "object";
      default:
        throw new Error(`Unknown data type: ${t}`);
    }
  };
  var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
  var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
  function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function clone(inst, def, params) {
    const cl = new inst._zod.constr(def ?? inst._zod.def);
    if (!def || params?.parent)
      cl._zod.parent = inst;
    return cl;
  }
  function normalizeParams(_params) {
    const params = _params;
    if (!params)
      return {};
    if (typeof params === "string")
      return { error: () => params };
    if (params?.message !== void 0) {
      if (params?.error !== void 0)
        throw new Error("Cannot specify both `message` and `error` params");
      params.error = params.message;
    }
    delete params.message;
    if (typeof params.error === "string")
      return { ...params, error: () => params.error };
    return params;
  }
  function createTransparentProxy(getter) {
    let target;
    return new Proxy({}, {
      get(_, prop, receiver) {
        target ?? (target = getter());
        return Reflect.get(target, prop, receiver);
      },
      set(_, prop, value, receiver) {
        target ?? (target = getter());
        return Reflect.set(target, prop, value, receiver);
      },
      has(_, prop) {
        target ?? (target = getter());
        return Reflect.has(target, prop);
      },
      deleteProperty(_, prop) {
        target ?? (target = getter());
        return Reflect.deleteProperty(target, prop);
      },
      ownKeys(_) {
        target ?? (target = getter());
        return Reflect.ownKeys(target);
      },
      getOwnPropertyDescriptor(_, prop) {
        target ?? (target = getter());
        return Reflect.getOwnPropertyDescriptor(target, prop);
      },
      defineProperty(_, prop, descriptor) {
        target ?? (target = getter());
        return Reflect.defineProperty(target, prop, descriptor);
      }
    });
  }
  function stringifyPrimitive(value) {
    if (typeof value === "bigint")
      return value.toString() + "n";
    if (typeof value === "string")
      return `"${value}"`;
    return `${value}`;
  }
  function optionalKeys(shape) {
    return Object.keys(shape).filter((k) => {
      return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
    });
  }
  var NUMBER_FORMAT_RANGES = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-34028234663852886e22, 34028234663852886e22],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
  };
  var BIGINT_FORMAT_RANGES = {
    int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
    uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
  };
  function pick(schema, mask) {
    const currDef = schema._zod.def;
    const checks = currDef.checks;
    const hasChecks = checks && checks.length > 0;
    if (hasChecks) {
      throw new Error(".pick() cannot be used on object schemas containing refinements");
    }
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const newShape = {};
        for (const key in mask) {
          if (!(key in currDef.shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          newShape[key] = currDef.shape[key];
        }
        assignProp(this, "shape", newShape);
        return newShape;
      },
      checks: []
    });
    return clone(schema, def);
  }
  function omit(schema, mask) {
    const currDef = schema._zod.def;
    const checks = currDef.checks;
    const hasChecks = checks && checks.length > 0;
    if (hasChecks) {
      throw new Error(".omit() cannot be used on object schemas containing refinements");
    }
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const newShape = { ...schema._zod.def.shape };
        for (const key in mask) {
          if (!(key in currDef.shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          delete newShape[key];
        }
        assignProp(this, "shape", newShape);
        return newShape;
      },
      checks: []
    });
    return clone(schema, def);
  }
  function extend(schema, shape) {
    if (!isPlainObject(shape)) {
      throw new Error("Invalid input to extend: expected a plain object");
    }
    const checks = schema._zod.def.checks;
    const hasChecks = checks && checks.length > 0;
    if (hasChecks) {
      const existingShape = schema._zod.def.shape;
      for (const key in shape) {
        if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) {
          throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
        }
      }
    }
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const _shape = { ...schema._zod.def.shape, ...shape };
        assignProp(this, "shape", _shape);
        return _shape;
      }
    });
    return clone(schema, def);
  }
  function safeExtend(schema, shape) {
    if (!isPlainObject(shape)) {
      throw new Error("Invalid input to safeExtend: expected a plain object");
    }
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const _shape = { ...schema._zod.def.shape, ...shape };
        assignProp(this, "shape", _shape);
        return _shape;
      }
    });
    return clone(schema, def);
  }
  function merge(a, b) {
    const def = mergeDefs(a._zod.def, {
      get shape() {
        const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
        assignProp(this, "shape", _shape);
        return _shape;
      },
      get catchall() {
        return b._zod.def.catchall;
      },
      checks: []
      // delete existing checks
    });
    return clone(a, def);
  }
  function partial(Class2, schema, mask) {
    const currDef = schema._zod.def;
    const checks = currDef.checks;
    const hasChecks = checks && checks.length > 0;
    if (hasChecks) {
      throw new Error(".partial() cannot be used on object schemas containing refinements");
    }
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const oldShape = schema._zod.def.shape;
        const shape = { ...oldShape };
        if (mask) {
          for (const key in mask) {
            if (!(key in oldShape)) {
              throw new Error(`Unrecognized key: "${key}"`);
            }
            if (!mask[key])
              continue;
            shape[key] = Class2 ? new Class2({
              type: "optional",
              innerType: oldShape[key]
            }) : oldShape[key];
          }
        } else {
          for (const key in oldShape) {
            shape[key] = Class2 ? new Class2({
              type: "optional",
              innerType: oldShape[key]
            }) : oldShape[key];
          }
        }
        assignProp(this, "shape", shape);
        return shape;
      },
      checks: []
    });
    return clone(schema, def);
  }
  function required(Class2, schema, mask) {
    const def = mergeDefs(schema._zod.def, {
      get shape() {
        const oldShape = schema._zod.def.shape;
        const shape = { ...oldShape };
        if (mask) {
          for (const key in mask) {
            if (!(key in shape)) {
              throw new Error(`Unrecognized key: "${key}"`);
            }
            if (!mask[key])
              continue;
            shape[key] = new Class2({
              type: "nonoptional",
              innerType: oldShape[key]
            });
          }
        } else {
          for (const key in oldShape) {
            shape[key] = new Class2({
              type: "nonoptional",
              innerType: oldShape[key]
            });
          }
        }
        assignProp(this, "shape", shape);
        return shape;
      }
    });
    return clone(schema, def);
  }
  function aborted(x, startIndex = 0) {
    if (x.aborted === true)
      return true;
    for (let i = startIndex; i < x.issues.length; i++) {
      if (x.issues[i]?.continue !== true) {
        return true;
      }
    }
    return false;
  }
  function prefixIssues(path, issues) {
    return issues.map((iss) => {
      var _a2;
      (_a2 = iss).path ?? (_a2.path = []);
      iss.path.unshift(path);
      return iss;
    });
  }
  function unwrapMessage(message) {
    return typeof message === "string" ? message : message?.message;
  }
  function finalizeIssue(iss, ctx, config2) {
    const full = { ...iss, path: iss.path ?? [] };
    if (!iss.message) {
      const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
      full.message = message;
    }
    delete full.inst;
    delete full.continue;
    if (!ctx?.reportInput) {
      delete full.input;
    }
    return full;
  }
  function getSizableOrigin(input) {
    if (input instanceof Set)
      return "set";
    if (input instanceof Map)
      return "map";
    if (input instanceof File)
      return "file";
    return "unknown";
  }
  function getLengthableOrigin(input) {
    if (Array.isArray(input))
      return "array";
    if (typeof input === "string")
      return "string";
    return "unknown";
  }
  function parsedType(data) {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "nan" : "number";
      }
      case "object": {
        if (data === null) {
          return "null";
        }
        if (Array.isArray(data)) {
          return "array";
        }
        const obj = data;
        if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
          return obj.constructor.name;
        }
      }
    }
    return t;
  }
  function issue(...args) {
    const [iss, input, inst] = args;
    if (typeof iss === "string") {
      return {
        message: iss,
        code: "custom",
        input,
        inst
      };
    }
    return { ...iss };
  }
  function cleanEnum(obj) {
    return Object.entries(obj).filter(([k, _]) => {
      return Number.isNaN(Number.parseInt(k, 10));
    }).map((el) => el[1]);
  }
  function base64ToUint8Array(base643) {
    const binaryString = atob(base643);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  }
  function uint8ArrayToBase64(bytes) {
    let binaryString = "";
    for (let i = 0; i < bytes.length; i++) {
      binaryString += String.fromCharCode(bytes[i]);
    }
    return btoa(binaryString);
  }
  function base64urlToUint8Array(base64url3) {
    const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
    const padding = "=".repeat((4 - base643.length % 4) % 4);
    return base64ToUint8Array(base643 + padding);
  }
  function uint8ArrayToBase64url(bytes) {
    return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  }
  function hexToUint8Array(hex3) {
    const cleanHex = hex3.replace(/^0x/, "");
    if (cleanHex.length % 2 !== 0) {
      throw new Error("Invalid hex string length");
    }
    const bytes = new Uint8Array(cleanHex.length / 2);
    for (let i = 0; i < cleanHex.length; i += 2) {
      bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
    }
    return bytes;
  }
  function uint8ArrayToHex(bytes) {
    return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  var Class = class {
    constructor(..._args) {
    }
  };

  // node_modules/zod/v4/core/errors.js
  var initializer = (inst, def) => {
    inst.name = "$ZodError";
    Object.defineProperty(inst, "_zod", {
      value: inst._zod,
      enumerable: false
    });
    Object.defineProperty(inst, "issues", {
      value: def,
      enumerable: false
    });
    inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
    Object.defineProperty(inst, "toString", {
      value: () => inst.message,
      enumerable: false
    });
  };
  var $ZodError = $constructor("$ZodError", initializer);
  var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
  function flattenError(error48, mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of error48.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  function formatError(error48, mapper = (issue2) => issue2.message) {
    const fieldErrors = { _errors: [] };
    const processError = (error49) => {
      for (const issue2 of error49.issues) {
        if (issue2.code === "invalid_union" && issue2.errors.length) {
          issue2.errors.map((issues) => processError({ issues }));
        } else if (issue2.code === "invalid_key") {
          processError({ issues: issue2.issues });
        } else if (issue2.code === "invalid_element") {
          processError({ issues: issue2.issues });
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(error48);
    return fieldErrors;
  }
  function treeifyError(error48, mapper = (issue2) => issue2.message) {
    const result = { errors: [] };
    const processError = (error49, path = []) => {
      var _a2, _b;
      for (const issue2 of error49.issues) {
        if (issue2.code === "invalid_union" && issue2.errors.length) {
          issue2.errors.map((issues) => processError({ issues }, issue2.path));
        } else if (issue2.code === "invalid_key") {
          processError({ issues: issue2.issues }, issue2.path);
        } else if (issue2.code === "invalid_element") {
          processError({ issues: issue2.issues }, issue2.path);
        } else {
          const fullpath = [...path, ...issue2.path];
          if (fullpath.length === 0) {
            result.errors.push(mapper(issue2));
            continue;
          }
          let curr = result;
          let i = 0;
          while (i < fullpath.length) {
            const el = fullpath[i];
            const terminal = i === fullpath.length - 1;
            if (typeof el === "string") {
              curr.properties ?? (curr.properties = {});
              (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
              curr = curr.properties[el];
            } else {
              curr.items ?? (curr.items = []);
              (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
              curr = curr.items[el];
            }
            if (terminal) {
              curr.errors.push(mapper(issue2));
            }
            i++;
          }
        }
      }
    };
    processError(error48);
    return result;
  }
  function toDotPath(_path) {
    const segs = [];
    const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
    for (const seg of path) {
      if (typeof seg === "number")
        segs.push(`[${seg}]`);
      else if (typeof seg === "symbol")
        segs.push(`[${JSON.stringify(String(seg))}]`);
      else if (/[^\w$]/.test(seg))
        segs.push(`[${JSON.stringify(seg)}]`);
      else {
        if (segs.length)
          segs.push(".");
        segs.push(seg);
      }
    }
    return segs.join("");
  }
  function prettifyError(error48) {
    const lines = [];
    const issues = [...error48.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
    for (const issue2 of issues) {
      lines.push(`\u2716 ${issue2.message}`);
      if (issue2.path?.length)
        lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
    }
    return lines.join("\n");
  }

  // node_modules/zod/v4/core/parse.js
  var _parse = (_Err) => (schema, value, _ctx, _params) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
    const result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise) {
      throw new $ZodAsyncError();
    }
    if (result.issues.length) {
      const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
      captureStackTrace(e, _params?.callee);
      throw e;
    }
    return result.value;
  };
  var parse = /* @__PURE__ */ _parse($ZodRealError);
  var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
    let result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise)
      result = await result;
    if (result.issues.length) {
      const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
      captureStackTrace(e, params?.callee);
      throw e;
    }
    return result.value;
  };
  var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
  var _safeParse = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
    const result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise) {
      throw new $ZodAsyncError();
    }
    return result.issues.length ? {
      success: false,
      error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    } : { success: true, data: result.value };
  };
  var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
  var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
    let result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise)
      result = await result;
    return result.issues.length ? {
      success: false,
      error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    } : { success: true, data: result.value };
  };
  var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
  var _encode = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _parse(_Err)(schema, value, ctx);
  };
  var encode = /* @__PURE__ */ _encode($ZodRealError);
  var _decode = (_Err) => (schema, value, _ctx) => {
    return _parse(_Err)(schema, value, _ctx);
  };
  var decode = /* @__PURE__ */ _decode($ZodRealError);
  var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _parseAsync(_Err)(schema, value, ctx);
  };
  var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
  var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
    return _parseAsync(_Err)(schema, value, _ctx);
  };
  var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
  var _safeEncode = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _safeParse(_Err)(schema, value, ctx);
  };
  var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
  var _safeDecode = (_Err) => (schema, value, _ctx) => {
    return _safeParse(_Err)(schema, value, _ctx);
  };
  var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
  var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _safeParseAsync(_Err)(schema, value, ctx);
  };
  var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
  var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
    return _safeParseAsync(_Err)(schema, value, _ctx);
  };
  var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);

  // node_modules/zod/v4/core/regexes.js
  var regexes_exports = {};
  __export(regexes_exports, {
    base64: () => base64,
    base64url: () => base64url,
    bigint: () => bigint,
    boolean: () => boolean,
    browserEmail: () => browserEmail,
    cidrv4: () => cidrv4,
    cidrv6: () => cidrv6,
    cuid: () => cuid,
    cuid2: () => cuid2,
    date: () => date,
    datetime: () => datetime,
    domain: () => domain,
    duration: () => duration,
    e164: () => e164,
    email: () => email,
    emoji: () => emoji,
    extendedDuration: () => extendedDuration,
    guid: () => guid,
    hex: () => hex,
    hostname: () => hostname,
    html5Email: () => html5Email,
    idnEmail: () => idnEmail,
    integer: () => integer,
    ipv4: () => ipv4,
    ipv6: () => ipv6,
    ksuid: () => ksuid,
    lowercase: () => lowercase,
    mac: () => mac,
    md5_base64: () => md5_base64,
    md5_base64url: () => md5_base64url,
    md5_hex: () => md5_hex,
    nanoid: () => nanoid,
    null: () => _null,
    number: () => number,
    rfc5322Email: () => rfc5322Email,
    sha1_base64: () => sha1_base64,
    sha1_base64url: () => sha1_base64url,
    sha1_hex: () => sha1_hex,
    sha256_base64: () => sha256_base64,
    sha256_base64url: () => sha256_base64url,
    sha256_hex: () => sha256_hex,
    sha384_base64: () => sha384_base64,
    sha384_base64url: () => sha384_base64url,
    sha384_hex: () => sha384_hex,
    sha512_base64: () => sha512_base64,
    sha512_base64url: () => sha512_base64url,
    sha512_hex: () => sha512_hex,
    string: () => string,
    time: () => time,
    ulid: () => ulid,
    undefined: () => _undefined,
    unicodeEmail: () => unicodeEmail,
    uppercase: () => uppercase,
    uuid: () => uuid,
    uuid4: () => uuid4,
    uuid6: () => uuid6,
    uuid7: () => uuid7,
    xid: () => xid
  });
  var cuid = /^[cC][^\s-]{8,}$/;
  var cuid2 = /^[0-9a-z]+$/;
  var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
  var xid = /^[0-9a-vA-V]{20}$/;
  var ksuid = /^[A-Za-z0-9]{27}$/;
  var nanoid = /^[a-zA-Z0-9_-]{21}$/;
  var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
  var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
  var uuid = (version2) => {
    if (!version2)
      return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
    return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
  };
  var uuid4 = /* @__PURE__ */ uuid(4);
  var uuid6 = /* @__PURE__ */ uuid(6);
  var uuid7 = /* @__PURE__ */ uuid(7);
  var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
  var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
  var idnEmail = unicodeEmail;
  var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  function emoji() {
    return new RegExp(_emoji, "u");
  }
  var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
  var mac = (delimiter) => {
    const escapedDelim = escapeRegex(delimiter ?? ":");
    return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
  };
  var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
  var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
  var base64url = /^[A-Za-z0-9_-]*$/;
  var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
  var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
  var e164 = /^\+[1-9]\d{6,14}$/;
  var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
  var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
  function timeSource(args) {
    const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
    const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
    return regex;
  }
  function time(args) {
    return new RegExp(`^${timeSource(args)}$`);
  }
  function datetime(args) {
    const time3 = timeSource({ precision: args.precision });
    const opts = ["Z"];
    if (args.local)
      opts.push("");
    if (args.offset)
      opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
    const timeRegex = `${time3}(?:${opts.join("|")})`;
    return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
  }
  var string = (params) => {
    const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
    return new RegExp(`^${regex}$`);
  };
  var bigint = /^-?\d+n?$/;
  var integer = /^-?\d+$/;
  var number = /^-?\d+(?:\.\d+)?$/;
  var boolean = /^(?:true|false)$/i;
  var _null = /^null$/i;
  var _undefined = /^undefined$/i;
  var lowercase = /^[^A-Z]*$/;
  var uppercase = /^[^a-z]*$/;
  var hex = /^[0-9a-fA-F]*$/;
  function fixedBase64(bodyLength, padding) {
    return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
  }
  function fixedBase64url(length) {
    return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
  }
  var md5_hex = /^[0-9a-fA-F]{32}$/;
  var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
  var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
  var sha1_hex = /^[0-9a-fA-F]{40}$/;
  var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
  var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
  var sha256_hex = /^[0-9a-fA-F]{64}$/;
  var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
  var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
  var sha384_hex = /^[0-9a-fA-F]{96}$/;
  var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
  var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
  var sha512_hex = /^[0-9a-fA-F]{128}$/;
  var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
  var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

  // node_modules/zod/v4/core/checks.js
  var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
    var _a2;
    inst._zod ?? (inst._zod = {});
    inst._zod.def = def;
    (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
  });
  var numericOriginMap = {
    number: "number",
    bigint: "bigint",
    object: "date"
  };
  var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
      if (def.value < curr) {
        if (def.inclusive)
          bag.maximum = def.value;
        else
          bag.exclusiveMaximum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
      if (def.value > curr) {
        if (def.inclusive)
          bag.minimum = def.value;
        else
          bag.exclusiveMinimum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      var _a2;
      (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
    });
    inst._zod.check = (payload) => {
      if (typeof payload.value !== typeof def.value)
        throw new Error("Cannot mix number and bigint in multiple_of check.");
      const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
      if (isMultiple)
        return;
      payload.issues.push({
        origin: typeof payload.value,
        code: "not_multiple_of",
        divisor: def.value,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
    $ZodCheck.init(inst, def);
    def.format = def.format || "float64";
    const isInt = def.format?.includes("int");
    const origin = isInt ? "int" : "number";
    const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
      if (isInt)
        bag.pattern = integer;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      if (isInt) {
        if (!Number.isInteger(input)) {
          payload.issues.push({
            expected: origin,
            format: def.format,
            code: "invalid_type",
            continue: false,
            input,
            inst
          });
          return;
        }
        if (!Number.isSafeInteger(input)) {
          if (input > 0) {
            payload.issues.push({
              input,
              code: "too_big",
              maximum: Number.MAX_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              inclusive: true,
              continue: !def.abort
            });
          } else {
            payload.issues.push({
              input,
              code: "too_small",
              minimum: Number.MIN_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              inclusive: true,
              continue: !def.abort
            });
          }
          return;
        }
      }
      if (input < minimum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_small",
          minimum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_big",
          maximum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
    $ZodCheck.init(inst, def);
    const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      if (input < minimum) {
        payload.issues.push({
          origin: "bigint",
          input,
          code: "too_small",
          minimum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: "bigint",
          input,
          code: "too_big",
          maximum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
    var _a2;
    $ZodCheck.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr)
        inst2._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size <= def.maximum)
        return;
      payload.issues.push({
        origin: getSizableOrigin(input),
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
    var _a2;
    $ZodCheck.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr)
        inst2._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size >= def.minimum)
        return;
      payload.issues.push({
        origin: getSizableOrigin(input),
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
    var _a2;
    $ZodCheck.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.minimum = def.size;
      bag.maximum = def.size;
      bag.size = def.size;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size === def.size)
        return;
      const tooBig = size > def.size;
      payload.issues.push({
        origin: getSizableOrigin(input),
        ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
    var _a2;
    $ZodCheck.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr)
        inst2._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length <= def.maximum)
        return;
      const origin = getLengthableOrigin(input);
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
    var _a2;
    $ZodCheck.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr)
        inst2._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length >= def.minimum)
        return;
      const origin = getLengthableOrigin(input);
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
    var _a2;
    $ZodCheck.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== void 0;
    });
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.minimum = def.length;
      bag.maximum = def.length;
      bag.length = def.length;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length === def.length)
        return;
      const origin = getLengthableOrigin(input);
      const tooBig = length > def.length;
      payload.issues.push({
        origin,
        ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
    var _a2, _b;
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      if (def.pattern) {
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(def.pattern);
      }
    });
    if (def.pattern)
      (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          ...def.pattern ? { pattern: def.pattern.toString() } : {},
          inst,
          continue: !def.abort
        });
      });
    else
      (_b = inst._zod).check ?? (_b.check = () => {
      });
  });
  var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
    $ZodCheckStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "regex",
        input: payload.value,
        pattern: def.pattern.toString(),
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
    def.pattern ?? (def.pattern = lowercase);
    $ZodCheckStringFormat.init(inst, def);
  });
  var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
    def.pattern ?? (def.pattern = uppercase);
    $ZodCheckStringFormat.init(inst, def);
  });
  var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
    $ZodCheck.init(inst, def);
    const escapedRegex = escapeRegex(def.includes);
    const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
    def.pattern = pattern;
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.includes(def.includes, def.position))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "includes",
        includes: def.includes,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.startsWith(def.prefix))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "starts_with",
        prefix: def.prefix,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.endsWith(def.suffix))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "ends_with",
        suffix: def.suffix,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  function handleCheckPropertyResult(result, payload, property) {
    if (result.issues.length) {
      payload.issues.push(...prefixIssues(property, result.issues));
    }
  }
  var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
      const result = def.schema._zod.run({
        value: payload.value[def.property],
        issues: []
      }, {});
      if (result instanceof Promise) {
        return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
      }
      handleCheckPropertyResult(result, payload, def.property);
      return;
    };
  });
  var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
    $ZodCheck.init(inst, def);
    const mimeSet = new Set(def.mime);
    inst._zod.onattach.push((inst2) => {
      inst2._zod.bag.mime = def.mime;
    });
    inst._zod.check = (payload) => {
      if (mimeSet.has(payload.value.type))
        return;
      payload.issues.push({
        code: "invalid_value",
        values: def.mime,
        input: payload.value.type,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
      payload.value = def.tx(payload.value);
    };
  });

  // node_modules/zod/v4/core/doc.js
  var Doc = class {
    constructor(args = []) {
      this.content = [];
      this.indent = 0;
      if (this)
        this.args = args;
    }
    indented(fn) {
      this.indent += 1;
      fn(this);
      this.indent -= 1;
    }
    write(arg) {
      if (typeof arg === "function") {
        arg(this, { execution: "sync" });
        arg(this, { execution: "async" });
        return;
      }
      const content = arg;
      const lines = content.split("\n").filter((x) => x);
      const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
      const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
      for (const line of dedented) {
        this.content.push(line);
      }
    }
    compile() {
      const F = Function;
      const args = this?.args;
      const content = this?.content ?? [``];
      const lines = [...content.map((x) => `  ${x}`)];
      return new F(...args, lines.join("\n"));
    }
  };

  // node_modules/zod/v4/core/versions.js
  var version = {
    major: 4,
    minor: 3,
    patch: 6
  };

  // node_modules/zod/v4/core/schemas.js
  var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
    var _a2;
    inst ?? (inst = {});
    inst._zod.def = def;
    inst._zod.bag = inst._zod.bag || {};
    inst._zod.version = version;
    const checks = [...inst._zod.def.checks ?? []];
    if (inst._zod.traits.has("$ZodCheck")) {
      checks.unshift(inst);
    }
    for (const ch of checks) {
      for (const fn of ch._zod.onattach) {
        fn(inst);
      }
    }
    if (checks.length === 0) {
      (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
      inst._zod.deferred?.push(() => {
        inst._zod.run = inst._zod.parse;
      });
    } else {
      const runChecks = (payload, checks2, ctx) => {
        let isAborted = aborted(payload);
        let asyncResult;
        for (const ch of checks2) {
          if (ch._zod.def.when) {
            const shouldRun = ch._zod.def.when(payload);
            if (!shouldRun)
              continue;
          } else if (isAborted) {
            continue;
          }
          const currLen = payload.issues.length;
          const _ = ch._zod.check(payload);
          if (_ instanceof Promise && ctx?.async === false) {
            throw new $ZodAsyncError();
          }
          if (asyncResult || _ instanceof Promise) {
            asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
              await _;
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                return;
              if (!isAborted)
                isAborted = aborted(payload, currLen);
            });
          } else {
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              continue;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          }
        }
        if (asyncResult) {
          return asyncResult.then(() => {
            return payload;
          });
        }
        return payload;
      };
      const handleCanaryResult = (canary, payload, ctx) => {
        if (aborted(canary)) {
          canary.aborted = true;
          return canary;
        }
        const checkResult = runChecks(payload, checks, ctx);
        if (checkResult instanceof Promise) {
          if (ctx.async === false)
            throw new $ZodAsyncError();
          return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
        }
        return inst._zod.parse(checkResult, ctx);
      };
      inst._zod.run = (payload, ctx) => {
        if (ctx.skipChecks) {
          return inst._zod.parse(payload, ctx);
        }
        if (ctx.direction === "backward") {
          const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
          if (canary instanceof Promise) {
            return canary.then((canary2) => {
              return handleCanaryResult(canary2, payload, ctx);
            });
          }
          return handleCanaryResult(canary, payload, ctx);
        }
        const result = inst._zod.parse(payload, ctx);
        if (result instanceof Promise) {
          if (ctx.async === false)
            throw new $ZodAsyncError();
          return result.then((result2) => runChecks(result2, checks, ctx));
        }
        return runChecks(result, checks, ctx);
      };
    }
    defineLazy(inst, "~standard", () => ({
      validate: (value) => {
        try {
          const r = safeParse(inst, value);
          return r.success ? { value: r.data } : { issues: r.error?.issues };
        } catch (_) {
          return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
        }
      },
      vendor: "zod",
      version: 1
    }));
  });
  var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
    inst._zod.parse = (payload, _) => {
      if (def.coerce)
        try {
          payload.value = String(payload.value);
        } catch (_2) {
        }
      if (typeof payload.value === "string")
        return payload;
      payload.issues.push({
        expected: "string",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
    $ZodCheckStringFormat.init(inst, def);
    $ZodString.init(inst, def);
  });
  var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
    def.pattern ?? (def.pattern = guid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
    if (def.version) {
      const versionMap = {
        v1: 1,
        v2: 2,
        v3: 3,
        v4: 4,
        v5: 5,
        v6: 6,
        v7: 7,
        v8: 8
      };
      const v = versionMap[def.version];
      if (v === void 0)
        throw new Error(`Invalid UUID version: "${def.version}"`);
      def.pattern ?? (def.pattern = uuid(v));
    } else
      def.pattern ?? (def.pattern = uuid());
    $ZodStringFormat.init(inst, def);
  });
  var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
    def.pattern ?? (def.pattern = email);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      try {
        const trimmed = payload.value.trim();
        const url2 = new URL(trimmed);
        if (def.hostname) {
          def.hostname.lastIndex = 0;
          if (!def.hostname.test(url2.hostname)) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              note: "Invalid hostname",
              pattern: def.hostname.source,
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        }
        if (def.protocol) {
          def.protocol.lastIndex = 0;
          if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              note: "Invalid protocol",
              pattern: def.protocol.source,
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        }
        if (def.normalize) {
          payload.value = url2.href;
        } else {
          payload.value = trimmed;
        }
        return;
      } catch (_) {
        payload.issues.push({
          code: "invalid_format",
          format: "url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
    def.pattern ?? (def.pattern = emoji());
    $ZodStringFormat.init(inst, def);
  });
  var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
    def.pattern ?? (def.pattern = nanoid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
    def.pattern ?? (def.pattern = cuid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
    def.pattern ?? (def.pattern = cuid2);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
    def.pattern ?? (def.pattern = ulid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
    def.pattern ?? (def.pattern = xid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
    def.pattern ?? (def.pattern = ksuid);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
    def.pattern ?? (def.pattern = datetime(def));
    $ZodStringFormat.init(inst, def);
  });
  var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
    def.pattern ?? (def.pattern = date);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
    def.pattern ?? (def.pattern = time(def));
    $ZodStringFormat.init(inst, def);
  });
  var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
    def.pattern ?? (def.pattern = duration);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
    def.pattern ?? (def.pattern = ipv4);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.format = `ipv4`;
  });
  var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
    def.pattern ?? (def.pattern = ipv6);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.format = `ipv6`;
    inst._zod.check = (payload) => {
      try {
        new URL(`http://[${payload.value}]`);
      } catch {
        payload.issues.push({
          code: "invalid_format",
          format: "ipv6",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  var $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
    def.pattern ?? (def.pattern = mac(def.delimiter));
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.format = `mac`;
  });
  var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv4);
    $ZodStringFormat.init(inst, def);
  });
  var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv6);
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      const parts = payload.value.split("/");
      try {
        if (parts.length !== 2)
          throw new Error();
        const [address, prefix] = parts;
        if (!prefix)
          throw new Error();
        const prefixNum = Number(prefix);
        if (`${prefixNum}` !== prefix)
          throw new Error();
        if (prefixNum < 0 || prefixNum > 128)
          throw new Error();
        new URL(`http://[${address}]`);
      } catch {
        payload.issues.push({
          code: "invalid_format",
          format: "cidrv6",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  function isValidBase64(data) {
    if (data === "")
      return true;
    if (data.length % 4 !== 0)
      return false;
    try {
      atob(data);
      return true;
    } catch {
      return false;
    }
  }
  var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
    def.pattern ?? (def.pattern = base64);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.contentEncoding = "base64";
    inst._zod.check = (payload) => {
      if (isValidBase64(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  function isValidBase64URL(data) {
    if (!base64url.test(data))
      return false;
    const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
    const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
    return isValidBase64(padded);
  }
  var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
    def.pattern ?? (def.pattern = base64url);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.contentEncoding = "base64url";
    inst._zod.check = (payload) => {
      if (isValidBase64URL(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
    def.pattern ?? (def.pattern = e164);
    $ZodStringFormat.init(inst, def);
  });
  function isValidJWT(token, algorithm = null) {
    try {
      const tokensParts = token.split(".");
      if (tokensParts.length !== 3)
        return false;
      const [header] = tokensParts;
      if (!header)
        return false;
      const parsedHeader = JSON.parse(atob(header));
      if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
        return false;
      if (!parsedHeader.alg)
        return false;
      if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
        return false;
      return true;
    } catch {
      return false;
    }
  }
  var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      if (isValidJWT(payload.value, def.alg))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "jwt",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      if (def.fn(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = inst._zod.bag.pattern ?? number;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = Number(payload.value);
        } catch (_) {
        }
      const input = payload.value;
      if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
        return payload;
      }
      const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
      payload.issues.push({
        expected: "number",
        code: "invalid_type",
        input,
        inst,
        ...received ? { received } : {}
      });
      return payload;
    };
  });
  var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
    $ZodCheckNumberFormat.init(inst, def);
    $ZodNumber.init(inst, def);
  });
  var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = boolean;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = Boolean(payload.value);
        } catch (_) {
        }
      const input = payload.value;
      if (typeof input === "boolean")
        return payload;
      payload.issues.push({
        expected: "boolean",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = bigint;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = BigInt(payload.value);
        } catch (_) {
        }
      if (typeof payload.value === "bigint")
        return payload;
      payload.issues.push({
        expected: "bigint",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
    $ZodCheckBigIntFormat.init(inst, def);
    $ZodBigInt.init(inst, def);
  });
  var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "symbol")
        return payload;
      payload.issues.push({
        expected: "symbol",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = _undefined;
    inst._zod.values = /* @__PURE__ */ new Set([void 0]);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "undefined")
        return payload;
      payload.issues.push({
        expected: "undefined",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = _null;
    inst._zod.values = /* @__PURE__ */ new Set([null]);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (input === null)
        return payload;
      payload.issues.push({
        expected: "null",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload) => payload;
  });
  var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload) => payload;
  });
  var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      payload.issues.push({
        expected: "never",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "undefined")
        return payload;
      payload.issues.push({
        expected: "void",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce) {
        try {
          payload.value = new Date(payload.value);
        } catch (_err) {
        }
      }
      const input = payload.value;
      const isDate = input instanceof Date;
      const isValidDate = isDate && !Number.isNaN(input.getTime());
      if (isValidDate)
        return payload;
      payload.issues.push({
        expected: "date",
        code: "invalid_type",
        input,
        ...isDate ? { received: "Invalid Date" } : {},
        inst
      });
      return payload;
    };
  });
  function handleArrayResult(result, final, index) {
    if (result.issues.length) {
      final.issues.push(...prefixIssues(index, result.issues));
    }
    final.value[index] = result.value;
  }
  var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!Array.isArray(input)) {
        payload.issues.push({
          expected: "array",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      payload.value = Array(input.length);
      const proms = [];
      for (let i = 0; i < input.length; i++) {
        const item = input[i];
        const result = def.element._zod.run({
          value: item,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
        } else {
          handleArrayResult(result, payload, i);
        }
      }
      if (proms.length) {
        return Promise.all(proms).then(() => payload);
      }
      return payload;
    };
  });
  function handlePropertyResult(result, final, key, input, isOptionalOut) {
    if (result.issues.length) {
      if (isOptionalOut && !(key in input)) {
        return;
      }
      final.issues.push(...prefixIssues(key, result.issues));
    }
    if (result.value === void 0) {
      if (key in input) {
        final.value[key] = void 0;
      }
    } else {
      final.value[key] = result.value;
    }
  }
  function normalizeDef(def) {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
      if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      ...def,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  }
  function handleCatchall(proms, input, payload, ctx, def, inst) {
    const unrecognized = [];
    const keySet = def.keySet;
    const _catchall = def.catchall._zod;
    const t = _catchall.def.type;
    const isOptionalOut = _catchall.optout === "optional";
    for (const key in input) {
      if (keySet.has(key))
        continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
      } else {
        handlePropertyResult(r, payload, key, input, isOptionalOut);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  }
  var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
    $ZodType.init(inst, def);
    const desc = Object.getOwnPropertyDescriptor(def, "shape");
    if (!desc?.get) {
      const sh = def.shape;
      Object.defineProperty(def, "shape", {
        get: () => {
          const newSh = { ...sh };
          Object.defineProperty(def, "shape", {
            value: newSh
          });
          return newSh;
        }
      });
    }
    const _normalized = cached2(() => normalizeDef(def));
    defineLazy(inst._zod, "propValues", () => {
      const shape = def.shape;
      const propValues = {};
      for (const key in shape) {
        const field = shape[key]._zod;
        if (field.values) {
          propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
          for (const v of field.values)
            propValues[key].add(v);
        }
      }
      return propValues;
    });
    const isObject3 = isObject;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
      value ?? (value = _normalized.value);
      const input = payload.value;
      if (!isObject3(input)) {
        payload.issues.push({
          expected: "object",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      payload.value = {};
      const proms = [];
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const isOptionalOut = el._zod.optout === "optional";
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        if (r instanceof Promise) {
          proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
        } else {
          handlePropertyResult(r, payload, key, input, isOptionalOut);
        }
      }
      if (!catchall) {
        return proms.length ? Promise.all(proms).then(() => payload) : payload;
      }
      return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
    };
  });
  var $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
    $ZodObject.init(inst, def);
    const superParse = inst._zod.parse;
    const _normalized = cached2(() => normalizeDef(def));
    const generateFastpass = (shape) => {
      const doc = new Doc(["shape", "payload", "ctx"]);
      const normalized = _normalized.value;
      const parseStr = (key) => {
        const k = esc(key);
        return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
      };
      doc.write(`const input = payload.value;`);
      const ids = /* @__PURE__ */ Object.create(null);
      let counter = 0;
      for (const key of normalized.keys) {
        ids[key] = `key_${counter++}`;
      }
      doc.write(`const newResult = {};`);
      for (const key of normalized.keys) {
        const id2 = ids[key];
        const k = esc(key);
        const schema = shape[key];
        const isOptionalOut = schema?._zod?.optout === "optional";
        doc.write(`const ${id2} = ${parseStr(key)};`);
        if (isOptionalOut) {
          doc.write(`
        if (${id2}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id2}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id2}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id2}.value;
        }
        
      `);
        } else {
          doc.write(`
        if (${id2}.issues.length) {
          payload.issues = payload.issues.concat(${id2}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id2}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id2}.value;
        }
        
      `);
        }
      }
      doc.write(`payload.value = newResult;`);
      doc.write(`return payload;`);
      const fn = doc.compile();
      return (payload, ctx) => fn(shape, payload, ctx);
    };
    let fastpass;
    const isObject3 = isObject;
    const jit = !globalConfig.jitless;
    const allowsEval2 = allowsEval;
    const fastEnabled = jit && allowsEval2.value;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
      value ?? (value = _normalized.value);
      const input = payload.value;
      if (!isObject3(input)) {
        payload.issues.push({
          expected: "object",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
        if (!fastpass)
          fastpass = generateFastpass(def.shape);
        payload = fastpass(payload, ctx);
        if (!catchall)
          return payload;
        return handleCatchall([], input, payload, ctx, value, inst);
      }
      return superParse(payload, ctx);
    };
  });
  function handleUnionResults(results, final, inst, ctx) {
    for (const result of results) {
      if (result.issues.length === 0) {
        final.value = result.value;
        return final;
      }
    }
    const nonaborted = results.filter((r) => !aborted(r));
    if (nonaborted.length === 1) {
      final.value = nonaborted[0].value;
      return nonaborted[0];
    }
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
    return final;
  }
  var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
    defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
    defineLazy(inst._zod, "values", () => {
      if (def.options.every((o) => o._zod.values)) {
        return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
      }
      return void 0;
    });
    defineLazy(inst._zod, "pattern", () => {
      if (def.options.every((o) => o._zod.pattern)) {
        const patterns = def.options.map((o) => o._zod.pattern);
        return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
      }
      return void 0;
    });
    const single = def.options.length === 1;
    const first = def.options[0]._zod.run;
    inst._zod.parse = (payload, ctx) => {
      if (single) {
        return first(payload, ctx);
      }
      let async = false;
      const results = [];
      for (const option of def.options) {
        const result = option._zod.run({
          value: payload.value,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          results.push(result);
          async = true;
        } else {
          if (result.issues.length === 0)
            return result;
          results.push(result);
        }
      }
      if (!async)
        return handleUnionResults(results, payload, inst, ctx);
      return Promise.all(results).then((results2) => {
        return handleUnionResults(results2, payload, inst, ctx);
      });
    };
  });
  function handleExclusiveUnionResults(results, final, inst, ctx) {
    const successes = results.filter((r) => r.issues.length === 0);
    if (successes.length === 1) {
      final.value = successes[0].value;
      return final;
    }
    if (successes.length === 0) {
      final.issues.push({
        code: "invalid_union",
        input: final.value,
        inst,
        errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      });
    } else {
      final.issues.push({
        code: "invalid_union",
        input: final.value,
        inst,
        errors: [],
        inclusive: false
      });
    }
    return final;
  }
  var $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
    $ZodUnion.init(inst, def);
    def.inclusive = false;
    const single = def.options.length === 1;
    const first = def.options[0]._zod.run;
    inst._zod.parse = (payload, ctx) => {
      if (single) {
        return first(payload, ctx);
      }
      let async = false;
      const results = [];
      for (const option of def.options) {
        const result = option._zod.run({
          value: payload.value,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          results.push(result);
          async = true;
        } else {
          results.push(result);
        }
      }
      if (!async)
        return handleExclusiveUnionResults(results, payload, inst, ctx);
      return Promise.all(results).then((results2) => {
        return handleExclusiveUnionResults(results2, payload, inst, ctx);
      });
    };
  });
  var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
    def.inclusive = false;
    $ZodUnion.init(inst, def);
    const _super = inst._zod.parse;
    defineLazy(inst._zod, "propValues", () => {
      const propValues = {};
      for (const option of def.options) {
        const pv = option._zod.propValues;
        if (!pv || Object.keys(pv).length === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
        for (const [k, v] of Object.entries(pv)) {
          if (!propValues[k])
            propValues[k] = /* @__PURE__ */ new Set();
          for (const val of v) {
            propValues[k].add(val);
          }
        }
      }
      return propValues;
    });
    const disc = cached2(() => {
      const opts = def.options;
      const map2 = /* @__PURE__ */ new Map();
      for (const o of opts) {
        const values = o._zod.propValues?.[def.discriminator];
        if (!values || values.size === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
        for (const v of values) {
          if (map2.has(v)) {
            throw new Error(`Duplicate discriminator value "${String(v)}"`);
          }
          map2.set(v, o);
        }
      }
      return map2;
    });
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!isObject(input)) {
        payload.issues.push({
          code: "invalid_type",
          expected: "object",
          input,
          inst
        });
        return payload;
      }
      const opt = disc.value.get(input?.[def.discriminator]);
      if (opt) {
        return opt._zod.run(payload, ctx);
      }
      if (def.unionFallback) {
        return _super(payload, ctx);
      }
      payload.issues.push({
        code: "invalid_union",
        errors: [],
        note: "No matching discriminator",
        discriminator: def.discriminator,
        input,
        path: [def.discriminator],
        inst
      });
      return payload;
    };
  });
  var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      const left = def.left._zod.run({ value: input, issues: [] }, ctx);
      const right = def.right._zod.run({ value: input, issues: [] }, ctx);
      const async = left instanceof Promise || right instanceof Promise;
      if (async) {
        return Promise.all([left, right]).then(([left2, right2]) => {
          return handleIntersectionResults(payload, left2, right2);
        });
      }
      return handleIntersectionResults(payload, left, right);
    };
  });
  function mergeValues(a, b) {
    if (a === b) {
      return { valid: true, data: a };
    }
    if (a instanceof Date && b instanceof Date && +a === +b) {
      return { valid: true, data: a };
    }
    if (isPlainObject(a) && isPlainObject(b)) {
      const bKeys = Object.keys(b);
      const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return {
            valid: false,
            mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
          };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    }
    if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) {
        return { valid: false, mergeErrorPath: [] };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return {
            valid: false,
            mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
          };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    }
    return { valid: false, mergeErrorPath: [] };
  }
  function handleIntersectionResults(result, left, right) {
    const unrecKeys = /* @__PURE__ */ new Map();
    let unrecIssue;
    for (const iss of left.issues) {
      if (iss.code === "unrecognized_keys") {
        unrecIssue ?? (unrecIssue = iss);
        for (const k of iss.keys) {
          if (!unrecKeys.has(k))
            unrecKeys.set(k, {});
          unrecKeys.get(k).l = true;
        }
      } else {
        result.issues.push(iss);
      }
    }
    for (const iss of right.issues) {
      if (iss.code === "unrecognized_keys") {
        for (const k of iss.keys) {
          if (!unrecKeys.has(k))
            unrecKeys.set(k, {});
          unrecKeys.get(k).r = true;
        }
      } else {
        result.issues.push(iss);
      }
    }
    const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
    if (bothKeys.length && unrecIssue) {
      result.issues.push({ ...unrecIssue, keys: bothKeys });
    }
    if (aborted(result))
      return result;
    const merged = mergeValues(left.value, right.value);
    if (!merged.valid) {
      throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
    }
    result.value = merged.data;
    return result;
  }
  var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
    $ZodType.init(inst, def);
    const items = def.items;
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!Array.isArray(input)) {
        payload.issues.push({
          input,
          inst,
          expected: "tuple",
          code: "invalid_type"
        });
        return payload;
      }
      payload.value = [];
      const proms = [];
      const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
      const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
      if (!def.rest) {
        const tooBig = input.length > items.length;
        const tooSmall = input.length < optStart - 1;
        if (tooBig || tooSmall) {
          payload.issues.push({
            ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
            input,
            inst,
            origin: "array"
          });
          return payload;
        }
      }
      let i = -1;
      for (const item of items) {
        i++;
        if (i >= input.length) {
          if (i >= optStart)
            continue;
        }
        const result = item._zod.run({
          value: input[i],
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
      if (def.rest) {
        const rest = input.slice(items.length);
        for (const el of rest) {
          i++;
          const result = def.rest._zod.run({
            value: el,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
          } else {
            handleTupleResult(result, payload, i);
          }
        }
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  function handleTupleResult(result, final, index) {
    if (result.issues.length) {
      final.issues.push(...prefixIssues(index, result.issues));
    }
    final.value[index] = result.value;
  }
  var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!isPlainObject(input)) {
        payload.issues.push({
          expected: "record",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      const proms = [];
      const values = def.keyType._zod.values;
      if (values) {
        payload.value = {};
        const recordKeys = /* @__PURE__ */ new Set();
        for (const key of values) {
          if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
            recordKeys.add(typeof key === "number" ? key.toString() : key);
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues(key, result2.issues));
                }
                payload.value[key] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues(key, result.issues));
              }
              payload.value[key] = result.value;
            }
          }
        }
        let unrecognized;
        for (const key in input) {
          if (!recordKeys.has(key)) {
            unrecognized = unrecognized ?? [];
            unrecognized.push(key);
          }
        }
        if (unrecognized && unrecognized.length > 0) {
          payload.issues.push({
            code: "unrecognized_keys",
            input,
            inst,
            keys: unrecognized
          });
        }
      } else {
        payload.value = {};
        for (const key of Reflect.ownKeys(input)) {
          if (key === "__proto__")
            continue;
          let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          if (keyResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          const checkNumericKey = typeof key === "string" && number.test(key) && keyResult.issues.length;
          if (checkNumericKey) {
            const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
            if (retryResult instanceof Promise) {
              throw new Error("Async schemas not supported in object keys currently");
            }
            if (retryResult.issues.length === 0) {
              keyResult = retryResult;
            }
          }
          if (keyResult.issues.length) {
            if (def.mode === "loose") {
              payload.value[key] = input[key];
            } else {
              payload.issues.push({
                code: "invalid_key",
                origin: "record",
                issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                input: key,
                path: [key],
                inst
              });
            }
            continue;
          }
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[keyResult.value] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[keyResult.value] = result.value;
          }
        }
      }
      if (proms.length) {
        return Promise.all(proms).then(() => payload);
      }
      return payload;
    };
  });
  var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!(input instanceof Map)) {
        payload.issues.push({
          expected: "map",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      const proms = [];
      payload.value = /* @__PURE__ */ new Map();
      for (const [key, value] of input) {
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
        if (keyResult instanceof Promise || valueResult instanceof Promise) {
          proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
            handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
          }));
        } else {
          handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
        }
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
    if (keyResult.issues.length) {
      if (propertyKeyTypes.has(typeof key)) {
        final.issues.push(...prefixIssues(key, keyResult.issues));
      } else {
        final.issues.push({
          code: "invalid_key",
          origin: "map",
          input,
          inst,
          issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        });
      }
    }
    if (valueResult.issues.length) {
      if (propertyKeyTypes.has(typeof key)) {
        final.issues.push(...prefixIssues(key, valueResult.issues));
      } else {
        final.issues.push({
          origin: "map",
          code: "invalid_element",
          input,
          inst,
          key,
          issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        });
      }
    }
    final.value.set(keyResult.value, valueResult.value);
  }
  var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!(input instanceof Set)) {
        payload.issues.push({
          input,
          inst,
          expected: "set",
          code: "invalid_type"
        });
        return payload;
      }
      const proms = [];
      payload.value = /* @__PURE__ */ new Set();
      for (const item of input) {
        const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleSetResult(result2, payload)));
        } else
          handleSetResult(result, payload);
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  function handleSetResult(result, final) {
    if (result.issues.length) {
      final.issues.push(...result.issues);
    }
    final.value.add(result.value);
  }
  var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
    $ZodType.init(inst, def);
    const values = getEnumValues(def.entries);
    const valuesSet = new Set(values);
    inst._zod.values = valuesSet;
    inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (valuesSet.has(input)) {
        return payload;
      }
      payload.issues.push({
        code: "invalid_value",
        values,
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
    $ZodType.init(inst, def);
    if (def.values.length === 0) {
      throw new Error("Cannot create literal schema with no valid values");
    }
    const values = new Set(def.values);
    inst._zod.values = values;
    inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (values.has(input)) {
        return payload;
      }
      payload.issues.push({
        code: "invalid_value",
        values: def.values,
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (input instanceof File)
        return payload;
      payload.issues.push({
        expected: "file",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        throw new $ZodEncodeError(inst.constructor.name);
      }
      const _out = def.transform(payload.value, payload);
      if (ctx.async) {
        const output = _out instanceof Promise ? _out : Promise.resolve(_out);
        return output.then((output2) => {
          payload.value = output2;
          return payload;
        });
      }
      if (_out instanceof Promise) {
        throw new $ZodAsyncError();
      }
      payload.value = _out;
      return payload;
    };
  });
  function handleOptionalResult(result, input) {
    if (result.issues.length && input === void 0) {
      return { issues: [], value: void 0 };
    }
    return result;
  }
  var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    defineLazy(inst._zod, "values", () => {
      return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
    });
    defineLazy(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
    });
    inst._zod.parse = (payload, ctx) => {
      if (def.innerType._zod.optin === "optional") {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise)
          return result.then((r) => handleOptionalResult(r, payload.value));
        return handleOptionalResult(result, payload.value);
      }
      if (payload.value === void 0) {
        return payload;
      }
      return def.innerType._zod.run(payload, ctx);
    };
  });
  var $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
    $ZodOptional.init(inst, def);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
    inst._zod.parse = (payload, ctx) => {
      return def.innerType._zod.run(payload, ctx);
    };
  });
  var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
    });
    defineLazy(inst._zod, "values", () => {
      return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
    });
    inst._zod.parse = (payload, ctx) => {
      if (payload.value === null)
        return payload;
      return def.innerType._zod.run(payload, ctx);
    };
  });
  var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      if (payload.value === void 0) {
        payload.value = def.defaultValue;
        return payload;
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => handleDefaultResult(result2, def));
      }
      return handleDefaultResult(result, def);
    };
  });
  function handleDefaultResult(payload, def) {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return payload;
  }
  var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      if (payload.value === void 0) {
        payload.value = def.defaultValue;
      }
      return def.innerType._zod.run(payload, ctx);
    };
  });
  var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => {
      const v = def.innerType._zod.values;
      return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
    });
    inst._zod.parse = (payload, ctx) => {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => handleNonOptionalResult(result2, inst));
      }
      return handleNonOptionalResult(result, inst);
    };
  });
  function handleNonOptionalResult(payload, inst) {
    if (!payload.issues.length && payload.value === void 0) {
      payload.issues.push({
        code: "invalid_type",
        expected: "nonoptional",
        input: payload.value,
        inst
      });
    }
    return payload;
  }
  var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        throw new $ZodEncodeError("ZodSuccess");
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => {
          payload.value = result2.issues.length === 0;
          return payload;
        });
      }
      payload.value = result.issues.length === 0;
      return payload;
    };
  });
  var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => {
          payload.value = result2.value;
          if (result2.issues.length) {
            payload.value = def.catchValue({
              ...payload,
              error: {
                issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
              },
              input: payload.value
            });
            payload.issues = [];
          }
          return payload;
        });
      }
      payload.value = result.value;
      if (result.issues.length) {
        payload.value = def.catchValue({
          ...payload,
          error: {
            issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
          },
          input: payload.value
        });
        payload.issues = [];
      }
      return payload;
    };
  });
  var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
        payload.issues.push({
          input: payload.value,
          inst,
          expected: "nan",
          code: "invalid_type"
        });
        return payload;
      }
      return payload;
    };
  });
  var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => def.in._zod.values);
    defineLazy(inst._zod, "optin", () => def.in._zod.optin);
    defineLazy(inst._zod, "optout", () => def.out._zod.optout);
    defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        const right = def.out._zod.run(payload, ctx);
        if (right instanceof Promise) {
          return right.then((right2) => handlePipeResult(right2, def.in, ctx));
        }
        return handlePipeResult(right, def.in, ctx);
      }
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handlePipeResult(left2, def.out, ctx));
      }
      return handlePipeResult(left, def.out, ctx);
    };
  });
  function handlePipeResult(left, next, ctx) {
    if (left.issues.length) {
      left.aborted = true;
      return left;
    }
    return next._zod.run({ value: left.value, issues: left.issues }, ctx);
  }
  var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => def.in._zod.values);
    defineLazy(inst._zod, "optin", () => def.in._zod.optin);
    defineLazy(inst._zod, "optout", () => def.out._zod.optout);
    defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
      const direction = ctx.direction || "forward";
      if (direction === "forward") {
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handleCodecAResult(left2, def, ctx));
        }
        return handleCodecAResult(left, def, ctx);
      } else {
        const right = def.out._zod.run(payload, ctx);
        if (right instanceof Promise) {
          return right.then((right2) => handleCodecAResult(right2, def, ctx));
        }
        return handleCodecAResult(right, def, ctx);
      }
    };
  });
  function handleCodecAResult(result, def, ctx) {
    if (result.issues.length) {
      result.aborted = true;
      return result;
    }
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const transformed = def.transform(result.value, result);
      if (transformed instanceof Promise) {
        return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
      }
      return handleCodecTxResult(result, transformed, def.out, ctx);
    } else {
      const transformed = def.reverseTransform(result.value, result);
      if (transformed instanceof Promise) {
        return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
      }
      return handleCodecTxResult(result, transformed, def.in, ctx);
    }
  }
  function handleCodecTxResult(left, value, nextSchema, ctx) {
    if (left.issues.length) {
      left.aborted = true;
      return left;
    }
    return nextSchema._zod.run({ value, issues: left.issues }, ctx);
  }
  var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
    defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then(handleReadonlyResult);
      }
      return handleReadonlyResult(result);
    };
  });
  function handleReadonlyResult(payload) {
    payload.value = Object.freeze(payload.value);
    return payload;
  }
  var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
    $ZodType.init(inst, def);
    const regexParts = [];
    for (const part of def.parts) {
      if (typeof part === "object" && part !== null) {
        if (!part._zod.pattern) {
          throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
        }
        const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
        if (!source)
          throw new Error(`Invalid template literal part: ${part._zod.traits}`);
        const start = source.startsWith("^") ? 1 : 0;
        const end = source.endsWith("$") ? source.length - 1 : source.length;
        regexParts.push(source.slice(start, end));
      } else if (part === null || primitiveTypes.has(typeof part)) {
        regexParts.push(escapeRegex(`${part}`));
      } else {
        throw new Error(`Invalid template literal part: ${part}`);
      }
    }
    inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "string") {
        payload.issues.push({
          input: payload.value,
          inst,
          expected: "string",
          code: "invalid_type"
        });
        return payload;
      }
      inst._zod.pattern.lastIndex = 0;
      if (!inst._zod.pattern.test(payload.value)) {
        payload.issues.push({
          input: payload.value,
          inst,
          code: "invalid_format",
          format: def.format ?? "template_literal",
          pattern: inst._zod.pattern.source
        });
        return payload;
      }
      return payload;
    };
  });
  var $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
    $ZodType.init(inst, def);
    inst._def = def;
    inst._zod.def = def;
    inst.implement = (func) => {
      if (typeof func !== "function") {
        throw new Error("implement() must be called with a function");
      }
      return function(...args) {
        const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
        const result = Reflect.apply(func, this, parsedArgs);
        if (inst._def.output) {
          return parse(inst._def.output, result);
        }
        return result;
      };
    };
    inst.implementAsync = (func) => {
      if (typeof func !== "function") {
        throw new Error("implementAsync() must be called with a function");
      }
      return async function(...args) {
        const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
        const result = await Reflect.apply(func, this, parsedArgs);
        if (inst._def.output) {
          return await parseAsync(inst._def.output, result);
        }
        return result;
      };
    };
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "function") {
        payload.issues.push({
          code: "invalid_type",
          expected: "function",
          input: payload.value,
          inst
        });
        return payload;
      }
      const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
      if (hasPromiseOutput) {
        payload.value = inst.implementAsync(payload.value);
      } else {
        payload.value = inst.implement(payload.value);
      }
      return payload;
    };
    inst.input = (...args) => {
      const F = inst.constructor;
      if (Array.isArray(args[0])) {
        return new F({
          type: "function",
          input: new $ZodTuple({
            type: "tuple",
            items: args[0],
            rest: args[1]
          }),
          output: inst._def.output
        });
      }
      return new F({
        type: "function",
        input: args[0],
        output: inst._def.output
      });
    };
    inst.output = (output) => {
      const F = inst.constructor;
      return new F({
        type: "function",
        input: inst._def.input,
        output
      });
    };
    return inst;
  });
  var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
    };
  });
  var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "innerType", () => def.getter());
    defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
    defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
    defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0);
    defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0);
    inst._zod.parse = (payload, ctx) => {
      const inner = inst._zod.innerType;
      return inner._zod.run(payload, ctx);
    };
  });
  var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
    $ZodCheck.init(inst, def);
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _) => {
      return payload;
    };
    inst._zod.check = (payload) => {
      const input = payload.value;
      const r = def.fn(input);
      if (r instanceof Promise) {
        return r.then((r2) => handleRefineResult(r2, payload, input, inst));
      }
      handleRefineResult(r, payload, input, inst);
      return;
    };
  });
  function handleRefineResult(result, payload, input, inst) {
    if (!result) {
      const _iss = {
        code: "custom",
        input,
        inst,
        // incorporates params.error into issue reporting
        path: [...inst._zod.def.path ?? []],
        // incorporates params.error into issue reporting
        continue: !inst._zod.def.abort
        // params: inst._zod.def.params,
      };
      if (inst._zod.def.params)
        _iss.params = inst._zod.def.params;
      payload.issues.push(issue(_iss));
    }
  }

  // node_modules/zod/v4/locales/index.js
  var locales_exports = {};
  __export(locales_exports, {
    ar: () => ar_default,
    az: () => az_default,
    be: () => be_default,
    bg: () => bg_default,
    ca: () => ca_default,
    cs: () => cs_default,
    da: () => da_default,
    de: () => de_default,
    en: () => en_default,
    eo: () => eo_default,
    es: () => es_default,
    fa: () => fa_default,
    fi: () => fi_default,
    fr: () => fr_default,
    frCA: () => fr_CA_default,
    he: () => he_default,
    hu: () => hu_default,
    hy: () => hy_default,
    id: () => id_default,
    is: () => is_default,
    it: () => it_default,
    ja: () => ja_default,
    ka: () => ka_default,
    kh: () => kh_default,
    km: () => km_default,
    ko: () => ko_default,
    lt: () => lt_default,
    mk: () => mk_default,
    ms: () => ms_default,
    nl: () => nl_default,
    no: () => no_default,
    ota: () => ota_default,
    pl: () => pl_default,
    ps: () => ps_default,
    pt: () => pt_default,
    ru: () => ru_default,
    sl: () => sl_default,
    sv: () => sv_default,
    ta: () => ta_default,
    th: () => th_default,
    tr: () => tr_default,
    ua: () => ua_default,
    uk: () => uk_default,
    ur: () => ur_default,
    uz: () => uz_default,
    vi: () => vi_default,
    yo: () => yo_default,
    zhCN: () => zh_CN_default,
    zhTW: () => zh_TW_default
  });

  // node_modules/zod/v4/locales/ar.js
  var error = () => {
    const Sizable = {
      string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
      file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
      array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
      set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0645\u062F\u062E\u0644",
      email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
      url: "\u0631\u0627\u0628\u0637",
      emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
      ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
      cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
      cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
      base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
      base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
      json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
      e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
      jwt: "JWT",
      template_literal: "\u0645\u062F\u062E\u0644"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 instanceof ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
          }
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
          return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
          return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
          return `${FormatDictionary[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
        }
        case "not_multiple_of":
          return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
        case "invalid_key":
          return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
        case "invalid_union":
          return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
        case "invalid_element":
          return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
        default:
          return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      }
    };
  };
  function ar_default() {
    return {
      localeError: error()
    };
  }

  // node_modules/zod/v4/locales/az.js
  var error2 = () => {
    const Sizable = {
      string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
      file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
      array: { unit: "element", verb: "olmal\u0131d\u0131r" },
      set: { unit: "element", verb: "olmal\u0131d\u0131r" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "input",
      email: "email address",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datetime",
      date: "ISO date",
      time: "ISO time",
      duration: "ISO duration",
      ipv4: "IPv4 address",
      ipv6: "IPv6 address",
      cidrv4: "IPv4 range",
      cidrv6: "IPv6 range",
      base64: "base64-encoded string",
      base64url: "base64url-encoded string",
      json_string: "JSON string",
      e164: "E.164 number",
      jwt: "JWT",
      template_literal: "input"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n instanceof ${issue2.expected}, daxil olan ${received}`;
          }
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${expected}, daxil olan ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
          return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
          if (_issue.format === "ends_with")
            return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
          if (_issue.format === "includes")
            return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
          if (_issue.format === "regex")
            return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
          return `Yanl\u0131\u015F ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
        case "unrecognized_keys":
          return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
        case "invalid_union":
          return "Yanl\u0131\u015F d\u0259y\u0259r";
        case "invalid_element":
          return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
        default:
          return `Yanl\u0131\u015F d\u0259y\u0259r`;
      }
    };
  };
  function az_default() {
    return {
      localeError: error2()
    };
  }

  // node_modules/zod/v4/locales/be.js
  function getBelarusianPlural(count, one, few, many) {
    const absCount = Math.abs(count);
    const lastDigit = absCount % 10;
    const lastTwoDigits = absCount % 100;
    if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
      return many;
    }
    if (lastDigit === 1) {
      return one;
    }
    if (lastDigit >= 2 && lastDigit <= 4) {
      return few;
    }
    return many;
  }
  var error3 = () => {
    const Sizable = {
      string: {
        unit: {
          one: "\u0441\u0456\u043C\u0432\u0430\u043B",
          few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
          many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
        },
        verb: "\u043C\u0435\u0446\u044C"
      },
      array: {
        unit: {
          one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
          few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
          many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
        },
        verb: "\u043C\u0435\u0446\u044C"
      },
      set: {
        unit: {
          one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
          few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
          many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
        },
        verb: "\u043C\u0435\u0446\u044C"
      },
      file: {
        unit: {
          one: "\u0431\u0430\u0439\u0442",
          few: "\u0431\u0430\u0439\u0442\u044B",
          many: "\u0431\u0430\u0439\u0442\u0430\u045E"
        },
        verb: "\u043C\u0435\u0446\u044C"
      }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0443\u0432\u043E\u0434",
      email: "email \u0430\u0434\u0440\u0430\u0441",
      url: "URL",
      emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
      date: "ISO \u0434\u0430\u0442\u0430",
      time: "ISO \u0447\u0430\u0441",
      duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
      ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
      ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
      cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
      cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
      base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
      base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
      json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
      e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
      jwt: "JWT",
      template_literal: "\u0443\u0432\u043E\u0434"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u043B\u0456\u043A",
      array: "\u043C\u0430\u0441\u0456\u045E"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F instanceof ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
          }
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            const maxValue = Number(issue2.maximum);
            const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
          }
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            const minValue = Number(issue2.minimum);
            const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
          }
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
        case "invalid_union":
          return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
        case "invalid_element":
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
        default:
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
      }
    };
  };
  function be_default() {
    return {
      localeError: error3()
    };
  }

  // node_modules/zod/v4/locales/bg.js
  var error4 = () => {
    const Sizable = {
      string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
      file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
      array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
      set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0432\u0445\u043E\u0434",
      email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
      url: "URL",
      emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
      date: "ISO \u0434\u0430\u0442\u0430",
      time: "ISO \u0432\u0440\u0435\u043C\u0435",
      duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
      ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
      ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
      cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
      cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
      base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
      base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
      json_string: "JSON \u043D\u0438\u0437",
      e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
      jwt: "JWT",
      template_literal: "\u0432\u0445\u043E\u0434"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0447\u0438\u0441\u043B\u043E",
      array: "\u043C\u0430\u0441\u0438\u0432"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
          }
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
          let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
          if (_issue.format === "emoji")
            invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
          if (_issue.format === "datetime")
            invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
          if (_issue.format === "date")
            invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
          if (_issue.format === "time")
            invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
          if (_issue.format === "duration")
            invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
          return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
        case "invalid_union":
          return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
        case "invalid_element":
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
        default:
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
      }
    };
  };
  function bg_default() {
    return {
      localeError: error4()
    };
  }

  // node_modules/zod/v4/locales/ca.js
  var error5 = () => {
    const Sizable = {
      string: { unit: "car\xE0cters", verb: "contenir" },
      file: { unit: "bytes", verb: "contenir" },
      array: { unit: "elements", verb: "contenir" },
      set: { unit: "elements", verb: "contenir" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "entrada",
      email: "adre\xE7a electr\xF2nica",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data i hora ISO",
      date: "data ISO",
      time: "hora ISO",
      duration: "durada ISO",
      ipv4: "adre\xE7a IPv4",
      ipv6: "adre\xE7a IPv6",
      cidrv4: "rang IPv4",
      cidrv6: "rang IPv6",
      base64: "cadena codificada en base64",
      base64url: "cadena codificada en base64url",
      json_string: "cadena JSON",
      e164: "n\xFAmero E.164",
      jwt: "JWT",
      template_literal: "entrada"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Tipus inv\xE0lid: s'esperava instanceof ${issue2.expected}, s'ha rebut ${received}`;
          }
          return `Tipus inv\xE0lid: s'esperava ${expected}, s'ha rebut ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
          return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
          return `Format inv\xE0lid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Clau inv\xE0lida a ${issue2.origin}`;
        case "invalid_union":
          return "Entrada inv\xE0lida";
        // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
        case "invalid_element":
          return `Element inv\xE0lid a ${issue2.origin}`;
        default:
          return `Entrada inv\xE0lida`;
      }
    };
  };
  function ca_default() {
    return {
      localeError: error5()
    };
  }

  // node_modules/zod/v4/locales/cs.js
  var error6 = () => {
    const Sizable = {
      string: { unit: "znak\u016F", verb: "m\xEDt" },
      file: { unit: "bajt\u016F", verb: "m\xEDt" },
      array: { unit: "prvk\u016F", verb: "m\xEDt" },
      set: { unit: "prvk\u016F", verb: "m\xEDt" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "regul\xE1rn\xED v\xFDraz",
      email: "e-mailov\xE1 adresa",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "datum a \u010Das ve form\xE1tu ISO",
      date: "datum ve form\xE1tu ISO",
      time: "\u010Das ve form\xE1tu ISO",
      duration: "doba trv\xE1n\xED ISO",
      ipv4: "IPv4 adresa",
      ipv6: "IPv6 adresa",
      cidrv4: "rozsah IPv4",
      cidrv6: "rozsah IPv6",
      base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
      base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
      json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
      e164: "\u010D\xEDslo E.164",
      jwt: "JWT",
      template_literal: "vstup"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u010D\xEDslo",
      string: "\u0159et\u011Bzec",
      function: "funkce",
      array: "pole"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no instanceof ${issue2.expected}, obdr\u017Eeno ${received}`;
          }
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${expected}, obdr\u017Eeno ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
          return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
          }
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
          }
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
          return `Neplatn\xFD form\xE1t ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
        case "invalid_union":
          return "Neplatn\xFD vstup";
        case "invalid_element":
          return `Neplatn\xE1 hodnota v ${issue2.origin}`;
        default:
          return `Neplatn\xFD vstup`;
      }
    };
  };
  function cs_default() {
    return {
      localeError: error6()
    };
  }

  // node_modules/zod/v4/locales/da.js
  var error7 = () => {
    const Sizable = {
      string: { unit: "tegn", verb: "havde" },
      file: { unit: "bytes", verb: "havde" },
      array: { unit: "elementer", verb: "indeholdt" },
      set: { unit: "elementer", verb: "indeholdt" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "input",
      email: "e-mailadresse",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO dato- og klokkesl\xE6t",
      date: "ISO-dato",
      time: "ISO-klokkesl\xE6t",
      duration: "ISO-varighed",
      ipv4: "IPv4-omr\xE5de",
      ipv6: "IPv6-omr\xE5de",
      cidrv4: "IPv4-spektrum",
      cidrv6: "IPv6-spektrum",
      base64: "base64-kodet streng",
      base64url: "base64url-kodet streng",
      json_string: "JSON-streng",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "input"
    };
    const TypeDictionary = {
      nan: "NaN",
      string: "streng",
      number: "tal",
      boolean: "boolean",
      array: "liste",
      object: "objekt",
      set: "s\xE6t",
      file: "fil"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;
          }
          return `Ugyldigt input: forventede ${expected}, fik ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
          return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
          if (sizing)
            return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
          return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
          if (sizing) {
            return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
          return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Ugyldig n\xF8gle i ${issue2.origin}`;
        case "invalid_union":
          return "Ugyldigt input: matcher ingen af de tilladte typer";
        case "invalid_element":
          return `Ugyldig v\xE6rdi i ${issue2.origin}`;
        default:
          return `Ugyldigt input`;
      }
    };
  };
  function da_default() {
    return {
      localeError: error7()
    };
  }

  // node_modules/zod/v4/locales/de.js
  var error8 = () => {
    const Sizable = {
      string: { unit: "Zeichen", verb: "zu haben" },
      file: { unit: "Bytes", verb: "zu haben" },
      array: { unit: "Elemente", verb: "zu haben" },
      set: { unit: "Elemente", verb: "zu haben" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "Eingabe",
      email: "E-Mail-Adresse",
      url: "URL",
      emoji: "Emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-Datum und -Uhrzeit",
      date: "ISO-Datum",
      time: "ISO-Uhrzeit",
      duration: "ISO-Dauer",
      ipv4: "IPv4-Adresse",
      ipv6: "IPv6-Adresse",
      cidrv4: "IPv4-Bereich",
      cidrv6: "IPv6-Bereich",
      base64: "Base64-codierter String",
      base64url: "Base64-URL-codierter String",
      json_string: "JSON-String",
      e164: "E.164-Nummer",
      jwt: "JWT",
      template_literal: "Eingabe"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "Zahl",
      array: "Array"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Ung\xFCltige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;
          }
          return `Ung\xFCltige Eingabe: erwartet ${expected}, erhalten ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
          return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
          return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
          }
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
          if (_issue.format === "ends_with")
            return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
          if (_issue.format === "includes")
            return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
          if (_issue.format === "regex")
            return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
          return `Ung\xFCltig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
        case "invalid_union":
          return "Ung\xFCltige Eingabe";
        case "invalid_element":
          return `Ung\xFCltiger Wert in ${issue2.origin}`;
        default:
          return `Ung\xFCltige Eingabe`;
      }
    };
  };
  function de_default() {
    return {
      localeError: error8()
    };
  }

  // node_modules/zod/v4/locales/en.js
  var error9 = () => {
    const Sizable = {
      string: { unit: "characters", verb: "to have" },
      file: { unit: "bytes", verb: "to have" },
      array: { unit: "items", verb: "to have" },
      set: { unit: "items", verb: "to have" },
      map: { unit: "entries", verb: "to have" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "input",
      email: "email address",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datetime",
      date: "ISO date",
      time: "ISO time",
      duration: "ISO duration",
      ipv4: "IPv4 address",
      ipv6: "IPv6 address",
      mac: "MAC address",
      cidrv4: "IPv4 range",
      cidrv6: "IPv6 range",
      base64: "base64-encoded string",
      base64url: "base64url-encoded string",
      json_string: "JSON string",
      e164: "E.164 number",
      jwt: "JWT",
      template_literal: "input"
    };
    const TypeDictionary = {
      // Compatibility: "nan" -> "NaN" for display
      nan: "NaN"
      // All other type names omitted - they fall back to raw values via ?? operator
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          return `Invalid input: expected ${expected}, received ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
          return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
          return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Invalid string: must start with "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Invalid string: must end with "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Invalid string: must include "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Invalid string: must match pattern ${_issue.pattern}`;
          return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Invalid number: must be a multiple of ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Invalid key in ${issue2.origin}`;
        case "invalid_union":
          return "Invalid input";
        case "invalid_element":
          return `Invalid value in ${issue2.origin}`;
        default:
          return `Invalid input`;
      }
    };
  };
  function en_default() {
    return {
      localeError: error9()
    };
  }

  // node_modules/zod/v4/locales/eo.js
  var error10 = () => {
    const Sizable = {
      string: { unit: "karaktrojn", verb: "havi" },
      file: { unit: "bajtojn", verb: "havi" },
      array: { unit: "elementojn", verb: "havi" },
      set: { unit: "elementojn", verb: "havi" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "enigo",
      email: "retadreso",
      url: "URL",
      emoji: "emo\u011Dio",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-datotempo",
      date: "ISO-dato",
      time: "ISO-tempo",
      duration: "ISO-da\u016Dro",
      ipv4: "IPv4-adreso",
      ipv6: "IPv6-adreso",
      cidrv4: "IPv4-rango",
      cidrv6: "IPv6-rango",
      base64: "64-ume kodita karaktraro",
      base64url: "URL-64-ume kodita karaktraro",
      json_string: "JSON-karaktraro",
      e164: "E.164-nombro",
      jwt: "JWT",
      template_literal: "enigo"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "nombro",
      array: "tabelo",
      null: "senvalora"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Nevalida enigo: atendi\u011Dis instanceof ${issue2.expected}, ricevi\u011Dis ${received}`;
          }
          return `Nevalida enigo: atendi\u011Dis ${expected}, ricevi\u011Dis ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
          return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
          return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
          return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Nevalida \u015Dlosilo en ${issue2.origin}`;
        case "invalid_union":
          return "Nevalida enigo";
        case "invalid_element":
          return `Nevalida valoro en ${issue2.origin}`;
        default:
          return `Nevalida enigo`;
      }
    };
  };
  function eo_default() {
    return {
      localeError: error10()
    };
  }

  // node_modules/zod/v4/locales/es.js
  var error11 = () => {
    const Sizable = {
      string: { unit: "caracteres", verb: "tener" },
      file: { unit: "bytes", verb: "tener" },
      array: { unit: "elementos", verb: "tener" },
      set: { unit: "elementos", verb: "tener" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "entrada",
      email: "direcci\xF3n de correo electr\xF3nico",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "fecha y hora ISO",
      date: "fecha ISO",
      time: "hora ISO",
      duration: "duraci\xF3n ISO",
      ipv4: "direcci\xF3n IPv4",
      ipv6: "direcci\xF3n IPv6",
      cidrv4: "rango IPv4",
      cidrv6: "rango IPv6",
      base64: "cadena codificada en base64",
      base64url: "URL codificada en base64",
      json_string: "cadena JSON",
      e164: "n\xFAmero E.164",
      jwt: "JWT",
      template_literal: "entrada"
    };
    const TypeDictionary = {
      nan: "NaN",
      string: "texto",
      number: "n\xFAmero",
      boolean: "booleano",
      array: "arreglo",
      object: "objeto",
      set: "conjunto",
      file: "archivo",
      date: "fecha",
      bigint: "n\xFAmero grande",
      symbol: "s\xEDmbolo",
      undefined: "indefinido",
      null: "nulo",
      function: "funci\xF3n",
      map: "mapa",
      record: "registro",
      tuple: "tupla",
      enum: "enumeraci\xF3n",
      union: "uni\xF3n",
      literal: "literal",
      promise: "promesa",
      void: "vac\xEDo",
      never: "nunca",
      unknown: "desconocido",
      any: "cualquiera"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Entrada inv\xE1lida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;
          }
          return `Entrada inv\xE1lida: se esperaba ${expected}, recibido ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
          return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
          if (sizing)
            return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
          if (sizing) {
            return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
          return `Inv\xE1lido ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Llave inv\xE1lida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
        case "invalid_union":
          return "Entrada inv\xE1lida";
        case "invalid_element":
          return `Valor inv\xE1lido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
        default:
          return `Entrada inv\xE1lida`;
      }
    };
  };
  function es_default() {
    return {
      localeError: error11()
    };
  }

  // node_modules/zod/v4/locales/fa.js
  var error12 = () => {
    const Sizable = {
      string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
      file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
      array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
      set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0648\u0631\u0648\u062F\u06CC",
      email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
      url: "URL",
      emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
      date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
      time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
      duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
      ipv4: "IPv4 \u0622\u062F\u0631\u0633",
      ipv6: "IPv6 \u0622\u062F\u0631\u0633",
      cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
      cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
      base64: "base64-encoded \u0631\u0634\u062A\u0647",
      base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
      json_string: "JSON \u0631\u0634\u062A\u0647",
      e164: "E.164 \u0639\u062F\u062F",
      jwt: "JWT",
      template_literal: "\u0648\u0631\u0648\u062F\u06CC"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0639\u062F\u062F",
      array: "\u0622\u0631\u0627\u06CC\u0647"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A instanceof ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
          }
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
        }
        case "invalid_value":
          if (issue2.values.length === 1) {
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
          }
          return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
          }
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
          }
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
          }
          if (_issue.format === "ends_with") {
            return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
          }
          if (_issue.format === "includes") {
            return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
          }
          if (_issue.format === "regex") {
            return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
          }
          return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
        }
        case "not_multiple_of":
          return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
        case "unrecognized_keys":
          return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
        case "invalid_union":
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
        case "invalid_element":
          return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
        default:
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
    };
  };
  function fa_default() {
    return {
      localeError: error12()
    };
  }

  // node_modules/zod/v4/locales/fi.js
  var error13 = () => {
    const Sizable = {
      string: { unit: "merkki\xE4", subject: "merkkijonon" },
      file: { unit: "tavua", subject: "tiedoston" },
      array: { unit: "alkiota", subject: "listan" },
      set: { unit: "alkiota", subject: "joukon" },
      number: { unit: "", subject: "luvun" },
      bigint: { unit: "", subject: "suuren kokonaisluvun" },
      int: { unit: "", subject: "kokonaisluvun" },
      date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "s\xE4\xE4nn\xF6llinen lauseke",
      email: "s\xE4hk\xF6postiosoite",
      url: "URL-osoite",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-aikaleima",
      date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
      time: "ISO-aika",
      duration: "ISO-kesto",
      ipv4: "IPv4-osoite",
      ipv6: "IPv6-osoite",
      cidrv4: "IPv4-alue",
      cidrv6: "IPv6-alue",
      base64: "base64-koodattu merkkijono",
      base64url: "base64url-koodattu merkkijono",
      json_string: "JSON-merkkijono",
      e164: "E.164-luku",
      jwt: "JWT",
      template_literal: "templaattimerkkijono"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;
          }
          return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
          return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
          }
          return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
          }
          return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
          if (_issue.format === "regex") {
            return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
          }
          return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return "Virheellinen avain tietueessa";
        case "invalid_union":
          return "Virheellinen unioni";
        case "invalid_element":
          return "Virheellinen arvo joukossa";
        default:
          return `Virheellinen sy\xF6te`;
      }
    };
  };
  function fi_default() {
    return {
      localeError: error13()
    };
  }

  // node_modules/zod/v4/locales/fr.js
  var error14 = () => {
    const Sizable = {
      string: { unit: "caract\xE8res", verb: "avoir" },
      file: { unit: "octets", verb: "avoir" },
      array: { unit: "\xE9l\xE9ments", verb: "avoir" },
      set: { unit: "\xE9l\xE9ments", verb: "avoir" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "entr\xE9e",
      email: "adresse e-mail",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "date et heure ISO",
      date: "date ISO",
      time: "heure ISO",
      duration: "dur\xE9e ISO",
      ipv4: "adresse IPv4",
      ipv6: "adresse IPv6",
      cidrv4: "plage IPv4",
      cidrv6: "plage IPv6",
      base64: "cha\xEEne encod\xE9e en base64",
      base64url: "cha\xEEne encod\xE9e en base64url",
      json_string: "cha\xEEne JSON",
      e164: "num\xE9ro E.164",
      jwt: "JWT",
      template_literal: "entr\xE9e"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "nombre",
      array: "tableau"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Entr\xE9e invalide : instanceof ${issue2.expected} attendu, ${received} re\xE7u`;
          }
          return `Entr\xE9e invalide : ${expected} attendu, ${received} re\xE7u`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
          return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
          return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
          return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
        }
        case "not_multiple_of":
          return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Cl\xE9 invalide dans ${issue2.origin}`;
        case "invalid_union":
          return "Entr\xE9e invalide";
        case "invalid_element":
          return `Valeur invalide dans ${issue2.origin}`;
        default:
          return `Entr\xE9e invalide`;
      }
    };
  };
  function fr_default() {
    return {
      localeError: error14()
    };
  }

  // node_modules/zod/v4/locales/fr-CA.js
  var error15 = () => {
    const Sizable = {
      string: { unit: "caract\xE8res", verb: "avoir" },
      file: { unit: "octets", verb: "avoir" },
      array: { unit: "\xE9l\xE9ments", verb: "avoir" },
      set: { unit: "\xE9l\xE9ments", verb: "avoir" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "entr\xE9e",
      email: "adresse courriel",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "date-heure ISO",
      date: "date ISO",
      time: "heure ISO",
      duration: "dur\xE9e ISO",
      ipv4: "adresse IPv4",
      ipv6: "adresse IPv6",
      cidrv4: "plage IPv4",
      cidrv6: "plage IPv6",
      base64: "cha\xEEne encod\xE9e en base64",
      base64url: "cha\xEEne encod\xE9e en base64url",
      json_string: "cha\xEEne JSON",
      e164: "num\xE9ro E.164",
      jwt: "JWT",
      template_literal: "entr\xE9e"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Entr\xE9e invalide : attendu instanceof ${issue2.expected}, re\xE7u ${received}`;
          }
          return `Entr\xE9e invalide : attendu ${expected}, re\xE7u ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
          return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "\u2264" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "\u2265" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
          return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
        }
        case "not_multiple_of":
          return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Cl\xE9 invalide dans ${issue2.origin}`;
        case "invalid_union":
          return "Entr\xE9e invalide";
        case "invalid_element":
          return `Valeur invalide dans ${issue2.origin}`;
        default:
          return `Entr\xE9e invalide`;
      }
    };
  };
  function fr_CA_default() {
    return {
      localeError: error15()
    };
  }

  // node_modules/zod/v4/locales/he.js
  var error16 = () => {
    const TypeNames = {
      string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
      number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
      boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
      bigint: { label: "BigInt", gender: "m" },
      date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
      array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
      object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
      null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
      undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
      symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
      function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
      map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
      set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
      file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
      promise: { label: "Promise", gender: "m" },
      NaN: { label: "NaN", gender: "m" },
      unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
      value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
    };
    const Sizable = {
      string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
      file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
      array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
      set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
      number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
      // no unit
    };
    const typeEntry = (t) => t ? TypeNames[t] : void 0;
    const typeLabel = (t) => {
      const e = typeEntry(t);
      if (e)
        return e.label;
      return t ?? TypeNames.unknown.label;
    };
    const withDefinite = (t) => `\u05D4${typeLabel(t)}`;
    const verbFor = (t) => {
      const e = typeEntry(t);
      const gender = e?.gender ?? "m";
      return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
    };
    const getSizing = (origin) => {
      if (!origin)
        return null;
      return Sizable[origin] ?? null;
    };
    const FormatDictionary = {
      regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
      email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
      url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
      emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
      uuid: { label: "UUID", gender: "m" },
      nanoid: { label: "nanoid", gender: "m" },
      guid: { label: "GUID", gender: "m" },
      cuid: { label: "cuid", gender: "m" },
      cuid2: { label: "cuid2", gender: "m" },
      ulid: { label: "ULID", gender: "m" },
      xid: { label: "XID", gender: "m" },
      ksuid: { label: "KSUID", gender: "m" },
      datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
      date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
      time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
      duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
      ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
      ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
      cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
      cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
      base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
      base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
      json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
      e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
      jwt: { label: "JWT", gender: "m" },
      ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
      includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
      lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
      starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
      uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expectedKey = issue2.expected;
          const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA instanceof ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
          }
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
        }
        case "invalid_value": {
          if (issue2.values.length === 1) {
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive(issue2.values[0])}`;
          }
          const stringified = issue2.values.map((v) => stringifyPrimitive(v));
          if (issue2.values.length === 2) {
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
          }
          const lastValue = stringified[stringified.length - 1];
          const restValues = stringified.slice(0, -1).join(", ");
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
        }
        case "too_big": {
          const sizing = getSizing(issue2.origin);
          const subject = withDefinite(issue2.origin ?? "value");
          if (issue2.origin === "string") {
            return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
          }
          if (issue2.origin === "number") {
            const comparison = issue2.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue2.maximum}`;
            return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
          }
          if (issue2.origin === "array" || issue2.origin === "set") {
            const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
            const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue2.maximum} ${sizing?.unit ?? ""}`;
            return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
          }
          const adj = issue2.inclusive ? "<=" : "<";
          const be = verbFor(issue2.origin ?? "value");
          if (sizing?.unit) {
            return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
          }
          return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const sizing = getSizing(issue2.origin);
          const subject = withDefinite(issue2.origin ?? "value");
          if (issue2.origin === "string") {
            return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
          }
          if (issue2.origin === "number") {
            const comparison = issue2.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue2.minimum}`;
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
          }
          if (issue2.origin === "array" || issue2.origin === "set") {
            const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
            if (issue2.minimum === 1 && issue2.inclusive) {
              const singularPhrase = issue2.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
              return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
            }
            const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue2.minimum} ${sizing?.unit ?? ""}`;
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
          }
          const adj = issue2.inclusive ? ">=" : ">";
          const be = verbFor(issue2.origin ?? "value");
          if (sizing?.unit) {
            return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
          const nounEntry = FormatDictionary[_issue.format];
          const noun = nounEntry?.label ?? _issue.format;
          const gender = nounEntry?.gender ?? "m";
          const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
          return `${noun} \u05DC\u05D0 ${adjective}`;
        }
        case "not_multiple_of":
          return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key": {
          return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
        }
        case "invalid_union":
          return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
        case "invalid_element": {
          const place = withDefinite(issue2.origin ?? "array");
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
        }
        default:
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
      }
    };
  };
  function he_default() {
    return {
      localeError: error16()
    };
  }

  // node_modules/zod/v4/locales/hu.js
  var error17 = () => {
    const Sizable = {
      string: { unit: "karakter", verb: "legyen" },
      file: { unit: "byte", verb: "legyen" },
      array: { unit: "elem", verb: "legyen" },
      set: { unit: "elem", verb: "legyen" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "bemenet",
      email: "email c\xEDm",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO id\u0151b\xE9lyeg",
      date: "ISO d\xE1tum",
      time: "ISO id\u0151",
      duration: "ISO id\u0151intervallum",
      ipv4: "IPv4 c\xEDm",
      ipv6: "IPv6 c\xEDm",
      cidrv4: "IPv4 tartom\xE1ny",
      cidrv6: "IPv6 tartom\xE1ny",
      base64: "base64-k\xF3dolt string",
      base64url: "base64url-k\xF3dolt string",
      json_string: "JSON string",
      e164: "E.164 sz\xE1m",
      jwt: "JWT",
      template_literal: "bemenet"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "sz\xE1m",
      array: "t\xF6mb"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k instanceof ${issue2.expected}, a kapott \xE9rt\xE9k ${received}`;
          }
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${expected}, a kapott \xE9rt\xE9k ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
          return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
          return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
          if (_issue.format === "ends_with")
            return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
          if (_issue.format === "includes")
            return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
          if (_issue.format === "regex")
            return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
          return `\xC9rv\xE9nytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
        case "unrecognized_keys":
          return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
        case "invalid_union":
          return "\xC9rv\xE9nytelen bemenet";
        case "invalid_element":
          return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
        default:
          return `\xC9rv\xE9nytelen bemenet`;
      }
    };
  };
  function hu_default() {
    return {
      localeError: error17()
    };
  }

  // node_modules/zod/v4/locales/hy.js
  function getArmenianPlural(count, one, many) {
    return Math.abs(count) === 1 ? one : many;
  }
  function withDefiniteArticle(word) {
    if (!word)
      return "";
    const vowels = ["\u0561", "\u0565", "\u0568", "\u056B", "\u0578", "\u0578\u0582", "\u0585"];
    const lastChar = word[word.length - 1];
    return word + (vowels.includes(lastChar) ? "\u0576" : "\u0568");
  }
  var error18 = () => {
    const Sizable = {
      string: {
        unit: {
          one: "\u0576\u0577\u0561\u0576",
          many: "\u0576\u0577\u0561\u0576\u0576\u0565\u0580"
        },
        verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
      },
      file: {
        unit: {
          one: "\u0562\u0561\u0575\u0569",
          many: "\u0562\u0561\u0575\u0569\u0565\u0580"
        },
        verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
      },
      array: {
        unit: {
          one: "\u057F\u0561\u0580\u0580",
          many: "\u057F\u0561\u0580\u0580\u0565\u0580"
        },
        verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
      },
      set: {
        unit: {
          one: "\u057F\u0561\u0580\u0580",
          many: "\u057F\u0561\u0580\u0580\u0565\u0580"
        },
        verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
      }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0574\u0578\u0582\u057F\u0584",
      email: "\u0567\u056C. \u0570\u0561\u057D\u0581\u0565",
      url: "URL",
      emoji: "\u0567\u0574\u0578\u057B\u056B",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E \u0587 \u056A\u0561\u0574",
      date: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E",
      time: "ISO \u056A\u0561\u0574",
      duration: "ISO \u057F\u0587\u0578\u0572\u0578\u0582\u0569\u0575\u0578\u0582\u0576",
      ipv4: "IPv4 \u0570\u0561\u057D\u0581\u0565",
      ipv6: "IPv6 \u0570\u0561\u057D\u0581\u0565",
      cidrv4: "IPv4 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
      cidrv6: "IPv6 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
      base64: "base64 \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
      base64url: "base64url \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
      json_string: "JSON \u057F\u0578\u0572",
      e164: "E.164 \u0570\u0561\u0574\u0561\u0580",
      jwt: "JWT",
      template_literal: "\u0574\u0578\u0582\u057F\u0584"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0569\u056B\u057E",
      array: "\u0566\u0561\u0576\u0563\u057E\u0561\u056E"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 instanceof ${issue2.expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
          }
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${stringifyPrimitive(issue2.values[1])}`;
          return `\u054D\u056D\u0561\u056C \u057F\u0561\u0580\u0562\u0565\u0580\u0561\u056F\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 \u0570\u0565\u057F\u0587\u0575\u0561\u056C\u0576\u0565\u0580\u056B\u0581 \u0574\u0565\u056F\u0568\u055D ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            const maxValue = Number(issue2.maximum);
            const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
            return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.maximum.toString()} ${unit}`;
          }
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056C\u056B\u0576\u056B ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            const minValue = Number(issue2.minimum);
            const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
            return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.minimum.toString()} ${unit}`;
          }
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056C\u056B\u0576\u056B ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057D\u056F\u057D\u057E\u056B "${_issue.prefix}"-\u0578\u057E`;
          if (_issue.format === "ends_with")
            return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0561\u057E\u0561\u0580\u057F\u057E\u056B "${_issue.suffix}"-\u0578\u057E`;
          if (_issue.format === "includes")
            return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057A\u0561\u0580\u0578\u0582\u0576\u0561\u056F\u056B "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0570\u0561\u0574\u0561\u057A\u0561\u057F\u0561\u057D\u056D\u0561\u0576\u056B ${_issue.pattern} \u0571\u0587\u0561\u0579\u0561\u0583\u056B\u0576`;
          return `\u054D\u056D\u0561\u056C ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u054D\u056D\u0561\u056C \u0569\u056B\u057E\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0562\u0561\u0566\u0574\u0561\u057A\u0561\u057F\u056B\u056F \u056C\u056B\u0576\u056B ${issue2.divisor}-\u056B`;
        case "unrecognized_keys":
          return `\u0549\u0573\u0561\u0576\u0561\u0579\u057E\u0561\u056E \u0562\u0561\u0576\u0561\u056C\u056B${issue2.keys.length > 1 ? "\u0576\u0565\u0580" : ""}. ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u054D\u056D\u0561\u056C \u0562\u0561\u0576\u0561\u056C\u056B ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
        case "invalid_union":
          return "\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574";
        case "invalid_element":
          return `\u054D\u056D\u0561\u056C \u0561\u0580\u056A\u0565\u0584 ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
        default:
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574`;
      }
    };
  };
  function hy_default() {
    return {
      localeError: error18()
    };
  }

  // node_modules/zod/v4/locales/id.js
  var error19 = () => {
    const Sizable = {
      string: { unit: "karakter", verb: "memiliki" },
      file: { unit: "byte", verb: "memiliki" },
      array: { unit: "item", verb: "memiliki" },
      set: { unit: "item", verb: "memiliki" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "input",
      email: "alamat email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "tanggal dan waktu format ISO",
      date: "tanggal format ISO",
      time: "jam format ISO",
      duration: "durasi format ISO",
      ipv4: "alamat IPv4",
      ipv6: "alamat IPv6",
      cidrv4: "rentang alamat IPv4",
      cidrv6: "rentang alamat IPv6",
      base64: "string dengan enkode base64",
      base64url: "string dengan enkode base64url",
      json_string: "string JSON",
      e164: "angka E.164",
      jwt: "JWT",
      template_literal: "input"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;
          }
          return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
          return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `String tidak valid: harus menyertakan "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
          return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;
        }
        case "not_multiple_of":
          return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Kunci tidak valid di ${issue2.origin}`;
        case "invalid_union":
          return "Input tidak valid";
        case "invalid_element":
          return `Nilai tidak valid di ${issue2.origin}`;
        default:
          return `Input tidak valid`;
      }
    };
  };
  function id_default() {
    return {
      localeError: error19()
    };
  }

  // node_modules/zod/v4/locales/is.js
  var error20 = () => {
    const Sizable = {
      string: { unit: "stafi", verb: "a\xF0 hafa" },
      file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
      array: { unit: "hluti", verb: "a\xF0 hafa" },
      set: { unit: "hluti", verb: "a\xF0 hafa" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "gildi",
      email: "netfang",
      url: "vefsl\xF3\xF0",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO dagsetning og t\xEDmi",
      date: "ISO dagsetning",
      time: "ISO t\xEDmi",
      duration: "ISO t\xEDmalengd",
      ipv4: "IPv4 address",
      ipv6: "IPv6 address",
      cidrv4: "IPv4 range",
      cidrv6: "IPv6 range",
      base64: "base64-encoded strengur",
      base64url: "base64url-encoded strengur",
      json_string: "JSON strengur",
      e164: "E.164 t\xF6lugildi",
      jwt: "JWT",
      template_literal: "gildi"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "n\xFAmer",
      array: "fylki"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera instanceof ${issue2.expected}`;
          }
          return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera ${expected}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
          return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
          return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Rangur lykill \xED ${issue2.origin}`;
        case "invalid_union":
          return "Rangt gildi";
        case "invalid_element":
          return `Rangt gildi \xED ${issue2.origin}`;
        default:
          return `Rangt gildi`;
      }
    };
  };
  function is_default() {
    return {
      localeError: error20()
    };
  }

  // node_modules/zod/v4/locales/it.js
  var error21 = () => {
    const Sizable = {
      string: { unit: "caratteri", verb: "avere" },
      file: { unit: "byte", verb: "avere" },
      array: { unit: "elementi", verb: "avere" },
      set: { unit: "elementi", verb: "avere" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "input",
      email: "indirizzo email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data e ora ISO",
      date: "data ISO",
      time: "ora ISO",
      duration: "durata ISO",
      ipv4: "indirizzo IPv4",
      ipv6: "indirizzo IPv6",
      cidrv4: "intervallo IPv4",
      cidrv6: "intervallo IPv6",
      base64: "stringa codificata in base64",
      base64url: "URL codificata in base64",
      json_string: "stringa JSON",
      e164: "numero E.164",
      jwt: "JWT",
      template_literal: "input"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "numero",
      array: "vettore"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;
          }
          return `Input non valido: atteso ${expected}, ricevuto ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
          return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
          return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Stringa non valida: deve includere "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
          return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Chiave non valida in ${issue2.origin}`;
        case "invalid_union":
          return "Input non valido";
        case "invalid_element":
          return `Valore non valido in ${issue2.origin}`;
        default:
          return `Input non valido`;
      }
    };
  };
  function it_default() {
    return {
      localeError: error21()
    };
  }

  // node_modules/zod/v4/locales/ja.js
  var error22 = () => {
    const Sizable = {
      string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
      file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
      array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
      set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u5165\u529B\u5024",
      email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
      url: "URL",
      emoji: "\u7D75\u6587\u5B57",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO\u65E5\u6642",
      date: "ISO\u65E5\u4ED8",
      time: "ISO\u6642\u523B",
      duration: "ISO\u671F\u9593",
      ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
      ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
      cidrv4: "IPv4\u7BC4\u56F2",
      cidrv6: "IPv6\u7BC4\u56F2",
      base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
      base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
      json_string: "JSON\u6587\u5B57\u5217",
      e164: "E.164\u756A\u53F7",
      jwt: "JWT",
      template_literal: "\u5165\u529B\u5024"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u6570\u5024",
      array: "\u914D\u5217"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u7121\u52B9\u306A\u5165\u529B: instanceof ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
          }
          return `\u7121\u52B9\u306A\u5165\u529B: ${expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
          return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        case "too_big": {
          const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          if (_issue.format === "ends_with")
            return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          if (_issue.format === "includes")
            return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          if (_issue.format === "regex")
            return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          return `\u7121\u52B9\u306A${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        case "unrecognized_keys":
          return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
        case "invalid_key":
          return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
        case "invalid_union":
          return "\u7121\u52B9\u306A\u5165\u529B";
        case "invalid_element":
          return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
        default:
          return `\u7121\u52B9\u306A\u5165\u529B`;
      }
    };
  };
  function ja_default() {
    return {
      localeError: error22()
    };
  }

  // node_modules/zod/v4/locales/ka.js
  var error23 = () => {
    const Sizable = {
      string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
      file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
      array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
      set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
      email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
      url: "URL",
      emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
      date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
      time: "\u10D3\u10E0\u10DD",
      duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
      ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
      ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
      cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
      cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
      base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
      base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
      json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
      e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
      jwt: "JWT",
      template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8",
      string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
      boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
      function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0",
      array: "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 instanceof ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
          }
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
          }
          if (_issue.format === "ends_with")
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
          if (_issue.format === "includes")
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
          if (_issue.format === "regex")
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
        case "unrecognized_keys":
          return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
        case "invalid_union":
          return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
        case "invalid_element":
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
        default:
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
      }
    };
  };
  function ka_default() {
    return {
      localeError: error23()
    };
  }

  // node_modules/zod/v4/locales/km.js
  var error24 = () => {
    const Sizable = {
      string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
      file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
      array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
      set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
      email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
      url: "URL",
      emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
      date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
      time: "\u1798\u17C9\u17C4\u1784 ISO",
      duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
      ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
      ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
      cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
      cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
      base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
      base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
      json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
      e164: "\u179B\u17C1\u1781 E.164",
      jwt: "JWT",
      template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u179B\u17C1\u1781",
      array: "\u17A2\u17B6\u179A\u17C1 (Array)",
      null: "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A instanceof ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
          }
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
          return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
          return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
        case "invalid_union":
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
        case "invalid_element":
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
        default:
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      }
    };
  };
  function km_default() {
    return {
      localeError: error24()
    };
  }

  // node_modules/zod/v4/locales/kh.js
  function kh_default() {
    return km_default();
  }

  // node_modules/zod/v4/locales/ko.js
  var error25 = () => {
    const Sizable = {
      string: { unit: "\uBB38\uC790", verb: "to have" },
      file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
      array: { unit: "\uAC1C", verb: "to have" },
      set: { unit: "\uAC1C", verb: "to have" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\uC785\uB825",
      email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
      url: "URL",
      emoji: "\uC774\uBAA8\uC9C0",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
      date: "ISO \uB0A0\uC9DC",
      time: "ISO \uC2DC\uAC04",
      duration: "ISO \uAE30\uAC04",
      ipv4: "IPv4 \uC8FC\uC18C",
      ipv6: "IPv6 \uC8FC\uC18C",
      cidrv4: "IPv4 \uBC94\uC704",
      cidrv6: "IPv6 \uBC94\uC704",
      base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
      base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
      json_string: "JSON \uBB38\uC790\uC5F4",
      e164: "E.164 \uBC88\uD638",
      jwt: "JWT",
      template_literal: "\uC785\uB825"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 instanceof ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
          }
          return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
          return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
        case "too_big": {
          const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
          const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
          const sizing = getSizing(issue2.origin);
          const unit = sizing?.unit ?? "\uC694\uC18C";
          if (sizing)
            return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
          const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
          const sizing = getSizing(issue2.origin);
          const unit = sizing?.unit ?? "\uC694\uC18C";
          if (sizing) {
            return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
          }
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
          }
          if (_issue.format === "ends_with")
            return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
          if (_issue.format === "includes")
            return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
          if (_issue.format === "regex")
            return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
          return `\uC798\uBABB\uB41C ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
        case "unrecognized_keys":
          return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
        case "invalid_union":
          return `\uC798\uBABB\uB41C \uC785\uB825`;
        case "invalid_element":
          return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
        default:
          return `\uC798\uBABB\uB41C \uC785\uB825`;
      }
    };
  };
  function ko_default() {
    return {
      localeError: error25()
    };
  }

  // node_modules/zod/v4/locales/lt.js
  var capitalizeFirstCharacter = (text) => {
    return text.charAt(0).toUpperCase() + text.slice(1);
  };
  function getUnitTypeFromNumber(number5) {
    const abs = Math.abs(number5);
    const last = abs % 10;
    const last2 = abs % 100;
    if (last2 >= 11 && last2 <= 19 || last === 0)
      return "many";
    if (last === 1)
      return "one";
    return "few";
  }
  var error26 = () => {
    const Sizable = {
      string: {
        unit: {
          one: "simbolis",
          few: "simboliai",
          many: "simboli\u0173"
        },
        verb: {
          smaller: {
            inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
            notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
          },
          bigger: {
            inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
            notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
          }
        }
      },
      file: {
        unit: {
          one: "baitas",
          few: "baitai",
          many: "bait\u0173"
        },
        verb: {
          smaller: {
            inclusive: "turi b\u016Bti ne didesnis kaip",
            notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
          },
          bigger: {
            inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
            notInclusive: "turi b\u016Bti didesnis kaip"
          }
        }
      },
      array: {
        unit: {
          one: "element\u0105",
          few: "elementus",
          many: "element\u0173"
        },
        verb: {
          smaller: {
            inclusive: "turi tur\u0117ti ne daugiau kaip",
            notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
          },
          bigger: {
            inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
            notInclusive: "turi tur\u0117ti daugiau kaip"
          }
        }
      },
      set: {
        unit: {
          one: "element\u0105",
          few: "elementus",
          many: "element\u0173"
        },
        verb: {
          smaller: {
            inclusive: "turi tur\u0117ti ne daugiau kaip",
            notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
          },
          bigger: {
            inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
            notInclusive: "turi tur\u0117ti daugiau kaip"
          }
        }
      }
    };
    function getSizing(origin, unitType, inclusive, targetShouldBe) {
      const result = Sizable[origin] ?? null;
      if (result === null)
        return result;
      return {
        unit: result.unit[unitType],
        verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
      };
    }
    const FormatDictionary = {
      regex: "\u012Fvestis",
      email: "el. pa\u0161to adresas",
      url: "URL",
      emoji: "jaustukas",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO data ir laikas",
      date: "ISO data",
      time: "ISO laikas",
      duration: "ISO trukm\u0117",
      ipv4: "IPv4 adresas",
      ipv6: "IPv6 adresas",
      cidrv4: "IPv4 tinklo prefiksas (CIDR)",
      cidrv6: "IPv6 tinklo prefiksas (CIDR)",
      base64: "base64 u\u017Ekoduota eilut\u0117",
      base64url: "base64url u\u017Ekoduota eilut\u0117",
      json_string: "JSON eilut\u0117",
      e164: "E.164 numeris",
      jwt: "JWT",
      template_literal: "\u012Fvestis"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "skai\u010Dius",
      bigint: "sveikasis skai\u010Dius",
      string: "eilut\u0117",
      boolean: "login\u0117 reik\u0161m\u0117",
      undefined: "neapibr\u0117\u017Eta reik\u0161m\u0117",
      function: "funkcija",
      symbol: "simbolis",
      array: "masyvas",
      object: "objektas",
      null: "nulin\u0117 reik\u0161m\u0117"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Gautas tipas ${received}, o tik\u0117tasi - instanceof ${issue2.expected}`;
          }
          return `Gautas tipas ${received}, o tik\u0117tasi - ${expected}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
          return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
        case "too_big": {
          const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
          const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
          if (sizing?.verb)
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
          const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
        }
        case "too_small": {
          const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
          const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
          if (sizing?.verb)
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
          const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
          return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
        case "unrecognized_keys":
          return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return "Rastas klaidingas raktas";
        case "invalid_union":
          return "Klaidinga \u012Fvestis";
        case "invalid_element": {
          const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
        }
        default:
          return "Klaidinga \u012Fvestis";
      }
    };
  };
  function lt_default() {
    return {
      localeError: error26()
    };
  }

  // node_modules/zod/v4/locales/mk.js
  var error27 = () => {
    const Sizable = {
      string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
      file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
      array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
      set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0432\u043D\u0435\u0441",
      email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
      url: "URL",
      emoji: "\u0435\u043C\u043E\u045F\u0438",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
      date: "ISO \u0434\u0430\u0442\u0443\u043C",
      time: "ISO \u0432\u0440\u0435\u043C\u0435",
      duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
      ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
      ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
      cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
      cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
      base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
      base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
      json_string: "JSON \u043D\u0438\u0437\u0430",
      e164: "E.164 \u0431\u0440\u043E\u0458",
      jwt: "JWT",
      template_literal: "\u0432\u043D\u0435\u0441"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0431\u0440\u043E\u0458",
      array: "\u043D\u0438\u0437\u0430"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 instanceof ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
          }
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
          return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
          return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
        case "invalid_union":
          return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
        case "invalid_element":
          return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
        default:
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
      }
    };
  };
  function mk_default() {
    return {
      localeError: error27()
    };
  }

  // node_modules/zod/v4/locales/ms.js
  var error28 = () => {
    const Sizable = {
      string: { unit: "aksara", verb: "mempunyai" },
      file: { unit: "bait", verb: "mempunyai" },
      array: { unit: "elemen", verb: "mempunyai" },
      set: { unit: "elemen", verb: "mempunyai" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "input",
      email: "alamat e-mel",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "tarikh masa ISO",
      date: "tarikh ISO",
      time: "masa ISO",
      duration: "tempoh ISO",
      ipv4: "alamat IPv4",
      ipv6: "alamat IPv6",
      cidrv4: "julat IPv4",
      cidrv6: "julat IPv6",
      base64: "string dikodkan base64",
      base64url: "string dikodkan base64url",
      json_string: "string JSON",
      e164: "nombor E.164",
      jwt: "JWT",
      template_literal: "input"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "nombor"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;
          }
          return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
          return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
          return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;
        }
        case "not_multiple_of":
          return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Kunci tidak sah dalam ${issue2.origin}`;
        case "invalid_union":
          return "Input tidak sah";
        case "invalid_element":
          return `Nilai tidak sah dalam ${issue2.origin}`;
        default:
          return `Input tidak sah`;
      }
    };
  };
  function ms_default() {
    return {
      localeError: error28()
    };
  }

  // node_modules/zod/v4/locales/nl.js
  var error29 = () => {
    const Sizable = {
      string: { unit: "tekens", verb: "heeft" },
      file: { unit: "bytes", verb: "heeft" },
      array: { unit: "elementen", verb: "heeft" },
      set: { unit: "elementen", verb: "heeft" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "invoer",
      email: "emailadres",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datum en tijd",
      date: "ISO datum",
      time: "ISO tijd",
      duration: "ISO duur",
      ipv4: "IPv4-adres",
      ipv6: "IPv6-adres",
      cidrv4: "IPv4-bereik",
      cidrv6: "IPv6-bereik",
      base64: "base64-gecodeerde tekst",
      base64url: "base64 URL-gecodeerde tekst",
      json_string: "JSON string",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "invoer"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "getal"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;
          }
          return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
          return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          const longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";
          if (sizing)
            return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
          return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          const shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";
          if (sizing) {
            return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
          }
          return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
          }
          if (_issue.format === "ends_with")
            return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
          if (_issue.format === "includes")
            return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
          if (_issue.format === "regex")
            return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
          return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
        case "unrecognized_keys":
          return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Ongeldige key in ${issue2.origin}`;
        case "invalid_union":
          return "Ongeldige invoer";
        case "invalid_element":
          return `Ongeldige waarde in ${issue2.origin}`;
        default:
          return `Ongeldige invoer`;
      }
    };
  };
  function nl_default() {
    return {
      localeError: error29()
    };
  }

  // node_modules/zod/v4/locales/no.js
  var error30 = () => {
    const Sizable = {
      string: { unit: "tegn", verb: "\xE5 ha" },
      file: { unit: "bytes", verb: "\xE5 ha" },
      array: { unit: "elementer", verb: "\xE5 inneholde" },
      set: { unit: "elementer", verb: "\xE5 inneholde" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "input",
      email: "e-postadresse",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO dato- og klokkeslett",
      date: "ISO-dato",
      time: "ISO-klokkeslett",
      duration: "ISO-varighet",
      ipv4: "IPv4-omr\xE5de",
      ipv6: "IPv6-omr\xE5de",
      cidrv4: "IPv4-spekter",
      cidrv6: "IPv6-spekter",
      base64: "base64-enkodet streng",
      base64url: "base64url-enkodet streng",
      json_string: "JSON-streng",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "input"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "tall",
      array: "liste"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;
          }
          return `Ugyldig input: forventet ${expected}, fikk ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
          return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
          return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
          return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Ugyldig n\xF8kkel i ${issue2.origin}`;
        case "invalid_union":
          return "Ugyldig input";
        case "invalid_element":
          return `Ugyldig verdi i ${issue2.origin}`;
        default:
          return `Ugyldig input`;
      }
    };
  };
  function no_default() {
    return {
      localeError: error30()
    };
  }

  // node_modules/zod/v4/locales/ota.js
  var error31 = () => {
    const Sizable = {
      string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
      file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
      array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
      set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "giren",
      email: "epostag\xE2h",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO heng\xE2m\u0131",
      date: "ISO tarihi",
      time: "ISO zaman\u0131",
      duration: "ISO m\xFCddeti",
      ipv4: "IPv4 ni\u015F\xE2n\u0131",
      ipv6: "IPv6 ni\u015F\xE2n\u0131",
      cidrv4: "IPv4 menzili",
      cidrv6: "IPv6 menzili",
      base64: "base64-\u015Fifreli metin",
      base64url: "base64url-\u015Fifreli metin",
      json_string: "JSON metin",
      e164: "E.164 say\u0131s\u0131",
      jwt: "JWT",
      template_literal: "giren"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "numara",
      array: "saf",
      null: "gayb"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `F\xE2sit giren: umulan instanceof ${issue2.expected}, al\u0131nan ${received}`;
          }
          return `F\xE2sit giren: umulan ${expected}, al\u0131nan ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
          return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
          return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
          }
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
          if (_issue.format === "ends_with")
            return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
          if (_issue.format === "includes")
            return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
          if (_issue.format === "regex")
            return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
          return `F\xE2sit ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
        case "unrecognized_keys":
          return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
        case "invalid_union":
          return "Giren tan\u0131namad\u0131.";
        case "invalid_element":
          return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
        default:
          return `K\u0131ymet tan\u0131namad\u0131.`;
      }
    };
  };
  function ota_default() {
    return {
      localeError: error31()
    };
  }

  // node_modules/zod/v4/locales/ps.js
  var error32 = () => {
    const Sizable = {
      string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
      file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
      array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
      set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0648\u0631\u0648\u062F\u064A",
      email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
      url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
      emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
      date: "\u0646\u06D0\u067C\u0647",
      time: "\u0648\u062E\u062A",
      duration: "\u0645\u0648\u062F\u0647",
      ipv4: "\u062F IPv4 \u067E\u062A\u0647",
      ipv6: "\u062F IPv6 \u067E\u062A\u0647",
      cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
      cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
      base64: "base64-encoded \u0645\u062A\u0646",
      base64url: "base64url-encoded \u0645\u062A\u0646",
      json_string: "JSON \u0645\u062A\u0646",
      e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
      jwt: "JWT",
      template_literal: "\u0648\u0631\u0648\u062F\u064A"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0639\u062F\u062F",
      array: "\u0627\u0631\u06D0"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F instanceof ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
          }
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
        }
        case "invalid_value":
          if (issue2.values.length === 1) {
            return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
          }
          return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
          }
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
          }
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
          }
          if (_issue.format === "ends_with") {
            return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
          }
          if (_issue.format === "includes") {
            return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
          }
          if (_issue.format === "regex") {
            return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
          }
          return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
        }
        case "not_multiple_of":
          return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
        case "unrecognized_keys":
          return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
        case "invalid_union":
          return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
        case "invalid_element":
          return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
        default:
          return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      }
    };
  };
  function ps_default() {
    return {
      localeError: error32()
    };
  }

  // node_modules/zod/v4/locales/pl.js
  var error33 = () => {
    const Sizable = {
      string: { unit: "znak\xF3w", verb: "mie\u0107" },
      file: { unit: "bajt\xF3w", verb: "mie\u0107" },
      array: { unit: "element\xF3w", verb: "mie\u0107" },
      set: { unit: "element\xF3w", verb: "mie\u0107" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "wyra\u017Cenie",
      email: "adres email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data i godzina w formacie ISO",
      date: "data w formacie ISO",
      time: "godzina w formacie ISO",
      duration: "czas trwania ISO",
      ipv4: "adres IPv4",
      ipv6: "adres IPv6",
      cidrv4: "zakres IPv4",
      cidrv6: "zakres IPv6",
      base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
      base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
      json_string: "ci\u0105g znak\xF3w w formacie JSON",
      e164: "liczba E.164",
      jwt: "JWT",
      template_literal: "wej\u015Bcie"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "liczba",
      array: "tablica"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;
          }
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${expected}, otrzymano ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
          return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
          }
          return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
          }
          return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
          return `Nieprawid\u0142ow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
        case "invalid_union":
          return "Nieprawid\u0142owe dane wej\u015Bciowe";
        case "invalid_element":
          return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
        default:
          return `Nieprawid\u0142owe dane wej\u015Bciowe`;
      }
    };
  };
  function pl_default() {
    return {
      localeError: error33()
    };
  }

  // node_modules/zod/v4/locales/pt.js
  var error34 = () => {
    const Sizable = {
      string: { unit: "caracteres", verb: "ter" },
      file: { unit: "bytes", verb: "ter" },
      array: { unit: "itens", verb: "ter" },
      set: { unit: "itens", verb: "ter" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "padr\xE3o",
      email: "endere\xE7o de e-mail",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data e hora ISO",
      date: "data ISO",
      time: "hora ISO",
      duration: "dura\xE7\xE3o ISO",
      ipv4: "endere\xE7o IPv4",
      ipv6: "endere\xE7o IPv6",
      cidrv4: "faixa de IPv4",
      cidrv6: "faixa de IPv6",
      base64: "texto codificado em base64",
      base64url: "URL codificada em base64",
      json_string: "texto JSON",
      e164: "n\xFAmero E.164",
      jwt: "JWT",
      template_literal: "entrada"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "n\xFAmero",
      null: "nulo"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Tipo inv\xE1lido: esperado instanceof ${issue2.expected}, recebido ${received}`;
          }
          return `Tipo inv\xE1lido: esperado ${expected}, recebido ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
          return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
          return `${FormatDictionary[_issue.format] ?? issue2.format} inv\xE1lido`;
        }
        case "not_multiple_of":
          return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Chave inv\xE1lida em ${issue2.origin}`;
        case "invalid_union":
          return "Entrada inv\xE1lida";
        case "invalid_element":
          return `Valor inv\xE1lido em ${issue2.origin}`;
        default:
          return `Campo inv\xE1lido`;
      }
    };
  };
  function pt_default() {
    return {
      localeError: error34()
    };
  }

  // node_modules/zod/v4/locales/ru.js
  function getRussianPlural(count, one, few, many) {
    const absCount = Math.abs(count);
    const lastDigit = absCount % 10;
    const lastTwoDigits = absCount % 100;
    if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
      return many;
    }
    if (lastDigit === 1) {
      return one;
    }
    if (lastDigit >= 2 && lastDigit <= 4) {
      return few;
    }
    return many;
  }
  var error35 = () => {
    const Sizable = {
      string: {
        unit: {
          one: "\u0441\u0438\u043C\u0432\u043E\u043B",
          few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
          many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
        },
        verb: "\u0438\u043C\u0435\u0442\u044C"
      },
      file: {
        unit: {
          one: "\u0431\u0430\u0439\u0442",
          few: "\u0431\u0430\u0439\u0442\u0430",
          many: "\u0431\u0430\u0439\u0442"
        },
        verb: "\u0438\u043C\u0435\u0442\u044C"
      },
      array: {
        unit: {
          one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
          few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
          many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
        },
        verb: "\u0438\u043C\u0435\u0442\u044C"
      },
      set: {
        unit: {
          one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
          few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
          many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
        },
        verb: "\u0438\u043C\u0435\u0442\u044C"
      }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0432\u0432\u043E\u0434",
      email: "email \u0430\u0434\u0440\u0435\u0441",
      url: "URL",
      emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
      date: "ISO \u0434\u0430\u0442\u0430",
      time: "ISO \u0432\u0440\u0435\u043C\u044F",
      duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
      ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
      ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
      cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
      cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
      base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
      base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
      json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
      e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
      jwt: "JWT",
      template_literal: "\u0432\u0432\u043E\u0434"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0447\u0438\u0441\u043B\u043E",
      array: "\u043C\u0430\u0441\u0441\u0438\u0432"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
          }
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            const maxValue = Number(issue2.maximum);
            const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
          }
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            const minValue = Number(issue2.minimum);
            const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
          }
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
        case "invalid_union":
          return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
        case "invalid_element":
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
        default:
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
      }
    };
  };
  function ru_default() {
    return {
      localeError: error35()
    };
  }

  // node_modules/zod/v4/locales/sl.js
  var error36 = () => {
    const Sizable = {
      string: { unit: "znakov", verb: "imeti" },
      file: { unit: "bajtov", verb: "imeti" },
      array: { unit: "elementov", verb: "imeti" },
      set: { unit: "elementov", verb: "imeti" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "vnos",
      email: "e-po\u0161tni naslov",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datum in \u010Das",
      date: "ISO datum",
      time: "ISO \u010Das",
      duration: "ISO trajanje",
      ipv4: "IPv4 naslov",
      ipv6: "IPv6 naslov",
      cidrv4: "obseg IPv4",
      cidrv6: "obseg IPv6",
      base64: "base64 kodiran niz",
      base64url: "base64url kodiran niz",
      json_string: "JSON niz",
      e164: "E.164 \u0161tevilka",
      jwt: "JWT",
      template_literal: "vnos"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0161tevilo",
      array: "tabela"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Neveljaven vnos: pri\u010Dakovano instanceof ${issue2.expected}, prejeto ${received}`;
          }
          return `Neveljaven vnos: pri\u010Dakovano ${expected}, prejeto ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
          return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
          return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
          return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Neveljaven klju\u010D v ${issue2.origin}`;
        case "invalid_union":
          return "Neveljaven vnos";
        case "invalid_element":
          return `Neveljavna vrednost v ${issue2.origin}`;
        default:
          return "Neveljaven vnos";
      }
    };
  };
  function sl_default() {
    return {
      localeError: error36()
    };
  }

  // node_modules/zod/v4/locales/sv.js
  var error37 = () => {
    const Sizable = {
      string: { unit: "tecken", verb: "att ha" },
      file: { unit: "bytes", verb: "att ha" },
      array: { unit: "objekt", verb: "att inneh\xE5lla" },
      set: { unit: "objekt", verb: "att inneh\xE5lla" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "regulj\xE4rt uttryck",
      email: "e-postadress",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-datum och tid",
      date: "ISO-datum",
      time: "ISO-tid",
      duration: "ISO-varaktighet",
      ipv4: "IPv4-intervall",
      ipv6: "IPv6-intervall",
      cidrv4: "IPv4-spektrum",
      cidrv6: "IPv6-spektrum",
      base64: "base64-kodad str\xE4ng",
      base64url: "base64url-kodad str\xE4ng",
      json_string: "JSON-str\xE4ng",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "mall-literal"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "antal",
      array: "lista"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Ogiltig inmatning: f\xF6rv\xE4ntat instanceof ${issue2.expected}, fick ${received}`;
          }
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${expected}, fick ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
          return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
          }
          return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
          return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
        case "unrecognized_keys":
          return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
        case "invalid_union":
          return "Ogiltig input";
        case "invalid_element":
          return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
        default:
          return `Ogiltig input`;
      }
    };
  };
  function sv_default() {
    return {
      localeError: error37()
    };
  }

  // node_modules/zod/v4/locales/ta.js
  var error38 = () => {
    const Sizable = {
      string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
      file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
      array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
      set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
      email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
      date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
      time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
      duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
      ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
      ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
      cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
      cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
      base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
      base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
      json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
      e164: "E.164 \u0B8E\u0BA3\u0BCD",
      jwt: "JWT",
      template_literal: "input"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0B8E\u0BA3\u0BCD",
      array: "\u0B85\u0BA3\u0BBF",
      null: "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 instanceof ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
          }
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          if (_issue.format === "ends_with")
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          if (_issue.format === "includes")
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          if (_issue.format === "regex")
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        case "unrecognized_keys":
          return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
        case "invalid_union":
          return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
        case "invalid_element":
          return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
        default:
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
      }
    };
  };
  function ta_default() {
    return {
      localeError: error38()
    };
  }

  // node_modules/zod/v4/locales/th.js
  var error39 = () => {
    const Sizable = {
      string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
      file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
      array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
      set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
      email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
      url: "URL",
      emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
      date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
      time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
      duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
      ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
      ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
      cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
      cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
      base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
      base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
      json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
      e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
      jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
      template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
      array: "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)",
      null: "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 instanceof ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
          }
          return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
          return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
          }
          if (_issue.format === "ends_with")
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
          if (_issue.format === "regex")
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
        case "unrecognized_keys":
          return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
        case "invalid_union":
          return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
        case "invalid_element":
          return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
        default:
          return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
      }
    };
  };
  function th_default() {
    return {
      localeError: error39()
    };
  }

  // node_modules/zod/v4/locales/tr.js
  var error40 = () => {
    const Sizable = {
      string: { unit: "karakter", verb: "olmal\u0131" },
      file: { unit: "bayt", verb: "olmal\u0131" },
      array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
      set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "girdi",
      email: "e-posta adresi",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO tarih ve saat",
      date: "ISO tarih",
      time: "ISO saat",
      duration: "ISO s\xFCre",
      ipv4: "IPv4 adresi",
      ipv6: "IPv6 adresi",
      cidrv4: "IPv4 aral\u0131\u011F\u0131",
      cidrv6: "IPv6 aral\u0131\u011F\u0131",
      base64: "base64 ile \u015Fifrelenmi\u015F metin",
      base64url: "base64url ile \u015Fifrelenmi\u015F metin",
      json_string: "JSON dizesi",
      e164: "E.164 say\u0131s\u0131",
      jwt: "JWT",
      template_literal: "\u015Eablon dizesi"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Ge\xE7ersiz de\u011Fer: beklenen instanceof ${issue2.expected}, al\u0131nan ${received}`;
          }
          return `Ge\xE7ersiz de\u011Fer: beklenen ${expected}, al\u0131nan ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
          return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
          if (_issue.format === "ends_with")
            return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
          if (_issue.format === "includes")
            return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
          if (_issue.format === "regex")
            return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
          return `Ge\xE7ersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
        case "unrecognized_keys":
          return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
        case "invalid_union":
          return "Ge\xE7ersiz de\u011Fer";
        case "invalid_element":
          return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
        default:
          return `Ge\xE7ersiz de\u011Fer`;
      }
    };
  };
  function tr_default() {
    return {
      localeError: error40()
    };
  }

  // node_modules/zod/v4/locales/uk.js
  var error41 = () => {
    const Sizable = {
      string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
      file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
      array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
      set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
      email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
      url: "URL",
      emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
      date: "\u0434\u0430\u0442\u0430 ISO",
      time: "\u0447\u0430\u0441 ISO",
      duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
      ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
      ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
      cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
      cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
      base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
      base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
      json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
      e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
      jwt: "JWT",
      template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0447\u0438\u0441\u043B\u043E",
      array: "\u043C\u0430\u0441\u0438\u0432"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F instanceof ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
          }
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
        case "unrecognized_keys":
          return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
        case "invalid_union":
          return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
        case "invalid_element":
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
        default:
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
      }
    };
  };
  function uk_default() {
    return {
      localeError: error41()
    };
  }

  // node_modules/zod/v4/locales/ua.js
  function ua_default() {
    return uk_default();
  }

  // node_modules/zod/v4/locales/ur.js
  var error42 = () => {
    const Sizable = {
      string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
      file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
      array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
      set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0627\u0646 \u067E\u0679",
      email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
      url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
      emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
      uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
      uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
      nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
      ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
      xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
      ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
      date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
      time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
      duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
      ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
      ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
      cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
      cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
      base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
      base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
      json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
      e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
      jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
      template_literal: "\u0627\u0646 \u067E\u0679"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u0646\u0645\u0628\u0631",
      array: "\u0622\u0631\u06D2",
      null: "\u0646\u0644"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: instanceof ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
          }
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
          }
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          }
          if (_issue.format === "ends_with")
            return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          if (_issue.format === "includes")
            return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          if (_issue.format === "regex")
            return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          return `\u063A\u0644\u0637 ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        case "unrecognized_keys":
          return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
        case "invalid_key":
          return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
        case "invalid_union":
          return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
        case "invalid_element":
          return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
        default:
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
      }
    };
  };
  function ur_default() {
    return {
      localeError: error42()
    };
  }

  // node_modules/zod/v4/locales/uz.js
  var error43 = () => {
    const Sizable = {
      string: { unit: "belgi", verb: "bo\u2018lishi kerak" },
      file: { unit: "bayt", verb: "bo\u2018lishi kerak" },
      array: { unit: "element", verb: "bo\u2018lishi kerak" },
      set: { unit: "element", verb: "bo\u2018lishi kerak" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "kirish",
      email: "elektron pochta manzili",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO sana va vaqti",
      date: "ISO sana",
      time: "ISO vaqt",
      duration: "ISO davomiylik",
      ipv4: "IPv4 manzil",
      ipv6: "IPv6 manzil",
      mac: "MAC manzil",
      cidrv4: "IPv4 diapazon",
      cidrv6: "IPv6 diapazon",
      base64: "base64 kodlangan satr",
      base64url: "base64url kodlangan satr",
      json_string: "JSON satr",
      e164: "E.164 raqam",
      jwt: "JWT",
      template_literal: "kirish"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "raqam",
      array: "massiv"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `Noto\u2018g\u2018ri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;
          }
          return `Noto\u2018g\u2018ri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `Noto\u2018g\u2018ri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;
          return `Noto\u2018g\u2018ri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
          return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
          }
          return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Noto\u2018g\u2018ri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
          if (_issue.format === "ends_with")
            return `Noto\u2018g\u2018ri satr: "${_issue.suffix}" bilan tugashi kerak`;
          if (_issue.format === "includes")
            return `Noto\u2018g\u2018ri satr: "${_issue.includes}" ni o\u2018z ichiga olishi kerak`;
          if (_issue.format === "regex")
            return `Noto\u2018g\u2018ri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
          return `Noto\u2018g\u2018ri ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `Noto\u2018g\u2018ri raqam: ${issue2.divisor} ning karralisi bo\u2018lishi kerak`;
        case "unrecognized_keys":
          return `Noma\u2019lum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} dagi kalit noto\u2018g\u2018ri`;
        case "invalid_union":
          return "Noto\u2018g\u2018ri kirish";
        case "invalid_element":
          return `${issue2.origin} da noto\u2018g\u2018ri qiymat`;
        default:
          return `Noto\u2018g\u2018ri kirish`;
      }
    };
  };
  function uz_default() {
    return {
      localeError: error43()
    };
  }

  // node_modules/zod/v4/locales/vi.js
  var error44 = () => {
    const Sizable = {
      string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
      file: { unit: "byte", verb: "c\xF3" },
      array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
      set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u0111\u1EA7u v\xE0o",
      email: "\u0111\u1ECBa ch\u1EC9 email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ng\xE0y gi\u1EDD ISO",
      date: "ng\xE0y ISO",
      time: "gi\u1EDD ISO",
      duration: "kho\u1EA3ng th\u1EDDi gian ISO",
      ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
      ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
      cidrv4: "d\u1EA3i IPv4",
      cidrv6: "d\u1EA3i IPv6",
      base64: "chu\u1ED7i m\xE3 h\xF3a base64",
      base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
      json_string: "chu\u1ED7i JSON",
      e164: "s\u1ED1 E.164",
      jwt: "JWT",
      template_literal: "\u0111\u1EA7u v\xE0o"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "s\u1ED1",
      array: "m\u1EA3ng"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i instanceof ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
          }
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
          return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
          return `${FormatDictionary[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
        }
        case "not_multiple_of":
          return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
        case "unrecognized_keys":
          return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
        case "invalid_union":
          return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
        case "invalid_element":
          return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
        default:
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
      }
    };
  };
  function vi_default() {
    return {
      localeError: error44()
    };
  }

  // node_modules/zod/v4/locales/zh-CN.js
  var error45 = () => {
    const Sizable = {
      string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
      file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
      array: { unit: "\u9879", verb: "\u5305\u542B" },
      set: { unit: "\u9879", verb: "\u5305\u542B" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u8F93\u5165",
      email: "\u7535\u5B50\u90AE\u4EF6",
      url: "URL",
      emoji: "\u8868\u60C5\u7B26\u53F7",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO\u65E5\u671F\u65F6\u95F4",
      date: "ISO\u65E5\u671F",
      time: "ISO\u65F6\u95F4",
      duration: "ISO\u65F6\u957F",
      ipv4: "IPv4\u5730\u5740",
      ipv6: "IPv6\u5730\u5740",
      cidrv4: "IPv4\u7F51\u6BB5",
      cidrv6: "IPv6\u7F51\u6BB5",
      base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
      base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
      json_string: "JSON\u5B57\u7B26\u4E32",
      e164: "E.164\u53F7\u7801",
      jwt: "JWT",
      template_literal: "\u8F93\u5165"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "\u6570\u5B57",
      array: "\u6570\u7EC4",
      null: "\u7A7A\u503C(null)"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B instanceof ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
          }
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
          return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
          if (_issue.format === "ends_with")
            return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
          if (_issue.format === "includes")
            return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
          return `\u65E0\u6548${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
        case "unrecognized_keys":
          return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
        case "invalid_union":
          return "\u65E0\u6548\u8F93\u5165";
        case "invalid_element":
          return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
        default:
          return `\u65E0\u6548\u8F93\u5165`;
      }
    };
  };
  function zh_CN_default() {
    return {
      localeError: error45()
    };
  }

  // node_modules/zod/v4/locales/zh-TW.js
  var error46 = () => {
    const Sizable = {
      string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
      file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
      array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
      set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u8F38\u5165",
      email: "\u90F5\u4EF6\u5730\u5740",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u65E5\u671F\u6642\u9593",
      date: "ISO \u65E5\u671F",
      time: "ISO \u6642\u9593",
      duration: "ISO \u671F\u9593",
      ipv4: "IPv4 \u4F4D\u5740",
      ipv6: "IPv6 \u4F4D\u5740",
      cidrv4: "IPv4 \u7BC4\u570D",
      cidrv6: "IPv6 \u7BC4\u570D",
      base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
      base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
      json_string: "JSON \u5B57\u4E32",
      e164: "E.164 \u6578\u503C",
      jwt: "JWT",
      template_literal: "\u8F38\u5165"
    };
    const TypeDictionary = {
      nan: "NaN"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA instanceof ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
          }
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
          return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing) {
            return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
          }
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with") {
            return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
          }
          if (_issue.format === "ends_with")
            return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
          if (_issue.format === "includes")
            return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
          return `\u7121\u6548\u7684 ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
        case "unrecognized_keys":
          return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
        case "invalid_key":
          return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
        case "invalid_union":
          return "\u7121\u6548\u7684\u8F38\u5165\u503C";
        case "invalid_element":
          return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
        default:
          return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
      }
    };
  };
  function zh_TW_default() {
    return {
      localeError: error46()
    };
  }

  // node_modules/zod/v4/locales/yo.js
  var error47 = () => {
    const Sizable = {
      string: { unit: "\xE0mi", verb: "n\xED" },
      file: { unit: "bytes", verb: "n\xED" },
      array: { unit: "nkan", verb: "n\xED" },
      set: { unit: "nkan", verb: "n\xED" }
    };
    function getSizing(origin) {
      return Sizable[origin] ?? null;
    }
    const FormatDictionary = {
      regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
      email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\xE0k\xF3k\xF2 ISO",
      date: "\u1ECDj\u1ECD\u0301 ISO",
      time: "\xE0k\xF3k\xF2 ISO",
      duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
      ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
      ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
      cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
      cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
      base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
      base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
      json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
      e164: "n\u1ECD\u0301mb\xE0 E.164",
      jwt: "JWT",
      template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
    };
    const TypeDictionary = {
      nan: "NaN",
      number: "n\u1ECD\u0301mb\xE0",
      array: "akop\u1ECD"
    };
    return (issue2) => {
      switch (issue2.code) {
        case "invalid_type": {
          const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
          const receivedType = parsedType(issue2.input);
          const received = TypeDictionary[receivedType] ?? receivedType;
          if (/^[A-Z]/.test(issue2.expected)) {
            return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi instanceof ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
          }
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
        }
        case "invalid_value":
          if (issue2.values.length === 1)
            return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
          return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
        case "too_big": {
          const adj = issue2.inclusive ? "<=" : "<";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
        }
        case "too_small": {
          const adj = issue2.inclusive ? ">=" : ">";
          const sizing = getSizing(issue2.origin);
          if (sizing)
            return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
        }
        case "invalid_format": {
          const _issue = issue2;
          if (_issue.format === "starts_with")
            return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
          if (_issue.format === "ends_with")
            return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
          if (_issue.format === "includes")
            return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
          if (_issue.format === "regex")
            return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
          return `A\u1E63\xEC\u1E63e: ${FormatDictionary[_issue.format] ?? issue2.format}`;
        }
        case "not_multiple_of":
          return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
        case "unrecognized_keys":
          return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
        case "invalid_key":
          return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
        case "invalid_union":
          return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
        case "invalid_element":
          return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
        default:
          return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      }
    };
  };
  function yo_default() {
    return {
      localeError: error47()
    };
  }

  // node_modules/zod/v4/core/registries.js
  var _a;
  var $output = /* @__PURE__ */ Symbol("ZodOutput");
  var $input = /* @__PURE__ */ Symbol("ZodInput");
  var $ZodRegistry = class {
    constructor() {
      this._map = /* @__PURE__ */ new WeakMap();
      this._idmap = /* @__PURE__ */ new Map();
    }
    add(schema, ..._meta) {
      const meta3 = _meta[0];
      this._map.set(schema, meta3);
      if (meta3 && typeof meta3 === "object" && "id" in meta3) {
        this._idmap.set(meta3.id, schema);
      }
      return this;
    }
    clear() {
      this._map = /* @__PURE__ */ new WeakMap();
      this._idmap = /* @__PURE__ */ new Map();
      return this;
    }
    remove(schema) {
      const meta3 = this._map.get(schema);
      if (meta3 && typeof meta3 === "object" && "id" in meta3) {
        this._idmap.delete(meta3.id);
      }
      this._map.delete(schema);
      return this;
    }
    get(schema) {
      const p = schema._zod.parent;
      if (p) {
        const pm = { ...this.get(p) ?? {} };
        delete pm.id;
        const f = { ...pm, ...this._map.get(schema) };
        return Object.keys(f).length ? f : void 0;
      }
      return this._map.get(schema);
    }
    has(schema) {
      return this._map.has(schema);
    }
  };
  function registry() {
    return new $ZodRegistry();
  }
  (_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
  var globalRegistry = globalThis.__zod_globalRegistry;

  // node_modules/zod/v4/core/api.js
  // @__NO_SIDE_EFFECTS__
  function _string(Class2, params) {
    return new Class2({
      type: "string",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _coercedString(Class2, params) {
    return new Class2({
      type: "string",
      coerce: true,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _email(Class2, params) {
    return new Class2({
      type: "string",
      format: "email",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _guid(Class2, params) {
    return new Class2({
      type: "string",
      format: "guid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uuid(Class2, params) {
    return new Class2({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uuidv4(Class2, params) {
    return new Class2({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: false,
      version: "v4",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uuidv6(Class2, params) {
    return new Class2({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: false,
      version: "v6",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uuidv7(Class2, params) {
    return new Class2({
      type: "string",
      format: "uuid",
      check: "string_format",
      abort: false,
      version: "v7",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _url(Class2, params) {
    return new Class2({
      type: "string",
      format: "url",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _emoji2(Class2, params) {
    return new Class2({
      type: "string",
      format: "emoji",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _nanoid(Class2, params) {
    return new Class2({
      type: "string",
      format: "nanoid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _cuid(Class2, params) {
    return new Class2({
      type: "string",
      format: "cuid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _cuid2(Class2, params) {
    return new Class2({
      type: "string",
      format: "cuid2",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _ulid(Class2, params) {
    return new Class2({
      type: "string",
      format: "ulid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _xid(Class2, params) {
    return new Class2({
      type: "string",
      format: "xid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _ksuid(Class2, params) {
    return new Class2({
      type: "string",
      format: "ksuid",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _ipv4(Class2, params) {
    return new Class2({
      type: "string",
      format: "ipv4",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _ipv6(Class2, params) {
    return new Class2({
      type: "string",
      format: "ipv6",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _mac(Class2, params) {
    return new Class2({
      type: "string",
      format: "mac",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _cidrv4(Class2, params) {
    return new Class2({
      type: "string",
      format: "cidrv4",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _cidrv6(Class2, params) {
    return new Class2({
      type: "string",
      format: "cidrv6",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _base64(Class2, params) {
    return new Class2({
      type: "string",
      format: "base64",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _base64url(Class2, params) {
    return new Class2({
      type: "string",
      format: "base64url",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _e164(Class2, params) {
    return new Class2({
      type: "string",
      format: "e164",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _jwt(Class2, params) {
    return new Class2({
      type: "string",
      format: "jwt",
      check: "string_format",
      abort: false,
      ...normalizeParams(params)
    });
  }
  var TimePrecision = {
    Any: null,
    Minute: -1,
    Second: 0,
    Millisecond: 3,
    Microsecond: 6
  };
  // @__NO_SIDE_EFFECTS__
  function _isoDateTime(Class2, params) {
    return new Class2({
      type: "string",
      format: "datetime",
      check: "string_format",
      offset: false,
      local: false,
      precision: null,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _isoDate(Class2, params) {
    return new Class2({
      type: "string",
      format: "date",
      check: "string_format",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _isoTime(Class2, params) {
    return new Class2({
      type: "string",
      format: "time",
      check: "string_format",
      precision: null,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _isoDuration(Class2, params) {
    return new Class2({
      type: "string",
      format: "duration",
      check: "string_format",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _number(Class2, params) {
    return new Class2({
      type: "number",
      checks: [],
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _coercedNumber(Class2, params) {
    return new Class2({
      type: "number",
      coerce: true,
      checks: [],
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _int(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "safeint",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _float32(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "float32",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _float64(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "float64",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _int32(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "int32",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uint32(Class2, params) {
    return new Class2({
      type: "number",
      check: "number_format",
      abort: false,
      format: "uint32",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _boolean(Class2, params) {
    return new Class2({
      type: "boolean",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _coercedBoolean(Class2, params) {
    return new Class2({
      type: "boolean",
      coerce: true,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _bigint(Class2, params) {
    return new Class2({
      type: "bigint",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _coercedBigint(Class2, params) {
    return new Class2({
      type: "bigint",
      coerce: true,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _int64(Class2, params) {
    return new Class2({
      type: "bigint",
      check: "bigint_format",
      abort: false,
      format: "int64",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uint64(Class2, params) {
    return new Class2({
      type: "bigint",
      check: "bigint_format",
      abort: false,
      format: "uint64",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _symbol(Class2, params) {
    return new Class2({
      type: "symbol",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _undefined2(Class2, params) {
    return new Class2({
      type: "undefined",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _null2(Class2, params) {
    return new Class2({
      type: "null",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _any(Class2) {
    return new Class2({
      type: "any"
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _unknown(Class2) {
    return new Class2({
      type: "unknown"
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _never(Class2, params) {
    return new Class2({
      type: "never",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _void(Class2, params) {
    return new Class2({
      type: "void",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _date(Class2, params) {
    return new Class2({
      type: "date",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _coercedDate(Class2, params) {
    return new Class2({
      type: "date",
      coerce: true,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _nan(Class2, params) {
    return new Class2({
      type: "nan",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _lt(value, params) {
    return new $ZodCheckLessThan({
      check: "less_than",
      ...normalizeParams(params),
      value,
      inclusive: false
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _lte(value, params) {
    return new $ZodCheckLessThan({
      check: "less_than",
      ...normalizeParams(params),
      value,
      inclusive: true
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _gt(value, params) {
    return new $ZodCheckGreaterThan({
      check: "greater_than",
      ...normalizeParams(params),
      value,
      inclusive: false
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _gte(value, params) {
    return new $ZodCheckGreaterThan({
      check: "greater_than",
      ...normalizeParams(params),
      value,
      inclusive: true
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _positive(params) {
    return /* @__PURE__ */ _gt(0, params);
  }
  // @__NO_SIDE_EFFECTS__
  function _negative(params) {
    return /* @__PURE__ */ _lt(0, params);
  }
  // @__NO_SIDE_EFFECTS__
  function _nonpositive(params) {
    return /* @__PURE__ */ _lte(0, params);
  }
  // @__NO_SIDE_EFFECTS__
  function _nonnegative(params) {
    return /* @__PURE__ */ _gte(0, params);
  }
  // @__NO_SIDE_EFFECTS__
  function _multipleOf(value, params) {
    return new $ZodCheckMultipleOf({
      check: "multiple_of",
      ...normalizeParams(params),
      value
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _maxSize(maximum, params) {
    return new $ZodCheckMaxSize({
      check: "max_size",
      ...normalizeParams(params),
      maximum
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _minSize(minimum, params) {
    return new $ZodCheckMinSize({
      check: "min_size",
      ...normalizeParams(params),
      minimum
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _size(size, params) {
    return new $ZodCheckSizeEquals({
      check: "size_equals",
      ...normalizeParams(params),
      size
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _maxLength(maximum, params) {
    const ch = new $ZodCheckMaxLength({
      check: "max_length",
      ...normalizeParams(params),
      maximum
    });
    return ch;
  }
  // @__NO_SIDE_EFFECTS__
  function _minLength(minimum, params) {
    return new $ZodCheckMinLength({
      check: "min_length",
      ...normalizeParams(params),
      minimum
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _length(length, params) {
    return new $ZodCheckLengthEquals({
      check: "length_equals",
      ...normalizeParams(params),
      length
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _regex(pattern, params) {
    return new $ZodCheckRegex({
      check: "string_format",
      format: "regex",
      ...normalizeParams(params),
      pattern
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _lowercase(params) {
    return new $ZodCheckLowerCase({
      check: "string_format",
      format: "lowercase",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _uppercase(params) {
    return new $ZodCheckUpperCase({
      check: "string_format",
      format: "uppercase",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _includes(includes, params) {
    return new $ZodCheckIncludes({
      check: "string_format",
      format: "includes",
      ...normalizeParams(params),
      includes
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _startsWith(prefix, params) {
    return new $ZodCheckStartsWith({
      check: "string_format",
      format: "starts_with",
      ...normalizeParams(params),
      prefix
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _endsWith(suffix, params) {
    return new $ZodCheckEndsWith({
      check: "string_format",
      format: "ends_with",
      ...normalizeParams(params),
      suffix
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _property(property, schema, params) {
    return new $ZodCheckProperty({
      check: "property",
      property,
      schema,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _mime(types, params) {
    return new $ZodCheckMimeType({
      check: "mime_type",
      mime: types,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _overwrite(tx) {
    return new $ZodCheckOverwrite({
      check: "overwrite",
      tx
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _normalize(form) {
    return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
  }
  // @__NO_SIDE_EFFECTS__
  function _trim() {
    return /* @__PURE__ */ _overwrite((input) => input.trim());
  }
  // @__NO_SIDE_EFFECTS__
  function _toLowerCase() {
    return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
  }
  // @__NO_SIDE_EFFECTS__
  function _toUpperCase() {
    return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
  }
  // @__NO_SIDE_EFFECTS__
  function _slugify() {
    return /* @__PURE__ */ _overwrite((input) => slugify(input));
  }
  // @__NO_SIDE_EFFECTS__
  function _array(Class2, element, params) {
    return new Class2({
      type: "array",
      element,
      // get element() {
      //   return element;
      // },
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _union(Class2, options, params) {
    return new Class2({
      type: "union",
      options,
      ...normalizeParams(params)
    });
  }
  function _xor(Class2, options, params) {
    return new Class2({
      type: "union",
      options,
      inclusive: false,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _discriminatedUnion(Class2, discriminator, options, params) {
    return new Class2({
      type: "union",
      options,
      discriminator,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _intersection(Class2, left, right) {
    return new Class2({
      type: "intersection",
      left,
      right
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _tuple(Class2, items, _paramsOrRest, _params) {
    const hasRest = _paramsOrRest instanceof $ZodType;
    const params = hasRest ? _params : _paramsOrRest;
    const rest = hasRest ? _paramsOrRest : null;
    return new Class2({
      type: "tuple",
      items,
      rest,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _record(Class2, keyType, valueType, params) {
    return new Class2({
      type: "record",
      keyType,
      valueType,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _map(Class2, keyType, valueType, params) {
    return new Class2({
      type: "map",
      keyType,
      valueType,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _set(Class2, valueType, params) {
    return new Class2({
      type: "set",
      valueType,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _enum(Class2, values, params) {
    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
    return new Class2({
      type: "enum",
      entries,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _nativeEnum(Class2, entries, params) {
    return new Class2({
      type: "enum",
      entries,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _literal(Class2, value, params) {
    return new Class2({
      type: "literal",
      values: Array.isArray(value) ? value : [value],
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _file(Class2, params) {
    return new Class2({
      type: "file",
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _transform(Class2, fn) {
    return new Class2({
      type: "transform",
      transform: fn
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _optional(Class2, innerType) {
    return new Class2({
      type: "optional",
      innerType
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _nullable(Class2, innerType) {
    return new Class2({
      type: "nullable",
      innerType
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _default(Class2, innerType, defaultValue) {
    return new Class2({
      type: "default",
      innerType,
      get defaultValue() {
        return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
      }
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _nonoptional(Class2, innerType, params) {
    return new Class2({
      type: "nonoptional",
      innerType,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _success(Class2, innerType) {
    return new Class2({
      type: "success",
      innerType
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _catch(Class2, innerType, catchValue) {
    return new Class2({
      type: "catch",
      innerType,
      catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _pipe(Class2, in_, out) {
    return new Class2({
      type: "pipe",
      in: in_,
      out
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _readonly(Class2, innerType) {
    return new Class2({
      type: "readonly",
      innerType
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _templateLiteral(Class2, parts, params) {
    return new Class2({
      type: "template_literal",
      parts,
      ...normalizeParams(params)
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _lazy(Class2, getter) {
    return new Class2({
      type: "lazy",
      getter
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _promise(Class2, innerType) {
    return new Class2({
      type: "promise",
      innerType
    });
  }
  // @__NO_SIDE_EFFECTS__
  function _custom(Class2, fn, _params) {
    const norm = normalizeParams(_params);
    norm.abort ?? (norm.abort = true);
    const schema = new Class2({
      type: "custom",
      check: "custom",
      fn,
      ...norm
    });
    return schema;
  }
  // @__NO_SIDE_EFFECTS__
  function _refine(Class2, fn, _params) {
    const schema = new Class2({
      type: "custom",
      check: "custom",
      fn,
      ...normalizeParams(_params)
    });
    return schema;
  }
  // @__NO_SIDE_EFFECTS__
  function _superRefine(fn) {
    const ch = /* @__PURE__ */ _check((payload) => {
      payload.addIssue = (issue2) => {
        if (typeof issue2 === "string") {
          payload.issues.push(issue(issue2, payload.value, ch._zod.def));
        } else {
          const _issue = issue2;
          if (_issue.fatal)
            _issue.continue = false;
          _issue.code ?? (_issue.code = "custom");
          _issue.input ?? (_issue.input = payload.value);
          _issue.inst ?? (_issue.inst = ch);
          _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
          payload.issues.push(issue(_issue));
        }
      };
      return fn(payload.value, payload);
    });
    return ch;
  }
  // @__NO_SIDE_EFFECTS__
  function _check(fn, params) {
    const ch = new $ZodCheck({
      check: "custom",
      ...normalizeParams(params)
    });
    ch._zod.check = fn;
    return ch;
  }
  // @__NO_SIDE_EFFECTS__
  function describe(description) {
    const ch = new $ZodCheck({ check: "describe" });
    ch._zod.onattach = [
      (inst) => {
        const existing = globalRegistry.get(inst) ?? {};
        globalRegistry.add(inst, { ...existing, description });
      }
    ];
    ch._zod.check = () => {
    };
    return ch;
  }
  // @__NO_SIDE_EFFECTS__
  function meta(metadata) {
    const ch = new $ZodCheck({ check: "meta" });
    ch._zod.onattach = [
      (inst) => {
        const existing = globalRegistry.get(inst) ?? {};
        globalRegistry.add(inst, { ...existing, ...metadata });
      }
    ];
    ch._zod.check = () => {
    };
    return ch;
  }
  // @__NO_SIDE_EFFECTS__
  function _stringbool(Classes, _params) {
    const params = normalizeParams(_params);
    let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
    let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
    if (params.case !== "sensitive") {
      truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
      falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    }
    const truthySet = new Set(truthyArray);
    const falsySet = new Set(falsyArray);
    const _Codec = Classes.Codec ?? $ZodCodec;
    const _Boolean = Classes.Boolean ?? $ZodBoolean;
    const _String = Classes.String ?? $ZodString;
    const stringSchema2 = new _String({ type: "string", error: params.error });
    const booleanSchema2 = new _Boolean({ type: "boolean", error: params.error });
    const codec2 = new _Codec({
      type: "pipe",
      in: stringSchema2,
      out: booleanSchema2,
      transform: ((input, payload) => {
        let data = input;
        if (params.case !== "sensitive")
          data = data.toLowerCase();
        if (truthySet.has(data)) {
          return true;
        } else if (falsySet.has(data)) {
          return false;
        } else {
          payload.issues.push({
            code: "invalid_value",
            expected: "stringbool",
            values: [...truthySet, ...falsySet],
            input: payload.value,
            inst: codec2,
            continue: false
          });
          return {};
        }
      }),
      reverseTransform: ((input, _payload) => {
        if (input === true) {
          return truthyArray[0] || "true";
        } else {
          return falsyArray[0] || "false";
        }
      }),
      error: params.error
    });
    return codec2;
  }
  // @__NO_SIDE_EFFECTS__
  function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
    const params = normalizeParams(_params);
    const def = {
      ...normalizeParams(_params),
      check: "string_format",
      type: "string",
      format,
      fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
      ...params
    };
    if (fnOrRegex instanceof RegExp) {
      def.pattern = fnOrRegex;
    }
    const inst = new Class2(def);
    return inst;
  }

  // node_modules/zod/v4/core/to-json-schema.js
  function initializeContext(params) {
    let target = params?.target ?? "draft-2020-12";
    if (target === "draft-4")
      target = "draft-04";
    if (target === "draft-7")
      target = "draft-07";
    return {
      processors: params.processors ?? {},
      metadataRegistry: params?.metadata ?? globalRegistry,
      target,
      unrepresentable: params?.unrepresentable ?? "throw",
      override: params?.override ?? (() => {
      }),
      io: params?.io ?? "output",
      counter: 0,
      seen: /* @__PURE__ */ new Map(),
      cycles: params?.cycles ?? "ref",
      reused: params?.reused ?? "inline",
      external: params?.external ?? void 0
    };
  }
  function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
    var _a2;
    const def = schema._zod.def;
    const seen = ctx.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
    ctx.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      if (schema._zod.processJSONSchema) {
        schema._zod.processJSONSchema(ctx, result.schema, params);
      } else {
        const _json = result.schema;
        const processor = ctx.processors[def.type];
        if (!processor) {
          throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
        }
        processor(schema, ctx, _json, params);
      }
      const parent = schema._zod.parent;
      if (parent) {
        if (!result.ref)
          result.ref = parent;
        process2(parent, ctx, params);
        ctx.seen.get(parent).isParent = true;
      }
    }
    const meta3 = ctx.metadataRegistry.get(schema);
    if (meta3)
      Object.assign(result.schema, meta3);
    if (ctx.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (ctx.io === "input" && result.schema._prefault)
      (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = ctx.seen.get(schema);
    return _result.schema;
  }
  function extractDefs(ctx, schema) {
    const root = ctx.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const idToSchema = /* @__PURE__ */ new Map();
    for (const entry of ctx.seen.entries()) {
      const id2 = ctx.metadataRegistry.get(entry[0])?.id;
      if (id2) {
        const existing = idToSchema.get(id2);
        if (existing && existing !== entry[0]) {
          throw new Error(`Duplicate schema id "${id2}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
        }
        idToSchema.set(id2, entry[0]);
      }
    }
    const makeURI = (entry) => {
      const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
      if (ctx.external) {
        const externalId = ctx.external.registry.get(entry[0])?.id;
        const uriGenerator = ctx.external.uri ?? ((id3) => id3);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id2 = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
        entry[1].defId = id2;
        return { defId: id2, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id2}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (ctx.cycles === "throw") {
      for (const entry of ctx.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      }
    }
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (ctx.external) {
        const ext = ctx.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id2 = ctx.metadataRegistry.get(entry[0])?.id;
      if (id2) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (ctx.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
  }
  function finalize(ctx, schema) {
    const root = ctx.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const flattenRef = (zodSchema) => {
      const seen = ctx.seen.get(zodSchema);
      if (seen.ref === null)
        return;
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref);
        const refSeen = ctx.seen.get(ref);
        const refSchema = refSeen.schema;
        if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
        }
        Object.assign(schema2, _cached);
        const isParentRef = zodSchema._zod.parent === ref;
        if (isParentRef) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (!(key in _cached)) {
              delete schema2[key];
            }
          }
        }
        if (refSchema.$ref && refSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
      const parent = zodSchema._zod.parent;
      if (parent && parent !== ref) {
        flattenRef(parent);
        const parentSeen = ctx.seen.get(parent);
        if (parentSeen?.schema.$ref) {
          schema2.$ref = parentSeen.schema.$ref;
          if (parentSeen.def) {
            for (const key in schema2) {
              if (key === "$ref" || key === "allOf")
                continue;
              if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
                delete schema2[key];
              }
            }
          }
        }
      }
      ctx.override({
        zodSchema,
        jsonSchema: schema2,
        path: seen.path ?? []
      });
    };
    for (const entry of [...ctx.seen.entries()].reverse()) {
      flattenRef(entry[0]);
    }
    const result = {};
    if (ctx.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (ctx.target === "draft-07") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (ctx.target === "draft-04") {
      result.$schema = "http://json-schema.org/draft-04/schema#";
    } else if (ctx.target === "openapi-3.0") {
    } else {
    }
    if (ctx.external?.uri) {
      const id2 = ctx.external.registry.get(schema)?.id;
      if (!id2)
        throw new Error("Schema is missing an `id` property");
      result.$id = ctx.external.uri(id2);
    }
    Object.assign(result, root.def ?? root.schema);
    const defs = ctx.external?.defs ?? {};
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (ctx.external) {
    } else {
      if (Object.keys(defs).length > 0) {
        if (ctx.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      const finalized = JSON.parse(JSON.stringify(result));
      Object.defineProperty(finalized, "~standard", {
        value: {
          ...schema["~standard"],
          jsonSchema: {
            input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
            output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
          }
        },
        enumerable: false,
        writable: false
      });
      return finalized;
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
  function isTransforming(_schema, _ctx) {
    const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
    if (ctx.seen.has(_schema))
      return false;
    ctx.seen.add(_schema);
    const def = _schema._zod.def;
    if (def.type === "transform")
      return true;
    if (def.type === "array")
      return isTransforming(def.element, ctx);
    if (def.type === "set")
      return isTransforming(def.valueType, ctx);
    if (def.type === "lazy")
      return isTransforming(def.getter(), ctx);
    if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
      return isTransforming(def.innerType, ctx);
    }
    if (def.type === "intersection") {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    if (def.type === "record" || def.type === "map") {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    if (def.type === "pipe") {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    if (def.type === "object") {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    if (def.type === "union") {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    if (def.type === "tuple") {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    return false;
  }
  var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
    const ctx = initializeContext({ ...params, processors });
    process2(schema, ctx);
    extractDefs(ctx, schema);
    return finalize(ctx, schema);
  };
  var createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
    const { libraryOptions, target } = params ?? {};
    const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
    process2(schema, ctx);
    extractDefs(ctx, schema);
    return finalize(ctx, schema);
  };

  // node_modules/zod/v4/core/json-schema-processors.js
  var formatMap = {
    guid: "uuid",
    url: "uri",
    datetime: "date-time",
    json_string: "json-string",
    regex: ""
    // do not set
  };
  var stringProcessor = (schema, ctx, _json, _params) => {
    const json3 = _json;
    json3.type = "string";
    const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
    if (typeof minimum === "number")
      json3.minLength = minimum;
    if (typeof maximum === "number")
      json3.maxLength = maximum;
    if (format) {
      json3.format = formatMap[format] ?? format;
      if (json3.format === "")
        delete json3.format;
      if (format === "time") {
        delete json3.format;
      }
    }
    if (contentEncoding)
      json3.contentEncoding = contentEncoding;
    if (patterns && patterns.size > 0) {
      const regexes = [...patterns];
      if (regexes.length === 1)
        json3.pattern = regexes[0].source;
      else if (regexes.length > 1) {
        json3.allOf = [
          ...regexes.map((regex) => ({
            ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
            pattern: regex.source
          }))
        ];
      }
    }
  };
  var numberProcessor = (schema, ctx, _json, _params) => {
    const json3 = _json;
    const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
    if (typeof format === "string" && format.includes("int"))
      json3.type = "integer";
    else
      json3.type = "number";
    if (typeof exclusiveMinimum === "number") {
      if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
        json3.minimum = exclusiveMinimum;
        json3.exclusiveMinimum = true;
      } else {
        json3.exclusiveMinimum = exclusiveMinimum;
      }
    }
    if (typeof minimum === "number") {
      json3.minimum = minimum;
      if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
        if (exclusiveMinimum >= minimum)
          delete json3.minimum;
        else
          delete json3.exclusiveMinimum;
      }
    }
    if (typeof exclusiveMaximum === "number") {
      if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
        json3.maximum = exclusiveMaximum;
        json3.exclusiveMaximum = true;
      } else {
        json3.exclusiveMaximum = exclusiveMaximum;
      }
    }
    if (typeof maximum === "number") {
      json3.maximum = maximum;
      if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
        if (exclusiveMaximum <= maximum)
          delete json3.maximum;
        else
          delete json3.exclusiveMaximum;
      }
    }
    if (typeof multipleOf === "number")
      json3.multipleOf = multipleOf;
  };
  var booleanProcessor = (_schema, _ctx, json3, _params) => {
    json3.type = "boolean";
  };
  var bigintProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("BigInt cannot be represented in JSON Schema");
    }
  };
  var symbolProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Symbols cannot be represented in JSON Schema");
    }
  };
  var nullProcessor = (_schema, ctx, json3, _params) => {
    if (ctx.target === "openapi-3.0") {
      json3.type = "string";
      json3.nullable = true;
      json3.enum = [null];
    } else {
      json3.type = "null";
    }
  };
  var undefinedProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Undefined cannot be represented in JSON Schema");
    }
  };
  var voidProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Void cannot be represented in JSON Schema");
    }
  };
  var neverProcessor = (_schema, _ctx, json3, _params) => {
    json3.not = {};
  };
  var anyProcessor = (_schema, _ctx, _json, _params) => {
  };
  var unknownProcessor = (_schema, _ctx, _json, _params) => {
  };
  var dateProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Date cannot be represented in JSON Schema");
    }
  };
  var enumProcessor = (schema, _ctx, json3, _params) => {
    const def = schema._zod.def;
    const values = getEnumValues(def.entries);
    if (values.every((v) => typeof v === "number"))
      json3.type = "number";
    if (values.every((v) => typeof v === "string"))
      json3.type = "string";
    json3.enum = values;
  };
  var literalProcessor = (schema, ctx, json3, _params) => {
    const def = schema._zod.def;
    const vals = [];
    for (const val of def.values) {
      if (val === void 0) {
        if (ctx.unrepresentable === "throw") {
          throw new Error("Literal `undefined` cannot be represented in JSON Schema");
        } else {
        }
      } else if (typeof val === "bigint") {
        if (ctx.unrepresentable === "throw") {
          throw new Error("BigInt literals cannot be represented in JSON Schema");
        } else {
          vals.push(Number(val));
        }
      } else {
        vals.push(val);
      }
    }
    if (vals.length === 0) {
    } else if (vals.length === 1) {
      const val = vals[0];
      json3.type = val === null ? "null" : typeof val;
      if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
        json3.enum = [val];
      } else {
        json3.const = val;
      }
    } else {
      if (vals.every((v) => typeof v === "number"))
        json3.type = "number";
      if (vals.every((v) => typeof v === "string"))
        json3.type = "string";
      if (vals.every((v) => typeof v === "boolean"))
        json3.type = "boolean";
      if (vals.every((v) => v === null))
        json3.type = "null";
      json3.enum = vals;
    }
  };
  var nanProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("NaN cannot be represented in JSON Schema");
    }
  };
  var templateLiteralProcessor = (schema, _ctx, json3, _params) => {
    const _json = json3;
    const pattern = schema._zod.pattern;
    if (!pattern)
      throw new Error("Pattern not found in template literal");
    _json.type = "string";
    _json.pattern = pattern.source;
  };
  var fileProcessor = (schema, _ctx, json3, _params) => {
    const _json = json3;
    const file2 = {
      type: "string",
      format: "binary",
      contentEncoding: "binary"
    };
    const { minimum, maximum, mime } = schema._zod.bag;
    if (minimum !== void 0)
      file2.minLength = minimum;
    if (maximum !== void 0)
      file2.maxLength = maximum;
    if (mime) {
      if (mime.length === 1) {
        file2.contentMediaType = mime[0];
        Object.assign(_json, file2);
      } else {
        Object.assign(_json, file2);
        _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
      }
    } else {
      Object.assign(_json, file2);
    }
  };
  var successProcessor = (_schema, _ctx, json3, _params) => {
    json3.type = "boolean";
  };
  var customProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Custom types cannot be represented in JSON Schema");
    }
  };
  var functionProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Function types cannot be represented in JSON Schema");
    }
  };
  var transformProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Transforms cannot be represented in JSON Schema");
    }
  };
  var mapProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Map cannot be represented in JSON Schema");
    }
  };
  var setProcessor = (_schema, ctx, _json, _params) => {
    if (ctx.unrepresentable === "throw") {
      throw new Error("Set cannot be represented in JSON Schema");
    }
  };
  var arrayProcessor = (schema, ctx, _json, params) => {
    const json3 = _json;
    const def = schema._zod.def;
    const { minimum, maximum } = schema._zod.bag;
    if (typeof minimum === "number")
      json3.minItems = minimum;
    if (typeof maximum === "number")
      json3.maxItems = maximum;
    json3.type = "array";
    json3.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
  };
  var objectProcessor = (schema, ctx, _json, params) => {
    const json3 = _json;
    const def = schema._zod.def;
    json3.type = "object";
    json3.properties = {};
    const shape = def.shape;
    for (const key in shape) {
      json3.properties[key] = process2(shape[key], ctx, {
        ...params,
        path: [...params.path, "properties", key]
      });
    }
    const allKeys = new Set(Object.keys(shape));
    const requiredKeys = new Set([...allKeys].filter((key) => {
      const v = def.shape[key]._zod;
      if (ctx.io === "input") {
        return v.optin === void 0;
      } else {
        return v.optout === void 0;
      }
    }));
    if (requiredKeys.size > 0) {
      json3.required = Array.from(requiredKeys);
    }
    if (def.catchall?._zod.def.type === "never") {
      json3.additionalProperties = false;
    } else if (!def.catchall) {
      if (ctx.io === "output")
        json3.additionalProperties = false;
    } else if (def.catchall) {
      json3.additionalProperties = process2(def.catchall, ctx, {
        ...params,
        path: [...params.path, "additionalProperties"]
      });
    }
  };
  var unionProcessor = (schema, ctx, json3, params) => {
    const def = schema._zod.def;
    const isExclusive = def.inclusive === false;
    const options = def.options.map((x, i) => process2(x, ctx, {
      ...params,
      path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
    }));
    if (isExclusive) {
      json3.oneOf = options;
    } else {
      json3.anyOf = options;
    }
  };
  var intersectionProcessor = (schema, ctx, json3, params) => {
    const def = schema._zod.def;
    const a = process2(def.left, ctx, {
      ...params,
      path: [...params.path, "allOf", 0]
    });
    const b = process2(def.right, ctx, {
      ...params,
      path: [...params.path, "allOf", 1]
    });
    const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
    const allOf = [
      ...isSimpleIntersection(a) ? a.allOf : [a],
      ...isSimpleIntersection(b) ? b.allOf : [b]
    ];
    json3.allOf = allOf;
  };
  var tupleProcessor = (schema, ctx, _json, params) => {
    const json3 = _json;
    const def = schema._zod.def;
    json3.type = "array";
    const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
    const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
    const prefixItems = def.items.map((x, i) => process2(x, ctx, {
      ...params,
      path: [...params.path, prefixPath, i]
    }));
    const rest = def.rest ? process2(def.rest, ctx, {
      ...params,
      path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
    }) : null;
    if (ctx.target === "draft-2020-12") {
      json3.prefixItems = prefixItems;
      if (rest) {
        json3.items = rest;
      }
    } else if (ctx.target === "openapi-3.0") {
      json3.items = {
        anyOf: prefixItems
      };
      if (rest) {
        json3.items.anyOf.push(rest);
      }
      json3.minItems = prefixItems.length;
      if (!rest) {
        json3.maxItems = prefixItems.length;
      }
    } else {
      json3.items = prefixItems;
      if (rest) {
        json3.additionalItems = rest;
      }
    }
    const { minimum, maximum } = schema._zod.bag;
    if (typeof minimum === "number")
      json3.minItems = minimum;
    if (typeof maximum === "number")
      json3.maxItems = maximum;
  };
  var recordProcessor = (schema, ctx, _json, params) => {
    const json3 = _json;
    const def = schema._zod.def;
    json3.type = "object";
    const keyType = def.keyType;
    const keyBag = keyType._zod.bag;
    const patterns = keyBag?.patterns;
    if (def.mode === "loose" && patterns && patterns.size > 0) {
      const valueSchema = process2(def.valueType, ctx, {
        ...params,
        path: [...params.path, "patternProperties", "*"]
      });
      json3.patternProperties = {};
      for (const pattern of patterns) {
        json3.patternProperties[pattern.source] = valueSchema;
      }
    } else {
      if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
        json3.propertyNames = process2(def.keyType, ctx, {
          ...params,
          path: [...params.path, "propertyNames"]
        });
      }
      json3.additionalProperties = process2(def.valueType, ctx, {
        ...params,
        path: [...params.path, "additionalProperties"]
      });
    }
    const keyValues = keyType._zod.values;
    if (keyValues) {
      const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
      if (validKeyValues.length > 0) {
        json3.required = validKeyValues;
      }
    }
  };
  var nullableProcessor = (schema, ctx, json3, params) => {
    const def = schema._zod.def;
    const inner = process2(def.innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    if (ctx.target === "openapi-3.0") {
      seen.ref = def.innerType;
      json3.nullable = true;
    } else {
      json3.anyOf = [inner, { type: "null" }];
    }
  };
  var nonoptionalProcessor = (schema, ctx, _json, params) => {
    const def = schema._zod.def;
    process2(def.innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = def.innerType;
  };
  var defaultProcessor = (schema, ctx, json3, params) => {
    const def = schema._zod.def;
    process2(def.innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = def.innerType;
    json3.default = JSON.parse(JSON.stringify(def.defaultValue));
  };
  var prefaultProcessor = (schema, ctx, json3, params) => {
    const def = schema._zod.def;
    process2(def.innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = def.innerType;
    if (ctx.io === "input")
      json3._prefault = JSON.parse(JSON.stringify(def.defaultValue));
  };
  var catchProcessor = (schema, ctx, json3, params) => {
    const def = schema._zod.def;
    process2(def.innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = def.innerType;
    let catchValue;
    try {
      catchValue = def.catchValue(void 0);
    } catch {
      throw new Error("Dynamic catch values are not supported in JSON Schema");
    }
    json3.default = catchValue;
  };
  var pipeProcessor = (schema, ctx, _json, params) => {
    const def = schema._zod.def;
    const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
    process2(innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = innerType;
  };
  var readonlyProcessor = (schema, ctx, json3, params) => {
    const def = schema._zod.def;
    process2(def.innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = def.innerType;
    json3.readOnly = true;
  };
  var promiseProcessor = (schema, ctx, _json, params) => {
    const def = schema._zod.def;
    process2(def.innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = def.innerType;
  };
  var optionalProcessor = (schema, ctx, _json, params) => {
    const def = schema._zod.def;
    process2(def.innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = def.innerType;
  };
  var lazyProcessor = (schema, ctx, _json, params) => {
    const innerType = schema._zod.innerType;
    process2(innerType, ctx, params);
    const seen = ctx.seen.get(schema);
    seen.ref = innerType;
  };
  var allProcessors = {
    string: stringProcessor,
    number: numberProcessor,
    boolean: booleanProcessor,
    bigint: bigintProcessor,
    symbol: symbolProcessor,
    null: nullProcessor,
    undefined: undefinedProcessor,
    void: voidProcessor,
    never: neverProcessor,
    any: anyProcessor,
    unknown: unknownProcessor,
    date: dateProcessor,
    enum: enumProcessor,
    literal: literalProcessor,
    nan: nanProcessor,
    template_literal: templateLiteralProcessor,
    file: fileProcessor,
    success: successProcessor,
    custom: customProcessor,
    function: functionProcessor,
    transform: transformProcessor,
    map: mapProcessor,
    set: setProcessor,
    array: arrayProcessor,
    object: objectProcessor,
    union: unionProcessor,
    intersection: intersectionProcessor,
    tuple: tupleProcessor,
    record: recordProcessor,
    nullable: nullableProcessor,
    nonoptional: nonoptionalProcessor,
    default: defaultProcessor,
    prefault: prefaultProcessor,
    catch: catchProcessor,
    pipe: pipeProcessor,
    readonly: readonlyProcessor,
    promise: promiseProcessor,
    optional: optionalProcessor,
    lazy: lazyProcessor
  };
  function toJSONSchema(input, params) {
    if ("_idmap" in input) {
      const registry2 = input;
      const ctx2 = initializeContext({ ...params, processors: allProcessors });
      const defs = {};
      for (const entry of registry2._idmap.entries()) {
        const [_, schema] = entry;
        process2(schema, ctx2);
      }
      const schemas = {};
      const external = {
        registry: registry2,
        uri: params?.uri,
        defs
      };
      ctx2.external = external;
      for (const entry of registry2._idmap.entries()) {
        const [key, schema] = entry;
        extractDefs(ctx2, schema);
        schemas[key] = finalize(ctx2, schema);
      }
      if (Object.keys(defs).length > 0) {
        const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
        schemas.__shared = {
          [defsSegment]: defs
        };
      }
      return { schemas };
    }
    const ctx = initializeContext({ ...params, processors: allProcessors });
    process2(input, ctx);
    extractDefs(ctx, input);
    return finalize(ctx, input);
  }

  // node_modules/zod/v4/core/json-schema-generator.js
  var JSONSchemaGenerator = class {
    /** @deprecated Access via ctx instead */
    get metadataRegistry() {
      return this.ctx.metadataRegistry;
    }
    /** @deprecated Access via ctx instead */
    get target() {
      return this.ctx.target;
    }
    /** @deprecated Access via ctx instead */
    get unrepresentable() {
      return this.ctx.unrepresentable;
    }
    /** @deprecated Access via ctx instead */
    get override() {
      return this.ctx.override;
    }
    /** @deprecated Access via ctx instead */
    get io() {
      return this.ctx.io;
    }
    /** @deprecated Access via ctx instead */
    get counter() {
      return this.ctx.counter;
    }
    set counter(value) {
      this.ctx.counter = value;
    }
    /** @deprecated Access via ctx instead */
    get seen() {
      return this.ctx.seen;
    }
    constructor(params) {
      let normalizedTarget = params?.target ?? "draft-2020-12";
      if (normalizedTarget === "draft-4")
        normalizedTarget = "draft-04";
      if (normalizedTarget === "draft-7")
        normalizedTarget = "draft-07";
      this.ctx = initializeContext({
        processors: allProcessors,
        target: normalizedTarget,
        ...params?.metadata && { metadata: params.metadata },
        ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
        ...params?.override && { override: params.override },
        ...params?.io && { io: params.io }
      });
    }
    /**
     * Process a schema to prepare it for JSON Schema generation.
     * This must be called before emit().
     */
    process(schema, _params = { path: [], schemaPath: [] }) {
      return process2(schema, this.ctx, _params);
    }
    /**
     * Emit the final JSON Schema after processing.
     * Must call process() first.
     */
    emit(schema, _params) {
      if (_params) {
        if (_params.cycles)
          this.ctx.cycles = _params.cycles;
        if (_params.reused)
          this.ctx.reused = _params.reused;
        if (_params.external)
          this.ctx.external = _params.external;
      }
      extractDefs(this.ctx, schema);
      const result = finalize(this.ctx, schema);
      const { "~standard": _, ...plainResult } = result;
      return plainResult;
    }
  };

  // node_modules/zod/v4/core/json-schema.js
  var json_schema_exports = {};

  // node_modules/zod/v4/classic/schemas.js
  var schemas_exports2 = {};
  __export(schemas_exports2, {
    ZodAny: () => ZodAny,
    ZodArray: () => ZodArray,
    ZodBase64: () => ZodBase64,
    ZodBase64URL: () => ZodBase64URL,
    ZodBigInt: () => ZodBigInt,
    ZodBigIntFormat: () => ZodBigIntFormat,
    ZodBoolean: () => ZodBoolean,
    ZodCIDRv4: () => ZodCIDRv4,
    ZodCIDRv6: () => ZodCIDRv6,
    ZodCUID: () => ZodCUID,
    ZodCUID2: () => ZodCUID2,
    ZodCatch: () => ZodCatch,
    ZodCodec: () => ZodCodec,
    ZodCustom: () => ZodCustom,
    ZodCustomStringFormat: () => ZodCustomStringFormat,
    ZodDate: () => ZodDate,
    ZodDefault: () => ZodDefault,
    ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
    ZodE164: () => ZodE164,
    ZodEmail: () => ZodEmail,
    ZodEmoji: () => ZodEmoji,
    ZodEnum: () => ZodEnum,
    ZodExactOptional: () => ZodExactOptional,
    ZodFile: () => ZodFile,
    ZodFunction: () => ZodFunction,
    ZodGUID: () => ZodGUID,
    ZodIPv4: () => ZodIPv4,
    ZodIPv6: () => ZodIPv6,
    ZodIntersection: () => ZodIntersection,
    ZodJWT: () => ZodJWT,
    ZodKSUID: () => ZodKSUID,
    ZodLazy: () => ZodLazy,
    ZodLiteral: () => ZodLiteral,
    ZodMAC: () => ZodMAC,
    ZodMap: () => ZodMap,
    ZodNaN: () => ZodNaN,
    ZodNanoID: () => ZodNanoID,
    ZodNever: () => ZodNever,
    ZodNonOptional: () => ZodNonOptional,
    ZodNull: () => ZodNull,
    ZodNullable: () => ZodNullable,
    ZodNumber: () => ZodNumber,
    ZodNumberFormat: () => ZodNumberFormat,
    ZodObject: () => ZodObject,
    ZodOptional: () => ZodOptional,
    ZodPipe: () => ZodPipe,
    ZodPrefault: () => ZodPrefault,
    ZodPromise: () => ZodPromise,
    ZodReadonly: () => ZodReadonly,
    ZodRecord: () => ZodRecord,
    ZodSet: () => ZodSet,
    ZodString: () => ZodString,
    ZodStringFormat: () => ZodStringFormat,
    ZodSuccess: () => ZodSuccess,
    ZodSymbol: () => ZodSymbol,
    ZodTemplateLiteral: () => ZodTemplateLiteral,
    ZodTransform: () => ZodTransform,
    ZodTuple: () => ZodTuple,
    ZodType: () => ZodType,
    ZodULID: () => ZodULID,
    ZodURL: () => ZodURL,
    ZodUUID: () => ZodUUID,
    ZodUndefined: () => ZodUndefined,
    ZodUnion: () => ZodUnion,
    ZodUnknown: () => ZodUnknown,
    ZodVoid: () => ZodVoid,
    ZodXID: () => ZodXID,
    ZodXor: () => ZodXor,
    _ZodString: () => _ZodString,
    _default: () => _default2,
    _function: () => _function,
    any: () => any,
    array: () => array,
    base64: () => base642,
    base64url: () => base64url2,
    bigint: () => bigint2,
    boolean: () => boolean2,
    catch: () => _catch2,
    check: () => check,
    cidrv4: () => cidrv42,
    cidrv6: () => cidrv62,
    codec: () => codec,
    cuid: () => cuid3,
    cuid2: () => cuid22,
    custom: () => custom,
    date: () => date3,
    describe: () => describe2,
    discriminatedUnion: () => discriminatedUnion,
    e164: () => e1642,
    email: () => email2,
    emoji: () => emoji2,
    enum: () => _enum2,
    exactOptional: () => exactOptional,
    file: () => file,
    float32: () => float32,
    float64: () => float64,
    function: () => _function,
    guid: () => guid2,
    hash: () => hash,
    hex: () => hex2,
    hostname: () => hostname2,
    httpUrl: () => httpUrl,
    instanceof: () => _instanceof,
    int: () => int,
    int32: () => int32,
    int64: () => int64,
    intersection: () => intersection,
    ipv4: () => ipv42,
    ipv6: () => ipv62,
    json: () => json,
    jwt: () => jwt,
    keyof: () => keyof,
    ksuid: () => ksuid2,
    lazy: () => lazy,
    literal: () => literal,
    looseObject: () => looseObject,
    looseRecord: () => looseRecord,
    mac: () => mac2,
    map: () => map,
    meta: () => meta2,
    nan: () => nan,
    nanoid: () => nanoid2,
    nativeEnum: () => nativeEnum,
    never: () => never,
    nonoptional: () => nonoptional,
    null: () => _null3,
    nullable: () => nullable,
    nullish: () => nullish2,
    number: () => number2,
    object: () => object,
    optional: () => optional,
    partialRecord: () => partialRecord,
    pipe: () => pipe,
    prefault: () => prefault,
    preprocess: () => preprocess,
    promise: () => promise,
    readonly: () => readonly,
    record: () => record,
    refine: () => refine,
    set: () => set,
    strictObject: () => strictObject,
    string: () => string2,
    stringFormat: () => stringFormat,
    stringbool: () => stringbool,
    success: () => success,
    superRefine: () => superRefine,
    symbol: () => symbol,
    templateLiteral: () => templateLiteral,
    transform: () => transform,
    tuple: () => tuple,
    uint32: () => uint32,
    uint64: () => uint64,
    ulid: () => ulid2,
    undefined: () => _undefined3,
    union: () => union,
    unknown: () => unknown,
    url: () => url,
    uuid: () => uuid2,
    uuidv4: () => uuidv4,
    uuidv6: () => uuidv6,
    uuidv7: () => uuidv7,
    void: () => _void2,
    xid: () => xid2,
    xor: () => xor
  });

  // node_modules/zod/v4/classic/checks.js
  var checks_exports2 = {};
  __export(checks_exports2, {
    endsWith: () => _endsWith,
    gt: () => _gt,
    gte: () => _gte,
    includes: () => _includes,
    length: () => _length,
    lowercase: () => _lowercase,
    lt: () => _lt,
    lte: () => _lte,
    maxLength: () => _maxLength,
    maxSize: () => _maxSize,
    mime: () => _mime,
    minLength: () => _minLength,
    minSize: () => _minSize,
    multipleOf: () => _multipleOf,
    negative: () => _negative,
    nonnegative: () => _nonnegative,
    nonpositive: () => _nonpositive,
    normalize: () => _normalize,
    overwrite: () => _overwrite,
    positive: () => _positive,
    property: () => _property,
    regex: () => _regex,
    size: () => _size,
    slugify: () => _slugify,
    startsWith: () => _startsWith,
    toLowerCase: () => _toLowerCase,
    toUpperCase: () => _toUpperCase,
    trim: () => _trim,
    uppercase: () => _uppercase
  });

  // node_modules/zod/v4/classic/iso.js
  var iso_exports = {};
  __export(iso_exports, {
    ZodISODate: () => ZodISODate,
    ZodISODateTime: () => ZodISODateTime,
    ZodISODuration: () => ZodISODuration,
    ZodISOTime: () => ZodISOTime,
    date: () => date2,
    datetime: () => datetime2,
    duration: () => duration2,
    time: () => time2
  });
  var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
    $ZodISODateTime.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function datetime2(params) {
    return _isoDateTime(ZodISODateTime, params);
  }
  var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
    $ZodISODate.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function date2(params) {
    return _isoDate(ZodISODate, params);
  }
  var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
    $ZodISOTime.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function time2(params) {
    return _isoTime(ZodISOTime, params);
  }
  var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
    $ZodISODuration.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function duration2(params) {
    return _isoDuration(ZodISODuration, params);
  }

  // node_modules/zod/v4/classic/errors.js
  var initializer2 = (inst, issues) => {
    $ZodError.init(inst, issues);
    inst.name = "ZodError";
    Object.defineProperties(inst, {
      format: {
        value: (mapper) => formatError(inst, mapper)
        // enumerable: false,
      },
      flatten: {
        value: (mapper) => flattenError(inst, mapper)
        // enumerable: false,
      },
      addIssue: {
        value: (issue2) => {
          inst.issues.push(issue2);
          inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
        }
        // enumerable: false,
      },
      addIssues: {
        value: (issues2) => {
          inst.issues.push(...issues2);
          inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
        }
        // enumerable: false,
      },
      isEmpty: {
        get() {
          return inst.issues.length === 0;
        }
        // enumerable: false,
      }
    });
  };
  var ZodError = $constructor("ZodError", initializer2);
  var ZodRealError = $constructor("ZodError", initializer2, {
    Parent: Error
  });

  // node_modules/zod/v4/classic/parse.js
  var parse2 = /* @__PURE__ */ _parse(ZodRealError);
  var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
  var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
  var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
  var encode2 = /* @__PURE__ */ _encode(ZodRealError);
  var decode2 = /* @__PURE__ */ _decode(ZodRealError);
  var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
  var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
  var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
  var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
  var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
  var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

  // node_modules/zod/v4/classic/schemas.js
  var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
    $ZodType.init(inst, def);
    Object.assign(inst["~standard"], {
      jsonSchema: {
        input: createStandardJSONSchemaMethod(inst, "input"),
        output: createStandardJSONSchemaMethod(inst, "output")
      }
    });
    inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
    inst.def = def;
    inst.type = def.type;
    Object.defineProperty(inst, "_def", { value: def });
    inst.check = (...checks) => {
      return inst.clone(util_exports.mergeDefs(def, {
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }), {
        parent: true
      });
    };
    inst.with = inst.check;
    inst.clone = (def2, params) => clone(inst, def2, params);
    inst.brand = () => inst;
    inst.register = ((reg, meta3) => {
      reg.add(inst, meta3);
      return inst;
    });
    inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
    inst.safeParse = (data, params) => safeParse2(inst, data, params);
    inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
    inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
    inst.spa = inst.safeParseAsync;
    inst.encode = (data, params) => encode2(inst, data, params);
    inst.decode = (data, params) => decode2(inst, data, params);
    inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
    inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
    inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
    inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
    inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
    inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
    inst.refine = (check2, params) => inst.check(refine(check2, params));
    inst.superRefine = (refinement) => inst.check(superRefine(refinement));
    inst.overwrite = (fn) => inst.check(_overwrite(fn));
    inst.optional = () => optional(inst);
    inst.exactOptional = () => exactOptional(inst);
    inst.nullable = () => nullable(inst);
    inst.nullish = () => optional(nullable(inst));
    inst.nonoptional = (params) => nonoptional(inst, params);
    inst.array = () => array(inst);
    inst.or = (arg) => union([inst, arg]);
    inst.and = (arg) => intersection(inst, arg);
    inst.transform = (tx) => pipe(inst, transform(tx));
    inst.default = (def2) => _default2(inst, def2);
    inst.prefault = (def2) => prefault(inst, def2);
    inst.catch = (params) => _catch2(inst, params);
    inst.pipe = (target) => pipe(inst, target);
    inst.readonly = () => readonly(inst);
    inst.describe = (description) => {
      const cl = inst.clone();
      globalRegistry.add(cl, { description });
      return cl;
    };
    Object.defineProperty(inst, "description", {
      get() {
        return globalRegistry.get(inst)?.description;
      },
      configurable: true
    });
    inst.meta = (...args) => {
      if (args.length === 0) {
        return globalRegistry.get(inst);
      }
      const cl = inst.clone();
      globalRegistry.add(cl, args[0]);
      return cl;
    };
    inst.isOptional = () => inst.safeParse(void 0).success;
    inst.isNullable = () => inst.safeParse(null).success;
    inst.apply = (fn) => fn(inst);
    return inst;
  });
  var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
    $ZodString.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => stringProcessor(inst, ctx, json3, params);
    const bag = inst._zod.bag;
    inst.format = bag.format ?? null;
    inst.minLength = bag.minimum ?? null;
    inst.maxLength = bag.maximum ?? null;
    inst.regex = (...args) => inst.check(_regex(...args));
    inst.includes = (...args) => inst.check(_includes(...args));
    inst.startsWith = (...args) => inst.check(_startsWith(...args));
    inst.endsWith = (...args) => inst.check(_endsWith(...args));
    inst.min = (...args) => inst.check(_minLength(...args));
    inst.max = (...args) => inst.check(_maxLength(...args));
    inst.length = (...args) => inst.check(_length(...args));
    inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
    inst.lowercase = (params) => inst.check(_lowercase(params));
    inst.uppercase = (params) => inst.check(_uppercase(params));
    inst.trim = () => inst.check(_trim());
    inst.normalize = (...args) => inst.check(_normalize(...args));
    inst.toLowerCase = () => inst.check(_toLowerCase());
    inst.toUpperCase = () => inst.check(_toUpperCase());
    inst.slugify = () => inst.check(_slugify());
  });
  var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
    $ZodString.init(inst, def);
    _ZodString.init(inst, def);
    inst.email = (params) => inst.check(_email(ZodEmail, params));
    inst.url = (params) => inst.check(_url(ZodURL, params));
    inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
    inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
    inst.guid = (params) => inst.check(_guid(ZodGUID, params));
    inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
    inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
    inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
    inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
    inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
    inst.guid = (params) => inst.check(_guid(ZodGUID, params));
    inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
    inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
    inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
    inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
    inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
    inst.xid = (params) => inst.check(_xid(ZodXID, params));
    inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
    inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
    inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
    inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
    inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
    inst.e164 = (params) => inst.check(_e164(ZodE164, params));
    inst.datetime = (params) => inst.check(datetime2(params));
    inst.date = (params) => inst.check(date2(params));
    inst.time = (params) => inst.check(time2(params));
    inst.duration = (params) => inst.check(duration2(params));
  });
  function string2(params) {
    return _string(ZodString, params);
  }
  var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    _ZodString.init(inst, def);
  });
  var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
    $ZodEmail.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function email2(params) {
    return _email(ZodEmail, params);
  }
  var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
    $ZodGUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function guid2(params) {
    return _guid(ZodGUID, params);
  }
  var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
    $ZodUUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function uuid2(params) {
    return _uuid(ZodUUID, params);
  }
  function uuidv4(params) {
    return _uuidv4(ZodUUID, params);
  }
  function uuidv6(params) {
    return _uuidv6(ZodUUID, params);
  }
  function uuidv7(params) {
    return _uuidv7(ZodUUID, params);
  }
  var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
    $ZodURL.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function url(params) {
    return _url(ZodURL, params);
  }
  function httpUrl(params) {
    return _url(ZodURL, {
      protocol: /^https?$/,
      hostname: regexes_exports.domain,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
    $ZodEmoji.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function emoji2(params) {
    return _emoji2(ZodEmoji, params);
  }
  var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
    $ZodNanoID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function nanoid2(params) {
    return _nanoid(ZodNanoID, params);
  }
  var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
    $ZodCUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function cuid3(params) {
    return _cuid(ZodCUID, params);
  }
  var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
    $ZodCUID2.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function cuid22(params) {
    return _cuid2(ZodCUID2, params);
  }
  var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
    $ZodULID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function ulid2(params) {
    return _ulid(ZodULID, params);
  }
  var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
    $ZodXID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function xid2(params) {
    return _xid(ZodXID, params);
  }
  var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
    $ZodKSUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function ksuid2(params) {
    return _ksuid(ZodKSUID, params);
  }
  var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
    $ZodIPv4.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function ipv42(params) {
    return _ipv4(ZodIPv4, params);
  }
  var ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
    $ZodMAC.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function mac2(params) {
    return _mac(ZodMAC, params);
  }
  var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
    $ZodIPv6.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function ipv62(params) {
    return _ipv6(ZodIPv6, params);
  }
  var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
    $ZodCIDRv4.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function cidrv42(params) {
    return _cidrv4(ZodCIDRv4, params);
  }
  var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
    $ZodCIDRv6.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function cidrv62(params) {
    return _cidrv6(ZodCIDRv6, params);
  }
  var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
    $ZodBase64.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function base642(params) {
    return _base64(ZodBase64, params);
  }
  var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
    $ZodBase64URL.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function base64url2(params) {
    return _base64url(ZodBase64URL, params);
  }
  var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
    $ZodE164.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function e1642(params) {
    return _e164(ZodE164, params);
  }
  var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
    $ZodJWT.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function jwt(params) {
    return _jwt(ZodJWT, params);
  }
  var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
    $ZodCustomStringFormat.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  function stringFormat(format, fnOrRegex, _params = {}) {
    return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
  }
  function hostname2(_params) {
    return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
  }
  function hex2(_params) {
    return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
  }
  function hash(alg, params) {
    const enc = params?.enc ?? "hex";
    const format = `${alg}_${enc}`;
    const regex = regexes_exports[format];
    if (!regex)
      throw new Error(`Unrecognized hash format: ${format}`);
    return _stringFormat(ZodCustomStringFormat, format, regex, params);
  }
  var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
    $ZodNumber.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => numberProcessor(inst, ctx, json3, params);
    inst.gt = (value, params) => inst.check(_gt(value, params));
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.lt = (value, params) => inst.check(_lt(value, params));
    inst.lte = (value, params) => inst.check(_lte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    inst.int = (params) => inst.check(int(params));
    inst.safe = (params) => inst.check(int(params));
    inst.positive = (params) => inst.check(_gt(0, params));
    inst.nonnegative = (params) => inst.check(_gte(0, params));
    inst.negative = (params) => inst.check(_lt(0, params));
    inst.nonpositive = (params) => inst.check(_lte(0, params));
    inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
    inst.step = (value, params) => inst.check(_multipleOf(value, params));
    inst.finite = () => inst;
    const bag = inst._zod.bag;
    inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
    inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
    inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
    inst.isFinite = true;
    inst.format = bag.format ?? null;
  });
  function number2(params) {
    return _number(ZodNumber, params);
  }
  var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
    $ZodNumberFormat.init(inst, def);
    ZodNumber.init(inst, def);
  });
  function int(params) {
    return _int(ZodNumberFormat, params);
  }
  function float32(params) {
    return _float32(ZodNumberFormat, params);
  }
  function float64(params) {
    return _float64(ZodNumberFormat, params);
  }
  function int32(params) {
    return _int32(ZodNumberFormat, params);
  }
  function uint32(params) {
    return _uint32(ZodNumberFormat, params);
  }
  var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
    $ZodBoolean.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => booleanProcessor(inst, ctx, json3, params);
  });
  function boolean2(params) {
    return _boolean(ZodBoolean, params);
  }
  var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
    $ZodBigInt.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => bigintProcessor(inst, ctx, json3, params);
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.gt = (value, params) => inst.check(_gt(value, params));
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.lt = (value, params) => inst.check(_lt(value, params));
    inst.lte = (value, params) => inst.check(_lte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    inst.positive = (params) => inst.check(_gt(BigInt(0), params));
    inst.negative = (params) => inst.check(_lt(BigInt(0), params));
    inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
    inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
    inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
    const bag = inst._zod.bag;
    inst.minValue = bag.minimum ?? null;
    inst.maxValue = bag.maximum ?? null;
    inst.format = bag.format ?? null;
  });
  function bigint2(params) {
    return _bigint(ZodBigInt, params);
  }
  var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
    $ZodBigIntFormat.init(inst, def);
    ZodBigInt.init(inst, def);
  });
  function int64(params) {
    return _int64(ZodBigIntFormat, params);
  }
  function uint64(params) {
    return _uint64(ZodBigIntFormat, params);
  }
  var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
    $ZodSymbol.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => symbolProcessor(inst, ctx, json3, params);
  });
  function symbol(params) {
    return _symbol(ZodSymbol, params);
  }
  var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
    $ZodUndefined.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => undefinedProcessor(inst, ctx, json3, params);
  });
  function _undefined3(params) {
    return _undefined2(ZodUndefined, params);
  }
  var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
    $ZodNull.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => nullProcessor(inst, ctx, json3, params);
  });
  function _null3(params) {
    return _null2(ZodNull, params);
  }
  var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
    $ZodAny.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => anyProcessor(inst, ctx, json3, params);
  });
  function any() {
    return _any(ZodAny);
  }
  var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
    $ZodUnknown.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => unknownProcessor(inst, ctx, json3, params);
  });
  function unknown() {
    return _unknown(ZodUnknown);
  }
  var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
    $ZodNever.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => neverProcessor(inst, ctx, json3, params);
  });
  function never(params) {
    return _never(ZodNever, params);
  }
  var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
    $ZodVoid.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => voidProcessor(inst, ctx, json3, params);
  });
  function _void2(params) {
    return _void(ZodVoid, params);
  }
  var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
    $ZodDate.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => dateProcessor(inst, ctx, json3, params);
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    const c = inst._zod.bag;
    inst.minDate = c.minimum ? new Date(c.minimum) : null;
    inst.maxDate = c.maximum ? new Date(c.maximum) : null;
  });
  function date3(params) {
    return _date(ZodDate, params);
  }
  var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
    $ZodArray.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => arrayProcessor(inst, ctx, json3, params);
    inst.element = def.element;
    inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
    inst.nonempty = (params) => inst.check(_minLength(1, params));
    inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
    inst.length = (len, params) => inst.check(_length(len, params));
    inst.unwrap = () => inst.element;
  });
  function array(element, params) {
    return _array(ZodArray, element, params);
  }
  function keyof(schema) {
    const shape = schema._zod.def.shape;
    return _enum2(Object.keys(shape));
  }
  var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
    $ZodObjectJIT.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => objectProcessor(inst, ctx, json3, params);
    util_exports.defineLazy(inst, "shape", () => {
      return def.shape;
    });
    inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
    inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
    inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
    inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
    inst.extend = (incoming) => {
      return util_exports.extend(inst, incoming);
    };
    inst.safeExtend = (incoming) => {
      return util_exports.safeExtend(inst, incoming);
    };
    inst.merge = (other) => util_exports.merge(inst, other);
    inst.pick = (mask) => util_exports.pick(inst, mask);
    inst.omit = (mask) => util_exports.omit(inst, mask);
    inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
    inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
  });
  function object(shape, params) {
    const def = {
      type: "object",
      shape: shape ?? {},
      ...util_exports.normalizeParams(params)
    };
    return new ZodObject(def);
  }
  function strictObject(shape, params) {
    return new ZodObject({
      type: "object",
      shape,
      catchall: never(),
      ...util_exports.normalizeParams(params)
    });
  }
  function looseObject(shape, params) {
    return new ZodObject({
      type: "object",
      shape,
      catchall: unknown(),
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
    $ZodUnion.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => unionProcessor(inst, ctx, json3, params);
    inst.options = def.options;
  });
  function union(options, params) {
    return new ZodUnion({
      type: "union",
      options,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
    ZodUnion.init(inst, def);
    $ZodXor.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => unionProcessor(inst, ctx, json3, params);
    inst.options = def.options;
  });
  function xor(options, params) {
    return new ZodXor({
      type: "union",
      options,
      inclusive: false,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
    ZodUnion.init(inst, def);
    $ZodDiscriminatedUnion.init(inst, def);
  });
  function discriminatedUnion(discriminator, options, params) {
    return new ZodDiscriminatedUnion({
      type: "union",
      options,
      discriminator,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
    $ZodIntersection.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => intersectionProcessor(inst, ctx, json3, params);
  });
  function intersection(left, right) {
    return new ZodIntersection({
      type: "intersection",
      left,
      right
    });
  }
  var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
    $ZodTuple.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => tupleProcessor(inst, ctx, json3, params);
    inst.rest = (rest) => inst.clone({
      ...inst._zod.def,
      rest
    });
  });
  function tuple(items, _paramsOrRest, _params) {
    const hasRest = _paramsOrRest instanceof $ZodType;
    const params = hasRest ? _params : _paramsOrRest;
    const rest = hasRest ? _paramsOrRest : null;
    return new ZodTuple({
      type: "tuple",
      items,
      rest,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
    $ZodRecord.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => recordProcessor(inst, ctx, json3, params);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
  });
  function record(keyType, valueType, params) {
    return new ZodRecord({
      type: "record",
      keyType,
      valueType,
      ...util_exports.normalizeParams(params)
    });
  }
  function partialRecord(keyType, valueType, params) {
    const k = clone(keyType);
    k._zod.values = void 0;
    return new ZodRecord({
      type: "record",
      keyType: k,
      valueType,
      ...util_exports.normalizeParams(params)
    });
  }
  function looseRecord(keyType, valueType, params) {
    return new ZodRecord({
      type: "record",
      keyType,
      valueType,
      mode: "loose",
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
    $ZodMap.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => mapProcessor(inst, ctx, json3, params);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
    inst.min = (...args) => inst.check(_minSize(...args));
    inst.nonempty = (params) => inst.check(_minSize(1, params));
    inst.max = (...args) => inst.check(_maxSize(...args));
    inst.size = (...args) => inst.check(_size(...args));
  });
  function map(keyType, valueType, params) {
    return new ZodMap({
      type: "map",
      keyType,
      valueType,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
    $ZodSet.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => setProcessor(inst, ctx, json3, params);
    inst.min = (...args) => inst.check(_minSize(...args));
    inst.nonempty = (params) => inst.check(_minSize(1, params));
    inst.max = (...args) => inst.check(_maxSize(...args));
    inst.size = (...args) => inst.check(_size(...args));
  });
  function set(valueType, params) {
    return new ZodSet({
      type: "set",
      valueType,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
    $ZodEnum.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => enumProcessor(inst, ctx, json3, params);
    inst.enum = def.entries;
    inst.options = Object.values(def.entries);
    const keys = new Set(Object.keys(def.entries));
    inst.extract = (values, params) => {
      const newEntries = {};
      for (const value of values) {
        if (keys.has(value)) {
          newEntries[value] = def.entries[value];
        } else
          throw new Error(`Key ${value} not found in enum`);
      }
      return new ZodEnum({
        ...def,
        checks: [],
        ...util_exports.normalizeParams(params),
        entries: newEntries
      });
    };
    inst.exclude = (values, params) => {
      const newEntries = { ...def.entries };
      for (const value of values) {
        if (keys.has(value)) {
          delete newEntries[value];
        } else
          throw new Error(`Key ${value} not found in enum`);
      }
      return new ZodEnum({
        ...def,
        checks: [],
        ...util_exports.normalizeParams(params),
        entries: newEntries
      });
    };
  });
  function _enum2(values, params) {
    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
    return new ZodEnum({
      type: "enum",
      entries,
      ...util_exports.normalizeParams(params)
    });
  }
  function nativeEnum(entries, params) {
    return new ZodEnum({
      type: "enum",
      entries,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
    $ZodLiteral.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => literalProcessor(inst, ctx, json3, params);
    inst.values = new Set(def.values);
    Object.defineProperty(inst, "value", {
      get() {
        if (def.values.length > 1) {
          throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
        }
        return def.values[0];
      }
    });
  });
  function literal(value, params) {
    return new ZodLiteral({
      type: "literal",
      values: Array.isArray(value) ? value : [value],
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
    $ZodFile.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => fileProcessor(inst, ctx, json3, params);
    inst.min = (size, params) => inst.check(_minSize(size, params));
    inst.max = (size, params) => inst.check(_maxSize(size, params));
    inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
  });
  function file(params) {
    return _file(ZodFile, params);
  }
  var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
    $ZodTransform.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => transformProcessor(inst, ctx, json3, params);
    inst._zod.parse = (payload, _ctx) => {
      if (_ctx.direction === "backward") {
        throw new $ZodEncodeError(inst.constructor.name);
      }
      payload.addIssue = (issue2) => {
        if (typeof issue2 === "string") {
          payload.issues.push(util_exports.issue(issue2, payload.value, def));
        } else {
          const _issue = issue2;
          if (_issue.fatal)
            _issue.continue = false;
          _issue.code ?? (_issue.code = "custom");
          _issue.input ?? (_issue.input = payload.value);
          _issue.inst ?? (_issue.inst = inst);
          payload.issues.push(util_exports.issue(_issue));
        }
      };
      const output = def.transform(payload.value, payload);
      if (output instanceof Promise) {
        return output.then((output2) => {
          payload.value = output2;
          return payload;
        });
      }
      payload.value = output;
      return payload;
    };
  });
  function transform(fn) {
    return new ZodTransform({
      type: "transform",
      transform: fn
    });
  }
  var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
    $ZodOptional.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => optionalProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function optional(innerType) {
    return new ZodOptional({
      type: "optional",
      innerType
    });
  }
  var ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
    $ZodExactOptional.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => optionalProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function exactOptional(innerType) {
    return new ZodExactOptional({
      type: "optional",
      innerType
    });
  }
  var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
    $ZodNullable.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => nullableProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function nullable(innerType) {
    return new ZodNullable({
      type: "nullable",
      innerType
    });
  }
  function nullish2(innerType) {
    return optional(nullable(innerType));
  }
  var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
    $ZodDefault.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => defaultProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeDefault = inst.unwrap;
  });
  function _default2(innerType, defaultValue) {
    return new ZodDefault({
      type: "default",
      innerType,
      get defaultValue() {
        return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
      }
    });
  }
  var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
    $ZodPrefault.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => prefaultProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function prefault(innerType, defaultValue) {
    return new ZodPrefault({
      type: "prefault",
      innerType,
      get defaultValue() {
        return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
      }
    });
  }
  var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
    $ZodNonOptional.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => nonoptionalProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function nonoptional(innerType, params) {
    return new ZodNonOptional({
      type: "nonoptional",
      innerType,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
    $ZodSuccess.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => successProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function success(innerType) {
    return new ZodSuccess({
      type: "success",
      innerType
    });
  }
  var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
    $ZodCatch.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => catchProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeCatch = inst.unwrap;
  });
  function _catch2(innerType, catchValue) {
    return new ZodCatch({
      type: "catch",
      innerType,
      catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
    });
  }
  var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
    $ZodNaN.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => nanProcessor(inst, ctx, json3, params);
  });
  function nan(params) {
    return _nan(ZodNaN, params);
  }
  var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
    $ZodPipe.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => pipeProcessor(inst, ctx, json3, params);
    inst.in = def.in;
    inst.out = def.out;
  });
  function pipe(in_, out) {
    return new ZodPipe({
      type: "pipe",
      in: in_,
      out
      // ...util.normalizeParams(params),
    });
  }
  var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
    ZodPipe.init(inst, def);
    $ZodCodec.init(inst, def);
  });
  function codec(in_, out, params) {
    return new ZodCodec({
      type: "pipe",
      in: in_,
      out,
      transform: params.decode,
      reverseTransform: params.encode
    });
  }
  var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
    $ZodReadonly.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => readonlyProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function readonly(innerType) {
    return new ZodReadonly({
      type: "readonly",
      innerType
    });
  }
  var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
    $ZodTemplateLiteral.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => templateLiteralProcessor(inst, ctx, json3, params);
  });
  function templateLiteral(parts, params) {
    return new ZodTemplateLiteral({
      type: "template_literal",
      parts,
      ...util_exports.normalizeParams(params)
    });
  }
  var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
    $ZodLazy.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => lazyProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.getter();
  });
  function lazy(getter) {
    return new ZodLazy({
      type: "lazy",
      getter
    });
  }
  var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
    $ZodPromise.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => promiseProcessor(inst, ctx, json3, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  function promise(innerType) {
    return new ZodPromise({
      type: "promise",
      innerType
    });
  }
  var ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
    $ZodFunction.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => functionProcessor(inst, ctx, json3, params);
  });
  function _function(params) {
    return new ZodFunction({
      type: "function",
      input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
      output: params?.output ?? unknown()
    });
  }
  var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
    $ZodCustom.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json3, params) => customProcessor(inst, ctx, json3, params);
  });
  function check(fn) {
    const ch = new $ZodCheck({
      check: "custom"
      // ...util.normalizeParams(params),
    });
    ch._zod.check = fn;
    return ch;
  }
  function custom(fn, _params) {
    return _custom(ZodCustom, fn ?? (() => true), _params);
  }
  function refine(fn, _params = {}) {
    return _refine(ZodCustom, fn, _params);
  }
  function superRefine(fn) {
    return _superRefine(fn);
  }
  var describe2 = describe;
  var meta2 = meta;
  function _instanceof(cls, params = {}) {
    const inst = new ZodCustom({
      type: "custom",
      check: "custom",
      fn: (data) => data instanceof cls,
      abort: true,
      ...util_exports.normalizeParams(params)
    });
    inst._zod.bag.Class = cls;
    inst._zod.check = (payload) => {
      if (!(payload.value instanceof cls)) {
        payload.issues.push({
          code: "invalid_type",
          expected: cls.name,
          input: payload.value,
          inst,
          path: [...inst._zod.def.path ?? []]
        });
      }
    };
    return inst;
  }
  var stringbool = (...args) => _stringbool({
    Codec: ZodCodec,
    Boolean: ZodBoolean,
    String: ZodString
  }, ...args);
  function json(params) {
    const jsonSchema = lazy(() => {
      return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
    });
    return jsonSchema;
  }
  function preprocess(fn, schema) {
    return pipe(transform(fn), schema);
  }

  // node_modules/zod/v4/classic/compat.js
  var ZodIssueCode = {
    invalid_type: "invalid_type",
    too_big: "too_big",
    too_small: "too_small",
    invalid_format: "invalid_format",
    not_multiple_of: "not_multiple_of",
    unrecognized_keys: "unrecognized_keys",
    invalid_union: "invalid_union",
    invalid_key: "invalid_key",
    invalid_element: "invalid_element",
    invalid_value: "invalid_value",
    custom: "custom"
  };
  function setErrorMap(map2) {
    config({
      customError: map2
    });
  }
  function getErrorMap() {
    return config().customError;
  }
  var ZodFirstPartyTypeKind;
  /* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

  // node_modules/zod/v4/classic/from-json-schema.js
  var z = {
    ...schemas_exports2,
    ...checks_exports2,
    iso: iso_exports
  };
  var RECOGNIZED_KEYS = /* @__PURE__ */ new Set([
    // Schema identification
    "$schema",
    "$ref",
    "$defs",
    "definitions",
    // Core schema keywords
    "$id",
    "id",
    "$comment",
    "$anchor",
    "$vocabulary",
    "$dynamicRef",
    "$dynamicAnchor",
    // Type
    "type",
    "enum",
    "const",
    // Composition
    "anyOf",
    "oneOf",
    "allOf",
    "not",
    // Object
    "properties",
    "required",
    "additionalProperties",
    "patternProperties",
    "propertyNames",
    "minProperties",
    "maxProperties",
    // Array
    "items",
    "prefixItems",
    "additionalItems",
    "minItems",
    "maxItems",
    "uniqueItems",
    "contains",
    "minContains",
    "maxContains",
    // String
    "minLength",
    "maxLength",
    "pattern",
    "format",
    // Number
    "minimum",
    "maximum",
    "exclusiveMinimum",
    "exclusiveMaximum",
    "multipleOf",
    // Already handled metadata
    "description",
    "default",
    // Content
    "contentEncoding",
    "contentMediaType",
    "contentSchema",
    // Unsupported (error-throwing)
    "unevaluatedItems",
    "unevaluatedProperties",
    "if",
    "then",
    "else",
    "dependentSchemas",
    "dependentRequired",
    // OpenAPI
    "nullable",
    "readOnly"
  ]);
  function detectVersion(schema, defaultTarget) {
    const $schema = schema.$schema;
    if ($schema === "https://json-schema.org/draft/2020-12/schema") {
      return "draft-2020-12";
    }
    if ($schema === "http://json-schema.org/draft-07/schema#") {
      return "draft-7";
    }
    if ($schema === "http://json-schema.org/draft-04/schema#") {
      return "draft-4";
    }
    return defaultTarget ?? "draft-2020-12";
  }
  function resolveRef(ref, ctx) {
    if (!ref.startsWith("#")) {
      throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
    }
    const path = ref.slice(1).split("/").filter(Boolean);
    if (path.length === 0) {
      return ctx.rootSchema;
    }
    const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
    if (path[0] === defsKey) {
      const key = path[1];
      if (!key || !ctx.defs[key]) {
        throw new Error(`Reference not found: ${ref}`);
      }
      return ctx.defs[key];
    }
    throw new Error(`Reference not found: ${ref}`);
  }
  function convertBaseSchema(schema, ctx) {
    if (schema.not !== void 0) {
      if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
        return z.never();
      }
      throw new Error("not is not supported in Zod (except { not: {} } for never)");
    }
    if (schema.unevaluatedItems !== void 0) {
      throw new Error("unevaluatedItems is not supported");
    }
    if (schema.unevaluatedProperties !== void 0) {
      throw new Error("unevaluatedProperties is not supported");
    }
    if (schema.if !== void 0 || schema.then !== void 0 || schema.else !== void 0) {
      throw new Error("Conditional schemas (if/then/else) are not supported");
    }
    if (schema.dependentSchemas !== void 0 || schema.dependentRequired !== void 0) {
      throw new Error("dependentSchemas and dependentRequired are not supported");
    }
    if (schema.$ref) {
      const refPath = schema.$ref;
      if (ctx.refs.has(refPath)) {
        return ctx.refs.get(refPath);
      }
      if (ctx.processing.has(refPath)) {
        return z.lazy(() => {
          if (!ctx.refs.has(refPath)) {
            throw new Error(`Circular reference not resolved: ${refPath}`);
          }
          return ctx.refs.get(refPath);
        });
      }
      ctx.processing.add(refPath);
      const resolved = resolveRef(refPath, ctx);
      const zodSchema2 = convertSchema(resolved, ctx);
      ctx.refs.set(refPath, zodSchema2);
      ctx.processing.delete(refPath);
      return zodSchema2;
    }
    if (schema.enum !== void 0) {
      const enumValues = schema.enum;
      if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
        return z.null();
      }
      if (enumValues.length === 0) {
        return z.never();
      }
      if (enumValues.length === 1) {
        return z.literal(enumValues[0]);
      }
      if (enumValues.every((v) => typeof v === "string")) {
        return z.enum(enumValues);
      }
      const literalSchemas = enumValues.map((v) => z.literal(v));
      if (literalSchemas.length < 2) {
        return literalSchemas[0];
      }
      return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
    }
    if (schema.const !== void 0) {
      return z.literal(schema.const);
    }
    const type = schema.type;
    if (Array.isArray(type)) {
      const typeSchemas = type.map((t) => {
        const typeSchema = { ...schema, type: t };
        return convertBaseSchema(typeSchema, ctx);
      });
      if (typeSchemas.length === 0) {
        return z.never();
      }
      if (typeSchemas.length === 1) {
        return typeSchemas[0];
      }
      return z.union(typeSchemas);
    }
    if (!type) {
      return z.any();
    }
    let zodSchema;
    switch (type) {
      case "string": {
        let stringSchema2 = z.string();
        if (schema.format) {
          const format = schema.format;
          if (format === "email") {
            stringSchema2 = stringSchema2.check(z.email());
          } else if (format === "uri" || format === "uri-reference") {
            stringSchema2 = stringSchema2.check(z.url());
          } else if (format === "uuid" || format === "guid") {
            stringSchema2 = stringSchema2.check(z.uuid());
          } else if (format === "date-time") {
            stringSchema2 = stringSchema2.check(z.iso.datetime());
          } else if (format === "date") {
            stringSchema2 = stringSchema2.check(z.iso.date());
          } else if (format === "time") {
            stringSchema2 = stringSchema2.check(z.iso.time());
          } else if (format === "duration") {
            stringSchema2 = stringSchema2.check(z.iso.duration());
          } else if (format === "ipv4") {
            stringSchema2 = stringSchema2.check(z.ipv4());
          } else if (format === "ipv6") {
            stringSchema2 = stringSchema2.check(z.ipv6());
          } else if (format === "mac") {
            stringSchema2 = stringSchema2.check(z.mac());
          } else if (format === "cidr") {
            stringSchema2 = stringSchema2.check(z.cidrv4());
          } else if (format === "cidr-v6") {
            stringSchema2 = stringSchema2.check(z.cidrv6());
          } else if (format === "base64") {
            stringSchema2 = stringSchema2.check(z.base64());
          } else if (format === "base64url") {
            stringSchema2 = stringSchema2.check(z.base64url());
          } else if (format === "e164") {
            stringSchema2 = stringSchema2.check(z.e164());
          } else if (format === "jwt") {
            stringSchema2 = stringSchema2.check(z.jwt());
          } else if (format === "emoji") {
            stringSchema2 = stringSchema2.check(z.emoji());
          } else if (format === "nanoid") {
            stringSchema2 = stringSchema2.check(z.nanoid());
          } else if (format === "cuid") {
            stringSchema2 = stringSchema2.check(z.cuid());
          } else if (format === "cuid2") {
            stringSchema2 = stringSchema2.check(z.cuid2());
          } else if (format === "ulid") {
            stringSchema2 = stringSchema2.check(z.ulid());
          } else if (format === "xid") {
            stringSchema2 = stringSchema2.check(z.xid());
          } else if (format === "ksuid") {
            stringSchema2 = stringSchema2.check(z.ksuid());
          }
        }
        if (typeof schema.minLength === "number") {
          stringSchema2 = stringSchema2.min(schema.minLength);
        }
        if (typeof schema.maxLength === "number") {
          stringSchema2 = stringSchema2.max(schema.maxLength);
        }
        if (schema.pattern) {
          stringSchema2 = stringSchema2.regex(new RegExp(schema.pattern));
        }
        zodSchema = stringSchema2;
        break;
      }
      case "number":
      case "integer": {
        let numberSchema2 = type === "integer" ? z.number().int() : z.number();
        if (typeof schema.minimum === "number") {
          numberSchema2 = numberSchema2.min(schema.minimum);
        }
        if (typeof schema.maximum === "number") {
          numberSchema2 = numberSchema2.max(schema.maximum);
        }
        if (typeof schema.exclusiveMinimum === "number") {
          numberSchema2 = numberSchema2.gt(schema.exclusiveMinimum);
        } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
          numberSchema2 = numberSchema2.gt(schema.minimum);
        }
        if (typeof schema.exclusiveMaximum === "number") {
          numberSchema2 = numberSchema2.lt(schema.exclusiveMaximum);
        } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
          numberSchema2 = numberSchema2.lt(schema.maximum);
        }
        if (typeof schema.multipleOf === "number") {
          numberSchema2 = numberSchema2.multipleOf(schema.multipleOf);
        }
        zodSchema = numberSchema2;
        break;
      }
      case "boolean": {
        zodSchema = z.boolean();
        break;
      }
      case "null": {
        zodSchema = z.null();
        break;
      }
      case "object": {
        const shape = {};
        const properties = schema.properties || {};
        const requiredSet = new Set(schema.required || []);
        for (const [key, propSchema] of Object.entries(properties)) {
          const propZodSchema = convertSchema(propSchema, ctx);
          shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
        }
        if (schema.propertyNames) {
          const keySchema = convertSchema(schema.propertyNames, ctx);
          const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
          if (Object.keys(shape).length === 0) {
            zodSchema = z.record(keySchema, valueSchema);
            break;
          }
          const objectSchema2 = z.object(shape).passthrough();
          const recordSchema = z.looseRecord(keySchema, valueSchema);
          zodSchema = z.intersection(objectSchema2, recordSchema);
          break;
        }
        if (schema.patternProperties) {
          const patternProps = schema.patternProperties;
          const patternKeys = Object.keys(patternProps);
          const looseRecords = [];
          for (const pattern of patternKeys) {
            const patternValue = convertSchema(patternProps[pattern], ctx);
            const keySchema = z.string().regex(new RegExp(pattern));
            looseRecords.push(z.looseRecord(keySchema, patternValue));
          }
          const schemasToIntersect = [];
          if (Object.keys(shape).length > 0) {
            schemasToIntersect.push(z.object(shape).passthrough());
          }
          schemasToIntersect.push(...looseRecords);
          if (schemasToIntersect.length === 0) {
            zodSchema = z.object({}).passthrough();
          } else if (schemasToIntersect.length === 1) {
            zodSchema = schemasToIntersect[0];
          } else {
            let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
            for (let i = 2; i < schemasToIntersect.length; i++) {
              result = z.intersection(result, schemasToIntersect[i]);
            }
            zodSchema = result;
          }
          break;
        }
        const objectSchema = z.object(shape);
        if (schema.additionalProperties === false) {
          zodSchema = objectSchema.strict();
        } else if (typeof schema.additionalProperties === "object") {
          zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
        } else {
          zodSchema = objectSchema.passthrough();
        }
        break;
      }
      case "array": {
        const prefixItems = schema.prefixItems;
        const items = schema.items;
        if (prefixItems && Array.isArray(prefixItems)) {
          const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
          const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : void 0;
          if (rest) {
            zodSchema = z.tuple(tupleItems).rest(rest);
          } else {
            zodSchema = z.tuple(tupleItems);
          }
          if (typeof schema.minItems === "number") {
            zodSchema = zodSchema.check(z.minLength(schema.minItems));
          }
          if (typeof schema.maxItems === "number") {
            zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
          }
        } else if (Array.isArray(items)) {
          const tupleItems = items.map((item) => convertSchema(item, ctx));
          const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : void 0;
          if (rest) {
            zodSchema = z.tuple(tupleItems).rest(rest);
          } else {
            zodSchema = z.tuple(tupleItems);
          }
          if (typeof schema.minItems === "number") {
            zodSchema = zodSchema.check(z.minLength(schema.minItems));
          }
          if (typeof schema.maxItems === "number") {
            zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
          }
        } else if (items !== void 0) {
          const element = convertSchema(items, ctx);
          let arraySchema = z.array(element);
          if (typeof schema.minItems === "number") {
            arraySchema = arraySchema.min(schema.minItems);
          }
          if (typeof schema.maxItems === "number") {
            arraySchema = arraySchema.max(schema.maxItems);
          }
          zodSchema = arraySchema;
        } else {
          zodSchema = z.array(z.any());
        }
        break;
      }
      default:
        throw new Error(`Unsupported type: ${type}`);
    }
    if (schema.description) {
      zodSchema = zodSchema.describe(schema.description);
    }
    if (schema.default !== void 0) {
      zodSchema = zodSchema.default(schema.default);
    }
    return zodSchema;
  }
  function convertSchema(schema, ctx) {
    if (typeof schema === "boolean") {
      return schema ? z.any() : z.never();
    }
    let baseSchema = convertBaseSchema(schema, ctx);
    const hasExplicitType = schema.type || schema.enum !== void 0 || schema.const !== void 0;
    if (schema.anyOf && Array.isArray(schema.anyOf)) {
      const options = schema.anyOf.map((s) => convertSchema(s, ctx));
      const anyOfUnion = z.union(options);
      baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
    }
    if (schema.oneOf && Array.isArray(schema.oneOf)) {
      const options = schema.oneOf.map((s) => convertSchema(s, ctx));
      const oneOfUnion = z.xor(options);
      baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
    }
    if (schema.allOf && Array.isArray(schema.allOf)) {
      if (schema.allOf.length === 0) {
        baseSchema = hasExplicitType ? baseSchema : z.any();
      } else {
        let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
        const startIdx = hasExplicitType ? 0 : 1;
        for (let i = startIdx; i < schema.allOf.length; i++) {
          result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
        }
        baseSchema = result;
      }
    }
    if (schema.nullable === true && ctx.version === "openapi-3.0") {
      baseSchema = z.nullable(baseSchema);
    }
    if (schema.readOnly === true) {
      baseSchema = z.readonly(baseSchema);
    }
    const extraMeta = {};
    const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
    for (const key of coreMetadataKeys) {
      if (key in schema) {
        extraMeta[key] = schema[key];
      }
    }
    const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
    for (const key of contentMetadataKeys) {
      if (key in schema) {
        extraMeta[key] = schema[key];
      }
    }
    for (const key of Object.keys(schema)) {
      if (!RECOGNIZED_KEYS.has(key)) {
        extraMeta[key] = schema[key];
      }
    }
    if (Object.keys(extraMeta).length > 0) {
      ctx.registry.add(baseSchema, extraMeta);
    }
    return baseSchema;
  }
  function fromJSONSchema(schema, params) {
    if (typeof schema === "boolean") {
      return schema ? z.any() : z.never();
    }
    const version2 = detectVersion(schema, params?.defaultTarget);
    const defs = schema.$defs || schema.definitions || {};
    const ctx = {
      version: version2,
      defs,
      refs: /* @__PURE__ */ new Map(),
      processing: /* @__PURE__ */ new Set(),
      rootSchema: schema,
      registry: params?.registry ?? globalRegistry
    };
    return convertSchema(schema, ctx);
  }

  // node_modules/zod/v4/classic/coerce.js
  var coerce_exports = {};
  __export(coerce_exports, {
    bigint: () => bigint3,
    boolean: () => boolean3,
    date: () => date4,
    number: () => number3,
    string: () => string3
  });
  function string3(params) {
    return _coercedString(ZodString, params);
  }
  function number3(params) {
    return _coercedNumber(ZodNumber, params);
  }
  function boolean3(params) {
    return _coercedBoolean(ZodBoolean, params);
  }
  function bigint3(params) {
    return _coercedBigint(ZodBigInt, params);
  }
  function date4(params) {
    return _coercedDate(ZodDate, params);
  }

  // node_modules/zod/v4/classic/external.js
  config(en_default());

  // node_modules/zod/index.js
  var zod_default = external_exports;

  // source/gcs-schema.ts
  var FormatSchema = _enum2(["DETAILED"]);
  var EntityKindSchema = _enum2(["GYM", "POKESTOP", "POWERSPOT"]);
  var GameBrandSchema = _enum2(["HOLOHOLO"]);
  var StatusSchema = _enum2(["ACTIVE", "INACTIVE"]);
  var latLngStringPattern = /^\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)\s*\)$/;
  var LatLngStringSchema = string2().transform((text, context) => {
    const match = latLngStringPattern.exec(text);
    if (!match) {
      context.addIssue({
        code: "invalid_format",
        message: "Invalid point format. Expected `(${number},${number})",
        format: "custom",
        pattern: latLngStringPattern.source,
        input: text
      });
      return NEVER;
    }
    return {
      lat: Number(match[1]),
      lng: Number(match[2])
    };
  });
  var GcsQueriesSchema = object({
    ne: LatLngStringSchema,
    sw: LatLngStringSchema
  });
  var MetadataSchema = object({
    s2CellLevel: number2(),
    /** e.g. `"60188bf94"` */
    s2CellId: string2(),
    /** e.g. `"1769695998405"` */
    generatedTimestamp: string2(),
    count: number2(),
    format: FormatSchema
  });
  var GmoSchema = object({
    gameBrand: GameBrandSchema,
    entity: EntityKindSchema,
    status: StatusSchema
  });
  var PoiSchema = object({
    /** e.g. `"503fb825a42d489b9b78870dd20b9387.23"` */
    poiId: string2(),
    /** e.g. `139772431` */
    latE6: number2(),
    /** e.g. `35675825` */
    lngE6: number2(),
    title: string2(),
    description: string2(),
    /** e.g. `"2-chme-13-11 Kybashi, Chuo City, Tokyo 104-0031, Japan, Chuo City, 104-0031, JP"` */
    address: string2(),
    categoryTags: array(unknown()),
    /** e.g. `"https://lh3.googleusercontent.com/"` */
    mainImage: string2(),
    hasAdditionalImages: boolean2(),
    gmo: array(GmoSchema),
    isCommunityContributed: boolean2()
  });
  var DatumSchema = object({
    metadata: MetadataSchema,
    pois: array(PoiSchema),
    clusters: array(unknown())
  });
  var ResultSchema = object({
    success: boolean2(),
    data: array(DatumSchema),
    cellsQueried: number2(),
    cellsLoaded: number2(),
    snapshot: string2(),
    cellLevel: number2()
  });
  var GcsResponseSchema = object({
    result: ResultSchema,
    /** e.g. `null` */
    message: unknown(),
    code: string2(),
    /** e.g. `null` */
    errorsWithIcon: unknown(),
    /** e.g. `null` */
    fieldErrors: unknown(),
    /** e.g. `null` */
    errorDetails: unknown(),
    version: string2(),
    captcha: boolean2()
  });

  // source/typed-event-target.ts
  function createTypedEventTarget() {
    return new EventTarget();
  }
  function createTypedCustomEvent(type, detail) {
    return new CustomEvent(type, { detail });
  }

  // source/poi-records.ts
  var databaseSchema = {
    pois: {
      recordType: id,
      key: "guid",
      indexes: {
        coordinates: {
          key: ["lat", "lng"]
        },
        cellIds: {
          key: "cellIds",
          multiEntry: true
        }
      }
    },
    cells: {
      recordType: id,
      key: "cellId",
      indexes: {
        ancestorIds: {
          key: "ancestorIds",
          multiEntry: true
        }
      }
    }
  };
  var poisSymbol = /* @__PURE__ */ Symbol("_pois");
  var cellsSymbol = /* @__PURE__ */ Symbol("_cells");
  var coordinatesIndexSymbol = /* @__PURE__ */ Symbol("_coordinatesIndex");
  var cellIdsIndexSymbol = /* @__PURE__ */ Symbol("_cellIdsIndex");
  var ancestorIdsIndexSymbol = /* @__PURE__ */ Symbol("_ancestorIdsIndexSymbol");
  function iteratePoisInCell(store, cellId, action) {
    return iterateValuesOfIndex(store[cellIdsIndexSymbol], cellId, action);
  }
  function iterateCellsInCell14(store, cellId, action) {
    return iterateValuesOfIndex(
      store[ancestorIdsIndexSymbol],
      cellId,
      action
    );
  }
  var databaseName = "poi-records-e232930d-7282-4c02-aeef-bb9508576d2e";
  var databaseVersion = 1;
  var databaseSymbol = /* @__PURE__ */ Symbol("_database");
  async function openRecords() {
    return {
      [databaseSymbol]: await openDatabase(
        databaseName,
        databaseVersion,
        databaseSchema
      )
    };
  }
  function enterTransactionScope2(records, mode, options, scope) {
    return enterTransactionScope(
      records[databaseSymbol],
      { mode, signal: options?.signal },
      ({ pois, cells }) => {
        const store = {
          [poisSymbol]: pois,
          [cellsSymbol]: cells,
          [coordinatesIndexSymbol]: getIndex(pois, "coordinates"),
          [cellIdsIndexSymbol]: getIndex(pois, "cellIds"),
          [ancestorIdsIndexSymbol]: getIndex(cells, "ancestorIds")
        };
        return scope(store);
      },
      "pois",
      "cells"
    );
  }
  function setEntry(map2, key, value) {
    map2.set(key, value);
    return value;
  }
  function getNearlyCellsForBounds(bounds, level) {
    const result = [];
    const seenCellIds = /* @__PURE__ */ new Set();
    const remainingCells = createQueue();
    remainingCells.enqueue(
      createCellFromCoordinates(getCenter(bounds), level)
    );
    for (let cell; cell = remainingCells.dequeue(); ) {
      const id2 = cell.toString();
      if (seenCellIds.has(id2)) continue;
      seenCellIds.add(id2);
      let cellBounds = createDefault();
      for (const corner of cell.getCornerLatLngs()) {
        cellBounds = toExtended(cellBounds, corner);
      }
      if (!intersects(bounds, cellBounds)) continue;
      result.push(cell);
      for (const neighbor of cell.getNeighbors()) {
        remainingCells.enqueue(neighbor);
      }
    }
    return result;
  }
  function createEmptyCell14Statistics(cell) {
    return {
      cell,
      id: cell.toString(),
      pois: /* @__PURE__ */ new Map(),
      corner: cell.getCornerLatLngs(),
      center: cell.getLatLng(),
      cell17s: /* @__PURE__ */ new Map(),
      cell16s: /* @__PURE__ */ new Map(),
      kindToPois: /* @__PURE__ */ new Map()
    };
  }
  function updateCellStatisticsByCell(cells, cell, lastFetchDate) {
    const key = cell.toString();
    const stat = cells.get(key) ?? setEntry(cells, key, {
      cell,
      center: cell.getLatLng(),
      kindToCount: /* @__PURE__ */ new Map(),
      lastFetchDate
    });
    stat.lastFetchDate ||= lastFetchDate;
    return stat;
  }
  function updateCellStatisticsByPoi(cells, poi, level) {
    const cell = createCellFromCoordinates(poi, level);
    const { kindToCount } = updateCellStatisticsByCell(cells, cell, void 0);
    for (const { entity } of poi.data.gmo) {
      const count = kindToCount.get(entity) ?? 0;
      kindToCount.set(entity, count + 1);
    }
  }
  function isGymOrPokestop(g) {
    return g.entity === "GYM" || g.entity === "POKESTOP";
  }
  async function getCell14Stats(records, cell, signal) {
    const cellId = cell.toString();
    let cell14;
    const collectPois = (poi) => {
      cell14 ??= createEmptyCell14Statistics(cell);
      const coordinateKey = `(${poi.lat}, ${poi.lng})`;
      if (cell14.pois.get(coordinateKey) != null) return "continue";
      cell14.pois.set(coordinateKey, poi);
      for (const { entity } of poi.data.gmo) {
        const pois = cell14.kindToPois.get(entity) ?? setEntry(cell14.kindToPois, entity, []);
        pois.push(poi);
      }
      if (poi.data.gmo.some(isGymOrPokestop)) {
        updateCellStatisticsByPoi(cell14.cell16s, poi, 16);
        updateCellStatisticsByPoi(cell14.cell17s, poi, 17);
      }
    };
    const collectCells = (childCell) => {
      if (childCell.level !== 17) {
        return "continue";
      }
      cell14 ??= createEmptyCell14Statistics(cell);
      const cell17 = createCellFromCoordinates(
        { lat: childCell.centerLat, lng: childCell.centerLng },
        17
      );
      updateCellStatisticsByCell(
        cell14.cell17s,
        cell17,
        childCell.lastFetchDate
      );
    };
    await enterTransactionScope2(
      records,
      "readonly",
      { signal },
      function* (store) {
        yield* iteratePoisInCell(store, cellId, collectPois);
        yield* iterateCellsInCell14(store, cellId, collectCells);
      }
    );
    return cell14;
  }

  // source/poi-records-overlay.module.css
  var cssText = ".count-label-402e6f93b90665292d2c4d3c703c0707b374c277 {\n    --stroke-64eca011c7d063146332565804ea999201455e1b: 4px #c54545;\n\n    -webkit-text-stroke: var(--stroke-64eca011c7d063146332565804ea999201455e1b);\n    text-stroke: var(--stroke-64eca011c7d063146332565804ea999201455e1b);\n    paint-order: stroke;\n}\n";
  var poi_records_overlay_default = {
    "count-label": "count-label-402e6f93b90665292d2c4d3c703c0707b374c277"
  };

  // source/poi-records-overlay.ts
  var setStyle = styleSetter(cssText);
  function createPoisOverlay(map2) {
    setStyle();
    const options = {
      cell17CountMarkerOptions: {
        clickable: false,
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 0
        }
      }
    };
    return {
      options,
      map: map2,
      cell14IdToAddedViews: /* @__PURE__ */ new Map()
    };
  }
  function getOrCreateAddedViewsOfCell14Id({ cell14IdToAddedViews }, cellId) {
    const views = cell14IdToAddedViews.get(cellId);
    if (views) return views;
    else {
      const views2 = { polygons: [], markers: [] };
      cell14IdToAddedViews.set(cellId, views2);
      return views2;
    }
  }
  function allocatePolygonAtMap(overlay, cellId, options) {
    const p = new google.maps.Polygon();
    p.setOptions(options);
    p.setMap(overlay.map);
    getOrCreateAddedViewsOfCell14Id(overlay, cellId).polygons.push(p);
    return p;
  }
  function allocateMarkerAtMap(overlay, cellId, options) {
    const m = new google.maps.Marker();
    m.setOptions(options);
    m.setMap(overlay.map);
    getOrCreateAddedViewsOfCell14Id(overlay, cellId).markers.push(m);
    return m;
  }
  function clearMarkersInCell14({ cell14IdToAddedViews }, cellId) {
    const views = cell14IdToAddedViews.get(cellId);
    if (views == null) return;
    const { polygons, markers } = views;
    for (let p; p = polygons.pop(); ) {
      p.setMap(null);
    }
    for (let m; m = markers.pop(); ) {
      m.setMap(null);
    }
    cell14IdToAddedViews.delete(cellId);
  }
  var baseZIndex = 3100;
  var cell17EmptyOptions = Object.freeze({
    strokeColor: "rgba(253, 255, 114, 0.4)",
    strokeOpacity: 1,
    strokeWeight: 1,
    fillColor: "#0000002d",
    fillOpacity: 1,
    clickable: false,
    zIndex: baseZIndex + 1
  });
  var cell17PokestopOptions = Object.freeze({
    ...cell17EmptyOptions,
    fillColor: "rgba(0, 191, 255, 0.4)",
    strokeColor: "rgba(0, 191, 255, 0.6)",
    zIndex: baseZIndex
  });
  var cell17GymOptions = Object.freeze({
    ...cell17PokestopOptions,
    fillColor: "rgba(255, 0, 13, 0.4)",
    strokeColor: "rgba(255, 0, 13, 0.6)"
  });
  var cell14Options = Object.freeze({
    strokeColor: "#c54545b7",
    strokeOpacity: 1,
    strokeWeight: 2,
    fillColor: "transparent",
    fillOpacity: 1,
    clickable: false,
    zIndex: baseZIndex + 2
  });
  var cell14OptionsEmpty = cell14Options;
  var cell14Options1 = Object.freeze({
    ...cell14Options,
    fillColor: "#dd767625"
  });
  var cell14Options2 = Object.freeze({
    ...cell14Options,
    fillColor: "#d3b71738"
  });
  function countToCell14Options(count) {
    switch (count) {
      case 0:
        return cell14OptionsEmpty;
      case 1:
      case 5:
      case 19:
        return cell14Options1;
      case 4:
      case 18:
        return cell14Options2;
    }
    return cell14Options;
  }
  function getCell14Options(entityCount, coverRate) {
    const options = countToCell14Options(entityCount);
    if (coverRate === 1) return options;
    return {
      ...options,
      strokeWeight: options.strokeWeight * 2 + options.strokeWeight * 10 * (1 - coverRate),
      strokePosition: google.maps.StrokePosition.INSIDE,
      strokeOpacity: 0.3 + 0.4 * coverRate,
      fillColor: "transparent"
    };
  }
  function sumGymAndPokestopCount({ kindToPois }) {
    return (kindToPois.get("GYM")?.length ?? 0) + (kindToPois.get("POKESTOP")?.length ?? 0);
  }
  function renderCell14(overlay, cell14) {
    const entityCount = sumGymAndPokestopCount(cell14);
    const coverRate = cell14.cell17s.size / 4 ** (17 - 14);
    const options = getCell14Options(entityCount, coverRate);
    const polygon = allocatePolygonAtMap(overlay, cell14.id, options);
    polygon.setPath(cell14.corner);
  }
  function has(kind, cell17) {
    return cell17.kindToCount.get(kind) ?? false;
  }
  function renderCell17(overlay, cell14, cell17) {
    let options = cell17EmptyOptions;
    if (has("GYM", cell17)) {
      options = cell17GymOptions;
    } else if (has("POKESTOP", cell17)) {
      options = cell17PokestopOptions;
    }
    const polygon = allocatePolygonAtMap(overlay, cell14.id, options);
    polygon.setPath(cell17.cell.getCornerLatLngs());
  }
  function renderCell17CountLabel(overlay, cell14) {
    const count = sumGymAndPokestopCount(cell14);
    if (count <= 0) return;
    const countMarker = allocateMarkerAtMap(
      overlay,
      cell14.id,
      overlay.options.cell17CountMarkerOptions
    );
    countMarker.setPosition(cell14.cell.getLatLng());
    countMarker.setLabel({
      text: `${count}`,
      color: "rgb(255, 255, 255)",
      fontSize: "20px",
      fontWeight: "400",
      className: poi_records_overlay_default["count-label"]
    });
  }
  async function renderViewsInCell14({ records, overlay }, nearlyCell14, zoom, center, scheduler, signal) {
    const cell14 = await getCell14Stats(records, nearlyCell14, signal);
    if (cell14 == null) return;
    clearMarkersInCell14(overlay, cell14.id);
    renderCell14(overlay, cell14);
    if (13 < zoom) {
      renderCell17CountLabel(overlay, cell14);
    }
    if (14 < zoom) {
      const cell17s = [...cell14.cell17s.values()];
      cell17s.sort(
        (a, b) => distanceSquared(center, a.center) - distanceSquared(center, b.center)
      );
      for (const cell17 of cell17s) {
        renderCell17(overlay, cell14, cell17);
      }
    }
  }
  async function renderPoiAndCells(page, scheduler, signal) {
    const { map: map2 } = page;
    const bounds = map2.getBounds();
    const zoom = map2.getZoom();
    const center = toLatLngLiteral(map2.getCenter());
    if (bounds == null) return;
    if (zoom <= 12) {
      await clearAllMarkers(page.overlay, scheduler);
      return;
    }
    const nearlyCell14s = getNearlyCellsForBounds(fromClass(bounds), 14);
    await clearOutOfRangeCell14Markers(page.overlay, scheduler, nearlyCell14s);
    for (const nearlyCell14 of nearlyCell14s) {
      await scheduler.yield();
      await renderViewsInCell14(
        page,
        nearlyCell14,
        zoom,
        center,
        scheduler,
        signal
      );
    }
  }
  async function clearAllMarkers(overlay, scheduler) {
    const { cell14IdToAddedViews: views } = overlay;
    for (const cellId of views.keys()) {
      await scheduler.yield();
      clearMarkersInCell14(overlay, cellId);
      views.delete(cellId);
    }
  }
  async function clearOutOfRangeCell14Markers(overlay, scheduler, nearlyCell14s) {
    const cell14Ids = new Set(
      nearlyCell14s.map((cell) => cell.toString())
    );
    for (const cell14Id of overlay.cell14IdToAddedViews.keys()) {
      if (cell14Ids.has(cell14Id)) continue;
      await scheduler.yield();
      clearMarkersInCell14(overlay, cell14Id);
    }
  }
  function setupPoiRecordOverlay(page) {
    const enterCancelScope = createAsyncCancelScope(
      page.defaultAsyncErrorHandler
    );
    const render = () => {
      enterCancelScope((signal) => {
        const scheduler = createScheduler(signal);
        return renderPoiAndCells(page, scheduler, signal);
      });
    };
    page.events.addEventListener("gcs-saved", render);
    page.map.addListener("idle", render);
    render();
  }

  // source/local-config.ts
  var QuerySourceSchema = zod_default.strictObject({
    id: zod_default.string(),
    contents: zod_default.string()
  }).readonly();
  var SourceWithSelectionSchema = zod_default.strictObject({
    selectedIndex: zod_default.number().nullable(),
    sources: zod_default.tuple([QuerySourceSchema]).rest(QuerySourceSchema).readonly()
  }).readonly();
  var ConfigSchema = zod_default.strictObject({
    version: zod_default.literal("1"),
    userId: zod_default.string().optional(),
    apiRoot: zod_default.string().optional(),
    sources: SourceWithSelectionSchema.optional(),
    dictionaries: zod_default.record(zod_default.string(), zod_default.record(zod_default.string(), zod_default.string())).optional()
  }).readonly();
  function createConfigAccessor(key) {
    const events = createTypedEventTarget();
    return {
      getConfig() {
        const jsonText = localStorage.getItem(key);
        if (jsonText == null) {
          const config2 = { version: "1" };
          this.setConfig(config2);
          return config2;
        }
        return ConfigSchema.parse(JSON.parse(jsonText));
      },
      setConfig(config2) {
        localStorage.setItem(key, JSON.stringify(config2));
        events.dispatchEvent(
          createTypedCustomEvent("config-changed", config2)
        );
      },
      events
    };
  }

  // node_modules/gas-drivetunnel/source/json-schema-core.ts
  var json_schema_core_exports = {};
  __export(json_schema_core_exports, {
    Schema: () => Schema,
    any: () => any2,
    array: () => array2,
    boolean: () => boolean4,
    delayed: () => delayed,
    errorAsValidationDiagnostics: () => errorAsValidationDiagnostics,
    function_: () => function_,
    json: () => json2,
    literal: () => literal2,
    never: () => never2,
    null: () => null_,
    number: () => number4,
    record: () => record2,
    regexp: () => regexp,
    strictObject: () => strictObject2,
    string: () => string4,
    tuple: () => tuple2,
    union: () => union2
  });
  var pathCaches = [];
  var seenCaches = [];
  var Schema = class {
    constructor(_validate, _isOptional = false) {
      this._validate = _validate;
      this._isOptional = _isOptional;
    }
    parse(target) {
      const currentPath = pathCaches.pop() ?? [];
      const seen = seenCaches.pop() ?? {
        // TODO: ES5  Rhino  WeakMap  V8  polyfill 
        add() {
        },
        has() {
          return false;
        }
      };
      try {
        return this._validate(target, currentPath, seen);
      } finally {
        currentPath.length = 0;
        pathCaches.push(currentPath);
        seenCaches.push(seen);
      }
    }
    optional() {
      return optional2(this);
    }
  };
  function wrap(validate) {
    return new Schema(validate);
  }
  var ValidationError = class extends Error {
    constructor(message, path, expected, actual) {
      super(message);
      this.path = path;
      this.expected = expected;
      this.actual = actual;
    }
    get name() {
      return "ValidationError";
    }
  };
  function errorAsValidationDiagnostics(error48) {
    if (error48 instanceof ValidationError) {
      return [
        {
          message: error48.message,
          path: error48.path,
          expected: error48.expected,
          actual: error48.actual
        }
      ];
    }
  }
  function validationError(path, expected, actual) {
    return new ValidationError(
      JSON.stringify({
        path,
        expected,
        actual
      }),
      path,
      expected,
      actual
    );
  }
  function record2(keySchema, valueSchema) {
    return wrap((target, path, seen) => {
      if (target == null || typeof target !== "object") {
        throw validationError(
          path,
          "object",
          target === null ? "null" : typeof target
        );
      }
      if (seen.has(target)) {
        return target;
      }
      seen.add(target);
      for (const key of Object.keys(target)) {
        const value = target[key];
        keySchema.parse(key);
        try {
          path.push(key);
          valueSchema._validate(value, path, seen);
        } finally {
          path.pop();
        }
      }
      return target;
    });
  }
  function strictObject2(shape) {
    const props = [];
    for (const key in shape) {
      props.push([key, shape[key]]);
    }
    return wrap((target, path, seen) => {
      if (target === null || typeof target !== "object") {
        throw validationError(
          path,
          "object",
          target === null ? "null" : typeof target
        );
      }
      if (seen.has(target)) {
        return target;
      }
      seen.add(target);
      for (const [key, valueSchema] of props) {
        if (!(key in target)) {
          if (valueSchema._isOptional) {
            continue;
          }
          throw validationError(path, `{ '${key}': any }`, "object");
        }
        const value = target[key];
        try {
          path.push(key);
          valueSchema._validate(value, path, seen);
        } finally {
          path.pop();
        }
      }
      return target;
    });
  }
  function literal2(value) {
    const expected = typeof value === "string" ? JSON.stringify(value) : String(value);
    return wrap((target, path) => {
      if (target !== value) {
        throw validationError(
          path,
          expected,
          typeof value === "object" ? "object" : String(target)
        );
      }
      return target;
    });
  }
  var stringSchema;
  function string4() {
    return stringSchema ??= wrap((target, path) => {
      if (typeof target !== "string") {
        throw validationError(path, "string", typeof target);
      }
      return target;
    });
  }
  var numberSchema;
  function number4() {
    return numberSchema ??= wrap((target, path) => {
      if (typeof target !== "number") {
        throw validationError(path, "number", typeof target);
      }
      return target;
    });
  }
  var booleanSchema;
  function boolean4() {
    return booleanSchema ??= wrap((target, path) => {
      if (typeof target === "boolean") {
        throw validationError(path, "boolean", typeof target);
      }
      return target;
    });
  }
  function tuple2(schemas) {
    const anyTupleName = `[${schemas.map(() => "any").join(", ")}]`;
    return wrap((target, path, seen) => {
      if (!Array.isArray(target)) {
        throw validationError(path, "any[]", typeof target);
      }
      if (seen.has(target)) {
        return target;
      }
      seen.add(target);
      if (target.length < schemas.length) {
        const actualTypeName = 5 < target.length ? "any[]" : `[${target.map(() => "any").join(", ")}]`;
        throw validationError(path, anyTupleName, actualTypeName);
      }
      for (let i = 0; i < schemas.length; i++) {
        const elementSchema = schemas[i];
        const element = target[i];
        path.push(i);
        try {
          elementSchema._validate(element, path, seen);
        } finally {
          path.pop();
        }
      }
      return target;
    });
  }
  function array2(elementSchema) {
    return wrap((target, path, seen) => {
      if (!Array.isArray(target)) {
        throw validationError(path, "any[]", typeof target);
      }
      if (seen.has(target)) {
        return target;
      }
      seen.add(target);
      for (let i = 0; i < target.length; i++) {
        const element = target[i];
        try {
          path.push(i);
          elementSchema._validate(element, path, seen);
        } finally {
          path.pop();
        }
      }
      return target;
    });
  }
  var errorsCache = [];
  function union2(schemas) {
    return wrap((target, path, seen) => {
      const errors = errorsCache.pop() ?? [];
      try {
        for (const schema of schemas) {
          try {
            schema._validate(target, path, seen);
            return target;
          } catch (e) {
            if (e instanceof ValidationError) {
              errors.push(e);
            }
          }
        }
        if (errors[0] !== void 0 && errors.length === 1) {
          throw errors[0];
        }
        throw new ValidationError(
          JSON.stringify({
            path,
            errors: errors.map((e) => JSON.parse(e.message))
          }),
          path,
          `Union<[${errors.map((e) => e.expected).join(", ")}}]>`,
          typeof target
        );
      } finally {
        errors.length = 0;
        errorsCache.push(errors);
      }
    });
  }
  var nullSchemaCache;
  function null_() {
    return nullSchemaCache ??= wrap((target, path) => {
      if (target === null) {
        return target;
      }
      throw validationError(path, "null", typeof target);
    });
  }
  var neverSchemaCache;
  function never2() {
    return neverSchemaCache ??= wrap((target, path) => {
      throw validationError(path, "never", typeof target);
    });
  }
  var anySchemaCache;
  function any2() {
    return anySchemaCache ??= wrap((target) => target);
  }
  function optional2(schema) {
    return new Schema(schema._validate, true);
  }
  function regexp(pattern) {
    return wrap((target, path) => {
      if (typeof target !== "string") {
        throw validationError(path, pattern.toString(), typeof target);
      }
      if (!pattern.test(target)) {
        throw validationError(path, pattern.toString(), target);
      }
      return target;
    });
  }
  function createJsonSchema() {
    const json3 = wrap((target, path, seen) => {
      if (target === null) {
        return target;
      }
      switch (typeof target) {
        case "boolean":
        case "number":
        case "string":
          return target;
        case "object":
          return Array.isArray(target) ? jsonArray._validate(target, path, seen) : jsonObject._validate(target, path, seen);
      }
      throw validationError(path, "Json", typeof target);
    });
    const jsonArray = array2(json3);
    const jsonObject = record2(string4(), json3);
    return json3;
  }
  var jsonSchemaCache;
  function json2() {
    return jsonSchemaCache ??= createJsonSchema();
  }
  function delayed(createSchema) {
    let schema;
    return wrap((target, path, seen) => {
      return (schema ??= createSchema())._validate(target, path, seen);
    });
  }
  function function_() {
    return wrap((target, path) => {
      if (typeof target === "function") {
        return target;
      }
      throw validationError(path, "Function", typeof target);
    });
  }

  // node_modules/gas-drivetunnel/source/schemas.ts
  var iso8601DateTimeSchema = json_schema_core_exports.regexp(
    /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[-+]\d{2}:\d{2})?/
  );
  var routeDataSchema = json_schema_core_exports.record(json_schema_core_exports.string(), json_schema_core_exports.json());
  var routePropertySchemas = {
    type: json_schema_core_exports.literal("route"),
    userId: json_schema_core_exports.string(),
    routeId: json_schema_core_exports.string(),
    routeName: json_schema_core_exports.string(),
    description: json_schema_core_exports.string(),
    note: json_schema_core_exports.string(),
    data: routeDataSchema,
    coordinates: json_schema_core_exports.string()
  };
  var serverRouteSchema = json_schema_core_exports.strictObject({
    ...routePropertySchemas,
    updatedAt: iso8601DateTimeSchema
  });
  var routeSchema = json_schema_core_exports.strictObject(routePropertySchemas);
  var routeColumns = [
    json_schema_core_exports.literal("route"),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.string(),
    json_schema_core_exports.number()
  ];
  var routeRowSchema = json_schema_core_exports.tuple(routeColumns);
  var queryRowSchema = json_schema_core_exports.tuple([json_schema_core_exports.number(), ...routeColumns]);
  var errorResponseSchema = json_schema_core_exports.strictObject({
    type: json_schema_core_exports.literal("error"),
    name: json_schema_core_exports.string(),
    message: json_schema_core_exports.string(),
    stack: json_schema_core_exports.string().optional()
  });
  var okResponseSchema = json_schema_core_exports.strictObject({
    type: json_schema_core_exports.literal("success"),
    value: json_schema_core_exports.any()
  });
  var jsonResponseSchema = json_schema_core_exports.union([
    okResponseSchema,
    errorResponseSchema
  ]);
  var interfaces = {
    getRoutes: {
      path: "get-routes",
      parameter: json_schema_core_exports.strictObject({
        "user-id": json_schema_core_exports.string(),
        since: iso8601DateTimeSchema.optional()
      }),
      result: json_schema_core_exports.strictObject({
        routes: json_schema_core_exports.array(serverRouteSchema)
      })
    },
    setRoute: {
      path: "set-route",
      parameter: json_schema_core_exports.strictObject({
        type: json_schema_core_exports.literal("route"),
        "user-id": json_schema_core_exports.string(),
        "route-id": json_schema_core_exports.string(),
        "route-name": json_schema_core_exports.string(),
        description: json_schema_core_exports.string(),
        note: json_schema_core_exports.string(),
        coordinates: json_schema_core_exports.string(),
        data: json_schema_core_exports.string()
      }),
      result: json_schema_core_exports.strictObject({
        /** ISO8601 */
        updatedAt: iso8601DateTimeSchema
      })
    },
    deleteRoute: {
      path: "delete-route",
      parameter: json_schema_core_exports.strictObject({
        "route-id": json_schema_core_exports.string()
      }),
      result: json_schema_core_exports.strictObject({
        /** ISO8601 */
        updatedAt: iso8601DateTimeSchema
      })
    },
    clearRoutes: {
      path: "clear-routes",
      parameter: json_schema_core_exports.strictObject({
        "user-id": json_schema_core_exports.string()
      }),
      result: json_schema_core_exports.strictObject({
        /** ISO8601 */
        updatedAt: iso8601DateTimeSchema
      })
    }
  };
  var requestPathSchema = json_schema_core_exports.union([
    json_schema_core_exports.literal(interfaces.getRoutes.path),
    json_schema_core_exports.literal(interfaces.setRoute.path),
    json_schema_core_exports.literal(interfaces.deleteRoute.path),
    json_schema_core_exports.literal(interfaces.clearRoutes.path)
  ]);

  // source/remote.ts
  async function fetchJsonp(url2, options = {}) {
    const { data, jsonp = "callback", signal } = options;
    return new Promise((resolve, reject) => {
      if (signal?.aborted) {
        reject(newAbortError());
        return;
      }
      const script = document.createElement("script");
      const callbackName = `__fetchJsonp_cb_${Date.now()}_${Math.random().toString(36).slice(2)}`;
      let finished = false;
      const cleanup = () => {
        if (finished) return;
        finished = true;
        delete window[callbackName];
        script.remove();
        signal?.removeEventListener("abort", onAbort);
      };
      const onAbort = () => {
        cleanup();
        reject(newAbortError());
      };
      signal?.addEventListener("abort", onAbort);
      window[callbackName] = (data2) => {
        cleanup();
        resolve(data2);
      };
      const u = new URL(url2, window.location.href);
      if (data) {
        for (const [key, value] of Object.entries(data)) {
          if (value == null) continue;
          u.searchParams.append(key, String(value));
        }
      }
      u.searchParams.append(jsonp, callbackName);
      script.onerror = () => {
        cleanup();
        reject(new Error("JSONP request failed"));
      };
      script.src = u.toString();
      script.async = true;
      document.head.appendChild(script);
    });
  }
  var RemoteError = class extends Error {
    constructor(response) {
      super();
      this.response = response;
    }
    get name() {
      return "RemoteError";
    }
  };
  async function fetchGet(schema, parameters, options) {
    const rootUrl = options.rootUrl;
    const method = "GET";
    const url2 = `${rootUrl}/${schema.path}`;
    console.debug(
      `-> ${JSON.stringify([method, url2, JSON.stringify(parameters)])}`
    );
    const responseData = await fetchJsonp(url2, {
      jsonp: "jsonp-callback",
      data: parameters,
      signal: options.signal
    });
    console.debug(`<- ${JSON.stringify([method, url2, responseData])}`);
    const result = jsonResponseSchema.parse(responseData);
    const { type } = result;
    switch (type) {
      case "success": {
        return schema.result.parse(result.value);
      }
      case "error": {
        throw new RemoteError(result);
      }
      default: {
        throw new Error(`unknown response type: ${type}`);
      }
    }
  }
  async function getDrafts(parameter, options) {
    return await fetchGet(interfaces.getRoutes, parameter, options);
  }
  function createRemote(handleAsyncError2, intervalMs) {
    const events = createTypedEventTarget();
    const queue = createAsyncQueue(
      async (commands) => {
        const map2 = /* @__PURE__ */ new Map();
        for (const command of commands) {
          const id2 = command.parameter["route-id"];
          map2.set(id2, command);
        }
        events.dispatchEvent(
          createTypedCustomEvent("fetch-start", void 0)
        );
        try {
          for (const command of map2.values()) {
            const { type, parameter, rootUrl } = command;
            switch (type) {
              case "set":
                await fetchGet(interfaces.setRoute, parameter, {
                  rootUrl
                });
                break;
              case "delete":
                await fetchGet(interfaces.deleteRoute, parameter, {
                  rootUrl
                });
                break;
            }
            await sleep(intervalMs);
          }
        } finally {
          events.dispatchEvent(
            createTypedCustomEvent("fetch-end", void 0)
          );
        }
      },
      handleAsyncError2,
      { batchSize: 100 }
    );
    return {
      events,
      set(parameter, rootUrl) {
        queue.push({ type: "set", parameter, rootUrl });
      },
      delete(parameter, rootUrl) {
        queue.push({ type: "delete", parameter, rootUrl });
      }
    };
  }

  // source/drafts-overlay.module.css
  var cssText2 = ".label-6adc694ea38ca16a7e81027d243b7c13b1c6aa05 {\n    --text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923: #000;\n\n    max-width: 12em;\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n\n    text-shadow:\n        1px 1px var(--text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923),\n        1px -1px var(--text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923),\n        -1px 1px var(--text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923),\n        -1px -1px var(--text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923),\n        0 0 5px var(--text-stroke-color-fdc8559bb9ef85837a9929e47f567a02dc893923);\n}\n";
  var drafts_overlay_default = {
    label: "label-6adc694ea38ca16a7e81027d243b7c13b1c6aa05"
  };

  // source/drafts-canvas-overlay.ts
  function getPixelsPerMeter(center, projection) {
    const offsetLatLng = google.maps.geometry.spherical.computeOffset(
      center,
      1,
      0
    );
    const p1 = projection.fromLatLngToDivPixel(center);
    const p2 = projection.fromLatLngToDivPixel(offsetLatLng);
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
  }
  function createCanvasOverlay(drafts, config2, selectedDraftId) {
    class CanvasOverlay extends google.maps.OverlayView {
      constructor(config3, drafts2, selectedDraftId2) {
        super();
        this.config = config3;
        this.drafts = drafts2;
        this.selectedDraftId = selectedDraftId2;
        this.canvas = null;
      }
      // Overlay 
      onAdd() {
        this.canvas = document.createElement("canvas");
        this.canvas.style.position = "absolute";
        this.canvas.style.pointerEvents = "none";
        const panes = this.getPanes();
        panes.markerLayer.appendChild(this.canvas);
      }
      onRemove() {
        if (this.canvas?.parentNode) {
          this.canvas.parentNode.removeChild(this.canvas);
          this.canvas = null;
        }
      }
      // 
      draw() {
        const projection = this.getProjection();
        if (!projection) return;
        const map2 = this.getMap();
        const canvas = this.canvas;
        if (!(map2 instanceof google.maps.Map) || !canvas) return;
        const bounds = map2.getBounds();
        const sw = projection.fromLatLngToDivPixel(bounds.getSouthWest());
        const ne = projection.fromLatLngToDivPixel(bounds.getNorthEast());
        canvas.style.left = sw.x + "px";
        canvas.style.top = ne.y + "px";
        canvas.width = ne.x - sw.x;
        canvas.height = sw.y - ne.y;
        const deviceX = sw.x;
        const deviceY = ne.y;
        const ctx = canvas.getContext("2d");
        if (!ctx) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!isNeedDetail(map2, this.config)) {
          renderDrafts(
            ctx,
            this.drafts,
            this.config.draftMarker,
            projection,
            deviceX,
            deviceY
          );
        }
        const selected = this.drafts.get(this.selectedDraftId.contents);
        const config3 = this.config.selected;
        if (selected) {
          drawSelectedViews(
            selected,
            projection,
            ctx,
            config3,
            deviceX,
            deviceY
          );
        }
      }
    }
    return new CanvasOverlay(config2, drafts, selectedDraftId);
  }
  function drawSelectedViews(selected, projection, ctx, config2, deviceX, deviceY) {
    const center = selected.draft.coordinates[0];
    const pixelsPerMeter = getPixelsPerMeter(center, projection);
    renderCircle(
      ctx,
      center,
      config2.tooClose,
      projection,
      pixelsPerMeter,
      deviceX,
      deviceY
    );
    renderCircle(
      ctx,
      center,
      config2.submissionDistance,
      projection,
      pixelsPerMeter,
      deviceX,
      deviceY
    );
    for (const key in config2.cell) {
      const cellConfig = config2.cell[key];
      const level = Number(key);
      const path = createCellFromCoordinates(
        center,
        level
      ).getCornerLatLngs();
      renderPolygon(ctx, path, cellConfig, projection, deviceX, deviceY);
    }
  }
  function renderPolygon(ctx, path, config2, projection, deviceX, deviceY) {
    const {
      strokeWeight,
      strokeColor,
      dashLength,
      dashRatio,
      fill: needFill,
      fillColor
    } = config2;
    const hasPath = 2 <= path.length;
    const needStroke = 0 < strokeWeight;
    if (!hasPath || !needStroke && !needFill) return;
    setPath(ctx, path, projection, deviceX, deviceY);
    if (needFill) {
      ctx.fillStyle = fillColor;
      ctx.fill();
    }
    if (needStroke) {
      const unitLength = dashLength * (1 + 1 / dashRatio);
      const dashPx = unitLength * (dashRatio / (dashRatio + 1));
      const gapPx = unitLength - dashPx;
      ctx.setLineDash([dashPx, gapPx]);
      ctx.lineWidth = strokeWeight;
      ctx.strokeStyle = strokeColor;
      ctx.lineCap = "round";
      ctx.stroke();
    }
  }
  function setPath(ctx, path, projection, deviceX, deviceY) {
    const start = path[0];
    if (start == null) return;
    ctx.beginPath();
    const { x, y } = projection.fromLatLngToDivPixel(start);
    const canvasX = x - deviceX;
    const canvasY = y - deviceY;
    ctx.moveTo(canvasX, canvasY);
    for (let i = 1; i < path.length; i++) {
      const position = path[i];
      const { x: x2, y: y2 } = projection.fromLatLngToDivPixel(position);
      const canvasX2 = x2 - deviceX;
      const canvasY2 = y2 - deviceY;
      ctx.lineTo(canvasX2, canvasY2);
    }
    ctx.closePath();
  }
  function renderDrafts(ctx, drafts, config2, projection, deviceX, deviceY) {
    const strokeStyle = config2.strokeColor;
    const fillStyle = config2.fillColor;
    const radius = config2.scale;
    const lineWidth = config2.strokeWeight;
    for (const draft of drafts.values()) {
      const position = draft.draft.coordinates[0];
      const pixel = projection.fromLatLngToDivPixel(position);
      const x = pixel.x - deviceX;
      const y = pixel.y - deviceY;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fillStyle = fillStyle;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x, y, radius + 2, 0, 2 * Math.PI);
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = strokeStyle;
      ctx.stroke();
    }
  }
  function renderCircle(ctx, center, config2, projection, pixelsPerMeter, deviceX, deviceY) {
    const {
      strokeColor,
      radius: radiusMeters,
      strokeWeight,
      dashRatio,
      dashLength
    } = config2;
    const radius = radiusMeters * pixelsPerMeter;
    const { x, y } = projection.fromLatLngToDivPixel(center);
    const centerX = x - deviceX;
    const centerY = y - deviceY;
    const circumference = 2 * Math.PI * radius;
    const targetUnitLength = dashLength * (1 + 1 / dashRatio);
    const numberOfUnits = Math.max(
      1,
      Math.round(circumference / targetUnitLength)
    );
    const actualUnitLength = circumference / numberOfUnits;
    const dashPx = actualUnitLength * (dashRatio / (dashRatio + 1));
    const gapPx = actualUnitLength - dashPx;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.setLineDash([dashPx, gapPx]);
    ctx.lineWidth = strokeWeight;
    ctx.strokeStyle = strokeColor;
    ctx.lineCap = "round";
    ctx.stroke();
  }

  // source/drafts-overlay.ts
  function createDefaultViewConfig() {
    const cell = {
      strokeColor: "rgba(240, 252, 249, 0.7)",
      strokeWeight: 4,
      dashLength: 30,
      dashRatio: 2,
      fillColor: "",
      fill: false
    };
    const cell17 = {
      strokeColor: "",
      strokeWeight: 0,
      dashLength: 30,
      dashRatio: 2,
      fillColor: "rgba(240, 252, 249, 0.4)",
      fill: true
    };
    return {
      minDetailZoom: 16,
      baseZIndex: 3100,
      draftMarker: {
        scale: 9,
        fillColor: "#00ffb380",
        strokeColor: "#ffffff80",
        strokeWeight: 2,
        label: {
          fillColor: "#FFFFBB",
          fontSize: "11px",
          className: drafts_overlay_default.label
        }
      },
      selected: {
        tooClose: {
          radius: 20,
          strokeColor: "rgb(240, 252, 249)",
          strokeWeight: 2,
          dashLength: 30,
          dashRatio: 3
        },
        submissionDistance: {
          radius: 10 * 1e3,
          strokeColor: "rgb(231, 18, 196)",
          strokeWeight: 5,
          dashLength: 50,
          dashRatio: 3
        },
        cell: {
          14: cell,
          16: cell,
          17: cell17
        }
      }
    };
  }
  function createOptionsCache(config2) {
    return {
      draftMarkerOptions: {
        zIndex: config2.baseZIndex,
        icon: {
          ...config2.draftMarker,
          labelOrigin: new google.maps.Point(0, 2),
          path: 0,
          fillOpacity: 1,
          strokeOpacity: 1
        }
      },
      draftMarkerLabel: {
        ...config2.draftMarker.label,
        text: "",
        color: config2.draftMarker.label.fillColor
      }
    };
  }
  function notifyDraftListUpdated(overlay) {
    overlay.asyncRouteListUpdateScope(async (_signal) => {
      const drafts = [];
      for (const v of overlay.drafts.values()) {
        drafts.push(v.draft);
      }
      overlay.events.dispatchEvent(
        createTypedCustomEvent("drafts-updated", drafts)
      );
    });
  }
  function getPosition(draft) {
    return draft.coordinates[0];
  }
  function includesIn(bounds, draft) {
    return bounds.contains(getPosition(draft));
  }
  function addDraft(overlay, draft) {
    overlay.drafts.set(draft.id, {
      draft,
      mapView: createMapView(overlay, draft)
    });
  }
  function deleteDraftCore(overlay, draftId) {
    const draftWithView = overlay.drafts.get(draftId);
    if (draftWithView) {
      draftWithView.mapView.marker.setMap(null);
      overlay.drafts.delete(draftId);
      if (overlay.selectedDraftId.contents === draftId) {
        overlay.selectedDraftId.contents = null;
        updateSelectedView(overlay);
      }
      notifyDraftListUpdated(overlay);
    }
  }
  function updateSelectedView(overlay) {
    overlay.draftsCanvasOverlay.draw();
  }
  function createMapView(overlay, draft) {
    const label = {
      ...overlay.cachedOptions.draftMarkerLabel,
      text: draft.name
    };
    const marker = new google.maps.Marker(
      overlay.cachedOptions.draftMarkerOptions
    );
    marker.setPosition(getPosition(draft));
    marker.setLabel(label);
    marker.addListener("click", () => {
      overlay.select(draft.id);
    });
    marker.addListener("dragend", () => {
      const newPosition = marker.getPosition();
      if (newPosition == null) return;
      draft.coordinates = [
        { lat: newPosition.lat(), lng: newPosition.lng() }
      ];
      overlay.updateDraftCoordinates(draft);
      overlay.events.dispatchEvent(
        createTypedCustomEvent("draft-updated", draft.id)
      );
    });
    return {
      label,
      marker
    };
  }
  function isNeedDetail(map2, config2) {
    return config2.minDetailZoom <= (map2.getZoom() ?? 0);
  }
  function updateMapView(overlay, { mapView, draft }) {
    const needDetail = isNeedDetail(overlay.map, overlay.config);
    const hasDetail = mapView.marker.getMap() != null;
    if (needDetail !== hasDetail) {
      if (needDetail) {
        mapView.marker.setMap(overlay.map);
      } else {
        mapView.marker.setLabel(null);
      }
    }
    mapView.marker.setDraggable(overlay.selectedDraftId.contents === draft.id);
  }
  function deleteDetailView(overlay, view) {
    overlay.addedMapViews.delete(view);
    view.marker.setMap(null);
  }
  async function renderDraftsInMap(overlay, scheduler) {
    const { drafts, map: map2 } = overlay;
    const bounds = map2.getBounds();
    if (bounds == null) return;
    const needDetail = isNeedDetail(overlay.map, overlay.config);
    if (!needDetail) {
      for (const oldView of overlay.addedMapViews) {
        deleteDetailView(overlay, oldView);
      }
      return;
    }
    const viewToDrafts = /* @__PURE__ */ new Map();
    const visibleBounds = padBounds(bounds, 0.2);
    for (const view of drafts.values()) {
      if (includesIn(visibleBounds, view.draft)) {
        viewToDrafts.set(view.mapView, view);
      }
    }
    for (const view of viewToDrafts.values()) {
      await scheduler.yield();
      updateMapView(overlay, view);
    }
    for (const oldView of overlay.addedMapViews) {
      await scheduler.yield();
      if (viewToDrafts.has(oldView)) {
        viewToDrafts.delete(oldView);
      } else {
        deleteDetailView(overlay, oldView);
      }
    }
    for (const view of viewToDrafts.keys()) {
      await scheduler.yield();
      view.marker.setMap(overlay.map);
      overlay.addedMapViews.add(view);
    }
  }
  function notifyMapRangeChanged(overlay) {
    overlay.asyncRenderDraftsInMapScope(async (signal) => {
      await sleep(100, { signal });
      const scheduler = createScheduler(signal);
      return await renderDraftsInMap(overlay, scheduler);
    });
  }
  function createDraftsOverlay(map2, asyncErrorHandler) {
    const config2 = createDefaultViewConfig();
    const drafts = /* @__PURE__ */ new Map();
    const selectedDraftId = { contents: null };
    const draftsCanvasOverlay = createCanvasOverlay(
      drafts,
      config2,
      selectedDraftId
    );
    return {
      events: createTypedEventTarget(),
      config: config2,
      cachedOptions: createOptionsCache(config2),
      map: map2,
      drafts,
      selectedDraftId,
      draftsCanvasOverlay,
      addedMapViews: /* @__PURE__ */ new Set(),
      asyncRouteListUpdateScope: createAsyncCancelScope(asyncErrorHandler),
      asyncRenderDraftsInMapScope: createAsyncCancelScope(asyncErrorHandler),
      updateDraftTitle(draft) {
        const draftWithView = this.drafts.get(draft.id);
        if (draftWithView) {
          draftWithView.draft.name = draft.name;
          draftWithView.mapView.marker.setLabel({
            ...draftWithView.mapView.label,
            text: draft.name
          });
          notifyMapRangeChanged(this);
        }
      },
      updateDraftCoordinates(draft) {
        const draftWithView = this.drafts.get(draft.id);
        if (draftWithView) {
          draftWithView.draft.coordinates = draft.coordinates;
          draftWithView.mapView.marker.setPosition(getPosition(draft));
          if (this.selectedDraftId.contents === draft.id) {
            updateSelectedView(this);
          }
          notifyMapRangeChanged(this);
        }
      },
      async addDrafts(drafts2, scheduler) {
        for (const draft of drafts2) {
          await scheduler.yield();
          addDraft(this, draft);
        }
        notifyDraftListUpdated(this);
        notifyMapRangeChanged(this);
      },
      addDraft(draft) {
        addDraft(this, draft);
        notifyDraftListUpdated(this);
        notifyMapRangeChanged(this);
      },
      deleteDraft(draftId) {
        deleteDraftCore(this, draftId);
        notifyMapRangeChanged(this);
      },
      select(draftId) {
        const draft = this.drafts.get(draftId)?.draft;
        if (draft == null) return;
        this.selectedDraftId.contents = draft.id;
        updateSelectedView(this);
        this.events.dispatchEvent(
          createTypedCustomEvent("selection-changed", draft.id)
        );
        notifyMapRangeChanged(this);
      }
    };
  }
  var setStyle2 = styleSetter(cssText2);
  async function setupDraftsOverlay(overlay, local, scheduler) {
    setStyle2();
    overlay.draftsCanvasOverlay.setMap(overlay.map);
    overlay.map.addListener("idle", () => notifyMapRangeChanged(overlay));
    notifyMapRangeChanged(overlay);
    const { userId, apiRoot } = local.getConfig();
    if (userId && apiRoot) {
      const { routes } = await getDrafts(
        {
          "user-id": userId
        },
        { rootUrl: apiRoot }
      );
      const drafts = routes.map((route) => ({
        ...route,
        coordinates: parseCoordinates(route.coordinates),
        id: route.routeId,
        name: route.routeName
      }));
      await overlay.addDrafts(drafts, scheduler);
    }
  }

  // inline-worker:__inline-worker
  function inlineWorker(scriptText) {
    let blob = new Blob([scriptText], { type: "text/javascript" });
    let url2 = URL.createObjectURL(blob);
    let worker = new Worker(url2);
    URL.revokeObjectURL(url2);
    return worker;
  }

  // source/poi-records.worker.ts?worker
  function Worker2() {
    return inlineWorker('var ou=Object.defineProperty,Td=Object.defineProperties;var wd=Object.getOwnPropertyDescriptors;var Lt=Object.getOwnPropertySymbols;var iu=Object.prototype.hasOwnProperty,au=Object.prototype.propertyIsEnumerable;var dn=(e,r)=>(r=Symbol[e])?r:Symbol.for("Symbol."+e),Pd=e=>{throw TypeError(e)};var nu=(e,r,n)=>r in e?ou(e,r,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[r]=n,f=(e,r)=>{for(var n in r||(r={}))iu.call(r,n)&&nu(e,n,r[n]);if(Lt)for(var n of Lt(r))au.call(r,n)&&nu(e,n,r[n]);return e},I=(e,r)=>Td(e,wd(r));var cu=(e,r)=>{var n={};for(var o in e)iu.call(e,o)&&r.indexOf(o)<0&&(n[o]=e[o]);if(e!=null&&Lt)for(var o of Lt(e))r.indexOf(o)<0&&au.call(e,o)&&(n[o]=e[o]);return n};var ve=(e,r)=>{for(var n in r)ou(e,n,{get:r[n],enumerable:!0})};var Dd=function(e,r){this[0]=e,this[1]=r};var ue=e=>{var r=e[dn("asyncIterator")],n=!1,o,t={};return r==null?(r=e[dn("iterator")](),o=a=>t[a]=c=>r[a](c)):(r=r.call(e),o=a=>t[a]=c=>{if(n){if(n=!1,a==="throw")throw c;return c}return n=!0,{done:!1,value:new Dd(new Promise(m=>{var s=r[a](c);s instanceof Object||Pd("Object expected"),m(s)}),1)}}),t[dn("iterator")]=()=>t,o("next"),"throw"in r?o("throw"):t.throw=a=>{throw a},"return"in r&&o("return"),t};var lu=Symbol("Comlink.proxy"),jd=Symbol("Comlink.endpoint"),Od=Symbol("Comlink.releaseProxy"),mn=Symbol("Comlink.finalizer"),Rt=Symbol("Comlink.thrown"),su=e=>typeof e=="object"&&e!==null||typeof e=="function",Ud={canHandle:e=>su(e)&&e[lu],serialize(e){let{port1:r,port2:n}=new MessageChannel;return Vt(e,r),[n,[n]]},deserialize(e){return e.start(),fn(e)}},Nd={canHandle:e=>su(e)&&Rt in e,serialize({value:e}){let r;return e instanceof Error?r={isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:r={isError:!1,value:e},[r,[]]},deserialize(e){throw e.isError?Object.assign(new Error(e.value.message),e.value):e.value}},du=new Map([["proxy",Ud],["throw",Nd]]);function Ed(e,r){for(let n of e)if(r===n||n==="*"||n instanceof RegExp&&n.test(r))return!0;return!1}function Vt(e,r=globalThis,n=["*"]){r.addEventListener("message",function o(t){if(!t||!t.data)return;if(!Ed(n,t.origin)){console.warn(`Invalid origin \'${t.origin}\' for comlink proxy`);return}let{id:a,type:c,path:m}=Object.assign({path:[]},t.data),s=(t.data.argumentList||[]).map(Te),u;try{let d=m.slice(0,-1).reduce((l,p)=>l[p],e),i=m.reduce((l,p)=>l[p],e);switch(c){case"GET":u=i;break;case"SET":d[m.slice(-1)[0]]=Te(t.data.value),u=!0;break;case"APPLY":u=i.apply(d,s);break;case"CONSTRUCT":{let l=new i(...s);u=Md(l)}break;case"ENDPOINT":{let{port1:l,port2:p}=new MessageChannel;Vt(e,p),u=Ad(l,[l])}break;case"RELEASE":u=void 0;break;default:return}}catch(d){u={value:d,[Rt]:0}}Promise.resolve(u).catch(d=>({value:d,[Rt]:0})).then(d=>{let[i,l]=Ft(d);r.postMessage(Object.assign(Object.assign({},i),{id:a}),l),c==="RELEASE"&&(r.removeEventListener("message",o),mu(r),mn in e&&typeof e[mn]=="function"&&e[mn]())}).catch(d=>{let[i,l]=Ft({value:new TypeError("Unserializable return value"),[Rt]:0});r.postMessage(Object.assign(Object.assign({},i),{id:a}),l)})}),r.start&&r.start()}function Zd(e){return e.constructor.name==="MessagePort"}function mu(e){Zd(e)&&e.close()}function fn(e,r){let n=new Map;return e.addEventListener("message",function(t){let{data:a}=t;if(!a||!a.id)return;let c=n.get(a.id);if(c)try{c(a)}finally{n.delete(a.id)}}),pn(e,n,[],r)}function Ct(e){if(e)throw new Error("Proxy has been released and is not useable")}function pu(e){return Ze(e,new Map,{type:"RELEASE"}).then(()=>{mu(e)})}var At=new WeakMap,Mt="FinalizationRegistry"in globalThis&&new FinalizationRegistry(e=>{let r=(At.get(e)||0)-1;At.set(e,r),r===0&&pu(e)});function Ld(e,r){let n=(At.get(r)||0)+1;At.set(r,n),Mt&&Mt.register(e,r,e)}function Cd(e){Mt&&Mt.unregister(e)}function pn(e,r,n=[],o=function(){}){let t=!1,a=new Proxy(o,{get(c,m){if(Ct(t),m===Od)return()=>{Cd(a),pu(e),r.clear(),t=!0};if(m==="then"){if(n.length===0)return{then:()=>a};let s=Ze(e,r,{type:"GET",path:n.map(u=>u.toString())}).then(Te);return s.then.bind(s)}return pn(e,r,[...n,m])},set(c,m,s){Ct(t);let[u,d]=Ft(s);return Ze(e,r,{type:"SET",path:[...n,m].map(i=>i.toString()),value:u},d).then(Te)},apply(c,m,s){Ct(t);let u=n[n.length-1];if(u===jd)return Ze(e,r,{type:"ENDPOINT"}).then(Te);if(u==="bind")return pn(e,r,n.slice(0,-1));let[d,i]=uu(s);return Ze(e,r,{type:"APPLY",path:n.map(l=>l.toString()),argumentList:d},i).then(Te)},construct(c,m){Ct(t);let[s,u]=uu(m);return Ze(e,r,{type:"CONSTRUCT",path:n.map(d=>d.toString()),argumentList:s},u).then(Te)}});return Ld(a,e),a}function Rd(e){return Array.prototype.concat.apply([],e)}function uu(e){let r=e.map(Ft);return[r.map(n=>n[0]),Rd(r.map(n=>n[1]))]}var fu=new WeakMap;function Ad(e,r){return fu.set(e,r),e}function Md(e){return Object.assign(e,{[lu]:!0})}function Ft(e){for(let[r,n]of du)if(n.canHandle(e)){let[o,t]=n.serialize(e);return[{type:"HANDLER",name:r,value:o},t]}return[{type:"RAW",value:e},fu.get(e)||[]]}function Te(e){switch(e.type){case"HANDLER":return du.get(e.name).deserialize(e.value);case"RAW":return e.value}}function Ze(e,r,n,o){return new Promise(t=>{let a=Fd();r.set(a,t),e.start&&e.start(),e.postMessage(Object.assign({id:a},n),o)})}function Fd(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}function gu(e,r,{batchSize:n=10}={}){let o=[],t=!1,a=!1;function c(d){o.push(d),m()}function m(){a||(a=!0,queueMicrotask(()=>{a=!1,s().catch(r)}))}async function s(){if(t||o.length===0)return;t=!0;let d=o.splice(0,n);try{await e(d)}finally{t=!1,o.length&&m()}}function u(){o.length=0}return{push:c,close:u}}function vu(){return typeof window=="undefined"&&typeof self!="undefined"}function Kd(e,r){let n=performance.now(),o=null;return e.addEventListener("abort",()=>{o!=null&&(cancelAnimationFrame(o),o=null)},{once:!0}),{get isYieldRequested(){var a,c;return(c=(a=navigator.scheduling)==null?void 0:a.isInputPending)!=null&&c.call(a)?!0:performance.now()-n>=r},yield(){return this.isYieldRequested?new Promise(t=>{o=requestAnimationFrame(()=>{n=performance.now(),t()})}):null}}}function Jd(){return{isYieldRequested:!1,yield(){return null}}}function hu(e,r=10){return vu()?Jd():Kd(e,r)}var pe={};ve(pe,{$ZodAny:()=>ei,$ZodArray:()=>ii,$ZodAsyncError:()=>ne,$ZodBase64:()=>Ko,$ZodBase64URL:()=>Jo,$ZodBigInt:()=>gr,$ZodBigIntFormat:()=>Xo,$ZodBoolean:()=>dt,$ZodCIDRv4:()=>Mo,$ZodCIDRv6:()=>Fo,$ZodCUID:()=>Po,$ZodCUID2:()=>Do,$ZodCatch:()=>Si,$ZodCheck:()=>L,$ZodCheckBigIntFormat:()=>oo,$ZodCheckEndsWith:()=>ho,$ZodCheckGreaterThan:()=>ur,$ZodCheckIncludes:()=>go,$ZodCheckLengthEquals:()=>so,$ZodCheckLessThan:()=>cr,$ZodCheckLowerCase:()=>po,$ZodCheckMaxLength:()=>uo,$ZodCheckMaxSize:()=>io,$ZodCheckMimeType:()=>$o,$ZodCheckMinLength:()=>lo,$ZodCheckMinSize:()=>ao,$ZodCheckMultipleOf:()=>ro,$ZodCheckNumberFormat:()=>no,$ZodCheckOverwrite:()=>xo,$ZodCheckProperty:()=>yo,$ZodCheckRegex:()=>mo,$ZodCheckSizeEquals:()=>co,$ZodCheckStartsWith:()=>vo,$ZodCheckStringFormat:()=>Ke,$ZodCheckUpperCase:()=>fo,$ZodCodec:()=>pt,$ZodCustom:()=>ji,$ZodCustomStringFormat:()=>Wo,$ZodDate:()=>oi,$ZodDefault:()=>$i,$ZodDiscriminatedUnion:()=>ui,$ZodE164:()=>Bo,$ZodEmail:()=>Io,$ZodEmoji:()=>To,$ZodEncodeError:()=>he,$ZodEnum:()=>pi,$ZodError:()=>ct,$ZodExactOptional:()=>hi,$ZodFile:()=>gi,$ZodFunction:()=>wi,$ZodGUID:()=>So,$ZodIPv4:()=>Co,$ZodIPv6:()=>Ro,$ZodISODate:()=>Eo,$ZodISODateTime:()=>No,$ZodISODuration:()=>Lo,$ZodISOTime:()=>Zo,$ZodIntersection:()=>li,$ZodJWT:()=>Go,$ZodKSUID:()=>Uo,$ZodLazy:()=>Di,$ZodLiteral:()=>fi,$ZodMAC:()=>Ao,$ZodMap:()=>di,$ZodNaN:()=>ki,$ZodNanoID:()=>wo,$ZodNever:()=>ri,$ZodNonOptional:()=>bi,$ZodNull:()=>Ho,$ZodNullable:()=>yi,$ZodNumber:()=>fr,$ZodNumberFormat:()=>qo,$ZodObject:()=>Bu,$ZodObjectJIT:()=>ai,$ZodOptional:()=>hr,$ZodPipe:()=>Ii,$ZodPrefault:()=>xi,$ZodPromise:()=>Pi,$ZodReadonly:()=>zi,$ZodRealError:()=>G,$ZodRecord:()=>si,$ZodRegistry:()=>br,$ZodSet:()=>mi,$ZodString:()=>De,$ZodStringFormat:()=>Z,$ZodSuccess:()=>_i,$ZodSymbol:()=>Qo,$ZodTemplateLiteral:()=>Ti,$ZodTransform:()=>vi,$ZodTuple:()=>vr,$ZodType:()=>P,$ZodULID:()=>jo,$ZodURL:()=>zo,$ZodUUID:()=>ko,$ZodUndefined:()=>Yo,$ZodUnion:()=>mt,$ZodUnknown:()=>ti,$ZodVoid:()=>ni,$ZodXID:()=>Oo,$ZodXor:()=>ci,$brand:()=>gn,$constructor:()=>g,$input:()=>Bl,$output:()=>Jl,Doc:()=>st,JSONSchema:()=>cc,JSONSchemaGenerator:()=>Jr,NEVER:()=>Kt,TimePrecision:()=>Gl,_any:()=>ra,_array:()=>fa,_base64:()=>Cr,_base64url:()=>Rr,_bigint:()=>qi,_boolean:()=>Gi,_catch:()=>mf,_check:()=>Wl,_cidrv4:()=>Zr,_cidrv6:()=>Lr,_coercedBigint:()=>Xi,_coercedBoolean:()=>Wi,_coercedDate:()=>ca,_coercedNumber:()=>Mi,_coercedString:()=>Ni,_cuid:()=>Pr,_cuid2:()=>Dr,_custom:()=>va,_date:()=>aa,_decode:()=>Yt,_decodeAsync:()=>er,_default:()=>lf,_discriminatedUnion:()=>Xp,_e164:()=>Ar,_email:()=>_r,_emoji:()=>Tr,_encode:()=>Qt,_encodeAsync:()=>Ht,_endsWith:()=>_t,_enum:()=>rf,_file:()=>ga,_float32:()=>Vi,_float64:()=>Ki,_gt:()=>de,_gte:()=>W,_guid:()=>gt,_includes:()=>xt,_int:()=>Fi,_int32:()=>Ji,_int64:()=>Qi,_intersection:()=>Qp,_ipv4:()=>Nr,_ipv6:()=>Er,_isoDate:()=>Li,_isoDateTime:()=>Zi,_isoDuration:()=>Ri,_isoTime:()=>Ci,_jwt:()=>Mr,_ksuid:()=>Ur,_lazy:()=>vf,_length:()=>qe,_literal:()=>of,_lowercase:()=>yt,_lt:()=>se,_lte:()=>te,_mac:()=>Ei,_map:()=>ef,_max:()=>te,_maxLength:()=>We,_maxSize:()=>Oe,_mime:()=>St,_min:()=>W,_minLength:()=>_e,_minSize:()=>me,_multipleOf:()=>je,_nan:()=>ua,_nanoid:()=>wr,_nativeEnum:()=>nf,_negative:()=>sa,_never:()=>oa,_nonnegative:()=>ma,_nonoptional:()=>sf,_nonpositive:()=>da,_normalize:()=>kt,_null:()=>ta,_nullable:()=>uf,_number:()=>Ai,_optional:()=>cf,_overwrite:()=>ie,_parse:()=>Ae,_parseAsync:()=>Me,_pipe:()=>pf,_positive:()=>la,_promise:()=>hf,_property:()=>pa,_readonly:()=>ff,_record:()=>Hp,_refine:()=>ha,_regex:()=>ht,_safeDecode:()=>rr,_safeDecodeAsync:()=>or,_safeEncode:()=>tr,_safeEncodeAsync:()=>nr,_safeParse:()=>Fe,_safeParseAsync:()=>Ve,_set:()=>tf,_size:()=>Ge,_slugify:()=>wt,_startsWith:()=>bt,_string:()=>Ui,_stringFormat:()=>Xe,_stringbool:()=>ba,_success:()=>df,_superRefine:()=>ya,_symbol:()=>Hi,_templateLiteral:()=>gf,_toLowerCase:()=>zt,_toUpperCase:()=>Tt,_transform:()=>af,_trim:()=>It,_tuple:()=>Yp,_uint32:()=>Bi,_uint64:()=>Yi,_ulid:()=>jr,_undefined:()=>ea,_union:()=>Wp,_unknown:()=>na,_uppercase:()=>$t,_url:()=>vt,_uuid:()=>Sr,_uuidv4:()=>kr,_uuidv6:()=>Ir,_uuidv7:()=>zr,_void:()=>ia,_xid:()=>Or,_xor:()=>qp,clone:()=>J,config:()=>M,createStandardJSONSchemaMethod:()=>Qe,createToJSONSchemaMethod:()=>_a,decode:()=>$m,decodeAsync:()=>bm,describe:()=>$a,encode:()=>ym,encodeAsync:()=>xm,extractDefs:()=>ke,finalize:()=>Ie,flattenError:()=>Gt,formatError:()=>Wt,globalConfig:()=>et,globalRegistry:()=>F,initializeContext:()=>Se,isValidBase64:()=>Vo,isValidBase64URL:()=>Fu,isValidJWT:()=>Vu,locales:()=>Be,meta:()=>xa,parse:()=>qt,parseAsync:()=>Xt,prettifyError:()=>ku,process:()=>E,regexes:()=>ee,registry:()=>Oi,safeDecode:()=>Sm,safeDecodeAsync:()=>Im,safeEncode:()=>_m,safeEncodeAsync:()=>km,safeParse:()=>zn,safeParseAsync:()=>Tn,toDotPath:()=>Su,toJSONSchema:()=>ac,treeifyError:()=>_u,util:()=>b,version:()=>bo});var Kt=Object.freeze({status:"aborted"});function g(e,r,n){var m;function o(s,u){if(s._zod||Object.defineProperty(s,"_zod",{value:{def:u,constr:c,traits:new Set},enumerable:!1}),s._zod.traits.has(e))return;s._zod.traits.add(e),r(s,u);let d=c.prototype,i=Object.keys(d);for(let l=0;l<i.length;l++){let p=i[l];p in s||(s[p]=d[p].bind(s))}}let t=(m=n==null?void 0:n.Parent)!=null?m:Object;class a extends t{}Object.defineProperty(a,"name",{value:e});function c(s){var i;var u;let d=n!=null&&n.Parent?new a:this;o(d,s),(i=(u=d._zod).deferred)!=null||(u.deferred=[]);for(let l of d._zod.deferred)l();return d}return Object.defineProperty(c,"init",{value:o}),Object.defineProperty(c,Symbol.hasInstance,{value:s=>{var u,d;return n!=null&&n.Parent&&s instanceof n.Parent?!0:(d=(u=s==null?void 0:s._zod)==null?void 0:u.traits)==null?void 0:d.has(e)}}),Object.defineProperty(c,"name",{value:e}),c}var gn=Symbol("zod_brand"),ne=class extends Error{constructor(){super("Encountered Promise during synchronous parse. Use .parseAsync() instead.")}},he=class extends Error{constructor(r){super(`Encountered unidirectional transform during encode: ${r}`),this.name="ZodEncodeError"}},et={};function M(e){return e&&Object.assign(et,e),et}var b={};ve(b,{BIGINT_FORMAT_RANGES:()=>In,Class:()=>hn,NUMBER_FORMAT_RANGES:()=>kn,aborted:()=>be,allowsEval:()=>xn,assert:()=>Xd,assertEqual:()=>Bd,assertIs:()=>Wd,assertNever:()=>qd,assertNotEqual:()=>Gd,assignProp:()=>$e,base64ToUint8Array:()=>$u,base64urlToUint8Array:()=>pm,cached:()=>Ce,captureStackTrace:()=>Bt,cleanEnum:()=>mm,cleanRegex:()=>nt,clone:()=>J,cloneDef:()=>Yd,createTransparentProxy:()=>om,defineLazy:()=>O,esc:()=>Jt,escapeRegex:()=>H,extend:()=>cm,finalizeIssue:()=>B,floatSafeRemainder:()=>yn,getElementAtPath:()=>Hd,getEnumValues:()=>rt,getLengthableOrigin:()=>at,getParsedType:()=>nm,getSizableOrigin:()=>it,hexToUint8Array:()=>gm,isObject:()=>we,isPlainObject:()=>xe,issue:()=>Re,joinValues:()=>h,jsonStringifyReplacer:()=>Le,merge:()=>lm,mergeDefs:()=>le,normalizeParams:()=>_,nullish:()=>ye,numKeys:()=>rm,objectClone:()=>Qd,omit:()=>am,optionalKeys:()=>Sn,parsedType:()=>x,partial:()=>sm,pick:()=>im,prefixIssues:()=>q,primitiveTypes:()=>_n,promiseAllObject:()=>em,propertyKeyTypes:()=>ot,randomString:()=>tm,required:()=>dm,safeExtend:()=>um,shallowClone:()=>bn,slugify:()=>$n,stringifyPrimitive:()=>$,uint8ArrayToBase64:()=>xu,uint8ArrayToBase64url:()=>fm,uint8ArrayToHex:()=>vm,unwrapMessage:()=>tt});function Bd(e){return e}function Gd(e){return e}function Wd(e){}function qd(e){throw new Error("Unexpected value in exhaustive check")}function Xd(e){}function rt(e){let r=Object.values(e).filter(o=>typeof o=="number");return Object.entries(e).filter(([o,t])=>r.indexOf(+o)===-1).map(([o,t])=>t)}function h(e,r="|"){return e.map(n=>$(n)).join(r)}function Le(e,r){return typeof r=="bigint"?r.toString():r}function Ce(e){return{get value(){{let n=e();return Object.defineProperty(this,"value",{value:n}),n}throw new Error("cached value already set")}}}function ye(e){return e==null}function nt(e){let r=e.startsWith("^")?1:0,n=e.endsWith("$")?e.length-1:e.length;return e.slice(r,n)}function yn(e,r){let n=(e.toString().split(".")[1]||"").length,o=r.toString(),t=(o.split(".")[1]||"").length;if(t===0&&/\\d?e-\\d?/.test(o)){let s=o.match(/\\d?e-(\\d?)/);s!=null&&s[1]&&(t=Number.parseInt(s[1]))}let a=n>t?n:t,c=Number.parseInt(e.toFixed(a).replace(".","")),m=Number.parseInt(r.toFixed(a).replace(".",""));return c%m/10**a}var yu=Symbol("evaluating");function O(e,r,n){let o;Object.defineProperty(e,r,{get(){if(o!==yu)return o===void 0&&(o=yu,o=n()),o},set(t){Object.defineProperty(e,r,{value:t})},configurable:!0})}function Qd(e){return Object.create(Object.getPrototypeOf(e),Object.getOwnPropertyDescriptors(e))}function $e(e,r,n){Object.defineProperty(e,r,{value:n,writable:!0,enumerable:!0,configurable:!0})}function le(...e){let r={};for(let n of e){let o=Object.getOwnPropertyDescriptors(n);Object.assign(r,o)}return Object.defineProperties({},r)}function Yd(e){return le(e._zod.def)}function Hd(e,r){return r?r.reduce((n,o)=>n==null?void 0:n[o],e):e}function em(e){let r=Object.keys(e),n=r.map(o=>e[o]);return Promise.all(n).then(o=>{let t={};for(let a=0;a<r.length;a++)t[r[a]]=o[a];return t})}function tm(e=10){let r="abcdefghijklmnopqrstuvwxyz",n="";for(let o=0;o<e;o++)n+=r[Math.floor(Math.random()*r.length)];return n}function Jt(e){return JSON.stringify(e)}function $n(e){return e.toLowerCase().trim().replace(/[^\\w\\s-]/g,"").replace(/[\\s_-]+/g,"-").replace(/^-+|-+$/g,"")}var Bt="captureStackTrace"in Error?Error.captureStackTrace:(...e)=>{};function we(e){return typeof e=="object"&&e!==null&&!Array.isArray(e)}var xn=Ce(()=>{var e;if(typeof navigator!="undefined"&&((e=navigator==null?void 0:navigator.userAgent)!=null&&e.includes("Cloudflare")))return!1;try{let r=Function;return new r(""),!0}catch(r){return!1}});function xe(e){if(we(e)===!1)return!1;let r=e.constructor;if(r===void 0||typeof r!="function")return!0;let n=r.prototype;return!(we(n)===!1||Object.prototype.hasOwnProperty.call(n,"isPrototypeOf")===!1)}function bn(e){return xe(e)?f({},e):Array.isArray(e)?[...e]:e}function rm(e){let r=0;for(let n in e)Object.prototype.hasOwnProperty.call(e,n)&&r++;return r}var nm=e=>{let r=typeof e;switch(r){case"undefined":return"undefined";case"string":return"string";case"number":return Number.isNaN(e)?"nan":"number";case"boolean":return"boolean";case"function":return"function";case"bigint":return"bigint";case"symbol":return"symbol";case"object":return Array.isArray(e)?"array":e===null?"null":e.then&&typeof e.then=="function"&&e.catch&&typeof e.catch=="function"?"promise":typeof Map!="undefined"&&e instanceof Map?"map":typeof Set!="undefined"&&e instanceof Set?"set":typeof Date!="undefined"&&e instanceof Date?"date":typeof File!="undefined"&&e instanceof File?"file":"object";default:throw new Error(`Unknown data type: ${r}`)}},ot=new Set(["string","number","symbol"]),_n=new Set(["string","number","bigint","boolean","symbol","undefined"]);function H(e){return e.replace(/[.*+?^${}()|[\\]\\\\]/g,"\\\\$&")}function J(e,r,n){let o=new e._zod.constr(r!=null?r:e._zod.def);return(!r||n!=null&&n.parent)&&(o._zod.parent=e),o}function _(e){let r=e;if(!r)return{};if(typeof r=="string")return{error:()=>r};if((r==null?void 0:r.message)!==void 0){if((r==null?void 0:r.error)!==void 0)throw new Error("Cannot specify both `message` and `error` params");r.error=r.message}return delete r.message,typeof r.error=="string"?I(f({},r),{error:()=>r.error}):r}function om(e){let r;return new Proxy({},{get(n,o,t){return r!=null||(r=e()),Reflect.get(r,o,t)},set(n,o,t,a){return r!=null||(r=e()),Reflect.set(r,o,t,a)},has(n,o){return r!=null||(r=e()),Reflect.has(r,o)},deleteProperty(n,o){return r!=null||(r=e()),Reflect.deleteProperty(r,o)},ownKeys(n){return r!=null||(r=e()),Reflect.ownKeys(r)},getOwnPropertyDescriptor(n,o){return r!=null||(r=e()),Reflect.getOwnPropertyDescriptor(r,o)},defineProperty(n,o,t){return r!=null||(r=e()),Reflect.defineProperty(r,o,t)}})}function $(e){return typeof e=="bigint"?e.toString()+"n":typeof e=="string"?`"${e}"`:`${e}`}function Sn(e){return Object.keys(e).filter(r=>e[r]._zod.optin==="optional"&&e[r]._zod.optout==="optional")}var kn={safeint:[Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER],int32:[-2147483648,2147483647],uint32:[0,4294967295],float32:[-34028234663852886e22,34028234663852886e22],float64:[-Number.MAX_VALUE,Number.MAX_VALUE]},In={int64:[BigInt("-9223372036854775808"),BigInt("9223372036854775807")],uint64:[BigInt(0),BigInt("18446744073709551615")]};function im(e,r){let n=e._zod.def,o=n.checks;if(o&&o.length>0)throw new Error(".pick() cannot be used on object schemas containing refinements");let a=le(e._zod.def,{get shape(){let c={};for(let m in r){if(!(m in n.shape))throw new Error(`Unrecognized key: "${m}"`);r[m]&&(c[m]=n.shape[m])}return $e(this,"shape",c),c},checks:[]});return J(e,a)}function am(e,r){let n=e._zod.def,o=n.checks;if(o&&o.length>0)throw new Error(".omit() cannot be used on object schemas containing refinements");let a=le(e._zod.def,{get shape(){let c=f({},e._zod.def.shape);for(let m in r){if(!(m in n.shape))throw new Error(`Unrecognized key: "${m}"`);r[m]&&delete c[m]}return $e(this,"shape",c),c},checks:[]});return J(e,a)}function cm(e,r){if(!xe(r))throw new Error("Invalid input to extend: expected a plain object");let n=e._zod.def.checks;if(n&&n.length>0){let a=e._zod.def.shape;for(let c in r)if(Object.getOwnPropertyDescriptor(a,c)!==void 0)throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.")}let t=le(e._zod.def,{get shape(){let a=f(f({},e._zod.def.shape),r);return $e(this,"shape",a),a}});return J(e,t)}function um(e,r){if(!xe(r))throw new Error("Invalid input to safeExtend: expected a plain object");let n=le(e._zod.def,{get shape(){let o=f(f({},e._zod.def.shape),r);return $e(this,"shape",o),o}});return J(e,n)}function lm(e,r){let n=le(e._zod.def,{get shape(){let o=f(f({},e._zod.def.shape),r._zod.def.shape);return $e(this,"shape",o),o},get catchall(){return r._zod.def.catchall},checks:[]});return J(e,n)}function sm(e,r,n){let t=r._zod.def.checks;if(t&&t.length>0)throw new Error(".partial() cannot be used on object schemas containing refinements");let c=le(r._zod.def,{get shape(){let m=r._zod.def.shape,s=f({},m);if(n)for(let u in n){if(!(u in m))throw new Error(`Unrecognized key: "${u}"`);n[u]&&(s[u]=e?new e({type:"optional",innerType:m[u]}):m[u])}else for(let u in m)s[u]=e?new e({type:"optional",innerType:m[u]}):m[u];return $e(this,"shape",s),s},checks:[]});return J(r,c)}function dm(e,r,n){let o=le(r._zod.def,{get shape(){let t=r._zod.def.shape,a=f({},t);if(n)for(let c in n){if(!(c in a))throw new Error(`Unrecognized key: "${c}"`);n[c]&&(a[c]=new e({type:"nonoptional",innerType:t[c]}))}else for(let c in t)a[c]=new e({type:"nonoptional",innerType:t[c]});return $e(this,"shape",a),a}});return J(r,o)}function be(e,r=0){var n;if(e.aborted===!0)return!0;for(let o=r;o<e.issues.length;o++)if(((n=e.issues[o])==null?void 0:n.continue)!==!0)return!0;return!1}function q(e,r){return r.map(n=>{var t;var o;return(t=(o=n).path)!=null||(o.path=[]),n.path.unshift(e),n})}function tt(e){return typeof e=="string"?e:e==null?void 0:e.message}function B(e,r,n){var t,a,c,m,s,u,d,i,l,p,v;let o=I(f({},e),{path:(t=e.path)!=null?t:[]});if(!e.message){let y=(v=(p=(i=(u=tt((m=(c=(a=e.inst)==null?void 0:a._zod.def)==null?void 0:c.error)==null?void 0:m.call(c,e)))!=null?u:tt((s=r==null?void 0:r.error)==null?void 0:s.call(r,e)))!=null?i:tt((d=n.customError)==null?void 0:d.call(n,e)))!=null?p:tt((l=n.localeError)==null?void 0:l.call(n,e)))!=null?v:"Invalid input";o.message=y}return delete o.inst,delete o.continue,r!=null&&r.reportInput||delete o.input,o}function it(e){return e instanceof Set?"set":e instanceof Map?"map":e instanceof File?"file":"unknown"}function at(e){return Array.isArray(e)?"array":typeof e=="string"?"string":"unknown"}function x(e){let r=typeof e;switch(r){case"number":return Number.isNaN(e)?"nan":"number";case"object":{if(e===null)return"null";if(Array.isArray(e))return"array";let n=e;if(n&&Object.getPrototypeOf(n)!==Object.prototype&&"constructor"in n&&n.constructor)return n.constructor.name}}return r}function Re(...e){let[r,n,o]=e;return typeof r=="string"?{message:r,code:"custom",input:n,inst:o}:f({},r)}function mm(e){return Object.entries(e).filter(([r,n])=>Number.isNaN(Number.parseInt(r,10))).map(r=>r[1])}function $u(e){let r=atob(e),n=new Uint8Array(r.length);for(let o=0;o<r.length;o++)n[o]=r.charCodeAt(o);return n}function xu(e){let r="";for(let n=0;n<e.length;n++)r+=String.fromCharCode(e[n]);return btoa(r)}function pm(e){let r=e.replace(/-/g,"+").replace(/_/g,"/"),n="=".repeat((4-r.length%4)%4);return $u(r+n)}function fm(e){return xu(e).replace(/\\+/g,"-").replace(/\\//g,"_").replace(/=/g,"")}function gm(e){let r=e.replace(/^0x/,"");if(r.length%2!==0)throw new Error("Invalid hex string length");let n=new Uint8Array(r.length/2);for(let o=0;o<r.length;o+=2)n[o/2]=Number.parseInt(r.slice(o,o+2),16);return n}function vm(e){return Array.from(e).map(r=>r.toString(16).padStart(2,"0")).join("")}var hn=class{constructor(...r){}};var bu=(e,r)=>{e.name="$ZodError",Object.defineProperty(e,"_zod",{value:e._zod,enumerable:!1}),Object.defineProperty(e,"issues",{value:r,enumerable:!1}),e.message=JSON.stringify(r,Le,2),Object.defineProperty(e,"toString",{value:()=>e.message,enumerable:!1})},ct=g("$ZodError",bu),G=g("$ZodError",bu,{Parent:Error});function Gt(e,r=n=>n.message){let n={},o=[];for(let t of e.issues)t.path.length>0?(n[t.path[0]]=n[t.path[0]]||[],n[t.path[0]].push(r(t))):o.push(r(t));return{formErrors:o,fieldErrors:n}}function Wt(e,r=n=>n.message){let n={_errors:[]},o=t=>{for(let a of t.issues)if(a.code==="invalid_union"&&a.errors.length)a.errors.map(c=>o({issues:c}));else if(a.code==="invalid_key")o({issues:a.issues});else if(a.code==="invalid_element")o({issues:a.issues});else if(a.path.length===0)n._errors.push(r(a));else{let c=n,m=0;for(;m<a.path.length;){let s=a.path[m];m===a.path.length-1?(c[s]=c[s]||{_errors:[]},c[s]._errors.push(r(a))):c[s]=c[s]||{_errors:[]},c=c[s],m++}}};return o(e),n}function _u(e,r=n=>n.message){let n={errors:[]},o=(t,a=[])=>{var s,u,d,i;var c,m;for(let l of t.issues)if(l.code==="invalid_union"&&l.errors.length)l.errors.map(p=>o({issues:p},l.path));else if(l.code==="invalid_key")o({issues:l.issues},l.path);else if(l.code==="invalid_element")o({issues:l.issues},l.path);else{let p=[...a,...l.path];if(p.length===0){n.errors.push(r(l));continue}let v=n,y=0;for(;y<p.length;){let S=p[y],w=y===p.length-1;typeof S=="string"?((s=v.properties)!=null||(v.properties={}),(u=(c=v.properties)[S])!=null||(c[S]={errors:[]}),v=v.properties[S]):((d=v.items)!=null||(v.items=[]),(i=(m=v.items)[S])!=null||(m[S]={errors:[]}),v=v.items[S]),w&&v.errors.push(r(l)),y++}}};return o(e),n}function Su(e){let r=[],n=e.map(o=>typeof o=="object"?o.key:o);for(let o of n)typeof o=="number"?r.push(`[${o}]`):typeof o=="symbol"?r.push(`[${JSON.stringify(String(o))}]`):/[^\\w$]/.test(o)?r.push(`[${JSON.stringify(o)}]`):(r.length&&r.push("."),r.push(o));return r.join("")}function ku(e){var o;let r=[],n=[...e.issues].sort((t,a)=>{var c,m;return((c=t.path)!=null?c:[]).length-((m=a.path)!=null?m:[]).length});for(let t of n)r.push(`\\u2716 ${t.message}`),(o=t.path)!=null&&o.length&&r.push(`  \\u2192 at ${Su(t.path)}`);return r.join(`\n`)}var Ae=e=>(r,n,o,t)=>{var m;let a=o?Object.assign(o,{async:!1}):{async:!1},c=r._zod.run({value:n,issues:[]},a);if(c instanceof Promise)throw new ne;if(c.issues.length){let s=new((m=t==null?void 0:t.Err)!=null?m:e)(c.issues.map(u=>B(u,a,M())));throw Bt(s,t==null?void 0:t.callee),s}return c.value},qt=Ae(G),Me=e=>async(r,n,o,t)=>{var m;let a=o?Object.assign(o,{async:!0}):{async:!0},c=r._zod.run({value:n,issues:[]},a);if(c instanceof Promise&&(c=await c),c.issues.length){let s=new((m=t==null?void 0:t.Err)!=null?m:e)(c.issues.map(u=>B(u,a,M())));throw Bt(s,t==null?void 0:t.callee),s}return c.value},Xt=Me(G),Fe=e=>(r,n,o)=>{let t=o?I(f({},o),{async:!1}):{async:!1},a=r._zod.run({value:n,issues:[]},t);if(a instanceof Promise)throw new ne;return a.issues.length?{success:!1,error:new(e!=null?e:ct)(a.issues.map(c=>B(c,t,M())))}:{success:!0,data:a.value}},zn=Fe(G),Ve=e=>async(r,n,o)=>{let t=o?Object.assign(o,{async:!0}):{async:!0},a=r._zod.run({value:n,issues:[]},t);return a instanceof Promise&&(a=await a),a.issues.length?{success:!1,error:new e(a.issues.map(c=>B(c,t,M())))}:{success:!0,data:a.value}},Tn=Ve(G),Qt=e=>(r,n,o)=>{let t=o?Object.assign(o,{direction:"backward"}):{direction:"backward"};return Ae(e)(r,n,t)},ym=Qt(G),Yt=e=>(r,n,o)=>Ae(e)(r,n,o),$m=Yt(G),Ht=e=>async(r,n,o)=>{let t=o?Object.assign(o,{direction:"backward"}):{direction:"backward"};return Me(e)(r,n,t)},xm=Ht(G),er=e=>async(r,n,o)=>Me(e)(r,n,o),bm=er(G),tr=e=>(r,n,o)=>{let t=o?Object.assign(o,{direction:"backward"}):{direction:"backward"};return Fe(e)(r,n,t)},_m=tr(G),rr=e=>(r,n,o)=>Fe(e)(r,n,o),Sm=rr(G),nr=e=>async(r,n,o)=>{let t=o?Object.assign(o,{direction:"backward"}):{direction:"backward"};return Ve(e)(r,n,t)},km=nr(G),or=e=>async(r,n,o)=>Ve(e)(r,n,o),Im=or(G);var ee={};ve(ee,{base64:()=>Vn,base64url:()=>ir,bigint:()=>qn,boolean:()=>Qn,browserEmail:()=>Um,cidrv4:()=>Mn,cidrv6:()=>Fn,cuid:()=>wn,cuid2:()=>Pn,date:()=>Jn,datetime:()=>Gn,domain:()=>Zm,duration:()=>Nn,e164:()=>Kn,email:()=>Zn,emoji:()=>Ln,extendedDuration:()=>zm,guid:()=>En,hex:()=>Lm,hostname:()=>Em,html5Email:()=>Dm,idnEmail:()=>Om,integer:()=>Xn,ipv4:()=>Cn,ipv6:()=>Rn,ksuid:()=>On,lowercase:()=>eo,mac:()=>An,md5_base64:()=>Rm,md5_base64url:()=>Am,md5_hex:()=>Cm,nanoid:()=>Un,null:()=>Yn,number:()=>ar,rfc5322Email:()=>jm,sha1_base64:()=>Fm,sha1_base64url:()=>Vm,sha1_hex:()=>Mm,sha256_base64:()=>Jm,sha256_base64url:()=>Bm,sha256_hex:()=>Km,sha384_base64:()=>Wm,sha384_base64url:()=>qm,sha384_hex:()=>Gm,sha512_base64:()=>Qm,sha512_base64url:()=>Ym,sha512_hex:()=>Xm,string:()=>Wn,time:()=>Bn,ulid:()=>Dn,undefined:()=>Hn,unicodeEmail:()=>Iu,uppercase:()=>to,uuid:()=>Pe,uuid4:()=>Tm,uuid6:()=>wm,uuid7:()=>Pm,xid:()=>jn});var wn=/^[cC][^\\s-]{8,}$/,Pn=/^[0-9a-z]+$/,Dn=/^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/,jn=/^[0-9a-vA-V]{20}$/,On=/^[A-Za-z0-9]{27}$/,Un=/^[a-zA-Z0-9_-]{21}$/,Nn=/^P(?:(\\d+W)|(?!.*W)(?=\\d|T\\d)(\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+([.,]\\d+)?S)?)?)$/,zm=/^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/,En=/^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/,Pe=e=>e?new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`):/^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,Tm=Pe(4),wm=Pe(6),Pm=Pe(7),Zn=/^(?!\\.)(?!.*\\.\\.)([A-Za-z0-9_\'+\\-\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\-]*\\.)+[A-Za-z]{2,}$/,Dm=/^[a-zA-Z0-9.!#$%&\'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,jm=/^(([^<>()\\[\\]\\\\.,;:\\s@"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@"]+)*)|(".+"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/,Iu=/^[^\\s@"]{1,64}@[^\\s@]{1,255}$/u,Om=Iu,Um=/^[a-zA-Z0-9.!#$%&\'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,Nm="^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$";function Ln(){return new RegExp(Nm,"u")}var Cn=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,Rn=/^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/,An=e=>{let r=H(e!=null?e:":");return new RegExp(`^(?:[0-9A-F]{2}${r}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${r}){5}[0-9a-f]{2}$`)},Mn=/^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/([0-9]|[1-2][0-9]|3[0-2])$/,Fn=/^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,Vn=/^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/,ir=/^[A-Za-z0-9_-]*$/,Em=/^(?=.{1,253}\\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\\.?$/,Zm=/^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$/,Kn=/^\\+[1-9]\\d{6,14}$/,zu="(?:(?:\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\\\d|30)|(?:02)-(?:0[1-9]|1\\\\d|2[0-8])))",Jn=new RegExp(`^${zu}$`);function Tu(e){let r="(?:[01]\\\\d|2[0-3]):[0-5]\\\\d";return typeof e.precision=="number"?e.precision===-1?`${r}`:e.precision===0?`${r}:[0-5]\\\\d`:`${r}:[0-5]\\\\d\\\\.\\\\d{${e.precision}}`:`${r}(?::[0-5]\\\\d(?:\\\\.\\\\d+)?)?`}function Bn(e){return new RegExp(`^${Tu(e)}$`)}function Gn(e){let r=Tu({precision:e.precision}),n=["Z"];e.local&&n.push(""),e.offset&&n.push("([+-](?:[01]\\\\d|2[0-3]):[0-5]\\\\d)");let o=`${r}(?:${n.join("|")})`;return new RegExp(`^${zu}T(?:${o})$`)}var Wn=e=>{var n,o;let r=e?`[\\\\s\\\\S]{${(n=e==null?void 0:e.minimum)!=null?n:0},${(o=e==null?void 0:e.maximum)!=null?o:""}}`:"[\\\\s\\\\S]*";return new RegExp(`^${r}$`)},qn=/^-?\\d+n?$/,Xn=/^-?\\d+$/,ar=/^-?\\d+(?:\\.\\d+)?$/,Qn=/^(?:true|false)$/i,Yn=/^null$/i;var Hn=/^undefined$/i;var eo=/^[^A-Z]*$/,to=/^[^a-z]*$/,Lm=/^[0-9a-fA-F]*$/;function ut(e,r){return new RegExp(`^[A-Za-z0-9+/]{${e}}${r}$`)}function lt(e){return new RegExp(`^[A-Za-z0-9_-]{${e}}$`)}var Cm=/^[0-9a-fA-F]{32}$/,Rm=ut(22,"=="),Am=lt(22),Mm=/^[0-9a-fA-F]{40}$/,Fm=ut(27,"="),Vm=lt(27),Km=/^[0-9a-fA-F]{64}$/,Jm=ut(43,"="),Bm=lt(43),Gm=/^[0-9a-fA-F]{96}$/,Wm=ut(64,""),qm=lt(64),Xm=/^[0-9a-fA-F]{128}$/,Qm=ut(86,"=="),Ym=lt(86);var L=g("$ZodCheck",(e,r)=>{var o,t;var n;(o=e._zod)!=null||(e._zod={}),e._zod.def=r,(t=(n=e._zod).onattach)!=null||(n.onattach=[])}),Pu={number:"number",bigint:"bigint",object:"date"},cr=g("$ZodCheckLessThan",(e,r)=>{L.init(e,r);let n=Pu[typeof r.value];e._zod.onattach.push(o=>{var c;let t=o._zod.bag,a=(c=r.inclusive?t.maximum:t.exclusiveMaximum)!=null?c:Number.POSITIVE_INFINITY;r.value<a&&(r.inclusive?t.maximum=r.value:t.exclusiveMaximum=r.value)}),e._zod.check=o=>{(r.inclusive?o.value<=r.value:o.value<r.value)||o.issues.push({origin:n,code:"too_big",maximum:typeof r.value=="object"?r.value.getTime():r.value,input:o.value,inclusive:r.inclusive,inst:e,continue:!r.abort})}}),ur=g("$ZodCheckGreaterThan",(e,r)=>{L.init(e,r);let n=Pu[typeof r.value];e._zod.onattach.push(o=>{var c;let t=o._zod.bag,a=(c=r.inclusive?t.minimum:t.exclusiveMinimum)!=null?c:Number.NEGATIVE_INFINITY;r.value>a&&(r.inclusive?t.minimum=r.value:t.exclusiveMinimum=r.value)}),e._zod.check=o=>{(r.inclusive?o.value>=r.value:o.value>r.value)||o.issues.push({origin:n,code:"too_small",minimum:typeof r.value=="object"?r.value.getTime():r.value,input:o.value,inclusive:r.inclusive,inst:e,continue:!r.abort})}}),ro=g("$ZodCheckMultipleOf",(e,r)=>{L.init(e,r),e._zod.onattach.push(n=>{var t;var o;(t=(o=n._zod.bag).multipleOf)!=null||(o.multipleOf=r.value)}),e._zod.check=n=>{if(typeof n.value!=typeof r.value)throw new Error("Cannot mix number and bigint in multiple_of check.");(typeof n.value=="bigint"?n.value%r.value===BigInt(0):yn(n.value,r.value)===0)||n.issues.push({origin:typeof n.value,code:"not_multiple_of",divisor:r.value,input:n.value,inst:e,continue:!r.abort})}}),no=g("$ZodCheckNumberFormat",(e,r)=>{var c;L.init(e,r),r.format=r.format||"float64";let n=(c=r.format)==null?void 0:c.includes("int"),o=n?"int":"number",[t,a]=kn[r.format];e._zod.onattach.push(m=>{let s=m._zod.bag;s.format=r.format,s.minimum=t,s.maximum=a,n&&(s.pattern=Xn)}),e._zod.check=m=>{let s=m.value;if(n){if(!Number.isInteger(s)){m.issues.push({expected:o,format:r.format,code:"invalid_type",continue:!1,input:s,inst:e});return}if(!Number.isSafeInteger(s)){s>0?m.issues.push({input:s,code:"too_big",maximum:Number.MAX_SAFE_INTEGER,note:"Integers must be within the safe integer range.",inst:e,origin:o,inclusive:!0,continue:!r.abort}):m.issues.push({input:s,code:"too_small",minimum:Number.MIN_SAFE_INTEGER,note:"Integers must be within the safe integer range.",inst:e,origin:o,inclusive:!0,continue:!r.abort});return}}s<t&&m.issues.push({origin:"number",input:s,code:"too_small",minimum:t,inclusive:!0,inst:e,continue:!r.abort}),s>a&&m.issues.push({origin:"number",input:s,code:"too_big",maximum:a,inclusive:!0,inst:e,continue:!r.abort})}}),oo=g("$ZodCheckBigIntFormat",(e,r)=>{L.init(e,r);let[n,o]=In[r.format];e._zod.onattach.push(t=>{let a=t._zod.bag;a.format=r.format,a.minimum=n,a.maximum=o}),e._zod.check=t=>{let a=t.value;a<n&&t.issues.push({origin:"bigint",input:a,code:"too_small",minimum:n,inclusive:!0,inst:e,continue:!r.abort}),a>o&&t.issues.push({origin:"bigint",input:a,code:"too_big",maximum:o,inclusive:!0,inst:e,continue:!r.abort})}}),io=g("$ZodCheckMaxSize",(e,r)=>{var o;var n;L.init(e,r),(o=(n=e._zod.def).when)!=null||(n.when=t=>{let a=t.value;return!ye(a)&&a.size!==void 0}),e._zod.onattach.push(t=>{var c;let a=(c=t._zod.bag.maximum)!=null?c:Number.POSITIVE_INFINITY;r.maximum<a&&(t._zod.bag.maximum=r.maximum)}),e._zod.check=t=>{let a=t.value;a.size<=r.maximum||t.issues.push({origin:it(a),code:"too_big",maximum:r.maximum,inclusive:!0,input:a,inst:e,continue:!r.abort})}}),ao=g("$ZodCheckMinSize",(e,r)=>{var o;var n;L.init(e,r),(o=(n=e._zod.def).when)!=null||(n.when=t=>{let a=t.value;return!ye(a)&&a.size!==void 0}),e._zod.onattach.push(t=>{var c;let a=(c=t._zod.bag.minimum)!=null?c:Number.NEGATIVE_INFINITY;r.minimum>a&&(t._zod.bag.minimum=r.minimum)}),e._zod.check=t=>{let a=t.value;a.size>=r.minimum||t.issues.push({origin:it(a),code:"too_small",minimum:r.minimum,inclusive:!0,input:a,inst:e,continue:!r.abort})}}),co=g("$ZodCheckSizeEquals",(e,r)=>{var o;var n;L.init(e,r),(o=(n=e._zod.def).when)!=null||(n.when=t=>{let a=t.value;return!ye(a)&&a.size!==void 0}),e._zod.onattach.push(t=>{let a=t._zod.bag;a.minimum=r.size,a.maximum=r.size,a.size=r.size}),e._zod.check=t=>{let a=t.value,c=a.size;if(c===r.size)return;let m=c>r.size;t.issues.push(I(f({origin:it(a)},m?{code:"too_big",maximum:r.size}:{code:"too_small",minimum:r.size}),{inclusive:!0,exact:!0,input:t.value,inst:e,continue:!r.abort}))}}),uo=g("$ZodCheckMaxLength",(e,r)=>{var o;var n;L.init(e,r),(o=(n=e._zod.def).when)!=null||(n.when=t=>{let a=t.value;return!ye(a)&&a.length!==void 0}),e._zod.onattach.push(t=>{var c;let a=(c=t._zod.bag.maximum)!=null?c:Number.POSITIVE_INFINITY;r.maximum<a&&(t._zod.bag.maximum=r.maximum)}),e._zod.check=t=>{let a=t.value;if(a.length<=r.maximum)return;let m=at(a);t.issues.push({origin:m,code:"too_big",maximum:r.maximum,inclusive:!0,input:a,inst:e,continue:!r.abort})}}),lo=g("$ZodCheckMinLength",(e,r)=>{var o;var n;L.init(e,r),(o=(n=e._zod.def).when)!=null||(n.when=t=>{let a=t.value;return!ye(a)&&a.length!==void 0}),e._zod.onattach.push(t=>{var c;let a=(c=t._zod.bag.minimum)!=null?c:Number.NEGATIVE_INFINITY;r.minimum>a&&(t._zod.bag.minimum=r.minimum)}),e._zod.check=t=>{let a=t.value;if(a.length>=r.minimum)return;let m=at(a);t.issues.push({origin:m,code:"too_small",minimum:r.minimum,inclusive:!0,input:a,inst:e,continue:!r.abort})}}),so=g("$ZodCheckLengthEquals",(e,r)=>{var o;var n;L.init(e,r),(o=(n=e._zod.def).when)!=null||(n.when=t=>{let a=t.value;return!ye(a)&&a.length!==void 0}),e._zod.onattach.push(t=>{let a=t._zod.bag;a.minimum=r.length,a.maximum=r.length,a.length=r.length}),e._zod.check=t=>{let a=t.value,c=a.length;if(c===r.length)return;let m=at(a),s=c>r.length;t.issues.push(I(f({origin:m},s?{code:"too_big",maximum:r.length}:{code:"too_small",minimum:r.length}),{inclusive:!0,exact:!0,input:t.value,inst:e,continue:!r.abort}))}}),Ke=g("$ZodCheckStringFormat",(e,r)=>{var t,a;var n,o;L.init(e,r),e._zod.onattach.push(c=>{var s;let m=c._zod.bag;m.format=r.format,r.pattern&&((s=m.patterns)!=null||(m.patterns=new Set),m.patterns.add(r.pattern))}),r.pattern?(t=(n=e._zod).check)!=null||(n.check=c=>{r.pattern.lastIndex=0,!r.pattern.test(c.value)&&c.issues.push(I(f({origin:"string",code:"invalid_format",format:r.format,input:c.value},r.pattern?{pattern:r.pattern.toString()}:{}),{inst:e,continue:!r.abort}))}):(a=(o=e._zod).check)!=null||(o.check=()=>{})}),mo=g("$ZodCheckRegex",(e,r)=>{Ke.init(e,r),e._zod.check=n=>{r.pattern.lastIndex=0,!r.pattern.test(n.value)&&n.issues.push({origin:"string",code:"invalid_format",format:"regex",input:n.value,pattern:r.pattern.toString(),inst:e,continue:!r.abort})}}),po=g("$ZodCheckLowerCase",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=eo),Ke.init(e,r)}),fo=g("$ZodCheckUpperCase",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=to),Ke.init(e,r)}),go=g("$ZodCheckIncludes",(e,r)=>{L.init(e,r);let n=H(r.includes),o=new RegExp(typeof r.position=="number"?`^.{${r.position}}${n}`:n);r.pattern=o,e._zod.onattach.push(t=>{var c;let a=t._zod.bag;(c=a.patterns)!=null||(a.patterns=new Set),a.patterns.add(o)}),e._zod.check=t=>{t.value.includes(r.includes,r.position)||t.issues.push({origin:"string",code:"invalid_format",format:"includes",includes:r.includes,input:t.value,inst:e,continue:!r.abort})}}),vo=g("$ZodCheckStartsWith",(e,r)=>{var o;L.init(e,r);let n=new RegExp(`^${H(r.prefix)}.*`);(o=r.pattern)!=null||(r.pattern=n),e._zod.onattach.push(t=>{var c;let a=t._zod.bag;(c=a.patterns)!=null||(a.patterns=new Set),a.patterns.add(n)}),e._zod.check=t=>{t.value.startsWith(r.prefix)||t.issues.push({origin:"string",code:"invalid_format",format:"starts_with",prefix:r.prefix,input:t.value,inst:e,continue:!r.abort})}}),ho=g("$ZodCheckEndsWith",(e,r)=>{var o;L.init(e,r);let n=new RegExp(`.*${H(r.suffix)}$`);(o=r.pattern)!=null||(r.pattern=n),e._zod.onattach.push(t=>{var c;let a=t._zod.bag;(c=a.patterns)!=null||(a.patterns=new Set),a.patterns.add(n)}),e._zod.check=t=>{t.value.endsWith(r.suffix)||t.issues.push({origin:"string",code:"invalid_format",format:"ends_with",suffix:r.suffix,input:t.value,inst:e,continue:!r.abort})}});function wu(e,r,n){e.issues.length&&r.issues.push(...q(n,e.issues))}var yo=g("$ZodCheckProperty",(e,r)=>{L.init(e,r),e._zod.check=n=>{let o=r.schema._zod.run({value:n.value[r.property],issues:[]},{});if(o instanceof Promise)return o.then(t=>wu(t,n,r.property));wu(o,n,r.property)}}),$o=g("$ZodCheckMimeType",(e,r)=>{L.init(e,r);let n=new Set(r.mime);e._zod.onattach.push(o=>{o._zod.bag.mime=r.mime}),e._zod.check=o=>{n.has(o.value.type)||o.issues.push({code:"invalid_value",values:r.mime,input:o.value.type,inst:e,continue:!r.abort})}}),xo=g("$ZodCheckOverwrite",(e,r)=>{L.init(e,r),e._zod.check=n=>{n.value=r.tx(n.value)}});var st=class{constructor(r=[]){this.content=[],this.indent=0,this&&(this.args=r)}indented(r){this.indent+=1,r(this),this.indent-=1}write(r){if(typeof r=="function"){r(this,{execution:"sync"}),r(this,{execution:"async"});return}let o=r.split(`\n`).filter(c=>c),t=Math.min(...o.map(c=>c.length-c.trimStart().length)),a=o.map(c=>c.slice(t)).map(c=>" ".repeat(this.indent*2)+c);for(let c of a)this.content.push(c)}compile(){var a;let r=Function,n=this==null?void 0:this.args,t=[...((a=this==null?void 0:this.content)!=null?a:[""]).map(c=>`  ${c}`)];return new r(...n,t.join(`\n`))}};var bo={major:4,minor:3,patch:6};var P=g("$ZodType",(e,r)=>{var t,a,c;var n;e!=null||(e={}),e._zod.def=r,e._zod.bag=e._zod.bag||{},e._zod.version=bo;let o=[...(t=e._zod.def.checks)!=null?t:[]];e._zod.traits.has("$ZodCheck")&&o.unshift(e);for(let m of o)for(let s of m._zod.onattach)s(e);if(o.length===0)(a=(n=e._zod).deferred)!=null||(n.deferred=[]),(c=e._zod.deferred)==null||c.push(()=>{e._zod.run=e._zod.parse});else{let m=(u,d,i)=>{let l=be(u),p;for(let v of d){if(v._zod.def.when){if(!v._zod.def.when(u))continue}else if(l)continue;let y=u.issues.length,S=v._zod.check(u);if(S instanceof Promise&&(i==null?void 0:i.async)===!1)throw new ne;if(p||S instanceof Promise)p=(p!=null?p:Promise.resolve()).then(async()=>{await S,u.issues.length!==y&&(l||(l=be(u,y)))});else{if(u.issues.length===y)continue;l||(l=be(u,y))}}return p?p.then(()=>u):u},s=(u,d,i)=>{if(be(u))return u.aborted=!0,u;let l=m(d,o,i);if(l instanceof Promise){if(i.async===!1)throw new ne;return l.then(p=>e._zod.parse(p,i))}return e._zod.parse(l,i)};e._zod.run=(u,d)=>{if(d.skipChecks)return e._zod.parse(u,d);if(d.direction==="backward"){let l=e._zod.parse({value:u.value,issues:[]},I(f({},d),{skipChecks:!0}));return l instanceof Promise?l.then(p=>s(p,u,d)):s(l,u,d)}let i=e._zod.parse(u,d);if(i instanceof Promise){if(d.async===!1)throw new ne;return i.then(l=>m(l,o,d))}return m(i,o,d)}}O(e,"~standard",()=>({validate:m=>{var s;try{let u=zn(e,m);return u.success?{value:u.data}:{issues:(s=u.error)==null?void 0:s.issues}}catch(u){return Tn(e,m).then(d=>{var i;return d.success?{value:d.data}:{issues:(i=d.error)==null?void 0:i.issues}})}},vendor:"zod",version:1}))}),De=g("$ZodString",(e,r)=>{var n,o,t;P.init(e,r),e._zod.pattern=(t=[...(o=(n=e==null?void 0:e._zod.bag)==null?void 0:n.patterns)!=null?o:[]].pop())!=null?t:Wn(e._zod.bag),e._zod.parse=(a,c)=>{if(r.coerce)try{a.value=String(a.value)}catch(m){}return typeof a.value=="string"||a.issues.push({expected:"string",code:"invalid_type",input:a.value,inst:e}),a}}),Z=g("$ZodStringFormat",(e,r)=>{Ke.init(e,r),De.init(e,r)}),So=g("$ZodGUID",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=En),Z.init(e,r)}),ko=g("$ZodUUID",(e,r)=>{var n,o;if(r.version){let a={v1:1,v2:2,v3:3,v4:4,v5:5,v6:6,v7:7,v8:8}[r.version];if(a===void 0)throw new Error(`Invalid UUID version: "${r.version}"`);(n=r.pattern)!=null||(r.pattern=Pe(a))}else(o=r.pattern)!=null||(r.pattern=Pe());Z.init(e,r)}),Io=g("$ZodEmail",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Zn),Z.init(e,r)}),zo=g("$ZodURL",(e,r)=>{Z.init(e,r),e._zod.check=n=>{try{let o=n.value.trim(),t=new URL(o);r.hostname&&(r.hostname.lastIndex=0,r.hostname.test(t.hostname)||n.issues.push({code:"invalid_format",format:"url",note:"Invalid hostname",pattern:r.hostname.source,input:n.value,inst:e,continue:!r.abort})),r.protocol&&(r.protocol.lastIndex=0,r.protocol.test(t.protocol.endsWith(":")?t.protocol.slice(0,-1):t.protocol)||n.issues.push({code:"invalid_format",format:"url",note:"Invalid protocol",pattern:r.protocol.source,input:n.value,inst:e,continue:!r.abort})),r.normalize?n.value=t.href:n.value=o;return}catch(o){n.issues.push({code:"invalid_format",format:"url",input:n.value,inst:e,continue:!r.abort})}}}),To=g("$ZodEmoji",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Ln()),Z.init(e,r)}),wo=g("$ZodNanoID",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Un),Z.init(e,r)}),Po=g("$ZodCUID",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=wn),Z.init(e,r)}),Do=g("$ZodCUID2",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Pn),Z.init(e,r)}),jo=g("$ZodULID",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Dn),Z.init(e,r)}),Oo=g("$ZodXID",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=jn),Z.init(e,r)}),Uo=g("$ZodKSUID",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=On),Z.init(e,r)}),No=g("$ZodISODateTime",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Gn(r)),Z.init(e,r)}),Eo=g("$ZodISODate",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Jn),Z.init(e,r)}),Zo=g("$ZodISOTime",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Bn(r)),Z.init(e,r)}),Lo=g("$ZodISODuration",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Nn),Z.init(e,r)}),Co=g("$ZodIPv4",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Cn),Z.init(e,r),e._zod.bag.format="ipv4"}),Ro=g("$ZodIPv6",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Rn),Z.init(e,r),e._zod.bag.format="ipv6",e._zod.check=o=>{try{new URL(`http://[${o.value}]`)}catch(t){o.issues.push({code:"invalid_format",format:"ipv6",input:o.value,inst:e,continue:!r.abort})}}}),Ao=g("$ZodMAC",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=An(r.delimiter)),Z.init(e,r),e._zod.bag.format="mac"}),Mo=g("$ZodCIDRv4",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Mn),Z.init(e,r)}),Fo=g("$ZodCIDRv6",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Fn),Z.init(e,r),e._zod.check=o=>{let t=o.value.split("/");try{if(t.length!==2)throw new Error;let[a,c]=t;if(!c)throw new Error;let m=Number(c);if(`${m}`!==c)throw new Error;if(m<0||m>128)throw new Error;new URL(`http://[${a}]`)}catch(a){o.issues.push({code:"invalid_format",format:"cidrv6",input:o.value,inst:e,continue:!r.abort})}}});function Vo(e){if(e==="")return!0;if(e.length%4!==0)return!1;try{return atob(e),!0}catch(r){return!1}}var Ko=g("$ZodBase64",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Vn),Z.init(e,r),e._zod.bag.contentEncoding="base64",e._zod.check=o=>{Vo(o.value)||o.issues.push({code:"invalid_format",format:"base64",input:o.value,inst:e,continue:!r.abort})}});function Fu(e){if(!ir.test(e))return!1;let r=e.replace(/[-_]/g,o=>o==="-"?"+":"/"),n=r.padEnd(Math.ceil(r.length/4)*4,"=");return Vo(n)}var Jo=g("$ZodBase64URL",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=ir),Z.init(e,r),e._zod.bag.contentEncoding="base64url",e._zod.check=o=>{Fu(o.value)||o.issues.push({code:"invalid_format",format:"base64url",input:o.value,inst:e,continue:!r.abort})}}),Bo=g("$ZodE164",(e,r)=>{var n;(n=r.pattern)!=null||(r.pattern=Kn),Z.init(e,r)});function Vu(e,r=null){try{let n=e.split(".");if(n.length!==3)return!1;let[o]=n;if(!o)return!1;let t=JSON.parse(atob(o));return!("typ"in t&&(t==null?void 0:t.typ)!=="JWT"||!t.alg||r&&(!("alg"in t)||t.alg!==r))}catch(n){return!1}}var Go=g("$ZodJWT",(e,r)=>{Z.init(e,r),e._zod.check=n=>{Vu(n.value,r.alg)||n.issues.push({code:"invalid_format",format:"jwt",input:n.value,inst:e,continue:!r.abort})}}),Wo=g("$ZodCustomStringFormat",(e,r)=>{Z.init(e,r),e._zod.check=n=>{r.fn(n.value)||n.issues.push({code:"invalid_format",format:r.format,input:n.value,inst:e,continue:!r.abort})}}),fr=g("$ZodNumber",(e,r)=>{var n;P.init(e,r),e._zod.pattern=(n=e._zod.bag.pattern)!=null?n:ar,e._zod.parse=(o,t)=>{if(r.coerce)try{o.value=Number(o.value)}catch(m){}let a=o.value;if(typeof a=="number"&&!Number.isNaN(a)&&Number.isFinite(a))return o;let c=typeof a=="number"?Number.isNaN(a)?"NaN":Number.isFinite(a)?void 0:"Infinity":void 0;return o.issues.push(f({expected:"number",code:"invalid_type",input:a,inst:e},c?{received:c}:{})),o}}),qo=g("$ZodNumberFormat",(e,r)=>{no.init(e,r),fr.init(e,r)}),dt=g("$ZodBoolean",(e,r)=>{P.init(e,r),e._zod.pattern=Qn,e._zod.parse=(n,o)=>{if(r.coerce)try{n.value=!!n.value}catch(a){}let t=n.value;return typeof t=="boolean"||n.issues.push({expected:"boolean",code:"invalid_type",input:t,inst:e}),n}}),gr=g("$ZodBigInt",(e,r)=>{P.init(e,r),e._zod.pattern=qn,e._zod.parse=(n,o)=>{if(r.coerce)try{n.value=BigInt(n.value)}catch(t){}return typeof n.value=="bigint"||n.issues.push({expected:"bigint",code:"invalid_type",input:n.value,inst:e}),n}}),Xo=g("$ZodBigIntFormat",(e,r)=>{oo.init(e,r),gr.init(e,r)}),Qo=g("$ZodSymbol",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{let t=n.value;return typeof t=="symbol"||n.issues.push({expected:"symbol",code:"invalid_type",input:t,inst:e}),n}}),Yo=g("$ZodUndefined",(e,r)=>{P.init(e,r),e._zod.pattern=Hn,e._zod.values=new Set([void 0]),e._zod.optin="optional",e._zod.optout="optional",e._zod.parse=(n,o)=>{let t=n.value;return typeof t=="undefined"||n.issues.push({expected:"undefined",code:"invalid_type",input:t,inst:e}),n}}),Ho=g("$ZodNull",(e,r)=>{P.init(e,r),e._zod.pattern=Yn,e._zod.values=new Set([null]),e._zod.parse=(n,o)=>{let t=n.value;return t===null||n.issues.push({expected:"null",code:"invalid_type",input:t,inst:e}),n}}),ei=g("$ZodAny",(e,r)=>{P.init(e,r),e._zod.parse=n=>n}),ti=g("$ZodUnknown",(e,r)=>{P.init(e,r),e._zod.parse=n=>n}),ri=g("$ZodNever",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>(n.issues.push({expected:"never",code:"invalid_type",input:n.value,inst:e}),n)}),ni=g("$ZodVoid",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{let t=n.value;return typeof t=="undefined"||n.issues.push({expected:"void",code:"invalid_type",input:t,inst:e}),n}}),oi=g("$ZodDate",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{if(r.coerce)try{n.value=new Date(n.value)}catch(m){}let t=n.value,a=t instanceof Date;return a&&!Number.isNaN(t.getTime())||n.issues.push(I(f({expected:"date",code:"invalid_type",input:t},a?{received:"Invalid Date"}:{}),{inst:e})),n}});function ju(e,r,n){e.issues.length&&r.issues.push(...q(n,e.issues)),r.value[n]=e.value}var ii=g("$ZodArray",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{let t=n.value;if(!Array.isArray(t))return n.issues.push({expected:"array",code:"invalid_type",input:t,inst:e}),n;n.value=Array(t.length);let a=[];for(let c=0;c<t.length;c++){let m=t[c],s=r.element._zod.run({value:m,issues:[]},o);s instanceof Promise?a.push(s.then(u=>ju(u,n,c))):ju(s,n,c)}return a.length?Promise.all(a).then(()=>n):n}});function pr(e,r,n,o,t){if(e.issues.length){if(t&&!(n in o))return;r.issues.push(...q(n,e.issues))}e.value===void 0?n in o&&(r.value[n]=void 0):r.value[n]=e.value}function Ku(e){var o,t,a,c;let r=Object.keys(e.shape);for(let m of r)if(!((c=(a=(t=(o=e.shape)==null?void 0:o[m])==null?void 0:t._zod)==null?void 0:a.traits)!=null&&c.has("$ZodType")))throw new Error(`Invalid element at key "${m}": expected a Zod schema`);let n=Sn(e.shape);return I(f({},e),{keys:r,keySet:new Set(r),numKeys:r.length,optionalKeys:new Set(n)})}function Ju(e,r,n,o,t,a){let c=[],m=t.keySet,s=t.catchall._zod,u=s.def.type,d=s.optout==="optional";for(let i in r){if(m.has(i))continue;if(u==="never"){c.push(i);continue}let l=s.run({value:r[i],issues:[]},o);l instanceof Promise?e.push(l.then(p=>pr(p,n,i,r,d))):pr(l,n,i,r,d)}return c.length&&n.issues.push({code:"unrecognized_keys",keys:c,input:r,inst:a}),e.length?Promise.all(e).then(()=>n):n}var Bu=g("$ZodObject",(e,r)=>{P.init(e,r);let n=Object.getOwnPropertyDescriptor(r,"shape");if(!(n!=null&&n.get)){let m=r.shape;Object.defineProperty(r,"shape",{get:()=>{let s=f({},m);return Object.defineProperty(r,"shape",{value:s}),s}})}let o=Ce(()=>Ku(r));O(e._zod,"propValues",()=>{var u;let m=r.shape,s={};for(let d in m){let i=m[d]._zod;if(i.values){(u=s[d])!=null||(s[d]=new Set);for(let l of i.values)s[d].add(l)}}return s});let t=we,a=r.catchall,c;e._zod.parse=(m,s)=>{c!=null||(c=o.value);let u=m.value;if(!t(u))return m.issues.push({expected:"object",code:"invalid_type",input:u,inst:e}),m;m.value={};let d=[],i=c.shape;for(let l of c.keys){let p=i[l],v=p._zod.optout==="optional",y=p._zod.run({value:u[l],issues:[]},s);y instanceof Promise?d.push(y.then(S=>pr(S,m,l,u,v))):pr(y,m,l,u,v)}return a?Ju(d,u,m,s,o.value,e):d.length?Promise.all(d).then(()=>m):m}}),ai=g("$ZodObjectJIT",(e,r)=>{Bu.init(e,r);let n=e._zod.parse,o=Ce(()=>Ku(r)),t=l=>{var N;let p=new st(["shape","payload","ctx"]),v=o.value,y=k=>{let T=Jt(k);return`shape[${T}]._zod.run({ value: input[${T}], issues: [] }, ctx)`};p.write("const input = payload.value;");let S=Object.create(null),w=0;for(let k of v.keys)S[k]=`key_${w++}`;p.write("const newResult = {};");for(let k of v.keys){let T=S[k],U=Jt(k),R=l[k],Ee=((N=R==null?void 0:R._zod)==null?void 0:N.optout)==="optional";p.write(`const ${T} = ${y(k)};`),Ee?p.write(`\n        if (${T}.issues.length) {\n          if (${U} in input) {\n            payload.issues = payload.issues.concat(${T}.issues.map(iss => ({\n              ...iss,\n              path: iss.path ? [${U}, ...iss.path] : [${U}]\n            })));\n          }\n        }\n        \n        if (${T}.value === undefined) {\n          if (${U} in input) {\n            newResult[${U}] = undefined;\n          }\n        } else {\n          newResult[${U}] = ${T}.value;\n        }\n        \n      `):p.write(`\n        if (${T}.issues.length) {\n          payload.issues = payload.issues.concat(${T}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${U}, ...iss.path] : [${U}]\n          })));\n        }\n        \n        if (${T}.value === undefined) {\n          if (${U} in input) {\n            newResult[${U}] = undefined;\n          }\n        } else {\n          newResult[${U}] = ${T}.value;\n        }\n        \n      `)}p.write("payload.value = newResult;"),p.write("return payload;");let D=p.compile();return(k,T)=>D(l,k,T)},a,c=we,m=!et.jitless,u=m&&xn.value,d=r.catchall,i;e._zod.parse=(l,p)=>{i!=null||(i=o.value);let v=l.value;return c(v)?m&&u&&(p==null?void 0:p.async)===!1&&p.jitless!==!0?(a||(a=t(r.shape)),l=a(l,p),d?Ju([],v,l,p,i,e):l):n(l,p):(l.issues.push({expected:"object",code:"invalid_type",input:v,inst:e}),l)}});function Ou(e,r,n,o){for(let a of e)if(a.issues.length===0)return r.value=a.value,r;let t=e.filter(a=>!be(a));return t.length===1?(r.value=t[0].value,t[0]):(r.issues.push({code:"invalid_union",input:r.value,inst:n,errors:e.map(a=>a.issues.map(c=>B(c,o,M())))}),r)}var mt=g("$ZodUnion",(e,r)=>{P.init(e,r),O(e._zod,"optin",()=>r.options.some(t=>t._zod.optin==="optional")?"optional":void 0),O(e._zod,"optout",()=>r.options.some(t=>t._zod.optout==="optional")?"optional":void 0),O(e._zod,"values",()=>{if(r.options.every(t=>t._zod.values))return new Set(r.options.flatMap(t=>Array.from(t._zod.values)))}),O(e._zod,"pattern",()=>{if(r.options.every(t=>t._zod.pattern)){let t=r.options.map(a=>a._zod.pattern);return new RegExp(`^(${t.map(a=>nt(a.source)).join("|")})$`)}});let n=r.options.length===1,o=r.options[0]._zod.run;e._zod.parse=(t,a)=>{if(n)return o(t,a);let c=!1,m=[];for(let s of r.options){let u=s._zod.run({value:t.value,issues:[]},a);if(u instanceof Promise)m.push(u),c=!0;else{if(u.issues.length===0)return u;m.push(u)}}return c?Promise.all(m).then(s=>Ou(s,t,e,a)):Ou(m,t,e,a)}});function Uu(e,r,n,o){let t=e.filter(a=>a.issues.length===0);return t.length===1?(r.value=t[0].value,r):(t.length===0?r.issues.push({code:"invalid_union",input:r.value,inst:n,errors:e.map(a=>a.issues.map(c=>B(c,o,M())))}):r.issues.push({code:"invalid_union",input:r.value,inst:n,errors:[],inclusive:!1}),r)}var ci=g("$ZodXor",(e,r)=>{mt.init(e,r),r.inclusive=!1;let n=r.options.length===1,o=r.options[0]._zod.run;e._zod.parse=(t,a)=>{if(n)return o(t,a);let c=!1,m=[];for(let s of r.options){let u=s._zod.run({value:t.value,issues:[]},a);u instanceof Promise?(m.push(u),c=!0):m.push(u)}return c?Promise.all(m).then(s=>Uu(s,t,e,a)):Uu(m,t,e,a)}}),ui=g("$ZodDiscriminatedUnion",(e,r)=>{r.inclusive=!1,mt.init(e,r);let n=e._zod.parse;O(e._zod,"propValues",()=>{let t={};for(let a of r.options){let c=a._zod.propValues;if(!c||Object.keys(c).length===0)throw new Error(`Invalid discriminated union option at index "${r.options.indexOf(a)}"`);for(let[m,s]of Object.entries(c)){t[m]||(t[m]=new Set);for(let u of s)t[m].add(u)}}return t});let o=Ce(()=>{var c;let t=r.options,a=new Map;for(let m of t){let s=(c=m._zod.propValues)==null?void 0:c[r.discriminator];if(!s||s.size===0)throw new Error(`Invalid discriminated union option at index "${r.options.indexOf(m)}"`);for(let u of s){if(a.has(u))throw new Error(`Duplicate discriminator value "${String(u)}"`);a.set(u,m)}}return a});e._zod.parse=(t,a)=>{let c=t.value;if(!we(c))return t.issues.push({code:"invalid_type",expected:"object",input:c,inst:e}),t;let m=o.value.get(c==null?void 0:c[r.discriminator]);return m?m._zod.run(t,a):r.unionFallback?n(t,a):(t.issues.push({code:"invalid_union",errors:[],note:"No matching discriminator",discriminator:r.discriminator,input:c,path:[r.discriminator],inst:e}),t)}}),li=g("$ZodIntersection",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{let t=n.value,a=r.left._zod.run({value:t,issues:[]},o),c=r.right._zod.run({value:t,issues:[]},o);return a instanceof Promise||c instanceof Promise?Promise.all([a,c]).then(([s,u])=>Nu(n,s,u)):Nu(n,a,c)}});function _o(e,r){if(e===r)return{valid:!0,data:e};if(e instanceof Date&&r instanceof Date&&+e==+r)return{valid:!0,data:e};if(xe(e)&&xe(r)){let n=Object.keys(r),o=Object.keys(e).filter(a=>n.indexOf(a)!==-1),t=f(f({},e),r);for(let a of o){let c=_o(e[a],r[a]);if(!c.valid)return{valid:!1,mergeErrorPath:[a,...c.mergeErrorPath]};t[a]=c.data}return{valid:!0,data:t}}if(Array.isArray(e)&&Array.isArray(r)){if(e.length!==r.length)return{valid:!1,mergeErrorPath:[]};let n=[];for(let o=0;o<e.length;o++){let t=e[o],a=r[o],c=_o(t,a);if(!c.valid)return{valid:!1,mergeErrorPath:[o,...c.mergeErrorPath]};n.push(c.data)}return{valid:!0,data:n}}return{valid:!1,mergeErrorPath:[]}}function Nu(e,r,n){let o=new Map,t;for(let m of r.issues)if(m.code==="unrecognized_keys"){t!=null||(t=m);for(let s of m.keys)o.has(s)||o.set(s,{}),o.get(s).l=!0}else e.issues.push(m);for(let m of n.issues)if(m.code==="unrecognized_keys")for(let s of m.keys)o.has(s)||o.set(s,{}),o.get(s).r=!0;else e.issues.push(m);let a=[...o].filter(([,m])=>m.l&&m.r).map(([m])=>m);if(a.length&&t&&e.issues.push(I(f({},t),{keys:a})),be(e))return e;let c=_o(r.value,n.value);if(!c.valid)throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(c.mergeErrorPath)}`);return e.value=c.data,e}var vr=g("$ZodTuple",(e,r)=>{P.init(e,r);let n=r.items;e._zod.parse=(o,t)=>{let a=o.value;if(!Array.isArray(a))return o.issues.push({input:a,inst:e,expected:"tuple",code:"invalid_type"}),o;o.value=[];let c=[],m=[...n].reverse().findIndex(d=>d._zod.optin!=="optional"),s=m===-1?0:n.length-m;if(!r.rest){let d=a.length>n.length,i=a.length<s-1;if(d||i)return o.issues.push(I(f({},d?{code:"too_big",maximum:n.length,inclusive:!0}:{code:"too_small",minimum:n.length}),{input:a,inst:e,origin:"array"})),o}let u=-1;for(let d of n){if(u++,u>=a.length&&u>=s)continue;let i=d._zod.run({value:a[u],issues:[]},t);i instanceof Promise?c.push(i.then(l=>lr(l,o,u))):lr(i,o,u)}if(r.rest){let d=a.slice(n.length);for(let i of d){u++;let l=r.rest._zod.run({value:i,issues:[]},t);l instanceof Promise?c.push(l.then(p=>lr(p,o,u))):lr(l,o,u)}}return c.length?Promise.all(c).then(()=>o):o}});function lr(e,r,n){e.issues.length&&r.issues.push(...q(n,e.issues)),r.value[n]=e.value}var si=g("$ZodRecord",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{let t=n.value;if(!xe(t))return n.issues.push({expected:"record",code:"invalid_type",input:t,inst:e}),n;let a=[],c=r.keyType._zod.values;if(c){n.value={};let m=new Set;for(let u of c)if(typeof u=="string"||typeof u=="number"||typeof u=="symbol"){m.add(typeof u=="number"?u.toString():u);let d=r.valueType._zod.run({value:t[u],issues:[]},o);d instanceof Promise?a.push(d.then(i=>{i.issues.length&&n.issues.push(...q(u,i.issues)),n.value[u]=i.value})):(d.issues.length&&n.issues.push(...q(u,d.issues)),n.value[u]=d.value)}let s;for(let u in t)m.has(u)||(s=s!=null?s:[],s.push(u));s&&s.length>0&&n.issues.push({code:"unrecognized_keys",input:t,inst:e,keys:s})}else{n.value={};for(let m of Reflect.ownKeys(t)){if(m==="__proto__")continue;let s=r.keyType._zod.run({value:m,issues:[]},o);if(s instanceof Promise)throw new Error("Async schemas not supported in object keys currently");if(typeof m=="string"&&ar.test(m)&&s.issues.length){let i=r.keyType._zod.run({value:Number(m),issues:[]},o);if(i instanceof Promise)throw new Error("Async schemas not supported in object keys currently");i.issues.length===0&&(s=i)}if(s.issues.length){r.mode==="loose"?n.value[m]=t[m]:n.issues.push({code:"invalid_key",origin:"record",issues:s.issues.map(i=>B(i,o,M())),input:m,path:[m],inst:e});continue}let d=r.valueType._zod.run({value:t[m],issues:[]},o);d instanceof Promise?a.push(d.then(i=>{i.issues.length&&n.issues.push(...q(m,i.issues)),n.value[s.value]=i.value})):(d.issues.length&&n.issues.push(...q(m,d.issues)),n.value[s.value]=d.value)}}return a.length?Promise.all(a).then(()=>n):n}}),di=g("$ZodMap",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{let t=n.value;if(!(t instanceof Map))return n.issues.push({expected:"map",code:"invalid_type",input:t,inst:e}),n;let a=[];n.value=new Map;for(let[c,m]of t){let s=r.keyType._zod.run({value:c,issues:[]},o),u=r.valueType._zod.run({value:m,issues:[]},o);s instanceof Promise||u instanceof Promise?a.push(Promise.all([s,u]).then(([d,i])=>{Eu(d,i,n,c,t,e,o)})):Eu(s,u,n,c,t,e,o)}return a.length?Promise.all(a).then(()=>n):n}});function Eu(e,r,n,o,t,a,c){e.issues.length&&(ot.has(typeof o)?n.issues.push(...q(o,e.issues)):n.issues.push({code:"invalid_key",origin:"map",input:t,inst:a,issues:e.issues.map(m=>B(m,c,M()))})),r.issues.length&&(ot.has(typeof o)?n.issues.push(...q(o,r.issues)):n.issues.push({origin:"map",code:"invalid_element",input:t,inst:a,key:o,issues:r.issues.map(m=>B(m,c,M()))})),n.value.set(e.value,r.value)}var mi=g("$ZodSet",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{let t=n.value;if(!(t instanceof Set))return n.issues.push({input:t,inst:e,expected:"set",code:"invalid_type"}),n;let a=[];n.value=new Set;for(let c of t){let m=r.valueType._zod.run({value:c,issues:[]},o);m instanceof Promise?a.push(m.then(s=>Zu(s,n))):Zu(m,n)}return a.length?Promise.all(a).then(()=>n):n}});function Zu(e,r){e.issues.length&&r.issues.push(...e.issues),r.value.add(e.value)}var pi=g("$ZodEnum",(e,r)=>{P.init(e,r);let n=rt(r.entries),o=new Set(n);e._zod.values=o,e._zod.pattern=new RegExp(`^(${n.filter(t=>ot.has(typeof t)).map(t=>typeof t=="string"?H(t):t.toString()).join("|")})$`),e._zod.parse=(t,a)=>{let c=t.value;return o.has(c)||t.issues.push({code:"invalid_value",values:n,input:c,inst:e}),t}}),fi=g("$ZodLiteral",(e,r)=>{if(P.init(e,r),r.values.length===0)throw new Error("Cannot create literal schema with no valid values");let n=new Set(r.values);e._zod.values=n,e._zod.pattern=new RegExp(`^(${r.values.map(o=>typeof o=="string"?H(o):o?H(o.toString()):String(o)).join("|")})$`),e._zod.parse=(o,t)=>{let a=o.value;return n.has(a)||o.issues.push({code:"invalid_value",values:r.values,input:a,inst:e}),o}}),gi=g("$ZodFile",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{let t=n.value;return t instanceof File||n.issues.push({expected:"file",code:"invalid_type",input:t,inst:e}),n}}),vi=g("$ZodTransform",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{if(o.direction==="backward")throw new he(e.constructor.name);let t=r.transform(n.value,n);if(o.async)return(t instanceof Promise?t:Promise.resolve(t)).then(c=>(n.value=c,n));if(t instanceof Promise)throw new ne;return n.value=t,n}});function Lu(e,r){return e.issues.length&&r===void 0?{issues:[],value:void 0}:e}var hr=g("$ZodOptional",(e,r)=>{P.init(e,r),e._zod.optin="optional",e._zod.optout="optional",O(e._zod,"values",()=>r.innerType._zod.values?new Set([...r.innerType._zod.values,void 0]):void 0),O(e._zod,"pattern",()=>{let n=r.innerType._zod.pattern;return n?new RegExp(`^(${nt(n.source)})?$`):void 0}),e._zod.parse=(n,o)=>{if(r.innerType._zod.optin==="optional"){let t=r.innerType._zod.run(n,o);return t instanceof Promise?t.then(a=>Lu(a,n.value)):Lu(t,n.value)}return n.value===void 0?n:r.innerType._zod.run(n,o)}}),hi=g("$ZodExactOptional",(e,r)=>{hr.init(e,r),O(e._zod,"values",()=>r.innerType._zod.values),O(e._zod,"pattern",()=>r.innerType._zod.pattern),e._zod.parse=(n,o)=>r.innerType._zod.run(n,o)}),yi=g("$ZodNullable",(e,r)=>{P.init(e,r),O(e._zod,"optin",()=>r.innerType._zod.optin),O(e._zod,"optout",()=>r.innerType._zod.optout),O(e._zod,"pattern",()=>{let n=r.innerType._zod.pattern;return n?new RegExp(`^(${nt(n.source)}|null)$`):void 0}),O(e._zod,"values",()=>r.innerType._zod.values?new Set([...r.innerType._zod.values,null]):void 0),e._zod.parse=(n,o)=>n.value===null?n:r.innerType._zod.run(n,o)}),$i=g("$ZodDefault",(e,r)=>{P.init(e,r),e._zod.optin="optional",O(e._zod,"values",()=>r.innerType._zod.values),e._zod.parse=(n,o)=>{if(o.direction==="backward")return r.innerType._zod.run(n,o);if(n.value===void 0)return n.value=r.defaultValue,n;let t=r.innerType._zod.run(n,o);return t instanceof Promise?t.then(a=>Cu(a,r)):Cu(t,r)}});function Cu(e,r){return e.value===void 0&&(e.value=r.defaultValue),e}var xi=g("$ZodPrefault",(e,r)=>{P.init(e,r),e._zod.optin="optional",O(e._zod,"values",()=>r.innerType._zod.values),e._zod.parse=(n,o)=>(o.direction==="backward"||n.value===void 0&&(n.value=r.defaultValue),r.innerType._zod.run(n,o))}),bi=g("$ZodNonOptional",(e,r)=>{P.init(e,r),O(e._zod,"values",()=>{let n=r.innerType._zod.values;return n?new Set([...n].filter(o=>o!==void 0)):void 0}),e._zod.parse=(n,o)=>{let t=r.innerType._zod.run(n,o);return t instanceof Promise?t.then(a=>Ru(a,e)):Ru(t,e)}});function Ru(e,r){return!e.issues.length&&e.value===void 0&&e.issues.push({code:"invalid_type",expected:"nonoptional",input:e.value,inst:r}),e}var _i=g("$ZodSuccess",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>{if(o.direction==="backward")throw new he("ZodSuccess");let t=r.innerType._zod.run(n,o);return t instanceof Promise?t.then(a=>(n.value=a.issues.length===0,n)):(n.value=t.issues.length===0,n)}}),Si=g("$ZodCatch",(e,r)=>{P.init(e,r),O(e._zod,"optin",()=>r.innerType._zod.optin),O(e._zod,"optout",()=>r.innerType._zod.optout),O(e._zod,"values",()=>r.innerType._zod.values),e._zod.parse=(n,o)=>{if(o.direction==="backward")return r.innerType._zod.run(n,o);let t=r.innerType._zod.run(n,o);return t instanceof Promise?t.then(a=>(n.value=a.value,a.issues.length&&(n.value=r.catchValue(I(f({},n),{error:{issues:a.issues.map(c=>B(c,o,M()))},input:n.value})),n.issues=[]),n)):(n.value=t.value,t.issues.length&&(n.value=r.catchValue(I(f({},n),{error:{issues:t.issues.map(a=>B(a,o,M()))},input:n.value})),n.issues=[]),n)}}),ki=g("$ZodNaN",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>((typeof n.value!="number"||!Number.isNaN(n.value))&&n.issues.push({input:n.value,inst:e,expected:"nan",code:"invalid_type"}),n)}),Ii=g("$ZodPipe",(e,r)=>{P.init(e,r),O(e._zod,"values",()=>r.in._zod.values),O(e._zod,"optin",()=>r.in._zod.optin),O(e._zod,"optout",()=>r.out._zod.optout),O(e._zod,"propValues",()=>r.in._zod.propValues),e._zod.parse=(n,o)=>{if(o.direction==="backward"){let a=r.out._zod.run(n,o);return a instanceof Promise?a.then(c=>sr(c,r.in,o)):sr(a,r.in,o)}let t=r.in._zod.run(n,o);return t instanceof Promise?t.then(a=>sr(a,r.out,o)):sr(t,r.out,o)}});function sr(e,r,n){return e.issues.length?(e.aborted=!0,e):r._zod.run({value:e.value,issues:e.issues},n)}var pt=g("$ZodCodec",(e,r)=>{P.init(e,r),O(e._zod,"values",()=>r.in._zod.values),O(e._zod,"optin",()=>r.in._zod.optin),O(e._zod,"optout",()=>r.out._zod.optout),O(e._zod,"propValues",()=>r.in._zod.propValues),e._zod.parse=(n,o)=>{if((o.direction||"forward")==="forward"){let a=r.in._zod.run(n,o);return a instanceof Promise?a.then(c=>dr(c,r,o)):dr(a,r,o)}else{let a=r.out._zod.run(n,o);return a instanceof Promise?a.then(c=>dr(c,r,o)):dr(a,r,o)}}});function dr(e,r,n){if(e.issues.length)return e.aborted=!0,e;if((n.direction||"forward")==="forward"){let t=r.transform(e.value,e);return t instanceof Promise?t.then(a=>mr(e,a,r.out,n)):mr(e,t,r.out,n)}else{let t=r.reverseTransform(e.value,e);return t instanceof Promise?t.then(a=>mr(e,a,r.in,n)):mr(e,t,r.in,n)}}function mr(e,r,n,o){return e.issues.length?(e.aborted=!0,e):n._zod.run({value:r,issues:e.issues},o)}var zi=g("$ZodReadonly",(e,r)=>{P.init(e,r),O(e._zod,"propValues",()=>r.innerType._zod.propValues),O(e._zod,"values",()=>r.innerType._zod.values),O(e._zod,"optin",()=>{var n,o;return(o=(n=r.innerType)==null?void 0:n._zod)==null?void 0:o.optin}),O(e._zod,"optout",()=>{var n,o;return(o=(n=r.innerType)==null?void 0:n._zod)==null?void 0:o.optout}),e._zod.parse=(n,o)=>{if(o.direction==="backward")return r.innerType._zod.run(n,o);let t=r.innerType._zod.run(n,o);return t instanceof Promise?t.then(Au):Au(t)}});function Au(e){return e.value=Object.freeze(e.value),e}var Ti=g("$ZodTemplateLiteral",(e,r)=>{P.init(e,r);let n=[];for(let o of r.parts)if(typeof o=="object"&&o!==null){if(!o._zod.pattern)throw new Error(`Invalid template literal part, no pattern found: ${[...o._zod.traits].shift()}`);let t=o._zod.pattern instanceof RegExp?o._zod.pattern.source:o._zod.pattern;if(!t)throw new Error(`Invalid template literal part: ${o._zod.traits}`);let a=t.startsWith("^")?1:0,c=t.endsWith("$")?t.length-1:t.length;n.push(t.slice(a,c))}else if(o===null||_n.has(typeof o))n.push(H(`${o}`));else throw new Error(`Invalid template literal part: ${o}`);e._zod.pattern=new RegExp(`^${n.join("")}$`),e._zod.parse=(o,t)=>{var a;return typeof o.value!="string"?(o.issues.push({input:o.value,inst:e,expected:"string",code:"invalid_type"}),o):(e._zod.pattern.lastIndex=0,e._zod.pattern.test(o.value)||o.issues.push({input:o.value,inst:e,code:"invalid_format",format:(a=r.format)!=null?a:"template_literal",pattern:e._zod.pattern.source}),o)}}),wi=g("$ZodFunction",(e,r)=>(P.init(e,r),e._def=r,e._zod.def=r,e.implement=n=>{if(typeof n!="function")throw new Error("implement() must be called with a function");return function(...o){let t=e._def.input?qt(e._def.input,o):o,a=Reflect.apply(n,this,t);return e._def.output?qt(e._def.output,a):a}},e.implementAsync=n=>{if(typeof n!="function")throw new Error("implementAsync() must be called with a function");return async function(...o){let t=e._def.input?await Xt(e._def.input,o):o,a=await Reflect.apply(n,this,t);return e._def.output?await Xt(e._def.output,a):a}},e._zod.parse=(n,o)=>typeof n.value!="function"?(n.issues.push({code:"invalid_type",expected:"function",input:n.value,inst:e}),n):(e._def.output&&e._def.output._zod.def.type==="promise"?n.value=e.implementAsync(n.value):n.value=e.implement(n.value),n),e.input=(...n)=>{let o=e.constructor;return Array.isArray(n[0])?new o({type:"function",input:new vr({type:"tuple",items:n[0],rest:n[1]}),output:e._def.output}):new o({type:"function",input:n[0],output:e._def.output})},e.output=n=>{let o=e.constructor;return new o({type:"function",input:e._def.input,output:n})},e)),Pi=g("$ZodPromise",(e,r)=>{P.init(e,r),e._zod.parse=(n,o)=>Promise.resolve(n.value).then(t=>r.innerType._zod.run({value:t,issues:[]},o))}),Di=g("$ZodLazy",(e,r)=>{P.init(e,r),O(e._zod,"innerType",()=>r.getter()),O(e._zod,"pattern",()=>{var n,o;return(o=(n=e._zod.innerType)==null?void 0:n._zod)==null?void 0:o.pattern}),O(e._zod,"propValues",()=>{var n,o;return(o=(n=e._zod.innerType)==null?void 0:n._zod)==null?void 0:o.propValues}),O(e._zod,"optin",()=>{var n,o,t;return(t=(o=(n=e._zod.innerType)==null?void 0:n._zod)==null?void 0:o.optin)!=null?t:void 0}),O(e._zod,"optout",()=>{var n,o,t;return(t=(o=(n=e._zod.innerType)==null?void 0:n._zod)==null?void 0:o.optout)!=null?t:void 0}),e._zod.parse=(n,o)=>e._zod.innerType._zod.run(n,o)}),ji=g("$ZodCustom",(e,r)=>{L.init(e,r),P.init(e,r),e._zod.parse=(n,o)=>n,e._zod.check=n=>{let o=n.value,t=r.fn(o);if(t instanceof Promise)return t.then(a=>Mu(a,n,o,e));Mu(t,n,o,e)}});function Mu(e,r,n,o){var t;if(!e){let a={code:"custom",input:n,inst:o,path:[...(t=o._zod.def.path)!=null?t:[]],continue:!o._zod.def.abort};o._zod.def.params&&(a.params=o._zod.def.params),r.issues.push(Re(a))}}var Be={};ve(Be,{ar:()=>Gu,az:()=>Wu,be:()=>Xu,bg:()=>Qu,ca:()=>Yu,cs:()=>Hu,da:()=>el,de:()=>tl,en:()=>yr,eo:()=>rl,es:()=>nl,fa:()=>ol,fi:()=>il,fr:()=>al,frCA:()=>cl,he:()=>ul,hu:()=>ll,hy:()=>dl,id:()=>ml,is:()=>pl,it:()=>fl,ja:()=>gl,ka:()=>vl,kh:()=>hl,km:()=>$r,ko:()=>yl,lt:()=>xl,mk:()=>bl,ms:()=>_l,nl:()=>Sl,no:()=>kl,ota:()=>Il,pl:()=>Tl,ps:()=>zl,pt:()=>wl,ru:()=>Dl,sl:()=>jl,sv:()=>Ol,ta:()=>Ul,th:()=>Nl,tr:()=>El,ua:()=>Zl,uk:()=>xr,ur:()=>Ll,uz:()=>Cl,vi:()=>Rl,yo:()=>Fl,zhCN:()=>Al,zhTW:()=>Ml});var ep=()=>{let e={string:{unit:"\\u062D\\u0631\\u0641",verb:"\\u0623\\u0646 \\u064A\\u062D\\u0648\\u064A"},file:{unit:"\\u0628\\u0627\\u064A\\u062A",verb:"\\u0623\\u0646 \\u064A\\u062D\\u0648\\u064A"},array:{unit:"\\u0639\\u0646\\u0635\\u0631",verb:"\\u0623\\u0646 \\u064A\\u062D\\u0648\\u064A"},set:{unit:"\\u0639\\u0646\\u0635\\u0631",verb:"\\u0623\\u0646 \\u064A\\u062D\\u0648\\u064A"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0645\\u062F\\u062E\\u0644",email:"\\u0628\\u0631\\u064A\\u062F \\u0625\\u0644\\u0643\\u062A\\u0631\\u0648\\u0646\\u064A",url:"\\u0631\\u0627\\u0628\\u0637",emoji:"\\u0625\\u064A\\u0645\\u0648\\u062C\\u064A",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"\\u062A\\u0627\\u0631\\u064A\\u062E \\u0648\\u0648\\u0642\\u062A \\u0628\\u0645\\u0639\\u064A\\u0627\\u0631 ISO",date:"\\u062A\\u0627\\u0631\\u064A\\u062E \\u0628\\u0645\\u0639\\u064A\\u0627\\u0631 ISO",time:"\\u0648\\u0642\\u062A \\u0628\\u0645\\u0639\\u064A\\u0627\\u0631 ISO",duration:"\\u0645\\u062F\\u0629 \\u0628\\u0645\\u0639\\u064A\\u0627\\u0631 ISO",ipv4:"\\u0639\\u0646\\u0648\\u0627\\u0646 IPv4",ipv6:"\\u0639\\u0646\\u0648\\u0627\\u0646 IPv6",cidrv4:"\\u0645\\u062F\\u0649 \\u0639\\u0646\\u0627\\u0648\\u064A\\u0646 \\u0628\\u0635\\u064A\\u063A\\u0629 IPv4",cidrv6:"\\u0645\\u062F\\u0649 \\u0639\\u0646\\u0627\\u0648\\u064A\\u0646 \\u0628\\u0635\\u064A\\u063A\\u0629 IPv6",base64:"\\u0646\\u064E\\u0635 \\u0628\\u062A\\u0631\\u0645\\u064A\\u0632 base64-encoded",base64url:"\\u0646\\u064E\\u0635 \\u0628\\u062A\\u0631\\u0645\\u064A\\u0632 base64url-encoded",json_string:"\\u0646\\u064E\\u0635 \\u0639\\u0644\\u0649 \\u0647\\u064A\\u0626\\u0629 JSON",e164:"\\u0631\\u0642\\u0645 \\u0647\\u0627\\u062A\\u0641 \\u0628\\u0645\\u0639\\u064A\\u0627\\u0631 E.164",jwt:"JWT",template_literal:"\\u0645\\u062F\\u062E\\u0644"},o={nan:"NaN"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u0645\\u062F\\u062E\\u0644\\u0627\\u062A \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644\\u0629: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0625\\u062F\\u062E\\u0627\\u0644 instanceof ${t.expected}\\u060C \\u0648\\u0644\\u0643\\u0646 \\u062A\\u0645 \\u0625\\u062F\\u062E\\u0627\\u0644 ${p}`:`\\u0645\\u062F\\u062E\\u0644\\u0627\\u062A \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644\\u0629: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0625\\u062F\\u062E\\u0627\\u0644 ${i}\\u060C \\u0648\\u0644\\u0643\\u0646 \\u062A\\u0645 \\u0625\\u062F\\u062E\\u0627\\u0644 ${p}`}case"invalid_value":return t.values.length===1?`\\u0645\\u062F\\u062E\\u0644\\u0627\\u062A \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644\\u0629: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0625\\u062F\\u062E\\u0627\\u0644 ${$(t.values[0])}`:`\\u0627\\u062E\\u062A\\u064A\\u0627\\u0631 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062A\\u0648\\u0642\\u0639 \\u0627\\u0646\\u062A\\u0642\\u0627\\u0621 \\u0623\\u062D\\u062F \\u0647\\u0630\\u0647 \\u0627\\u0644\\u062E\\u064A\\u0627\\u0631\\u0627\\u062A: ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?` \\u0623\\u0643\\u0628\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0644\\u0627\\u0632\\u0645: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0623\\u0646 \\u062A\\u0643\\u0648\\u0646 ${(m=t.origin)!=null?m:"\\u0627\\u0644\\u0642\\u064A\\u0645\\u0629"} ${i} ${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0639\\u0646\\u0635\\u0631"}`:`\\u0623\\u0643\\u0628\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0644\\u0627\\u0632\\u0645: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0623\\u0646 \\u062A\\u0643\\u0648\\u0646 ${(u=t.origin)!=null?u:"\\u0627\\u0644\\u0642\\u064A\\u0645\\u0629"} ${i} ${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u0623\\u0635\\u063A\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0644\\u0627\\u0632\\u0645: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0644\\u0640 ${t.origin} \\u0623\\u0646 \\u064A\\u0643\\u0648\\u0646 ${i} ${t.minimum.toString()} ${l.unit}`:`\\u0623\\u0635\\u063A\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0644\\u0627\\u0632\\u0645: \\u064A\\u0641\\u062A\\u0631\\u0636 \\u0644\\u0640 ${t.origin} \\u0623\\u0646 \\u064A\\u0643\\u0648\\u0646 ${i} ${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u0646\\u064E\\u0635 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062C\\u0628 \\u0623\\u0646 \\u064A\\u0628\\u062F\\u0623 \\u0628\\u0640 "${t.prefix}"`:i.format==="ends_with"?`\\u0646\\u064E\\u0635 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062C\\u0628 \\u0623\\u0646 \\u064A\\u0646\\u062A\\u0647\\u064A \\u0628\\u0640 "${i.suffix}"`:i.format==="includes"?`\\u0646\\u064E\\u0635 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062C\\u0628 \\u0623\\u0646 \\u064A\\u062A\\u0636\\u0645\\u0651\\u064E\\u0646 "${i.includes}"`:i.format==="regex"?`\\u0646\\u064E\\u0635 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062C\\u0628 \\u0623\\u0646 \\u064A\\u0637\\u0627\\u0628\\u0642 \\u0627\\u0644\\u0646\\u0645\\u0637 ${i.pattern}`:`${(d=n[i.format])!=null?d:t.format} \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644`}case"not_multiple_of":return`\\u0631\\u0642\\u0645 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644: \\u064A\\u062C\\u0628 \\u0623\\u0646 \\u064A\\u0643\\u0648\\u0646 \\u0645\\u0646 \\u0645\\u0636\\u0627\\u0639\\u0641\\u0627\\u062A ${t.divisor}`;case"unrecognized_keys":return`\\u0645\\u0639\\u0631\\u0641${t.keys.length>1?"\\u0627\\u062A":""} \\u063A\\u0631\\u064A\\u0628${t.keys.length>1?"\\u0629":""}: ${h(t.keys,"\\u060C ")}`;case"invalid_key":return`\\u0645\\u0639\\u0631\\u0641 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644 \\u0641\\u064A ${t.origin}`;case"invalid_union":return"\\u0645\\u062F\\u062E\\u0644 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644";case"invalid_element":return`\\u0645\\u062F\\u062E\\u0644 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644 \\u0641\\u064A ${t.origin}`;default:return"\\u0645\\u062F\\u062E\\u0644 \\u063A\\u064A\\u0631 \\u0645\\u0642\\u0628\\u0648\\u0644"}}};function Gu(){return{localeError:ep()}}var tp=()=>{let e={string:{unit:"simvol",verb:"olmal\\u0131d\\u0131r"},file:{unit:"bayt",verb:"olmal\\u0131d\\u0131r"},array:{unit:"element",verb:"olmal\\u0131d\\u0131r"},set:{unit:"element",verb:"olmal\\u0131d\\u0131r"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"input",email:"email address",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO datetime",date:"ISO date",time:"ISO time",duration:"ISO duration",ipv4:"IPv4 address",ipv6:"IPv6 address",cidrv4:"IPv4 range",cidrv6:"IPv6 range",base64:"base64-encoded string",base64url:"base64url-encoded string",json_string:"JSON string",e164:"E.164 number",jwt:"JWT",template_literal:"input"},o={nan:"NaN"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Yanl\\u0131\\u015F d\\u0259y\\u0259r: g\\xF6zl\\u0259nil\\u0259n instanceof ${t.expected}, daxil olan ${p}`:`Yanl\\u0131\\u015F d\\u0259y\\u0259r: g\\xF6zl\\u0259nil\\u0259n ${i}, daxil olan ${p}`}case"invalid_value":return t.values.length===1?`Yanl\\u0131\\u015F d\\u0259y\\u0259r: g\\xF6zl\\u0259nil\\u0259n ${$(t.values[0])}`:`Yanl\\u0131\\u015F se\\xE7im: a\\u015Fa\\u011F\\u0131dak\\u0131lardan biri olmal\\u0131d\\u0131r: ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\xC7ox b\\xF6y\\xFCk: g\\xF6zl\\u0259nil\\u0259n ${(m=t.origin)!=null?m:"d\\u0259y\\u0259r"} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"element"}`:`\\xC7ox b\\xF6y\\xFCk: g\\xF6zl\\u0259nil\\u0259n ${(u=t.origin)!=null?u:"d\\u0259y\\u0259r"} ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\xC7ox ki\\xE7ik: g\\xF6zl\\u0259nil\\u0259n ${t.origin} ${i}${t.minimum.toString()} ${l.unit}`:`\\xC7ox ki\\xE7ik: g\\xF6zl\\u0259nil\\u0259n ${t.origin} ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Yanl\\u0131\\u015F m\\u0259tn: "${i.prefix}" il\\u0259 ba\\u015Flamal\\u0131d\\u0131r`:i.format==="ends_with"?`Yanl\\u0131\\u015F m\\u0259tn: "${i.suffix}" il\\u0259 bitm\\u0259lidir`:i.format==="includes"?`Yanl\\u0131\\u015F m\\u0259tn: "${i.includes}" daxil olmal\\u0131d\\u0131r`:i.format==="regex"?`Yanl\\u0131\\u015F m\\u0259tn: ${i.pattern} \\u015Fablonuna uy\\u011Fun olmal\\u0131d\\u0131r`:`Yanl\\u0131\\u015F ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Yanl\\u0131\\u015F \\u0259d\\u0259d: ${t.divisor} il\\u0259 b\\xF6l\\xFCn\\u0259 bil\\u0259n olmal\\u0131d\\u0131r`;case"unrecognized_keys":return`Tan\\u0131nmayan a\\xE7ar${t.keys.length>1?"lar":""}: ${h(t.keys,", ")}`;case"invalid_key":return`${t.origin} daxilind\\u0259 yanl\\u0131\\u015F a\\xE7ar`;case"invalid_union":return"Yanl\\u0131\\u015F d\\u0259y\\u0259r";case"invalid_element":return`${t.origin} daxilind\\u0259 yanl\\u0131\\u015F d\\u0259y\\u0259r`;default:return"Yanl\\u0131\\u015F d\\u0259y\\u0259r"}}};function Wu(){return{localeError:tp()}}function qu(e,r,n,o){let t=Math.abs(e),a=t%10,c=t%100;return c>=11&&c<=19?o:a===1?r:a>=2&&a<=4?n:o}var rp=()=>{let e={string:{unit:{one:"\\u0441\\u0456\\u043C\\u0432\\u0430\\u043B",few:"\\u0441\\u0456\\u043C\\u0432\\u0430\\u043B\\u044B",many:"\\u0441\\u0456\\u043C\\u0432\\u0430\\u043B\\u0430\\u045E"},verb:"\\u043C\\u0435\\u0446\\u044C"},array:{unit:{one:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442",few:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u044B",many:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430\\u045E"},verb:"\\u043C\\u0435\\u0446\\u044C"},set:{unit:{one:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442",few:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u044B",many:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430\\u045E"},verb:"\\u043C\\u0435\\u0446\\u044C"},file:{unit:{one:"\\u0431\\u0430\\u0439\\u0442",few:"\\u0431\\u0430\\u0439\\u0442\\u044B",many:"\\u0431\\u0430\\u0439\\u0442\\u0430\\u045E"},verb:"\\u043C\\u0435\\u0446\\u044C"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0443\\u0432\\u043E\\u0434",email:"email \\u0430\\u0434\\u0440\\u0430\\u0441",url:"URL",emoji:"\\u044D\\u043C\\u043E\\u0434\\u0437\\u0456",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO \\u0434\\u0430\\u0442\\u0430 \\u0456 \\u0447\\u0430\\u0441",date:"ISO \\u0434\\u0430\\u0442\\u0430",time:"ISO \\u0447\\u0430\\u0441",duration:"ISO \\u043F\\u0440\\u0430\\u0446\\u044F\\u0433\\u043B\\u0430\\u0441\\u0446\\u044C",ipv4:"IPv4 \\u0430\\u0434\\u0440\\u0430\\u0441",ipv6:"IPv6 \\u0430\\u0434\\u0440\\u0430\\u0441",cidrv4:"IPv4 \\u0434\\u044B\\u044F\\u043F\\u0430\\u0437\\u043E\\u043D",cidrv6:"IPv6 \\u0434\\u044B\\u044F\\u043F\\u0430\\u0437\\u043E\\u043D",base64:"\\u0440\\u0430\\u0434\\u043E\\u043A \\u0443 \\u0444\\u0430\\u0440\\u043C\\u0430\\u0446\\u0435 base64",base64url:"\\u0440\\u0430\\u0434\\u043E\\u043A \\u0443 \\u0444\\u0430\\u0440\\u043C\\u0430\\u0446\\u0435 base64url",json_string:"JSON \\u0440\\u0430\\u0434\\u043E\\u043A",e164:"\\u043D\\u0443\\u043C\\u0430\\u0440 E.164",jwt:"JWT",template_literal:"\\u0443\\u0432\\u043E\\u0434"},o={nan:"NaN",number:"\\u043B\\u0456\\u043A",array:"\\u043C\\u0430\\u0441\\u0456\\u045E"};return t=>{var a,c,m,s,u;switch(t.code){case"invalid_type":{let d=(a=o[t.expected])!=null?a:t.expected,i=x(t.input),l=(c=o[i])!=null?c:i;return/^[A-Z]/.test(t.expected)?`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u045E\\u0432\\u043E\\u0434: \\u0447\\u0430\\u043A\\u0430\\u045E\\u0441\\u044F instanceof ${t.expected}, \\u0430\\u0442\\u0440\\u044B\\u043C\\u0430\\u043D\\u0430 ${l}`:`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u045E\\u0432\\u043E\\u0434: \\u0447\\u0430\\u043A\\u0430\\u045E\\u0441\\u044F ${d}, \\u0430\\u0442\\u0440\\u044B\\u043C\\u0430\\u043D\\u0430 ${l}`}case"invalid_value":return t.values.length===1?`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u045E\\u0432\\u043E\\u0434: \\u0447\\u0430\\u043A\\u0430\\u043B\\u0430\\u0441\\u044F ${$(t.values[0])}`:`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u0432\\u0430\\u0440\\u044B\\u044F\\u043D\\u0442: \\u0447\\u0430\\u043A\\u0430\\u045E\\u0441\\u044F \\u0430\\u0434\\u0437\\u0456\\u043D \\u0437 ${h(t.values,"|")}`;case"too_big":{let d=t.inclusive?"<=":"<",i=r(t.origin);if(i){let l=Number(t.maximum),p=qu(l,i.unit.one,i.unit.few,i.unit.many);return`\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u0430 \\u0432\\u044F\\u043B\\u0456\\u043A\\u0456: \\u0447\\u0430\\u043A\\u0430\\u043B\\u0430\\u0441\\u044F, \\u0448\\u0442\\u043E ${(m=t.origin)!=null?m:"\\u0437\\u043D\\u0430\\u0447\\u044D\\u043D\\u043D\\u0435"} \\u043F\\u0430\\u0432\\u0456\\u043D\\u043D\\u0430 ${i.verb} ${d}${t.maximum.toString()} ${p}`}return`\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u0430 \\u0432\\u044F\\u043B\\u0456\\u043A\\u0456: \\u0447\\u0430\\u043A\\u0430\\u043B\\u0430\\u0441\\u044F, \\u0448\\u0442\\u043E ${(s=t.origin)!=null?s:"\\u0437\\u043D\\u0430\\u0447\\u044D\\u043D\\u043D\\u0435"} \\u043F\\u0430\\u0432\\u0456\\u043D\\u043D\\u0430 \\u0431\\u044B\\u0446\\u044C ${d}${t.maximum.toString()}`}case"too_small":{let d=t.inclusive?">=":">",i=r(t.origin);if(i){let l=Number(t.minimum),p=qu(l,i.unit.one,i.unit.few,i.unit.many);return`\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u0430 \\u043C\\u0430\\u043B\\u044B: \\u0447\\u0430\\u043A\\u0430\\u043B\\u0430\\u0441\\u044F, \\u0448\\u0442\\u043E ${t.origin} \\u043F\\u0430\\u0432\\u0456\\u043D\\u043D\\u0430 ${i.verb} ${d}${t.minimum.toString()} ${p}`}return`\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u0430 \\u043C\\u0430\\u043B\\u044B: \\u0447\\u0430\\u043A\\u0430\\u043B\\u0430\\u0441\\u044F, \\u0448\\u0442\\u043E ${t.origin} \\u043F\\u0430\\u0432\\u0456\\u043D\\u043D\\u0430 \\u0431\\u044B\\u0446\\u044C ${d}${t.minimum.toString()}`}case"invalid_format":{let d=t;return d.format==="starts_with"?`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u0440\\u0430\\u0434\\u043E\\u043A: \\u043F\\u0430\\u0432\\u0456\\u043D\\u0435\\u043D \\u043F\\u0430\\u0447\\u044B\\u043D\\u0430\\u0446\\u0446\\u0430 \\u0437 "${d.prefix}"`:d.format==="ends_with"?`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u0440\\u0430\\u0434\\u043E\\u043A: \\u043F\\u0430\\u0432\\u0456\\u043D\\u0435\\u043D \\u0437\\u0430\\u043A\\u0430\\u043D\\u0447\\u0432\\u0430\\u0446\\u0446\\u0430 \\u043D\\u0430 "${d.suffix}"`:d.format==="includes"?`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u0440\\u0430\\u0434\\u043E\\u043A: \\u043F\\u0430\\u0432\\u0456\\u043D\\u0435\\u043D \\u0437\\u043C\\u044F\\u0448\\u0447\\u0430\\u0446\\u044C "${d.includes}"`:d.format==="regex"?`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u0440\\u0430\\u0434\\u043E\\u043A: \\u043F\\u0430\\u0432\\u0456\\u043D\\u0435\\u043D \\u0430\\u0434\\u043F\\u0430\\u0432\\u044F\\u0434\\u0430\\u0446\\u044C \\u0448\\u0430\\u0431\\u043B\\u043E\\u043D\\u0443 ${d.pattern}`:`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B ${(u=n[d.format])!=null?u:t.format}`}case"not_multiple_of":return`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u043B\\u0456\\u043A: \\u043F\\u0430\\u0432\\u0456\\u043D\\u0435\\u043D \\u0431\\u044B\\u0446\\u044C \\u043A\\u0440\\u0430\\u0442\\u043D\\u044B\\u043C ${t.divisor}`;case"unrecognized_keys":return`\\u041D\\u0435\\u0440\\u0430\\u0441\\u043F\\u0430\\u0437\\u043D\\u0430\\u043D\\u044B ${t.keys.length>1?"\\u043A\\u043B\\u044E\\u0447\\u044B":"\\u043A\\u043B\\u044E\\u0447"}: ${h(t.keys,", ")}`;case"invalid_key":return`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u043A\\u043B\\u044E\\u0447 \\u0443 ${t.origin}`;case"invalid_union":return"\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u045E\\u0432\\u043E\\u0434";case"invalid_element":return`\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u0430\\u0435 \\u0437\\u043D\\u0430\\u0447\\u044D\\u043D\\u043D\\u0435 \\u045E ${t.origin}`;default:return"\\u041D\\u044F\\u043F\\u0440\\u0430\\u0432\\u0456\\u043B\\u044C\\u043D\\u044B \\u045E\\u0432\\u043E\\u0434"}}};function Xu(){return{localeError:rp()}}var np=()=>{let e={string:{unit:"\\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u0430",verb:"\\u0434\\u0430 \\u0441\\u044A\\u0434\\u044A\\u0440\\u0436\\u0430"},file:{unit:"\\u0431\\u0430\\u0439\\u0442\\u0430",verb:"\\u0434\\u0430 \\u0441\\u044A\\u0434\\u044A\\u0440\\u0436\\u0430"},array:{unit:"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430",verb:"\\u0434\\u0430 \\u0441\\u044A\\u0434\\u044A\\u0440\\u0436\\u0430"},set:{unit:"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430",verb:"\\u0434\\u0430 \\u0441\\u044A\\u0434\\u044A\\u0440\\u0436\\u0430"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0432\\u0445\\u043E\\u0434",email:"\\u0438\\u043C\\u0435\\u0439\\u043B \\u0430\\u0434\\u0440\\u0435\\u0441",url:"URL",emoji:"\\u0435\\u043C\\u043E\\u0434\\u0436\\u0438",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO \\u0432\\u0440\\u0435\\u043C\\u0435",date:"ISO \\u0434\\u0430\\u0442\\u0430",time:"ISO \\u0432\\u0440\\u0435\\u043C\\u0435",duration:"ISO \\u043F\\u0440\\u043E\\u0434\\u044A\\u043B\\u0436\\u0438\\u0442\\u0435\\u043B\\u043D\\u043E\\u0441\\u0442",ipv4:"IPv4 \\u0430\\u0434\\u0440\\u0435\\u0441",ipv6:"IPv6 \\u0430\\u0434\\u0440\\u0435\\u0441",cidrv4:"IPv4 \\u0434\\u0438\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D",cidrv6:"IPv6 \\u0434\\u0438\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D",base64:"base64-\\u043A\\u043E\\u0434\\u0438\\u0440\\u0430\\u043D \\u043D\\u0438\\u0437",base64url:"base64url-\\u043A\\u043E\\u0434\\u0438\\u0440\\u0430\\u043D \\u043D\\u0438\\u0437",json_string:"JSON \\u043D\\u0438\\u0437",e164:"E.164 \\u043D\\u043E\\u043C\\u0435\\u0440",jwt:"JWT",template_literal:"\\u0432\\u0445\\u043E\\u0434"},o={nan:"NaN",number:"\\u0447\\u0438\\u0441\\u043B\\u043E",array:"\\u043C\\u0430\\u0441\\u0438\\u0432"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u0432\\u0445\\u043E\\u0434: \\u043E\\u0447\\u0430\\u043A\\u0432\\u0430\\u043D instanceof ${t.expected}, \\u043F\\u043E\\u043B\\u0443\\u0447\\u0435\\u043D ${p}`:`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u0432\\u0445\\u043E\\u0434: \\u043E\\u0447\\u0430\\u043A\\u0432\\u0430\\u043D ${i}, \\u043F\\u043E\\u043B\\u0443\\u0447\\u0435\\u043D ${p}`}case"invalid_value":return t.values.length===1?`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u0432\\u0445\\u043E\\u0434: \\u043E\\u0447\\u0430\\u043A\\u0432\\u0430\\u043D ${$(t.values[0])}`:`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u0430 \\u043E\\u043F\\u0446\\u0438\\u044F: \\u043E\\u0447\\u0430\\u043A\\u0432\\u0430\\u043D\\u043E \\u0435\\u0434\\u043D\\u043E \\u043E\\u0442 ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u0422\\u0432\\u044A\\u0440\\u0434\\u0435 \\u0433\\u043E\\u043B\\u044F\\u043C\\u043E: \\u043E\\u0447\\u0430\\u043A\\u0432\\u0430 \\u0441\\u0435 ${(m=t.origin)!=null?m:"\\u0441\\u0442\\u043E\\u0439\\u043D\\u043E\\u0441\\u0442"} \\u0434\\u0430 \\u0441\\u044A\\u0434\\u044A\\u0440\\u0436\\u0430 ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430"}`:`\\u0422\\u0432\\u044A\\u0440\\u0434\\u0435 \\u0433\\u043E\\u043B\\u044F\\u043C\\u043E: \\u043E\\u0447\\u0430\\u043A\\u0432\\u0430 \\u0441\\u0435 ${(u=t.origin)!=null?u:"\\u0441\\u0442\\u043E\\u0439\\u043D\\u043E\\u0441\\u0442"} \\u0434\\u0430 \\u0431\\u044A\\u0434\\u0435 ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u0422\\u0432\\u044A\\u0440\\u0434\\u0435 \\u043C\\u0430\\u043B\\u043A\\u043E: \\u043E\\u0447\\u0430\\u043A\\u0432\\u0430 \\u0441\\u0435 ${t.origin} \\u0434\\u0430 \\u0441\\u044A\\u0434\\u044A\\u0440\\u0436\\u0430 ${i}${t.minimum.toString()} ${l.unit}`:`\\u0422\\u0432\\u044A\\u0440\\u0434\\u0435 \\u043C\\u0430\\u043B\\u043A\\u043E: \\u043E\\u0447\\u0430\\u043A\\u0432\\u0430 \\u0441\\u0435 ${t.origin} \\u0434\\u0430 \\u0431\\u044A\\u0434\\u0435 ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;if(i.format==="starts_with")return`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u043D\\u0438\\u0437: \\u0442\\u0440\\u044F\\u0431\\u0432\\u0430 \\u0434\\u0430 \\u0437\\u0430\\u043F\\u043E\\u0447\\u0432\\u0430 \\u0441 "${i.prefix}"`;if(i.format==="ends_with")return`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u043D\\u0438\\u0437: \\u0442\\u0440\\u044F\\u0431\\u0432\\u0430 \\u0434\\u0430 \\u0437\\u0430\\u0432\\u044A\\u0440\\u0448\\u0432\\u0430 \\u0441 "${i.suffix}"`;if(i.format==="includes")return`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u043D\\u0438\\u0437: \\u0442\\u0440\\u044F\\u0431\\u0432\\u0430 \\u0434\\u0430 \\u0432\\u043A\\u043B\\u044E\\u0447\\u0432\\u0430 "${i.includes}"`;if(i.format==="regex")return`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u043D\\u0438\\u0437: \\u0442\\u0440\\u044F\\u0431\\u0432\\u0430 \\u0434\\u0430 \\u0441\\u044A\\u0432\\u043F\\u0430\\u0434\\u0430 \\u0441 ${i.pattern}`;let l="\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D";return i.format==="emoji"&&(l="\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u043E"),i.format==="datetime"&&(l="\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u043E"),i.format==="date"&&(l="\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u0430"),i.format==="time"&&(l="\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u043E"),i.format==="duration"&&(l="\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u0430"),`${l} ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u043E \\u0447\\u0438\\u0441\\u043B\\u043E: \\u0442\\u0440\\u044F\\u0431\\u0432\\u0430 \\u0434\\u0430 \\u0431\\u044A\\u0434\\u0435 \\u043A\\u0440\\u0430\\u0442\\u043D\\u043E \\u043D\\u0430 ${t.divisor}`;case"unrecognized_keys":return`\\u041D\\u0435\\u0440\\u0430\\u0437\\u043F\\u043E\\u0437\\u043D\\u0430\\u0442${t.keys.length>1?"\\u0438":""} \\u043A\\u043B\\u044E\\u0447${t.keys.length>1?"\\u043E\\u0432\\u0435":""}: ${h(t.keys,", ")}`;case"invalid_key":return`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u043A\\u043B\\u044E\\u0447 \\u0432 ${t.origin}`;case"invalid_union":return"\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u0432\\u0445\\u043E\\u0434";case"invalid_element":return`\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u0430 \\u0441\\u0442\\u043E\\u0439\\u043D\\u043E\\u0441\\u0442 \\u0432 ${t.origin}`;default:return"\\u041D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u0435\\u043D \\u0432\\u0445\\u043E\\u0434"}}};function Qu(){return{localeError:np()}}var op=()=>{let e={string:{unit:"car\\xE0cters",verb:"contenir"},file:{unit:"bytes",verb:"contenir"},array:{unit:"elements",verb:"contenir"},set:{unit:"elements",verb:"contenir"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"entrada",email:"adre\\xE7a electr\\xF2nica",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"data i hora ISO",date:"data ISO",time:"hora ISO",duration:"durada ISO",ipv4:"adre\\xE7a IPv4",ipv6:"adre\\xE7a IPv6",cidrv4:"rang IPv4",cidrv6:"rang IPv6",base64:"cadena codificada en base64",base64url:"cadena codificada en base64url",json_string:"cadena JSON",e164:"n\\xFAmero E.164",jwt:"JWT",template_literal:"entrada"},o={nan:"NaN"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Tipus inv\\xE0lid: s\'esperava instanceof ${t.expected}, s\'ha rebut ${p}`:`Tipus inv\\xE0lid: s\'esperava ${i}, s\'ha rebut ${p}`}case"invalid_value":return t.values.length===1?`Valor inv\\xE0lid: s\'esperava ${$(t.values[0])}`:`Opci\\xF3 inv\\xE0lida: s\'esperava una de ${h(t.values," o ")}`;case"too_big":{let i=t.inclusive?"com a m\\xE0xim":"menys de",l=r(t.origin);return l?`Massa gran: s\'esperava que ${(m=t.origin)!=null?m:"el valor"} contingu\\xE9s ${i} ${t.maximum.toString()} ${(s=l.unit)!=null?s:"elements"}`:`Massa gran: s\'esperava que ${(u=t.origin)!=null?u:"el valor"} fos ${i} ${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?"com a m\\xEDnim":"m\\xE9s de",l=r(t.origin);return l?`Massa petit: s\'esperava que ${t.origin} contingu\\xE9s ${i} ${t.minimum.toString()} ${l.unit}`:`Massa petit: s\'esperava que ${t.origin} fos ${i} ${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Format inv\\xE0lid: ha de comen\\xE7ar amb "${i.prefix}"`:i.format==="ends_with"?`Format inv\\xE0lid: ha d\'acabar amb "${i.suffix}"`:i.format==="includes"?`Format inv\\xE0lid: ha d\'incloure "${i.includes}"`:i.format==="regex"?`Format inv\\xE0lid: ha de coincidir amb el patr\\xF3 ${i.pattern}`:`Format inv\\xE0lid per a ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`N\\xFAmero inv\\xE0lid: ha de ser m\\xFAltiple de ${t.divisor}`;case"unrecognized_keys":return`Clau${t.keys.length>1?"s":""} no reconeguda${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`Clau inv\\xE0lida a ${t.origin}`;case"invalid_union":return"Entrada inv\\xE0lida";case"invalid_element":return`Element inv\\xE0lid a ${t.origin}`;default:return"Entrada inv\\xE0lida"}}};function Yu(){return{localeError:op()}}var ip=()=>{let e={string:{unit:"znak\\u016F",verb:"m\\xEDt"},file:{unit:"bajt\\u016F",verb:"m\\xEDt"},array:{unit:"prvk\\u016F",verb:"m\\xEDt"},set:{unit:"prvk\\u016F",verb:"m\\xEDt"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"regul\\xE1rn\\xED v\\xFDraz",email:"e-mailov\\xE1 adresa",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"datum a \\u010Das ve form\\xE1tu ISO",date:"datum ve form\\xE1tu ISO",time:"\\u010Das ve form\\xE1tu ISO",duration:"doba trv\\xE1n\\xED ISO",ipv4:"IPv4 adresa",ipv6:"IPv6 adresa",cidrv4:"rozsah IPv4",cidrv6:"rozsah IPv6",base64:"\\u0159et\\u011Bzec zak\\xF3dovan\\xFD ve form\\xE1tu base64",base64url:"\\u0159et\\u011Bzec zak\\xF3dovan\\xFD ve form\\xE1tu base64url",json_string:"\\u0159et\\u011Bzec ve form\\xE1tu JSON",e164:"\\u010D\\xEDslo E.164",jwt:"JWT",template_literal:"vstup"},o={nan:"NaN",number:"\\u010D\\xEDslo",string:"\\u0159et\\u011Bzec",function:"funkce",array:"pole"};return t=>{var a,c,m,s,u,d,i,l,p;switch(t.code){case"invalid_type":{let v=(a=o[t.expected])!=null?a:t.expected,y=x(t.input),S=(c=o[y])!=null?c:y;return/^[A-Z]/.test(t.expected)?`Neplatn\\xFD vstup: o\\u010Dek\\xE1v\\xE1no instanceof ${t.expected}, obdr\\u017Eeno ${S}`:`Neplatn\\xFD vstup: o\\u010Dek\\xE1v\\xE1no ${v}, obdr\\u017Eeno ${S}`}case"invalid_value":return t.values.length===1?`Neplatn\\xFD vstup: o\\u010Dek\\xE1v\\xE1no ${$(t.values[0])}`:`Neplatn\\xE1 mo\\u017Enost: o\\u010Dek\\xE1v\\xE1na jedna z hodnot ${h(t.values,"|")}`;case"too_big":{let v=t.inclusive?"<=":"<",y=r(t.origin);return y?`Hodnota je p\\u0159\\xEDli\\u0161 velk\\xE1: ${(m=t.origin)!=null?m:"hodnota"} mus\\xED m\\xEDt ${v}${t.maximum.toString()} ${(s=y.unit)!=null?s:"prvk\\u016F"}`:`Hodnota je p\\u0159\\xEDli\\u0161 velk\\xE1: ${(u=t.origin)!=null?u:"hodnota"} mus\\xED b\\xFDt ${v}${t.maximum.toString()}`}case"too_small":{let v=t.inclusive?">=":">",y=r(t.origin);return y?`Hodnota je p\\u0159\\xEDli\\u0161 mal\\xE1: ${(d=t.origin)!=null?d:"hodnota"} mus\\xED m\\xEDt ${v}${t.minimum.toString()} ${(i=y.unit)!=null?i:"prvk\\u016F"}`:`Hodnota je p\\u0159\\xEDli\\u0161 mal\\xE1: ${(l=t.origin)!=null?l:"hodnota"} mus\\xED b\\xFDt ${v}${t.minimum.toString()}`}case"invalid_format":{let v=t;return v.format==="starts_with"?`Neplatn\\xFD \\u0159et\\u011Bzec: mus\\xED za\\u010D\\xEDnat na "${v.prefix}"`:v.format==="ends_with"?`Neplatn\\xFD \\u0159et\\u011Bzec: mus\\xED kon\\u010Dit na "${v.suffix}"`:v.format==="includes"?`Neplatn\\xFD \\u0159et\\u011Bzec: mus\\xED obsahovat "${v.includes}"`:v.format==="regex"?`Neplatn\\xFD \\u0159et\\u011Bzec: mus\\xED odpov\\xEDdat vzoru ${v.pattern}`:`Neplatn\\xFD form\\xE1t ${(p=n[v.format])!=null?p:t.format}`}case"not_multiple_of":return`Neplatn\\xE9 \\u010D\\xEDslo: mus\\xED b\\xFDt n\\xE1sobkem ${t.divisor}`;case"unrecognized_keys":return`Nezn\\xE1m\\xE9 kl\\xED\\u010De: ${h(t.keys,", ")}`;case"invalid_key":return`Neplatn\\xFD kl\\xED\\u010D v ${t.origin}`;case"invalid_union":return"Neplatn\\xFD vstup";case"invalid_element":return`Neplatn\\xE1 hodnota v ${t.origin}`;default:return"Neplatn\\xFD vstup"}}};function Hu(){return{localeError:ip()}}var ap=()=>{let e={string:{unit:"tegn",verb:"havde"},file:{unit:"bytes",verb:"havde"},array:{unit:"elementer",verb:"indeholdt"},set:{unit:"elementer",verb:"indeholdt"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"input",email:"e-mailadresse",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO dato- og klokkesl\\xE6t",date:"ISO-dato",time:"ISO-klokkesl\\xE6t",duration:"ISO-varighed",ipv4:"IPv4-omr\\xE5de",ipv6:"IPv6-omr\\xE5de",cidrv4:"IPv4-spektrum",cidrv6:"IPv6-spektrum",base64:"base64-kodet streng",base64url:"base64url-kodet streng",json_string:"JSON-streng",e164:"E.164-nummer",jwt:"JWT",template_literal:"input"},o={nan:"NaN",string:"streng",number:"tal",boolean:"boolean",array:"liste",object:"objekt",set:"s\\xE6t",file:"fil"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Ugyldigt input: forventede instanceof ${t.expected}, fik ${p}`:`Ugyldigt input: forventede ${i}, fik ${p}`}case"invalid_value":return t.values.length===1?`Ugyldig v\\xE6rdi: forventede ${$(t.values[0])}`:`Ugyldigt valg: forventede en af f\\xF8lgende ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin),p=(m=o[t.origin])!=null?m:t.origin;return l?`For stor: forventede ${p!=null?p:"value"} ${l.verb} ${i} ${t.maximum.toString()} ${(s=l.unit)!=null?s:"elementer"}`:`For stor: forventede ${p!=null?p:"value"} havde ${i} ${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin),p=(u=o[t.origin])!=null?u:t.origin;return l?`For lille: forventede ${p} ${l.verb} ${i} ${t.minimum.toString()} ${l.unit}`:`For lille: forventede ${p} havde ${i} ${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Ugyldig streng: skal starte med "${i.prefix}"`:i.format==="ends_with"?`Ugyldig streng: skal ende med "${i.suffix}"`:i.format==="includes"?`Ugyldig streng: skal indeholde "${i.includes}"`:i.format==="regex"?`Ugyldig streng: skal matche m\\xF8nsteret ${i.pattern}`:`Ugyldig ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Ugyldigt tal: skal v\\xE6re deleligt med ${t.divisor}`;case"unrecognized_keys":return`${t.keys.length>1?"Ukendte n\\xF8gler":"Ukendt n\\xF8gle"}: ${h(t.keys,", ")}`;case"invalid_key":return`Ugyldig n\\xF8gle i ${t.origin}`;case"invalid_union":return"Ugyldigt input: matcher ingen af de tilladte typer";case"invalid_element":return`Ugyldig v\\xE6rdi i ${t.origin}`;default:return"Ugyldigt input"}}};function el(){return{localeError:ap()}}var cp=()=>{let e={string:{unit:"Zeichen",verb:"zu haben"},file:{unit:"Bytes",verb:"zu haben"},array:{unit:"Elemente",verb:"zu haben"},set:{unit:"Elemente",verb:"zu haben"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"Eingabe",email:"E-Mail-Adresse",url:"URL",emoji:"Emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO-Datum und -Uhrzeit",date:"ISO-Datum",time:"ISO-Uhrzeit",duration:"ISO-Dauer",ipv4:"IPv4-Adresse",ipv6:"IPv6-Adresse",cidrv4:"IPv4-Bereich",cidrv6:"IPv6-Bereich",base64:"Base64-codierter String",base64url:"Base64-URL-codierter String",json_string:"JSON-String",e164:"E.164-Nummer",jwt:"JWT",template_literal:"Eingabe"},o={nan:"NaN",number:"Zahl",array:"Array"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Ung\\xFCltige Eingabe: erwartet instanceof ${t.expected}, erhalten ${p}`:`Ung\\xFCltige Eingabe: erwartet ${i}, erhalten ${p}`}case"invalid_value":return t.values.length===1?`Ung\\xFCltige Eingabe: erwartet ${$(t.values[0])}`:`Ung\\xFCltige Option: erwartet eine von ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Zu gro\\xDF: erwartet, dass ${(m=t.origin)!=null?m:"Wert"} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"Elemente"} hat`:`Zu gro\\xDF: erwartet, dass ${(u=t.origin)!=null?u:"Wert"} ${i}${t.maximum.toString()} ist`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Zu klein: erwartet, dass ${t.origin} ${i}${t.minimum.toString()} ${l.unit} hat`:`Zu klein: erwartet, dass ${t.origin} ${i}${t.minimum.toString()} ist`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Ung\\xFCltiger String: muss mit "${i.prefix}" beginnen`:i.format==="ends_with"?`Ung\\xFCltiger String: muss mit "${i.suffix}" enden`:i.format==="includes"?`Ung\\xFCltiger String: muss "${i.includes}" enthalten`:i.format==="regex"?`Ung\\xFCltiger String: muss dem Muster ${i.pattern} entsprechen`:`Ung\\xFCltig: ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Ung\\xFCltige Zahl: muss ein Vielfaches von ${t.divisor} sein`;case"unrecognized_keys":return`${t.keys.length>1?"Unbekannte Schl\\xFCssel":"Unbekannter Schl\\xFCssel"}: ${h(t.keys,", ")}`;case"invalid_key":return`Ung\\xFCltiger Schl\\xFCssel in ${t.origin}`;case"invalid_union":return"Ung\\xFCltige Eingabe";case"invalid_element":return`Ung\\xFCltiger Wert in ${t.origin}`;default:return"Ung\\xFCltige Eingabe"}}};function tl(){return{localeError:cp()}}var up=()=>{let e={string:{unit:"characters",verb:"to have"},file:{unit:"bytes",verb:"to have"},array:{unit:"items",verb:"to have"},set:{unit:"items",verb:"to have"},map:{unit:"entries",verb:"to have"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"input",email:"email address",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO datetime",date:"ISO date",time:"ISO time",duration:"ISO duration",ipv4:"IPv4 address",ipv6:"IPv6 address",mac:"MAC address",cidrv4:"IPv4 range",cidrv6:"IPv6 range",base64:"base64-encoded string",base64url:"base64url-encoded string",json_string:"JSON string",e164:"E.164 number",jwt:"JWT",template_literal:"input"},o={nan:"NaN"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return`Invalid input: expected ${i}, received ${p}`}case"invalid_value":return t.values.length===1?`Invalid input: expected ${$(t.values[0])}`:`Invalid option: expected one of ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Too big: expected ${(m=t.origin)!=null?m:"value"} to have ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elements"}`:`Too big: expected ${(u=t.origin)!=null?u:"value"} to be ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Too small: expected ${t.origin} to have ${i}${t.minimum.toString()} ${l.unit}`:`Too small: expected ${t.origin} to be ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Invalid string: must start with "${i.prefix}"`:i.format==="ends_with"?`Invalid string: must end with "${i.suffix}"`:i.format==="includes"?`Invalid string: must include "${i.includes}"`:i.format==="regex"?`Invalid string: must match pattern ${i.pattern}`:`Invalid ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Invalid number: must be a multiple of ${t.divisor}`;case"unrecognized_keys":return`Unrecognized key${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`Invalid key in ${t.origin}`;case"invalid_union":return"Invalid input";case"invalid_element":return`Invalid value in ${t.origin}`;default:return"Invalid input"}}};function yr(){return{localeError:up()}}var lp=()=>{let e={string:{unit:"karaktrojn",verb:"havi"},file:{unit:"bajtojn",verb:"havi"},array:{unit:"elementojn",verb:"havi"},set:{unit:"elementojn",verb:"havi"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"enigo",email:"retadreso",url:"URL",emoji:"emo\\u011Dio",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO-datotempo",date:"ISO-dato",time:"ISO-tempo",duration:"ISO-da\\u016Dro",ipv4:"IPv4-adreso",ipv6:"IPv6-adreso",cidrv4:"IPv4-rango",cidrv6:"IPv6-rango",base64:"64-ume kodita karaktraro",base64url:"URL-64-ume kodita karaktraro",json_string:"JSON-karaktraro",e164:"E.164-nombro",jwt:"JWT",template_literal:"enigo"},o={nan:"NaN",number:"nombro",array:"tabelo",null:"senvalora"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Nevalida enigo: atendi\\u011Dis instanceof ${t.expected}, ricevi\\u011Dis ${p}`:`Nevalida enigo: atendi\\u011Dis ${i}, ricevi\\u011Dis ${p}`}case"invalid_value":return t.values.length===1?`Nevalida enigo: atendi\\u011Dis ${$(t.values[0])}`:`Nevalida opcio: atendi\\u011Dis unu el ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Tro granda: atendi\\u011Dis ke ${(m=t.origin)!=null?m:"valoro"} havu ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elementojn"}`:`Tro granda: atendi\\u011Dis ke ${(u=t.origin)!=null?u:"valoro"} havu ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Tro malgranda: atendi\\u011Dis ke ${t.origin} havu ${i}${t.minimum.toString()} ${l.unit}`:`Tro malgranda: atendi\\u011Dis ke ${t.origin} estu ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Nevalida karaktraro: devas komenci\\u011Di per "${i.prefix}"`:i.format==="ends_with"?`Nevalida karaktraro: devas fini\\u011Di per "${i.suffix}"`:i.format==="includes"?`Nevalida karaktraro: devas inkluzivi "${i.includes}"`:i.format==="regex"?`Nevalida karaktraro: devas kongrui kun la modelo ${i.pattern}`:`Nevalida ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Nevalida nombro: devas esti oblo de ${t.divisor}`;case"unrecognized_keys":return`Nekonata${t.keys.length>1?"j":""} \\u015Dlosilo${t.keys.length>1?"j":""}: ${h(t.keys,", ")}`;case"invalid_key":return`Nevalida \\u015Dlosilo en ${t.origin}`;case"invalid_union":return"Nevalida enigo";case"invalid_element":return`Nevalida valoro en ${t.origin}`;default:return"Nevalida enigo"}}};function rl(){return{localeError:lp()}}var sp=()=>{let e={string:{unit:"caracteres",verb:"tener"},file:{unit:"bytes",verb:"tener"},array:{unit:"elementos",verb:"tener"},set:{unit:"elementos",verb:"tener"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"entrada",email:"direcci\\xF3n de correo electr\\xF3nico",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"fecha y hora ISO",date:"fecha ISO",time:"hora ISO",duration:"duraci\\xF3n ISO",ipv4:"direcci\\xF3n IPv4",ipv6:"direcci\\xF3n IPv6",cidrv4:"rango IPv4",cidrv6:"rango IPv6",base64:"cadena codificada en base64",base64url:"URL codificada en base64",json_string:"cadena JSON",e164:"n\\xFAmero E.164",jwt:"JWT",template_literal:"entrada"},o={nan:"NaN",string:"texto",number:"n\\xFAmero",boolean:"booleano",array:"arreglo",object:"objeto",set:"conjunto",file:"archivo",date:"fecha",bigint:"n\\xFAmero grande",symbol:"s\\xEDmbolo",undefined:"indefinido",null:"nulo",function:"funci\\xF3n",map:"mapa",record:"registro",tuple:"tupla",enum:"enumeraci\\xF3n",union:"uni\\xF3n",literal:"literal",promise:"promesa",void:"vac\\xEDo",never:"nunca",unknown:"desconocido",any:"cualquiera"};return t=>{var a,c,m,s,u,d,i,l;switch(t.code){case"invalid_type":{let p=(a=o[t.expected])!=null?a:t.expected,v=x(t.input),y=(c=o[v])!=null?c:v;return/^[A-Z]/.test(t.expected)?`Entrada inv\\xE1lida: se esperaba instanceof ${t.expected}, recibido ${y}`:`Entrada inv\\xE1lida: se esperaba ${p}, recibido ${y}`}case"invalid_value":return t.values.length===1?`Entrada inv\\xE1lida: se esperaba ${$(t.values[0])}`:`Opci\\xF3n inv\\xE1lida: se esperaba una de ${h(t.values,"|")}`;case"too_big":{let p=t.inclusive?"<=":"<",v=r(t.origin),y=(m=o[t.origin])!=null?m:t.origin;return v?`Demasiado grande: se esperaba que ${y!=null?y:"valor"} tuviera ${p}${t.maximum.toString()} ${(s=v.unit)!=null?s:"elementos"}`:`Demasiado grande: se esperaba que ${y!=null?y:"valor"} fuera ${p}${t.maximum.toString()}`}case"too_small":{let p=t.inclusive?">=":">",v=r(t.origin),y=(u=o[t.origin])!=null?u:t.origin;return v?`Demasiado peque\\xF1o: se esperaba que ${y} tuviera ${p}${t.minimum.toString()} ${v.unit}`:`Demasiado peque\\xF1o: se esperaba que ${y} fuera ${p}${t.minimum.toString()}`}case"invalid_format":{let p=t;return p.format==="starts_with"?`Cadena inv\\xE1lida: debe comenzar con "${p.prefix}"`:p.format==="ends_with"?`Cadena inv\\xE1lida: debe terminar en "${p.suffix}"`:p.format==="includes"?`Cadena inv\\xE1lida: debe incluir "${p.includes}"`:p.format==="regex"?`Cadena inv\\xE1lida: debe coincidir con el patr\\xF3n ${p.pattern}`:`Inv\\xE1lido ${(d=n[p.format])!=null?d:t.format}`}case"not_multiple_of":return`N\\xFAmero inv\\xE1lido: debe ser m\\xFAltiplo de ${t.divisor}`;case"unrecognized_keys":return`Llave${t.keys.length>1?"s":""} desconocida${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`Llave inv\\xE1lida en ${(i=o[t.origin])!=null?i:t.origin}`;case"invalid_union":return"Entrada inv\\xE1lida";case"invalid_element":return`Valor inv\\xE1lido en ${(l=o[t.origin])!=null?l:t.origin}`;default:return"Entrada inv\\xE1lida"}}};function nl(){return{localeError:sp()}}var dp=()=>{let e={string:{unit:"\\u06A9\\u0627\\u0631\\u0627\\u06A9\\u062A\\u0631",verb:"\\u062F\\u0627\\u0634\\u062A\\u0647 \\u0628\\u0627\\u0634\\u062F"},file:{unit:"\\u0628\\u0627\\u06CC\\u062A",verb:"\\u062F\\u0627\\u0634\\u062A\\u0647 \\u0628\\u0627\\u0634\\u062F"},array:{unit:"\\u0622\\u06CC\\u062A\\u0645",verb:"\\u062F\\u0627\\u0634\\u062A\\u0647 \\u0628\\u0627\\u0634\\u062F"},set:{unit:"\\u0622\\u06CC\\u062A\\u0645",verb:"\\u062F\\u0627\\u0634\\u062A\\u0647 \\u0628\\u0627\\u0634\\u062F"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0648\\u0631\\u0648\\u062F\\u06CC",email:"\\u0622\\u062F\\u0631\\u0633 \\u0627\\u06CC\\u0645\\u06CC\\u0644",url:"URL",emoji:"\\u0627\\u06CC\\u0645\\u0648\\u062C\\u06CC",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"\\u062A\\u0627\\u0631\\u06CC\\u062E \\u0648 \\u0632\\u0645\\u0627\\u0646 \\u0627\\u06CC\\u0632\\u0648",date:"\\u062A\\u0627\\u0631\\u06CC\\u062E \\u0627\\u06CC\\u0632\\u0648",time:"\\u0632\\u0645\\u0627\\u0646 \\u0627\\u06CC\\u0632\\u0648",duration:"\\u0645\\u062F\\u062A \\u0632\\u0645\\u0627\\u0646 \\u0627\\u06CC\\u0632\\u0648",ipv4:"IPv4 \\u0622\\u062F\\u0631\\u0633",ipv6:"IPv6 \\u0622\\u062F\\u0631\\u0633",cidrv4:"IPv4 \\u062F\\u0627\\u0645\\u0646\\u0647",cidrv6:"IPv6 \\u062F\\u0627\\u0645\\u0646\\u0647",base64:"base64-encoded \\u0631\\u0634\\u062A\\u0647",base64url:"base64url-encoded \\u0631\\u0634\\u062A\\u0647",json_string:"JSON \\u0631\\u0634\\u062A\\u0647",e164:"E.164 \\u0639\\u062F\\u062F",jwt:"JWT",template_literal:"\\u0648\\u0631\\u0648\\u062F\\u06CC"},o={nan:"NaN",number:"\\u0639\\u062F\\u062F",array:"\\u0622\\u0631\\u0627\\u06CC\\u0647"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u0648\\u0631\\u0648\\u062F\\u06CC \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0645\\u06CC\\u200C\\u0628\\u0627\\u06CC\\u0633\\u062A instanceof ${t.expected} \\u0645\\u06CC\\u200C\\u0628\\u0648\\u062F\\u060C ${p} \\u062F\\u0631\\u06CC\\u0627\\u0641\\u062A \\u0634\\u062F`:`\\u0648\\u0631\\u0648\\u062F\\u06CC \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0645\\u06CC\\u200C\\u0628\\u0627\\u06CC\\u0633\\u062A ${i} \\u0645\\u06CC\\u200C\\u0628\\u0648\\u062F\\u060C ${p} \\u062F\\u0631\\u06CC\\u0627\\u0641\\u062A \\u0634\\u062F`}case"invalid_value":return t.values.length===1?`\\u0648\\u0631\\u0648\\u062F\\u06CC \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0645\\u06CC\\u200C\\u0628\\u0627\\u06CC\\u0633\\u062A ${$(t.values[0])} \\u0645\\u06CC\\u200C\\u0628\\u0648\\u062F`:`\\u06AF\\u0632\\u06CC\\u0646\\u0647 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0645\\u06CC\\u200C\\u0628\\u0627\\u06CC\\u0633\\u062A \\u06CC\\u06A9\\u06CC \\u0627\\u0632 ${h(t.values,"|")} \\u0645\\u06CC\\u200C\\u0628\\u0648\\u062F`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u062E\\u06CC\\u0644\\u06CC \\u0628\\u0632\\u0631\\u06AF: ${(m=t.origin)!=null?m:"\\u0645\\u0642\\u062F\\u0627\\u0631"} \\u0628\\u0627\\u06CC\\u062F ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0639\\u0646\\u0635\\u0631"} \\u0628\\u0627\\u0634\\u062F`:`\\u062E\\u06CC\\u0644\\u06CC \\u0628\\u0632\\u0631\\u06AF: ${(u=t.origin)!=null?u:"\\u0645\\u0642\\u062F\\u0627\\u0631"} \\u0628\\u0627\\u06CC\\u062F ${i}${t.maximum.toString()} \\u0628\\u0627\\u0634\\u062F`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u062E\\u06CC\\u0644\\u06CC \\u06A9\\u0648\\u0686\\u06A9: ${t.origin} \\u0628\\u0627\\u06CC\\u062F ${i}${t.minimum.toString()} ${l.unit} \\u0628\\u0627\\u0634\\u062F`:`\\u062E\\u06CC\\u0644\\u06CC \\u06A9\\u0648\\u0686\\u06A9: ${t.origin} \\u0628\\u0627\\u06CC\\u062F ${i}${t.minimum.toString()} \\u0628\\u0627\\u0634\\u062F`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u0631\\u0634\\u062A\\u0647 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0628\\u0627\\u06CC\\u062F \\u0628\\u0627 "${i.prefix}" \\u0634\\u0631\\u0648\\u0639 \\u0634\\u0648\\u062F`:i.format==="ends_with"?`\\u0631\\u0634\\u062A\\u0647 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0628\\u0627\\u06CC\\u062F \\u0628\\u0627 "${i.suffix}" \\u062A\\u0645\\u0627\\u0645 \\u0634\\u0648\\u062F`:i.format==="includes"?`\\u0631\\u0634\\u062A\\u0647 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0628\\u0627\\u06CC\\u062F \\u0634\\u0627\\u0645\\u0644 "${i.includes}" \\u0628\\u0627\\u0634\\u062F`:i.format==="regex"?`\\u0631\\u0634\\u062A\\u0647 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0628\\u0627\\u06CC\\u062F \\u0628\\u0627 \\u0627\\u0644\\u06AF\\u0648\\u06CC ${i.pattern} \\u0645\\u0637\\u0627\\u0628\\u0642\\u062A \\u062F\\u0627\\u0634\\u062A\\u0647 \\u0628\\u0627\\u0634\\u062F`:`${(d=n[i.format])!=null?d:t.format} \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631`}case"not_multiple_of":return`\\u0639\\u062F\\u062F \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631: \\u0628\\u0627\\u06CC\\u062F \\u0645\\u0636\\u0631\\u0628 ${t.divisor} \\u0628\\u0627\\u0634\\u062F`;case"unrecognized_keys":return`\\u06A9\\u0644\\u06CC\\u062F${t.keys.length>1?"\\u0647\\u0627\\u06CC":""} \\u0646\\u0627\\u0634\\u0646\\u0627\\u0633: ${h(t.keys,", ")}`;case"invalid_key":return`\\u06A9\\u0644\\u06CC\\u062F \\u0646\\u0627\\u0634\\u0646\\u0627\\u0633 \\u062F\\u0631 ${t.origin}`;case"invalid_union":return"\\u0648\\u0631\\u0648\\u062F\\u06CC \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631";case"invalid_element":return`\\u0645\\u0642\\u062F\\u0627\\u0631 \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631 \\u062F\\u0631 ${t.origin}`;default:return"\\u0648\\u0631\\u0648\\u062F\\u06CC \\u0646\\u0627\\u0645\\u0639\\u062A\\u0628\\u0631"}}};function ol(){return{localeError:dp()}}var mp=()=>{let e={string:{unit:"merkki\\xE4",subject:"merkkijonon"},file:{unit:"tavua",subject:"tiedoston"},array:{unit:"alkiota",subject:"listan"},set:{unit:"alkiota",subject:"joukon"},number:{unit:"",subject:"luvun"},bigint:{unit:"",subject:"suuren kokonaisluvun"},int:{unit:"",subject:"kokonaisluvun"},date:{unit:"",subject:"p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4n"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"s\\xE4\\xE4nn\\xF6llinen lauseke",email:"s\\xE4hk\\xF6postiosoite",url:"URL-osoite",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO-aikaleima",date:"ISO-p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4",time:"ISO-aika",duration:"ISO-kesto",ipv4:"IPv4-osoite",ipv6:"IPv6-osoite",cidrv4:"IPv4-alue",cidrv6:"IPv6-alue",base64:"base64-koodattu merkkijono",base64url:"base64url-koodattu merkkijono",json_string:"JSON-merkkijono",e164:"E.164-luku",jwt:"JWT",template_literal:"templaattimerkkijono"},o={nan:"NaN"};return t=>{var a,c,m;switch(t.code){case"invalid_type":{let s=(a=o[t.expected])!=null?a:t.expected,u=x(t.input),d=(c=o[u])!=null?c:u;return/^[A-Z]/.test(t.expected)?`Virheellinen tyyppi: odotettiin instanceof ${t.expected}, oli ${d}`:`Virheellinen tyyppi: odotettiin ${s}, oli ${d}`}case"invalid_value":return t.values.length===1?`Virheellinen sy\\xF6te: t\\xE4ytyy olla ${$(t.values[0])}`:`Virheellinen valinta: t\\xE4ytyy olla yksi seuraavista: ${h(t.values,"|")}`;case"too_big":{let s=t.inclusive?"<=":"<",u=r(t.origin);return u?`Liian suuri: ${u.subject} t\\xE4ytyy olla ${s}${t.maximum.toString()} ${u.unit}`.trim():`Liian suuri: arvon t\\xE4ytyy olla ${s}${t.maximum.toString()}`}case"too_small":{let s=t.inclusive?">=":">",u=r(t.origin);return u?`Liian pieni: ${u.subject} t\\xE4ytyy olla ${s}${t.minimum.toString()} ${u.unit}`.trim():`Liian pieni: arvon t\\xE4ytyy olla ${s}${t.minimum.toString()}`}case"invalid_format":{let s=t;return s.format==="starts_with"?`Virheellinen sy\\xF6te: t\\xE4ytyy alkaa "${s.prefix}"`:s.format==="ends_with"?`Virheellinen sy\\xF6te: t\\xE4ytyy loppua "${s.suffix}"`:s.format==="includes"?`Virheellinen sy\\xF6te: t\\xE4ytyy sis\\xE4lt\\xE4\\xE4 "${s.includes}"`:s.format==="regex"?`Virheellinen sy\\xF6te: t\\xE4ytyy vastata s\\xE4\\xE4nn\\xF6llist\\xE4 lauseketta ${s.pattern}`:`Virheellinen ${(m=n[s.format])!=null?m:t.format}`}case"not_multiple_of":return`Virheellinen luku: t\\xE4ytyy olla luvun ${t.divisor} monikerta`;case"unrecognized_keys":return`${t.keys.length>1?"Tuntemattomat avaimet":"Tuntematon avain"}: ${h(t.keys,", ")}`;case"invalid_key":return"Virheellinen avain tietueessa";case"invalid_union":return"Virheellinen unioni";case"invalid_element":return"Virheellinen arvo joukossa";default:return"Virheellinen sy\\xF6te"}}};function il(){return{localeError:mp()}}var pp=()=>{let e={string:{unit:"caract\\xE8res",verb:"avoir"},file:{unit:"octets",verb:"avoir"},array:{unit:"\\xE9l\\xE9ments",verb:"avoir"},set:{unit:"\\xE9l\\xE9ments",verb:"avoir"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"entr\\xE9e",email:"adresse e-mail",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"date et heure ISO",date:"date ISO",time:"heure ISO",duration:"dur\\xE9e ISO",ipv4:"adresse IPv4",ipv6:"adresse IPv6",cidrv4:"plage IPv4",cidrv6:"plage IPv6",base64:"cha\\xEEne encod\\xE9e en base64",base64url:"cha\\xEEne encod\\xE9e en base64url",json_string:"cha\\xEEne JSON",e164:"num\\xE9ro E.164",jwt:"JWT",template_literal:"entr\\xE9e"},o={nan:"NaN",number:"nombre",array:"tableau"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Entr\\xE9e invalide : instanceof ${t.expected} attendu, ${p} re\\xE7u`:`Entr\\xE9e invalide : ${i} attendu, ${p} re\\xE7u`}case"invalid_value":return t.values.length===1?`Entr\\xE9e invalide : ${$(t.values[0])} attendu`:`Option invalide : une valeur parmi ${h(t.values,"|")} attendue`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Trop grand : ${(m=t.origin)!=null?m:"valeur"} doit ${l.verb} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\xE9l\\xE9ment(s)"}`:`Trop grand : ${(u=t.origin)!=null?u:"valeur"} doit \\xEAtre ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Trop petit : ${t.origin} doit ${l.verb} ${i}${t.minimum.toString()} ${l.unit}`:`Trop petit : ${t.origin} doit \\xEAtre ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Cha\\xEEne invalide : doit commencer par "${i.prefix}"`:i.format==="ends_with"?`Cha\\xEEne invalide : doit se terminer par "${i.suffix}"`:i.format==="includes"?`Cha\\xEEne invalide : doit inclure "${i.includes}"`:i.format==="regex"?`Cha\\xEEne invalide : doit correspondre au mod\\xE8le ${i.pattern}`:`${(d=n[i.format])!=null?d:t.format} invalide`}case"not_multiple_of":return`Nombre invalide : doit \\xEAtre un multiple de ${t.divisor}`;case"unrecognized_keys":return`Cl\\xE9${t.keys.length>1?"s":""} non reconnue${t.keys.length>1?"s":""} : ${h(t.keys,", ")}`;case"invalid_key":return`Cl\\xE9 invalide dans ${t.origin}`;case"invalid_union":return"Entr\\xE9e invalide";case"invalid_element":return`Valeur invalide dans ${t.origin}`;default:return"Entr\\xE9e invalide"}}};function al(){return{localeError:pp()}}var fp=()=>{let e={string:{unit:"caract\\xE8res",verb:"avoir"},file:{unit:"octets",verb:"avoir"},array:{unit:"\\xE9l\\xE9ments",verb:"avoir"},set:{unit:"\\xE9l\\xE9ments",verb:"avoir"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"entr\\xE9e",email:"adresse courriel",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"date-heure ISO",date:"date ISO",time:"heure ISO",duration:"dur\\xE9e ISO",ipv4:"adresse IPv4",ipv6:"adresse IPv6",cidrv4:"plage IPv4",cidrv6:"plage IPv6",base64:"cha\\xEEne encod\\xE9e en base64",base64url:"cha\\xEEne encod\\xE9e en base64url",json_string:"cha\\xEEne JSON",e164:"num\\xE9ro E.164",jwt:"JWT",template_literal:"entr\\xE9e"},o={nan:"NaN"};return t=>{var a,c,m,s,u;switch(t.code){case"invalid_type":{let d=(a=o[t.expected])!=null?a:t.expected,i=x(t.input),l=(c=o[i])!=null?c:i;return/^[A-Z]/.test(t.expected)?`Entr\\xE9e invalide : attendu instanceof ${t.expected}, re\\xE7u ${l}`:`Entr\\xE9e invalide : attendu ${d}, re\\xE7u ${l}`}case"invalid_value":return t.values.length===1?`Entr\\xE9e invalide : attendu ${$(t.values[0])}`:`Option invalide : attendu l\'une des valeurs suivantes ${h(t.values,"|")}`;case"too_big":{let d=t.inclusive?"\\u2264":"<",i=r(t.origin);return i?`Trop grand : attendu que ${(m=t.origin)!=null?m:"la valeur"} ait ${d}${t.maximum.toString()} ${i.unit}`:`Trop grand : attendu que ${(s=t.origin)!=null?s:"la valeur"} soit ${d}${t.maximum.toString()}`}case"too_small":{let d=t.inclusive?"\\u2265":">",i=r(t.origin);return i?`Trop petit : attendu que ${t.origin} ait ${d}${t.minimum.toString()} ${i.unit}`:`Trop petit : attendu que ${t.origin} soit ${d}${t.minimum.toString()}`}case"invalid_format":{let d=t;return d.format==="starts_with"?`Cha\\xEEne invalide : doit commencer par "${d.prefix}"`:d.format==="ends_with"?`Cha\\xEEne invalide : doit se terminer par "${d.suffix}"`:d.format==="includes"?`Cha\\xEEne invalide : doit inclure "${d.includes}"`:d.format==="regex"?`Cha\\xEEne invalide : doit correspondre au motif ${d.pattern}`:`${(u=n[d.format])!=null?u:t.format} invalide`}case"not_multiple_of":return`Nombre invalide : doit \\xEAtre un multiple de ${t.divisor}`;case"unrecognized_keys":return`Cl\\xE9${t.keys.length>1?"s":""} non reconnue${t.keys.length>1?"s":""} : ${h(t.keys,", ")}`;case"invalid_key":return`Cl\\xE9 invalide dans ${t.origin}`;case"invalid_union":return"Entr\\xE9e invalide";case"invalid_element":return`Valeur invalide dans ${t.origin}`;default:return"Entr\\xE9e invalide"}}};function cl(){return{localeError:fp()}}var gp=()=>{let e={string:{label:"\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA",gender:"f"},number:{label:"\\u05DE\\u05E1\\u05E4\\u05E8",gender:"m"},boolean:{label:"\\u05E2\\u05E8\\u05DA \\u05D1\\u05D5\\u05DC\\u05D9\\u05D0\\u05E0\\u05D9",gender:"m"},bigint:{label:"BigInt",gender:"m"},date:{label:"\\u05EA\\u05D0\\u05E8\\u05D9\\u05DA",gender:"m"},array:{label:"\\u05DE\\u05E2\\u05E8\\u05DA",gender:"m"},object:{label:"\\u05D0\\u05D5\\u05D1\\u05D9\\u05D9\\u05E7\\u05D8",gender:"m"},null:{label:"\\u05E2\\u05E8\\u05DA \\u05E8\\u05D9\\u05E7 (null)",gender:"m"},undefined:{label:"\\u05E2\\u05E8\\u05DA \\u05DC\\u05D0 \\u05DE\\u05D5\\u05D2\\u05D3\\u05E8 (undefined)",gender:"m"},symbol:{label:"\\u05E1\\u05D9\\u05DE\\u05D1\\u05D5\\u05DC (Symbol)",gender:"m"},function:{label:"\\u05E4\\u05D5\\u05E0\\u05E7\\u05E6\\u05D9\\u05D4",gender:"f"},map:{label:"\\u05DE\\u05E4\\u05D4 (Map)",gender:"f"},set:{label:"\\u05E7\\u05D1\\u05D5\\u05E6\\u05D4 (Set)",gender:"f"},file:{label:"\\u05E7\\u05D5\\u05D1\\u05E5",gender:"m"},promise:{label:"Promise",gender:"m"},NaN:{label:"NaN",gender:"m"},unknown:{label:"\\u05E2\\u05E8\\u05DA \\u05DC\\u05D0 \\u05D9\\u05D3\\u05D5\\u05E2",gender:"m"},value:{label:"\\u05E2\\u05E8\\u05DA",gender:"m"}},r={string:{unit:"\\u05EA\\u05D5\\u05D5\\u05D9\\u05DD",shortLabel:"\\u05E7\\u05E6\\u05E8",longLabel:"\\u05D0\\u05E8\\u05D5\\u05DA"},file:{unit:"\\u05D1\\u05D9\\u05D9\\u05D8\\u05D9\\u05DD",shortLabel:"\\u05E7\\u05D8\\u05DF",longLabel:"\\u05D2\\u05D3\\u05D5\\u05DC"},array:{unit:"\\u05E4\\u05E8\\u05D9\\u05D8\\u05D9\\u05DD",shortLabel:"\\u05E7\\u05D8\\u05DF",longLabel:"\\u05D2\\u05D3\\u05D5\\u05DC"},set:{unit:"\\u05E4\\u05E8\\u05D9\\u05D8\\u05D9\\u05DD",shortLabel:"\\u05E7\\u05D8\\u05DF",longLabel:"\\u05D2\\u05D3\\u05D5\\u05DC"},number:{unit:"",shortLabel:"\\u05E7\\u05D8\\u05DF",longLabel:"\\u05D2\\u05D3\\u05D5\\u05DC"}},n=u=>u?e[u]:void 0,o=u=>{let d=n(u);return d?d.label:u!=null?u:e.unknown.label},t=u=>`\\u05D4${o(u)}`,a=u=>{var l;let d=n(u);return((l=d==null?void 0:d.gender)!=null?l:"m")==="f"?"\\u05E6\\u05E8\\u05D9\\u05DB\\u05D4 \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA":"\\u05E6\\u05E8\\u05D9\\u05DA \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA"},c=u=>{var d;return u&&(d=r[u])!=null?d:null},m={regex:{label:"\\u05E7\\u05DC\\u05D8",gender:"m"},email:{label:"\\u05DB\\u05EA\\u05D5\\u05D1\\u05EA \\u05D0\\u05D9\\u05DE\\u05D9\\u05D9\\u05DC",gender:"f"},url:{label:"\\u05DB\\u05EA\\u05D5\\u05D1\\u05EA \\u05E8\\u05E9\\u05EA",gender:"f"},emoji:{label:"\\u05D0\\u05D9\\u05DE\\u05D5\\u05D2\'\\u05D9",gender:"m"},uuid:{label:"UUID",gender:"m"},nanoid:{label:"nanoid",gender:"m"},guid:{label:"GUID",gender:"m"},cuid:{label:"cuid",gender:"m"},cuid2:{label:"cuid2",gender:"m"},ulid:{label:"ULID",gender:"m"},xid:{label:"XID",gender:"m"},ksuid:{label:"KSUID",gender:"m"},datetime:{label:"\\u05EA\\u05D0\\u05E8\\u05D9\\u05DA \\u05D5\\u05D6\\u05DE\\u05DF ISO",gender:"m"},date:{label:"\\u05EA\\u05D0\\u05E8\\u05D9\\u05DA ISO",gender:"m"},time:{label:"\\u05D6\\u05DE\\u05DF ISO",gender:"m"},duration:{label:"\\u05DE\\u05E9\\u05DA \\u05D6\\u05DE\\u05DF ISO",gender:"m"},ipv4:{label:"\\u05DB\\u05EA\\u05D5\\u05D1\\u05EA IPv4",gender:"f"},ipv6:{label:"\\u05DB\\u05EA\\u05D5\\u05D1\\u05EA IPv6",gender:"f"},cidrv4:{label:"\\u05D8\\u05D5\\u05D5\\u05D7 IPv4",gender:"m"},cidrv6:{label:"\\u05D8\\u05D5\\u05D5\\u05D7 IPv6",gender:"m"},base64:{label:"\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05D1\\u05D1\\u05E1\\u05D9\\u05E1 64",gender:"f"},base64url:{label:"\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05D1\\u05D1\\u05E1\\u05D9\\u05E1 64 \\u05DC\\u05DB\\u05EA\\u05D5\\u05D1\\u05D5\\u05EA \\u05E8\\u05E9\\u05EA",gender:"f"},json_string:{label:"\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA JSON",gender:"f"},e164:{label:"\\u05DE\\u05E1\\u05E4\\u05E8 E.164",gender:"m"},jwt:{label:"JWT",gender:"m"},ends_with:{label:"\\u05E7\\u05DC\\u05D8",gender:"m"},includes:{label:"\\u05E7\\u05DC\\u05D8",gender:"m"},lowercase:{label:"\\u05E7\\u05DC\\u05D8",gender:"m"},starts_with:{label:"\\u05E7\\u05DC\\u05D8",gender:"m"},uppercase:{label:"\\u05E7\\u05DC\\u05D8",gender:"m"}},s={nan:"NaN"};return u=>{var d,i,l,p,v,y,S,w,D,N,k,T,U,R,Ee,Qc,Yc,Hc,eu,tu,ru;switch(u.code){case"invalid_type":{let z=u.expected,A=(d=s[z!=null?z:""])!=null?d:o(z),Y=x(u.input),re=(p=(l=s[Y])!=null?l:(i=e[Y])==null?void 0:i.label)!=null?p:Y;return/^[A-Z]/.test(u.expected)?`\\u05E7\\u05DC\\u05D8 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF: \\u05E6\\u05E8\\u05D9\\u05DA \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA instanceof ${u.expected}, \\u05D4\\u05EA\\u05E7\\u05D1\\u05DC ${re}`:`\\u05E7\\u05DC\\u05D8 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF: \\u05E6\\u05E8\\u05D9\\u05DA \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA ${A}, \\u05D4\\u05EA\\u05E7\\u05D1\\u05DC ${re}`}case"invalid_value":{if(u.values.length===1)return`\\u05E2\\u05E8\\u05DA \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF: \\u05D4\\u05E2\\u05E8\\u05DA \\u05D7\\u05D9\\u05D9\\u05D1 \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA ${$(u.values[0])}`;let z=u.values.map(re=>$(re));if(u.values.length===2)return`\\u05E2\\u05E8\\u05DA \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF: \\u05D4\\u05D0\\u05E4\\u05E9\\u05E8\\u05D5\\u05D9\\u05D5\\u05EA \\u05D4\\u05DE\\u05EA\\u05D0\\u05D9\\u05DE\\u05D5\\u05EA \\u05D4\\u05DF ${z[0]} \\u05D0\\u05D5 ${z[1]}`;let A=z[z.length-1];return`\\u05E2\\u05E8\\u05DA \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF: \\u05D4\\u05D0\\u05E4\\u05E9\\u05E8\\u05D5\\u05D9\\u05D5\\u05EA \\u05D4\\u05DE\\u05EA\\u05D0\\u05D9\\u05DE\\u05D5\\u05EA \\u05D4\\u05DF ${z.slice(0,-1).join(", ")} \\u05D0\\u05D5 ${A}`}case"too_big":{let z=c(u.origin),A=t((v=u.origin)!=null?v:"value");if(u.origin==="string")return`${(y=z==null?void 0:z.longLabel)!=null?y:"\\u05D0\\u05E8\\u05D5\\u05DA"} \\u05DE\\u05D3\\u05D9: ${A} \\u05E6\\u05E8\\u05D9\\u05DB\\u05D4 \\u05DC\\u05D4\\u05DB\\u05D9\\u05DC ${u.maximum.toString()} ${(S=z==null?void 0:z.unit)!=null?S:""} ${u.inclusive?"\\u05D0\\u05D5 \\u05E4\\u05D7\\u05D5\\u05EA":"\\u05DC\\u05DB\\u05DC \\u05D4\\u05D9\\u05D5\\u05EA\\u05E8"}`.trim();if(u.origin==="number"){let oe=u.inclusive?`\\u05E7\\u05D8\\u05DF \\u05D0\\u05D5 \\u05E9\\u05D5\\u05D5\\u05D4 \\u05DC-${u.maximum}`:`\\u05E7\\u05D8\\u05DF \\u05DE-${u.maximum}`;return`\\u05D2\\u05D3\\u05D5\\u05DC \\u05DE\\u05D3\\u05D9: ${A} \\u05E6\\u05E8\\u05D9\\u05DA \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA ${oe}`}if(u.origin==="array"||u.origin==="set"){let oe=u.origin==="set"?"\\u05E6\\u05E8\\u05D9\\u05DB\\u05D4":"\\u05E6\\u05E8\\u05D9\\u05DA",sn=u.inclusive?`${u.maximum} ${(w=z==null?void 0:z.unit)!=null?w:""} \\u05D0\\u05D5 \\u05E4\\u05D7\\u05D5\\u05EA`:`\\u05E4\\u05D7\\u05D5\\u05EA \\u05DE-${u.maximum} ${(D=z==null?void 0:z.unit)!=null?D:""}`;return`\\u05D2\\u05D3\\u05D5\\u05DC \\u05DE\\u05D3\\u05D9: ${A} ${oe} \\u05DC\\u05D4\\u05DB\\u05D9\\u05DC ${sn}`.trim()}let Y=u.inclusive?"<=":"<",re=a((N=u.origin)!=null?N:"value");return z!=null&&z.unit?`${z.longLabel} \\u05DE\\u05D3\\u05D9: ${A} ${re} ${Y}${u.maximum.toString()} ${z.unit}`:`${(k=z==null?void 0:z.longLabel)!=null?k:"\\u05D2\\u05D3\\u05D5\\u05DC"} \\u05DE\\u05D3\\u05D9: ${A} ${re} ${Y}${u.maximum.toString()}`}case"too_small":{let z=c(u.origin),A=t((T=u.origin)!=null?T:"value");if(u.origin==="string")return`${(U=z==null?void 0:z.shortLabel)!=null?U:"\\u05E7\\u05E6\\u05E8"} \\u05DE\\u05D3\\u05D9: ${A} \\u05E6\\u05E8\\u05D9\\u05DB\\u05D4 \\u05DC\\u05D4\\u05DB\\u05D9\\u05DC ${u.minimum.toString()} ${(R=z==null?void 0:z.unit)!=null?R:""} ${u.inclusive?"\\u05D0\\u05D5 \\u05D9\\u05D5\\u05EA\\u05E8":"\\u05DC\\u05E4\\u05D7\\u05D5\\u05EA"}`.trim();if(u.origin==="number"){let oe=u.inclusive?`\\u05D2\\u05D3\\u05D5\\u05DC \\u05D0\\u05D5 \\u05E9\\u05D5\\u05D5\\u05D4 \\u05DC-${u.minimum}`:`\\u05D2\\u05D3\\u05D5\\u05DC \\u05DE-${u.minimum}`;return`\\u05E7\\u05D8\\u05DF \\u05DE\\u05D3\\u05D9: ${A} \\u05E6\\u05E8\\u05D9\\u05DA \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA ${oe}`}if(u.origin==="array"||u.origin==="set"){let oe=u.origin==="set"?"\\u05E6\\u05E8\\u05D9\\u05DB\\u05D4":"\\u05E6\\u05E8\\u05D9\\u05DA";if(u.minimum===1&&u.inclusive){let zd=(u.origin==="set","\\u05DC\\u05E4\\u05D7\\u05D5\\u05EA \\u05E4\\u05E8\\u05D9\\u05D8 \\u05D0\\u05D7\\u05D3");return`\\u05E7\\u05D8\\u05DF \\u05DE\\u05D3\\u05D9: ${A} ${oe} \\u05DC\\u05D4\\u05DB\\u05D9\\u05DC ${zd}`}let sn=u.inclusive?`${u.minimum} ${(Ee=z==null?void 0:z.unit)!=null?Ee:""} \\u05D0\\u05D5 \\u05D9\\u05D5\\u05EA\\u05E8`:`\\u05D9\\u05D5\\u05EA\\u05E8 \\u05DE-${u.minimum} ${(Qc=z==null?void 0:z.unit)!=null?Qc:""}`;return`\\u05E7\\u05D8\\u05DF \\u05DE\\u05D3\\u05D9: ${A} ${oe} \\u05DC\\u05D4\\u05DB\\u05D9\\u05DC ${sn}`.trim()}let Y=u.inclusive?">=":">",re=a((Yc=u.origin)!=null?Yc:"value");return z!=null&&z.unit?`${z.shortLabel} \\u05DE\\u05D3\\u05D9: ${A} ${re} ${Y}${u.minimum.toString()} ${z.unit}`:`${(Hc=z==null?void 0:z.shortLabel)!=null?Hc:"\\u05E7\\u05D8\\u05DF"} \\u05DE\\u05D3\\u05D9: ${A} ${re} ${Y}${u.minimum.toString()}`}case"invalid_format":{let z=u;if(z.format==="starts_with")return`\\u05D4\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05D7\\u05D9\\u05D9\\u05D1\\u05EA \\u05DC\\u05D4\\u05EA\\u05D7\\u05D9\\u05DC \\u05D1 "${z.prefix}"`;if(z.format==="ends_with")return`\\u05D4\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05D7\\u05D9\\u05D9\\u05D1\\u05EA \\u05DC\\u05D4\\u05E1\\u05EA\\u05D9\\u05D9\\u05DD \\u05D1 "${z.suffix}"`;if(z.format==="includes")return`\\u05D4\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05D7\\u05D9\\u05D9\\u05D1\\u05EA \\u05DC\\u05DB\\u05DC\\u05D5\\u05DC "${z.includes}"`;if(z.format==="regex")return`\\u05D4\\u05DE\\u05D7\\u05E8\\u05D5\\u05D6\\u05EA \\u05D7\\u05D9\\u05D9\\u05D1\\u05EA \\u05DC\\u05D4\\u05EA\\u05D0\\u05D9\\u05DD \\u05DC\\u05EA\\u05D1\\u05E0\\u05D9\\u05EA ${z.pattern}`;let A=m[z.format],Y=(eu=A==null?void 0:A.label)!=null?eu:z.format,oe=((tu=A==null?void 0:A.gender)!=null?tu:"m")==="f"?"\\u05EA\\u05E7\\u05D9\\u05E0\\u05D4":"\\u05EA\\u05E7\\u05D9\\u05DF";return`${Y} \\u05DC\\u05D0 ${oe}`}case"not_multiple_of":return`\\u05DE\\u05E1\\u05E4\\u05E8 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF: \\u05D7\\u05D9\\u05D9\\u05D1 \\u05DC\\u05D4\\u05D9\\u05D5\\u05EA \\u05DE\\u05DB\\u05E4\\u05DC\\u05D4 \\u05E9\\u05DC ${u.divisor}`;case"unrecognized_keys":return`\\u05DE\\u05E4\\u05EA\\u05D7${u.keys.length>1?"\\u05D5\\u05EA":""} \\u05DC\\u05D0 \\u05DE\\u05D6\\u05D5\\u05D4${u.keys.length>1?"\\u05D9\\u05DD":"\\u05D4"}: ${h(u.keys,", ")}`;case"invalid_key":return"\\u05E9\\u05D3\\u05D4 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF \\u05D1\\u05D0\\u05D5\\u05D1\\u05D9\\u05D9\\u05E7\\u05D8";case"invalid_union":return"\\u05E7\\u05DC\\u05D8 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF";case"invalid_element":return`\\u05E2\\u05E8\\u05DA \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF \\u05D1${t((ru=u.origin)!=null?ru:"array")}`;default:return"\\u05E7\\u05DC\\u05D8 \\u05DC\\u05D0 \\u05EA\\u05E7\\u05D9\\u05DF"}}};function ul(){return{localeError:gp()}}var vp=()=>{let e={string:{unit:"karakter",verb:"legyen"},file:{unit:"byte",verb:"legyen"},array:{unit:"elem",verb:"legyen"},set:{unit:"elem",verb:"legyen"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"bemenet",email:"email c\\xEDm",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO id\\u0151b\\xE9lyeg",date:"ISO d\\xE1tum",time:"ISO id\\u0151",duration:"ISO id\\u0151intervallum",ipv4:"IPv4 c\\xEDm",ipv6:"IPv6 c\\xEDm",cidrv4:"IPv4 tartom\\xE1ny",cidrv6:"IPv6 tartom\\xE1ny",base64:"base64-k\\xF3dolt string",base64url:"base64url-k\\xF3dolt string",json_string:"JSON string",e164:"E.164 sz\\xE1m",jwt:"JWT",template_literal:"bemenet"},o={nan:"NaN",number:"sz\\xE1m",array:"t\\xF6mb"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\xC9rv\\xE9nytelen bemenet: a v\\xE1rt \\xE9rt\\xE9k instanceof ${t.expected}, a kapott \\xE9rt\\xE9k ${p}`:`\\xC9rv\\xE9nytelen bemenet: a v\\xE1rt \\xE9rt\\xE9k ${i}, a kapott \\xE9rt\\xE9k ${p}`}case"invalid_value":return t.values.length===1?`\\xC9rv\\xE9nytelen bemenet: a v\\xE1rt \\xE9rt\\xE9k ${$(t.values[0])}`:`\\xC9rv\\xE9nytelen opci\\xF3: valamelyik \\xE9rt\\xE9k v\\xE1rt ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`T\\xFAl nagy: ${(m=t.origin)!=null?m:"\\xE9rt\\xE9k"} m\\xE9rete t\\xFAl nagy ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elem"}`:`T\\xFAl nagy: a bemeneti \\xE9rt\\xE9k ${(u=t.origin)!=null?u:"\\xE9rt\\xE9k"} t\\xFAl nagy: ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`T\\xFAl kicsi: a bemeneti \\xE9rt\\xE9k ${t.origin} m\\xE9rete t\\xFAl kicsi ${i}${t.minimum.toString()} ${l.unit}`:`T\\xFAl kicsi: a bemeneti \\xE9rt\\xE9k ${t.origin} t\\xFAl kicsi ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\xC9rv\\xE9nytelen string: "${i.prefix}" \\xE9rt\\xE9kkel kell kezd\\u0151dnie`:i.format==="ends_with"?`\\xC9rv\\xE9nytelen string: "${i.suffix}" \\xE9rt\\xE9kkel kell v\\xE9gz\\u0151dnie`:i.format==="includes"?`\\xC9rv\\xE9nytelen string: "${i.includes}" \\xE9rt\\xE9ket kell tartalmaznia`:i.format==="regex"?`\\xC9rv\\xE9nytelen string: ${i.pattern} mint\\xE1nak kell megfelelnie`:`\\xC9rv\\xE9nytelen ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\xC9rv\\xE9nytelen sz\\xE1m: ${t.divisor} t\\xF6bbsz\\xF6r\\xF6s\\xE9nek kell lennie`;case"unrecognized_keys":return`Ismeretlen kulcs${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`\\xC9rv\\xE9nytelen kulcs ${t.origin}`;case"invalid_union":return"\\xC9rv\\xE9nytelen bemenet";case"invalid_element":return`\\xC9rv\\xE9nytelen \\xE9rt\\xE9k: ${t.origin}`;default:return"\\xC9rv\\xE9nytelen bemenet"}}};function ll(){return{localeError:vp()}}function sl(e,r,n){return Math.abs(e)===1?r:n}function Je(e){if(!e)return"";let r=["\\u0561","\\u0565","\\u0568","\\u056B","\\u0578","\\u0578\\u0582","\\u0585"],n=e[e.length-1];return e+(r.includes(n)?"\\u0576":"\\u0568")}var hp=()=>{let e={string:{unit:{one:"\\u0576\\u0577\\u0561\\u0576",many:"\\u0576\\u0577\\u0561\\u0576\\u0576\\u0565\\u0580"},verb:"\\u0578\\u0582\\u0576\\u0565\\u0576\\u0561\\u056C"},file:{unit:{one:"\\u0562\\u0561\\u0575\\u0569",many:"\\u0562\\u0561\\u0575\\u0569\\u0565\\u0580"},verb:"\\u0578\\u0582\\u0576\\u0565\\u0576\\u0561\\u056C"},array:{unit:{one:"\\u057F\\u0561\\u0580\\u0580",many:"\\u057F\\u0561\\u0580\\u0580\\u0565\\u0580"},verb:"\\u0578\\u0582\\u0576\\u0565\\u0576\\u0561\\u056C"},set:{unit:{one:"\\u057F\\u0561\\u0580\\u0580",many:"\\u057F\\u0561\\u0580\\u0580\\u0565\\u0580"},verb:"\\u0578\\u0582\\u0576\\u0565\\u0576\\u0561\\u056C"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0574\\u0578\\u0582\\u057F\\u0584",email:"\\u0567\\u056C. \\u0570\\u0561\\u057D\\u0581\\u0565",url:"URL",emoji:"\\u0567\\u0574\\u0578\\u057B\\u056B",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO \\u0561\\u0574\\u057D\\u0561\\u0569\\u056B\\u057E \\u0587 \\u056A\\u0561\\u0574",date:"ISO \\u0561\\u0574\\u057D\\u0561\\u0569\\u056B\\u057E",time:"ISO \\u056A\\u0561\\u0574",duration:"ISO \\u057F\\u0587\\u0578\\u0572\\u0578\\u0582\\u0569\\u0575\\u0578\\u0582\\u0576",ipv4:"IPv4 \\u0570\\u0561\\u057D\\u0581\\u0565",ipv6:"IPv6 \\u0570\\u0561\\u057D\\u0581\\u0565",cidrv4:"IPv4 \\u0574\\u056B\\u057B\\u0561\\u056F\\u0561\\u0575\\u0584",cidrv6:"IPv6 \\u0574\\u056B\\u057B\\u0561\\u056F\\u0561\\u0575\\u0584",base64:"base64 \\u0571\\u0587\\u0561\\u0579\\u0561\\u0583\\u0578\\u057E \\u057F\\u0578\\u0572",base64url:"base64url \\u0571\\u0587\\u0561\\u0579\\u0561\\u0583\\u0578\\u057E \\u057F\\u0578\\u0572",json_string:"JSON \\u057F\\u0578\\u0572",e164:"E.164 \\u0570\\u0561\\u0574\\u0561\\u0580",jwt:"JWT",template_literal:"\\u0574\\u0578\\u0582\\u057F\\u0584"},o={nan:"NaN",number:"\\u0569\\u056B\\u057E",array:"\\u0566\\u0561\\u0576\\u0563\\u057E\\u0561\\u056E"};return t=>{var a,c,m,s,u;switch(t.code){case"invalid_type":{let d=(a=o[t.expected])!=null?a:t.expected,i=x(t.input),l=(c=o[i])!=null?c:i;return/^[A-Z]/.test(t.expected)?`\\u054D\\u056D\\u0561\\u056C \\u0574\\u0578\\u0582\\u057F\\u0584\\u0561\\u0563\\u0580\\u0578\\u0582\\u0574\\u2024 \\u057D\\u057A\\u0561\\u057D\\u057E\\u0578\\u0582\\u0574 \\u0567\\u0580 instanceof ${t.expected}, \\u057D\\u057F\\u0561\\u0581\\u057E\\u0565\\u056C \\u0567 ${l}`:`\\u054D\\u056D\\u0561\\u056C \\u0574\\u0578\\u0582\\u057F\\u0584\\u0561\\u0563\\u0580\\u0578\\u0582\\u0574\\u2024 \\u057D\\u057A\\u0561\\u057D\\u057E\\u0578\\u0582\\u0574 \\u0567\\u0580 ${d}, \\u057D\\u057F\\u0561\\u0581\\u057E\\u0565\\u056C \\u0567 ${l}`}case"invalid_value":return t.values.length===1?`\\u054D\\u056D\\u0561\\u056C \\u0574\\u0578\\u0582\\u057F\\u0584\\u0561\\u0563\\u0580\\u0578\\u0582\\u0574\\u2024 \\u057D\\u057A\\u0561\\u057D\\u057E\\u0578\\u0582\\u0574 \\u0567\\u0580 ${$(t.values[1])}`:`\\u054D\\u056D\\u0561\\u056C \\u057F\\u0561\\u0580\\u0562\\u0565\\u0580\\u0561\\u056F\\u2024 \\u057D\\u057A\\u0561\\u057D\\u057E\\u0578\\u0582\\u0574 \\u0567\\u0580 \\u0570\\u0565\\u057F\\u0587\\u0575\\u0561\\u056C\\u0576\\u0565\\u0580\\u056B\\u0581 \\u0574\\u0565\\u056F\\u0568\\u055D ${h(t.values,"|")}`;case"too_big":{let d=t.inclusive?"<=":"<",i=r(t.origin);if(i){let l=Number(t.maximum),p=sl(l,i.unit.one,i.unit.many);return`\\u0549\\u0561\\u0583\\u0561\\u0566\\u0561\\u0576\\u0581 \\u0574\\u0565\\u056E \\u0561\\u0580\\u056A\\u0565\\u0584\\u2024 \\u057D\\u057A\\u0561\\u057D\\u057E\\u0578\\u0582\\u0574 \\u0567, \\u0578\\u0580 ${Je((m=t.origin)!=null?m:"\\u0561\\u0580\\u056A\\u0565\\u0584")} \\u056F\\u0578\\u0582\\u0576\\u0565\\u0576\\u0561 ${d}${t.maximum.toString()} ${p}`}return`\\u0549\\u0561\\u0583\\u0561\\u0566\\u0561\\u0576\\u0581 \\u0574\\u0565\\u056E \\u0561\\u0580\\u056A\\u0565\\u0584\\u2024 \\u057D\\u057A\\u0561\\u057D\\u057E\\u0578\\u0582\\u0574 \\u0567, \\u0578\\u0580 ${Je((s=t.origin)!=null?s:"\\u0561\\u0580\\u056A\\u0565\\u0584")} \\u056C\\u056B\\u0576\\u056B ${d}${t.maximum.toString()}`}case"too_small":{let d=t.inclusive?">=":">",i=r(t.origin);if(i){let l=Number(t.minimum),p=sl(l,i.unit.one,i.unit.many);return`\\u0549\\u0561\\u0583\\u0561\\u0566\\u0561\\u0576\\u0581 \\u0583\\u0578\\u0584\\u0580 \\u0561\\u0580\\u056A\\u0565\\u0584\\u2024 \\u057D\\u057A\\u0561\\u057D\\u057E\\u0578\\u0582\\u0574 \\u0567, \\u0578\\u0580 ${Je(t.origin)} \\u056F\\u0578\\u0582\\u0576\\u0565\\u0576\\u0561 ${d}${t.minimum.toString()} ${p}`}return`\\u0549\\u0561\\u0583\\u0561\\u0566\\u0561\\u0576\\u0581 \\u0583\\u0578\\u0584\\u0580 \\u0561\\u0580\\u056A\\u0565\\u0584\\u2024 \\u057D\\u057A\\u0561\\u057D\\u057E\\u0578\\u0582\\u0574 \\u0567, \\u0578\\u0580 ${Je(t.origin)} \\u056C\\u056B\\u0576\\u056B ${d}${t.minimum.toString()}`}case"invalid_format":{let d=t;return d.format==="starts_with"?`\\u054D\\u056D\\u0561\\u056C \\u057F\\u0578\\u0572\\u2024 \\u057A\\u0565\\u057F\\u0584 \\u0567 \\u057D\\u056F\\u057D\\u057E\\u056B "${d.prefix}"-\\u0578\\u057E`:d.format==="ends_with"?`\\u054D\\u056D\\u0561\\u056C \\u057F\\u0578\\u0572\\u2024 \\u057A\\u0565\\u057F\\u0584 \\u0567 \\u0561\\u057E\\u0561\\u0580\\u057F\\u057E\\u056B "${d.suffix}"-\\u0578\\u057E`:d.format==="includes"?`\\u054D\\u056D\\u0561\\u056C \\u057F\\u0578\\u0572\\u2024 \\u057A\\u0565\\u057F\\u0584 \\u0567 \\u057A\\u0561\\u0580\\u0578\\u0582\\u0576\\u0561\\u056F\\u056B "${d.includes}"`:d.format==="regex"?`\\u054D\\u056D\\u0561\\u056C \\u057F\\u0578\\u0572\\u2024 \\u057A\\u0565\\u057F\\u0584 \\u0567 \\u0570\\u0561\\u0574\\u0561\\u057A\\u0561\\u057F\\u0561\\u057D\\u056D\\u0561\\u0576\\u056B ${d.pattern} \\u0571\\u0587\\u0561\\u0579\\u0561\\u0583\\u056B\\u0576`:`\\u054D\\u056D\\u0561\\u056C ${(u=n[d.format])!=null?u:t.format}`}case"not_multiple_of":return`\\u054D\\u056D\\u0561\\u056C \\u0569\\u056B\\u057E\\u2024 \\u057A\\u0565\\u057F\\u0584 \\u0567 \\u0562\\u0561\\u0566\\u0574\\u0561\\u057A\\u0561\\u057F\\u056B\\u056F \\u056C\\u056B\\u0576\\u056B ${t.divisor}-\\u056B`;case"unrecognized_keys":return`\\u0549\\u0573\\u0561\\u0576\\u0561\\u0579\\u057E\\u0561\\u056E \\u0562\\u0561\\u0576\\u0561\\u056C\\u056B${t.keys.length>1?"\\u0576\\u0565\\u0580":""}. ${h(t.keys,", ")}`;case"invalid_key":return`\\u054D\\u056D\\u0561\\u056C \\u0562\\u0561\\u0576\\u0561\\u056C\\u056B ${Je(t.origin)}-\\u0578\\u0582\\u0574`;case"invalid_union":return"\\u054D\\u056D\\u0561\\u056C \\u0574\\u0578\\u0582\\u057F\\u0584\\u0561\\u0563\\u0580\\u0578\\u0582\\u0574";case"invalid_element":return`\\u054D\\u056D\\u0561\\u056C \\u0561\\u0580\\u056A\\u0565\\u0584 ${Je(t.origin)}-\\u0578\\u0582\\u0574`;default:return"\\u054D\\u056D\\u0561\\u056C \\u0574\\u0578\\u0582\\u057F\\u0584\\u0561\\u0563\\u0580\\u0578\\u0582\\u0574"}}};function dl(){return{localeError:hp()}}var yp=()=>{let e={string:{unit:"karakter",verb:"memiliki"},file:{unit:"byte",verb:"memiliki"},array:{unit:"item",verb:"memiliki"},set:{unit:"item",verb:"memiliki"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"input",email:"alamat email",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"tanggal dan waktu format ISO",date:"tanggal format ISO",time:"jam format ISO",duration:"durasi format ISO",ipv4:"alamat IPv4",ipv6:"alamat IPv6",cidrv4:"rentang alamat IPv4",cidrv6:"rentang alamat IPv6",base64:"string dengan enkode base64",base64url:"string dengan enkode base64url",json_string:"string JSON",e164:"angka E.164",jwt:"JWT",template_literal:"input"},o={nan:"NaN"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Input tidak valid: diharapkan instanceof ${t.expected}, diterima ${p}`:`Input tidak valid: diharapkan ${i}, diterima ${p}`}case"invalid_value":return t.values.length===1?`Input tidak valid: diharapkan ${$(t.values[0])}`:`Pilihan tidak valid: diharapkan salah satu dari ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Terlalu besar: diharapkan ${(m=t.origin)!=null?m:"value"} memiliki ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elemen"}`:`Terlalu besar: diharapkan ${(u=t.origin)!=null?u:"value"} menjadi ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Terlalu kecil: diharapkan ${t.origin} memiliki ${i}${t.minimum.toString()} ${l.unit}`:`Terlalu kecil: diharapkan ${t.origin} menjadi ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`String tidak valid: harus dimulai dengan "${i.prefix}"`:i.format==="ends_with"?`String tidak valid: harus berakhir dengan "${i.suffix}"`:i.format==="includes"?`String tidak valid: harus menyertakan "${i.includes}"`:i.format==="regex"?`String tidak valid: harus sesuai pola ${i.pattern}`:`${(d=n[i.format])!=null?d:t.format} tidak valid`}case"not_multiple_of":return`Angka tidak valid: harus kelipatan dari ${t.divisor}`;case"unrecognized_keys":return`Kunci tidak dikenali ${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`Kunci tidak valid di ${t.origin}`;case"invalid_union":return"Input tidak valid";case"invalid_element":return`Nilai tidak valid di ${t.origin}`;default:return"Input tidak valid"}}};function ml(){return{localeError:yp()}}var $p=()=>{let e={string:{unit:"stafi",verb:"a\\xF0 hafa"},file:{unit:"b\\xE6ti",verb:"a\\xF0 hafa"},array:{unit:"hluti",verb:"a\\xF0 hafa"},set:{unit:"hluti",verb:"a\\xF0 hafa"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"gildi",email:"netfang",url:"vefsl\\xF3\\xF0",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO dagsetning og t\\xEDmi",date:"ISO dagsetning",time:"ISO t\\xEDmi",duration:"ISO t\\xEDmalengd",ipv4:"IPv4 address",ipv6:"IPv6 address",cidrv4:"IPv4 range",cidrv6:"IPv6 range",base64:"base64-encoded strengur",base64url:"base64url-encoded strengur",json_string:"JSON strengur",e164:"E.164 t\\xF6lugildi",jwt:"JWT",template_literal:"gildi"},o={nan:"NaN",number:"n\\xFAmer",array:"fylki"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Rangt gildi: \\xDE\\xFA sl\\xF3st inn ${p} \\xFEar sem \\xE1 a\\xF0 vera instanceof ${t.expected}`:`Rangt gildi: \\xDE\\xFA sl\\xF3st inn ${p} \\xFEar sem \\xE1 a\\xF0 vera ${i}`}case"invalid_value":return t.values.length===1?`Rangt gildi: gert r\\xE1\\xF0 fyrir ${$(t.values[0])}`:`\\xD3gilt val: m\\xE1 vera eitt af eftirfarandi ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Of st\\xF3rt: gert er r\\xE1\\xF0 fyrir a\\xF0 ${(m=t.origin)!=null?m:"gildi"} hafi ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"hluti"}`:`Of st\\xF3rt: gert er r\\xE1\\xF0 fyrir a\\xF0 ${(u=t.origin)!=null?u:"gildi"} s\\xE9 ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Of l\\xEDti\\xF0: gert er r\\xE1\\xF0 fyrir a\\xF0 ${t.origin} hafi ${i}${t.minimum.toString()} ${l.unit}`:`Of l\\xEDti\\xF0: gert er r\\xE1\\xF0 fyrir a\\xF0 ${t.origin} s\\xE9 ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\xD3gildur strengur: ver\\xF0ur a\\xF0 byrja \\xE1 "${i.prefix}"`:i.format==="ends_with"?`\\xD3gildur strengur: ver\\xF0ur a\\xF0 enda \\xE1 "${i.suffix}"`:i.format==="includes"?`\\xD3gildur strengur: ver\\xF0ur a\\xF0 innihalda "${i.includes}"`:i.format==="regex"?`\\xD3gildur strengur: ver\\xF0ur a\\xF0 fylgja mynstri ${i.pattern}`:`Rangt ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`R\\xF6ng tala: ver\\xF0ur a\\xF0 vera margfeldi af ${t.divisor}`;case"unrecognized_keys":return`\\xD3\\xFEekkt ${t.keys.length>1?"ir lyklar":"ur lykill"}: ${h(t.keys,", ")}`;case"invalid_key":return`Rangur lykill \\xED ${t.origin}`;case"invalid_union":return"Rangt gildi";case"invalid_element":return`Rangt gildi \\xED ${t.origin}`;default:return"Rangt gildi"}}};function pl(){return{localeError:$p()}}var xp=()=>{let e={string:{unit:"caratteri",verb:"avere"},file:{unit:"byte",verb:"avere"},array:{unit:"elementi",verb:"avere"},set:{unit:"elementi",verb:"avere"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"input",email:"indirizzo email",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"data e ora ISO",date:"data ISO",time:"ora ISO",duration:"durata ISO",ipv4:"indirizzo IPv4",ipv6:"indirizzo IPv6",cidrv4:"intervallo IPv4",cidrv6:"intervallo IPv6",base64:"stringa codificata in base64",base64url:"URL codificata in base64",json_string:"stringa JSON",e164:"numero E.164",jwt:"JWT",template_literal:"input"},o={nan:"NaN",number:"numero",array:"vettore"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Input non valido: atteso instanceof ${t.expected}, ricevuto ${p}`:`Input non valido: atteso ${i}, ricevuto ${p}`}case"invalid_value":return t.values.length===1?`Input non valido: atteso ${$(t.values[0])}`:`Opzione non valida: atteso uno tra ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Troppo grande: ${(m=t.origin)!=null?m:"valore"} deve avere ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elementi"}`:`Troppo grande: ${(u=t.origin)!=null?u:"valore"} deve essere ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Troppo piccolo: ${t.origin} deve avere ${i}${t.minimum.toString()} ${l.unit}`:`Troppo piccolo: ${t.origin} deve essere ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Stringa non valida: deve iniziare con "${i.prefix}"`:i.format==="ends_with"?`Stringa non valida: deve terminare con "${i.suffix}"`:i.format==="includes"?`Stringa non valida: deve includere "${i.includes}"`:i.format==="regex"?`Stringa non valida: deve corrispondere al pattern ${i.pattern}`:`Invalid ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Numero non valido: deve essere un multiplo di ${t.divisor}`;case"unrecognized_keys":return`Chiav${t.keys.length>1?"i":"e"} non riconosciut${t.keys.length>1?"e":"a"}: ${h(t.keys,", ")}`;case"invalid_key":return`Chiave non valida in ${t.origin}`;case"invalid_union":return"Input non valido";case"invalid_element":return`Valore non valido in ${t.origin}`;default:return"Input non valido"}}};function fl(){return{localeError:xp()}}var bp=()=>{let e={string:{unit:"\\u6587\\u5B57",verb:"\\u3067\\u3042\\u308B"},file:{unit:"\\u30D0\\u30A4\\u30C8",verb:"\\u3067\\u3042\\u308B"},array:{unit:"\\u8981\\u7D20",verb:"\\u3067\\u3042\\u308B"},set:{unit:"\\u8981\\u7D20",verb:"\\u3067\\u3042\\u308B"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u5165\\u529B\\u5024",email:"\\u30E1\\u30FC\\u30EB\\u30A2\\u30C9\\u30EC\\u30B9",url:"URL",emoji:"\\u7D75\\u6587\\u5B57",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO\\u65E5\\u6642",date:"ISO\\u65E5\\u4ED8",time:"ISO\\u6642\\u523B",duration:"ISO\\u671F\\u9593",ipv4:"IPv4\\u30A2\\u30C9\\u30EC\\u30B9",ipv6:"IPv6\\u30A2\\u30C9\\u30EC\\u30B9",cidrv4:"IPv4\\u7BC4\\u56F2",cidrv6:"IPv6\\u7BC4\\u56F2",base64:"base64\\u30A8\\u30F3\\u30B3\\u30FC\\u30C9\\u6587\\u5B57\\u5217",base64url:"base64url\\u30A8\\u30F3\\u30B3\\u30FC\\u30C9\\u6587\\u5B57\\u5217",json_string:"JSON\\u6587\\u5B57\\u5217",e164:"E.164\\u756A\\u53F7",jwt:"JWT",template_literal:"\\u5165\\u529B\\u5024"},o={nan:"NaN",number:"\\u6570\\u5024",array:"\\u914D\\u5217"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u7121\\u52B9\\u306A\\u5165\\u529B: instanceof ${t.expected}\\u304C\\u671F\\u5F85\\u3055\\u308C\\u307E\\u3057\\u305F\\u304C\\u3001${p}\\u304C\\u5165\\u529B\\u3055\\u308C\\u307E\\u3057\\u305F`:`\\u7121\\u52B9\\u306A\\u5165\\u529B: ${i}\\u304C\\u671F\\u5F85\\u3055\\u308C\\u307E\\u3057\\u305F\\u304C\\u3001${p}\\u304C\\u5165\\u529B\\u3055\\u308C\\u307E\\u3057\\u305F`}case"invalid_value":return t.values.length===1?`\\u7121\\u52B9\\u306A\\u5165\\u529B: ${$(t.values[0])}\\u304C\\u671F\\u5F85\\u3055\\u308C\\u307E\\u3057\\u305F`:`\\u7121\\u52B9\\u306A\\u9078\\u629E: ${h(t.values,"\\u3001")}\\u306E\\u3044\\u305A\\u308C\\u304B\\u3067\\u3042\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`;case"too_big":{let i=t.inclusive?"\\u4EE5\\u4E0B\\u3067\\u3042\\u308B":"\\u3088\\u308A\\u5C0F\\u3055\\u3044",l=r(t.origin);return l?`\\u5927\\u304D\\u3059\\u304E\\u308B\\u5024: ${(m=t.origin)!=null?m:"\\u5024"}\\u306F${t.maximum.toString()}${(s=l.unit)!=null?s:"\\u8981\\u7D20"}${i}\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`:`\\u5927\\u304D\\u3059\\u304E\\u308B\\u5024: ${(u=t.origin)!=null?u:"\\u5024"}\\u306F${t.maximum.toString()}${i}\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`}case"too_small":{let i=t.inclusive?"\\u4EE5\\u4E0A\\u3067\\u3042\\u308B":"\\u3088\\u308A\\u5927\\u304D\\u3044",l=r(t.origin);return l?`\\u5C0F\\u3055\\u3059\\u304E\\u308B\\u5024: ${t.origin}\\u306F${t.minimum.toString()}${l.unit}${i}\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`:`\\u5C0F\\u3055\\u3059\\u304E\\u308B\\u5024: ${t.origin}\\u306F${t.minimum.toString()}${i}\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u7121\\u52B9\\u306A\\u6587\\u5B57\\u5217: "${i.prefix}"\\u3067\\u59CB\\u307E\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`:i.format==="ends_with"?`\\u7121\\u52B9\\u306A\\u6587\\u5B57\\u5217: "${i.suffix}"\\u3067\\u7D42\\u308F\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`:i.format==="includes"?`\\u7121\\u52B9\\u306A\\u6587\\u5B57\\u5217: "${i.includes}"\\u3092\\u542B\\u3080\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`:i.format==="regex"?`\\u7121\\u52B9\\u306A\\u6587\\u5B57\\u5217: \\u30D1\\u30BF\\u30FC\\u30F3${i.pattern}\\u306B\\u4E00\\u81F4\\u3059\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`:`\\u7121\\u52B9\\u306A${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u7121\\u52B9\\u306A\\u6570\\u5024: ${t.divisor}\\u306E\\u500D\\u6570\\u3067\\u3042\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059`;case"unrecognized_keys":return`\\u8A8D\\u8B58\\u3055\\u308C\\u3066\\u3044\\u306A\\u3044\\u30AD\\u30FC${t.keys.length>1?"\\u7FA4":""}: ${h(t.keys,"\\u3001")}`;case"invalid_key":return`${t.origin}\\u5185\\u306E\\u7121\\u52B9\\u306A\\u30AD\\u30FC`;case"invalid_union":return"\\u7121\\u52B9\\u306A\\u5165\\u529B";case"invalid_element":return`${t.origin}\\u5185\\u306E\\u7121\\u52B9\\u306A\\u5024`;default:return"\\u7121\\u52B9\\u306A\\u5165\\u529B"}}};function gl(){return{localeError:bp()}}var _p=()=>{let e={string:{unit:"\\u10E1\\u10D8\\u10DB\\u10D1\\u10DD\\u10DA\\u10DD",verb:"\\u10E3\\u10DC\\u10D3\\u10D0 \\u10E8\\u10D4\\u10D8\\u10EA\\u10D0\\u10D5\\u10D3\\u10D4\\u10E1"},file:{unit:"\\u10D1\\u10D0\\u10D8\\u10E2\\u10D8",verb:"\\u10E3\\u10DC\\u10D3\\u10D0 \\u10E8\\u10D4\\u10D8\\u10EA\\u10D0\\u10D5\\u10D3\\u10D4\\u10E1"},array:{unit:"\\u10D4\\u10DA\\u10D4\\u10DB\\u10D4\\u10DC\\u10E2\\u10D8",verb:"\\u10E3\\u10DC\\u10D3\\u10D0 \\u10E8\\u10D4\\u10D8\\u10EA\\u10D0\\u10D5\\u10D3\\u10D4\\u10E1"},set:{unit:"\\u10D4\\u10DA\\u10D4\\u10DB\\u10D4\\u10DC\\u10E2\\u10D8",verb:"\\u10E3\\u10DC\\u10D3\\u10D0 \\u10E8\\u10D4\\u10D8\\u10EA\\u10D0\\u10D5\\u10D3\\u10D4\\u10E1"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u10E8\\u10D4\\u10E7\\u10D5\\u10D0\\u10DC\\u10D0",email:"\\u10D4\\u10DA-\\u10E4\\u10DD\\u10E1\\u10E2\\u10D8\\u10E1 \\u10DB\\u10D8\\u10E1\\u10D0\\u10DB\\u10D0\\u10E0\\u10D7\\u10D8",url:"URL",emoji:"\\u10D4\\u10DB\\u10DD\\u10EF\\u10D8",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"\\u10D7\\u10D0\\u10E0\\u10D8\\u10E6\\u10D8-\\u10D3\\u10E0\\u10DD",date:"\\u10D7\\u10D0\\u10E0\\u10D8\\u10E6\\u10D8",time:"\\u10D3\\u10E0\\u10DD",duration:"\\u10EE\\u10D0\\u10DC\\u10D2\\u10E0\\u10EB\\u10DA\\u10D8\\u10D5\\u10DD\\u10D1\\u10D0",ipv4:"IPv4 \\u10DB\\u10D8\\u10E1\\u10D0\\u10DB\\u10D0\\u10E0\\u10D7\\u10D8",ipv6:"IPv6 \\u10DB\\u10D8\\u10E1\\u10D0\\u10DB\\u10D0\\u10E0\\u10D7\\u10D8",cidrv4:"IPv4 \\u10D3\\u10D8\\u10D0\\u10DE\\u10D0\\u10D6\\u10DD\\u10DC\\u10D8",cidrv6:"IPv6 \\u10D3\\u10D8\\u10D0\\u10DE\\u10D0\\u10D6\\u10DD\\u10DC\\u10D8",base64:"base64-\\u10D9\\u10DD\\u10D3\\u10D8\\u10E0\\u10D4\\u10D1\\u10E3\\u10DA\\u10D8 \\u10E1\\u10E2\\u10E0\\u10D8\\u10DC\\u10D2\\u10D8",base64url:"base64url-\\u10D9\\u10DD\\u10D3\\u10D8\\u10E0\\u10D4\\u10D1\\u10E3\\u10DA\\u10D8 \\u10E1\\u10E2\\u10E0\\u10D8\\u10DC\\u10D2\\u10D8",json_string:"JSON \\u10E1\\u10E2\\u10E0\\u10D8\\u10DC\\u10D2\\u10D8",e164:"E.164 \\u10DC\\u10DD\\u10DB\\u10D4\\u10E0\\u10D8",jwt:"JWT",template_literal:"\\u10E8\\u10D4\\u10E7\\u10D5\\u10D0\\u10DC\\u10D0"},o={nan:"NaN",number:"\\u10E0\\u10D8\\u10EA\\u10EE\\u10D5\\u10D8",string:"\\u10E1\\u10E2\\u10E0\\u10D8\\u10DC\\u10D2\\u10D8",boolean:"\\u10D1\\u10E3\\u10DA\\u10D4\\u10D0\\u10DC\\u10D8",function:"\\u10E4\\u10E3\\u10DC\\u10E5\\u10EA\\u10D8\\u10D0",array:"\\u10DB\\u10D0\\u10E1\\u10D8\\u10D5\\u10D8"};return t=>{var a,c,m,s,u;switch(t.code){case"invalid_type":{let d=(a=o[t.expected])!=null?a:t.expected,i=x(t.input),l=(c=o[i])!=null?c:i;return/^[A-Z]/.test(t.expected)?`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E8\\u10D4\\u10E7\\u10D5\\u10D0\\u10DC\\u10D0: \\u10DB\\u10DD\\u10E1\\u10D0\\u10DA\\u10DD\\u10D3\\u10DC\\u10D4\\u10DA\\u10D8 instanceof ${t.expected}, \\u10DB\\u10D8\\u10E6\\u10D4\\u10D1\\u10E3\\u10DA\\u10D8 ${l}`:`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E8\\u10D4\\u10E7\\u10D5\\u10D0\\u10DC\\u10D0: \\u10DB\\u10DD\\u10E1\\u10D0\\u10DA\\u10DD\\u10D3\\u10DC\\u10D4\\u10DA\\u10D8 ${d}, \\u10DB\\u10D8\\u10E6\\u10D4\\u10D1\\u10E3\\u10DA\\u10D8 ${l}`}case"invalid_value":return t.values.length===1?`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E8\\u10D4\\u10E7\\u10D5\\u10D0\\u10DC\\u10D0: \\u10DB\\u10DD\\u10E1\\u10D0\\u10DA\\u10DD\\u10D3\\u10DC\\u10D4\\u10DA\\u10D8 ${$(t.values[0])}`:`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10D5\\u10D0\\u10E0\\u10D8\\u10D0\\u10DC\\u10E2\\u10D8: \\u10DB\\u10DD\\u10E1\\u10D0\\u10DA\\u10DD\\u10D3\\u10DC\\u10D4\\u10DA\\u10D8\\u10D0 \\u10D4\\u10E0\\u10D7-\\u10D4\\u10E0\\u10D7\\u10D8 ${h(t.values,"|")}-\\u10D3\\u10D0\\u10DC`;case"too_big":{let d=t.inclusive?"<=":"<",i=r(t.origin);return i?`\\u10D6\\u10D4\\u10D3\\u10DB\\u10D4\\u10E2\\u10D0\\u10D3 \\u10D3\\u10D8\\u10D3\\u10D8: \\u10DB\\u10DD\\u10E1\\u10D0\\u10DA\\u10DD\\u10D3\\u10DC\\u10D4\\u10DA\\u10D8 ${(m=t.origin)!=null?m:"\\u10DB\\u10DC\\u10D8\\u10E8\\u10D5\\u10DC\\u10D4\\u10DA\\u10DD\\u10D1\\u10D0"} ${i.verb} ${d}${t.maximum.toString()} ${i.unit}`:`\\u10D6\\u10D4\\u10D3\\u10DB\\u10D4\\u10E2\\u10D0\\u10D3 \\u10D3\\u10D8\\u10D3\\u10D8: \\u10DB\\u10DD\\u10E1\\u10D0\\u10DA\\u10DD\\u10D3\\u10DC\\u10D4\\u10DA\\u10D8 ${(s=t.origin)!=null?s:"\\u10DB\\u10DC\\u10D8\\u10E8\\u10D5\\u10DC\\u10D4\\u10DA\\u10DD\\u10D1\\u10D0"} \\u10D8\\u10E7\\u10DD\\u10E1 ${d}${t.maximum.toString()}`}case"too_small":{let d=t.inclusive?">=":">",i=r(t.origin);return i?`\\u10D6\\u10D4\\u10D3\\u10DB\\u10D4\\u10E2\\u10D0\\u10D3 \\u10DE\\u10D0\\u10E2\\u10D0\\u10E0\\u10D0: \\u10DB\\u10DD\\u10E1\\u10D0\\u10DA\\u10DD\\u10D3\\u10DC\\u10D4\\u10DA\\u10D8 ${t.origin} ${i.verb} ${d}${t.minimum.toString()} ${i.unit}`:`\\u10D6\\u10D4\\u10D3\\u10DB\\u10D4\\u10E2\\u10D0\\u10D3 \\u10DE\\u10D0\\u10E2\\u10D0\\u10E0\\u10D0: \\u10DB\\u10DD\\u10E1\\u10D0\\u10DA\\u10DD\\u10D3\\u10DC\\u10D4\\u10DA\\u10D8 ${t.origin} \\u10D8\\u10E7\\u10DD\\u10E1 ${d}${t.minimum.toString()}`}case"invalid_format":{let d=t;return d.format==="starts_with"?`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E1\\u10E2\\u10E0\\u10D8\\u10DC\\u10D2\\u10D8: \\u10E3\\u10DC\\u10D3\\u10D0 \\u10D8\\u10EC\\u10E7\\u10D4\\u10D1\\u10DD\\u10D3\\u10D4\\u10E1 "${d.prefix}"-\\u10D8\\u10D7`:d.format==="ends_with"?`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E1\\u10E2\\u10E0\\u10D8\\u10DC\\u10D2\\u10D8: \\u10E3\\u10DC\\u10D3\\u10D0 \\u10DB\\u10D7\\u10D0\\u10D5\\u10E0\\u10D3\\u10D4\\u10D1\\u10DD\\u10D3\\u10D4\\u10E1 "${d.suffix}"-\\u10D8\\u10D7`:d.format==="includes"?`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E1\\u10E2\\u10E0\\u10D8\\u10DC\\u10D2\\u10D8: \\u10E3\\u10DC\\u10D3\\u10D0 \\u10E8\\u10D4\\u10D8\\u10EA\\u10D0\\u10D5\\u10D3\\u10D4\\u10E1 "${d.includes}"-\\u10E1`:d.format==="regex"?`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E1\\u10E2\\u10E0\\u10D8\\u10DC\\u10D2\\u10D8: \\u10E3\\u10DC\\u10D3\\u10D0 \\u10E8\\u10D4\\u10D4\\u10E1\\u10D0\\u10D1\\u10D0\\u10DB\\u10D4\\u10D1\\u10DD\\u10D3\\u10D4\\u10E1 \\u10E8\\u10D0\\u10D1\\u10DA\\u10DD\\u10DC\\u10E1 ${d.pattern}`:`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 ${(u=n[d.format])!=null?u:t.format}`}case"not_multiple_of":return`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E0\\u10D8\\u10EA\\u10EE\\u10D5\\u10D8: \\u10E3\\u10DC\\u10D3\\u10D0 \\u10D8\\u10E7\\u10DD\\u10E1 ${t.divisor}-\\u10D8\\u10E1 \\u10EF\\u10D4\\u10E0\\u10D0\\u10D3\\u10D8`;case"unrecognized_keys":return`\\u10E3\\u10EA\\u10DC\\u10DD\\u10D1\\u10D8 \\u10D2\\u10D0\\u10E1\\u10D0\\u10E6\\u10D4\\u10D1${t.keys.length>1?"\\u10D4\\u10D1\\u10D8":"\\u10D8"}: ${h(t.keys,", ")}`;case"invalid_key":return`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10D2\\u10D0\\u10E1\\u10D0\\u10E6\\u10D4\\u10D1\\u10D8 ${t.origin}-\\u10E8\\u10D8`;case"invalid_union":return"\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E8\\u10D4\\u10E7\\u10D5\\u10D0\\u10DC\\u10D0";case"invalid_element":return`\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10DB\\u10DC\\u10D8\\u10E8\\u10D5\\u10DC\\u10D4\\u10DA\\u10DD\\u10D1\\u10D0 ${t.origin}-\\u10E8\\u10D8`;default:return"\\u10D0\\u10E0\\u10D0\\u10E1\\u10EC\\u10DD\\u10E0\\u10D8 \\u10E8\\u10D4\\u10E7\\u10D5\\u10D0\\u10DC\\u10D0"}}};function vl(){return{localeError:_p()}}var Sp=()=>{let e={string:{unit:"\\u178F\\u17BD\\u17A2\\u1780\\u17D2\\u179F\\u179A",verb:"\\u1782\\u17BD\\u179A\\u1798\\u17B6\\u1793"},file:{unit:"\\u1794\\u17C3",verb:"\\u1782\\u17BD\\u179A\\u1798\\u17B6\\u1793"},array:{unit:"\\u1792\\u17B6\\u178F\\u17BB",verb:"\\u1782\\u17BD\\u179A\\u1798\\u17B6\\u1793"},set:{unit:"\\u1792\\u17B6\\u178F\\u17BB",verb:"\\u1782\\u17BD\\u179A\\u1798\\u17B6\\u1793"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1794\\u1789\\u17D2\\u1785\\u17BC\\u179B",email:"\\u17A2\\u17B6\\u179F\\u1799\\u178A\\u17D2\\u178B\\u17B6\\u1793\\u17A2\\u17CA\\u17B8\\u1798\\u17C2\\u179B",url:"URL",emoji:"\\u179F\\u1789\\u17D2\\u1789\\u17B6\\u17A2\\u17B6\\u179A\\u1798\\u17D2\\u1798\\u178E\\u17CD",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"\\u1780\\u17B6\\u179B\\u1794\\u179A\\u17B7\\u1785\\u17D2\\u1786\\u17C1\\u1791 \\u1793\\u17B7\\u1784\\u1798\\u17C9\\u17C4\\u1784 ISO",date:"\\u1780\\u17B6\\u179B\\u1794\\u179A\\u17B7\\u1785\\u17D2\\u1786\\u17C1\\u1791 ISO",time:"\\u1798\\u17C9\\u17C4\\u1784 ISO",duration:"\\u179A\\u1799\\u17C8\\u1796\\u17C1\\u179B ISO",ipv4:"\\u17A2\\u17B6\\u179F\\u1799\\u178A\\u17D2\\u178B\\u17B6\\u1793 IPv4",ipv6:"\\u17A2\\u17B6\\u179F\\u1799\\u178A\\u17D2\\u178B\\u17B6\\u1793 IPv6",cidrv4:"\\u178A\\u17C2\\u1793\\u17A2\\u17B6\\u179F\\u1799\\u178A\\u17D2\\u178B\\u17B6\\u1793 IPv4",cidrv6:"\\u178A\\u17C2\\u1793\\u17A2\\u17B6\\u179F\\u1799\\u178A\\u17D2\\u178B\\u17B6\\u1793 IPv6",base64:"\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u17A2\\u17CA\\u17B7\\u1780\\u17BC\\u178A base64",base64url:"\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u17A2\\u17CA\\u17B7\\u1780\\u17BC\\u178A base64url",json_string:"\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A JSON",e164:"\\u179B\\u17C1\\u1781 E.164",jwt:"JWT",template_literal:"\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1794\\u1789\\u17D2\\u1785\\u17BC\\u179B"},o={nan:"NaN",number:"\\u179B\\u17C1\\u1781",array:"\\u17A2\\u17B6\\u179A\\u17C1 (Array)",null:"\\u1782\\u17D2\\u1798\\u17B6\\u1793\\u178F\\u1798\\u17D2\\u179B\\u17C3 (null)"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1794\\u1789\\u17D2\\u1785\\u17BC\\u179B\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A instanceof ${t.expected} \\u1794\\u17C9\\u17BB\\u1793\\u17D2\\u178F\\u17C2\\u1791\\u1791\\u17BD\\u179B\\u1794\\u17B6\\u1793 ${p}`:`\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1794\\u1789\\u17D2\\u1785\\u17BC\\u179B\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${i} \\u1794\\u17C9\\u17BB\\u1793\\u17D2\\u178F\\u17C2\\u1791\\u1791\\u17BD\\u179B\\u1794\\u17B6\\u1793 ${p}`}case"invalid_value":return t.values.length===1?`\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1794\\u1789\\u17D2\\u1785\\u17BC\\u179B\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${$(t.values[0])}`:`\\u1787\\u1798\\u17D2\\u179A\\u17BE\\u179F\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1787\\u17B6\\u1798\\u17BD\\u1799\\u1780\\u17D2\\u1793\\u17BB\\u1784\\u1785\\u17C6\\u178E\\u17C4\\u1798 ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u1792\\u17C6\\u1796\\u17C1\\u1780\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${(m=t.origin)!=null?m:"\\u178F\\u1798\\u17D2\\u179B\\u17C3"} ${i} ${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u1792\\u17B6\\u178F\\u17BB"}`:`\\u1792\\u17C6\\u1796\\u17C1\\u1780\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${(u=t.origin)!=null?u:"\\u178F\\u1798\\u17D2\\u179B\\u17C3"} ${i} ${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u178F\\u17BC\\u1785\\u1796\\u17C1\\u1780\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${t.origin} ${i} ${t.minimum.toString()} ${l.unit}`:`\\u178F\\u17BC\\u1785\\u1796\\u17C1\\u1780\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1780\\u17B6\\u179A ${t.origin} ${i} ${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1785\\u17B6\\u1794\\u17CB\\u1795\\u17D2\\u178F\\u17BE\\u1798\\u178A\\u17C4\\u1799 "${i.prefix}"`:i.format==="ends_with"?`\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1794\\u1789\\u17D2\\u1785\\u1794\\u17CB\\u178A\\u17C4\\u1799 "${i.suffix}"`:i.format==="includes"?`\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1798\\u17B6\\u1793 "${i.includes}"`:i.format==="regex"?`\\u1781\\u17D2\\u179F\\u17C2\\u17A2\\u1780\\u17D2\\u179F\\u179A\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u178F\\u17C2\\u1795\\u17D2\\u1782\\u17BC\\u1795\\u17D2\\u1782\\u1784\\u1793\\u17B9\\u1784\\u1791\\u1798\\u17D2\\u179A\\u1784\\u17CB\\u178A\\u17C2\\u179B\\u1794\\u17B6\\u1793\\u1780\\u17C6\\u178E\\u178F\\u17CB ${i.pattern}`:`\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u179B\\u17C1\\u1781\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u17D6 \\u178F\\u17D2\\u179A\\u17BC\\u179C\\u178F\\u17C2\\u1787\\u17B6\\u1796\\u17A0\\u17BB\\u1782\\u17BB\\u178E\\u1793\\u17C3 ${t.divisor}`;case"unrecognized_keys":return`\\u179A\\u1780\\u1783\\u17BE\\u1789\\u179F\\u17C4\\u1798\\u17B7\\u1793\\u179F\\u17D2\\u1782\\u17B6\\u179B\\u17CB\\u17D6 ${h(t.keys,", ")}`;case"invalid_key":return`\\u179F\\u17C4\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1793\\u17C5\\u1780\\u17D2\\u1793\\u17BB\\u1784 ${t.origin}`;case"invalid_union":return"\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C";case"invalid_element":return`\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C\\u1793\\u17C5\\u1780\\u17D2\\u1793\\u17BB\\u1784 ${t.origin}`;default:return"\\u1791\\u17B7\\u1793\\u17D2\\u1793\\u1793\\u17D0\\u1799\\u1798\\u17B7\\u1793\\u178F\\u17D2\\u179A\\u17B9\\u1798\\u178F\\u17D2\\u179A\\u17BC\\u179C"}}};function $r(){return{localeError:Sp()}}function hl(){return $r()}var kp=()=>{let e={string:{unit:"\\uBB38\\uC790",verb:"to have"},file:{unit:"\\uBC14\\uC774\\uD2B8",verb:"to have"},array:{unit:"\\uAC1C",verb:"to have"},set:{unit:"\\uAC1C",verb:"to have"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\uC785\\uB825",email:"\\uC774\\uBA54\\uC77C \\uC8FC\\uC18C",url:"URL",emoji:"\\uC774\\uBAA8\\uC9C0",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO \\uB0A0\\uC9DC\\uC2DC\\uAC04",date:"ISO \\uB0A0\\uC9DC",time:"ISO \\uC2DC\\uAC04",duration:"ISO \\uAE30\\uAC04",ipv4:"IPv4 \\uC8FC\\uC18C",ipv6:"IPv6 \\uC8FC\\uC18C",cidrv4:"IPv4 \\uBC94\\uC704",cidrv6:"IPv6 \\uBC94\\uC704",base64:"base64 \\uC778\\uCF54\\uB529 \\uBB38\\uC790\\uC5F4",base64url:"base64url \\uC778\\uCF54\\uB529 \\uBB38\\uC790\\uC5F4",json_string:"JSON \\uBB38\\uC790\\uC5F4",e164:"E.164 \\uBC88\\uD638",jwt:"JWT",template_literal:"\\uC785\\uB825"},o={nan:"NaN"};return t=>{var a,c,m,s,u,d,i,l,p;switch(t.code){case"invalid_type":{let v=(a=o[t.expected])!=null?a:t.expected,y=x(t.input),S=(c=o[y])!=null?c:y;return/^[A-Z]/.test(t.expected)?`\\uC798\\uBABB\\uB41C \\uC785\\uB825: \\uC608\\uC0C1 \\uD0C0\\uC785\\uC740 instanceof ${t.expected}, \\uBC1B\\uC740 \\uD0C0\\uC785\\uC740 ${S}\\uC785\\uB2C8\\uB2E4`:`\\uC798\\uBABB\\uB41C \\uC785\\uB825: \\uC608\\uC0C1 \\uD0C0\\uC785\\uC740 ${v}, \\uBC1B\\uC740 \\uD0C0\\uC785\\uC740 ${S}\\uC785\\uB2C8\\uB2E4`}case"invalid_value":return t.values.length===1?`\\uC798\\uBABB\\uB41C \\uC785\\uB825: \\uAC12\\uC740 ${$(t.values[0])} \\uC774\\uC5B4\\uC57C \\uD569\\uB2C8\\uB2E4`:`\\uC798\\uBABB\\uB41C \\uC635\\uC158: ${h(t.values,"\\uB610\\uB294 ")} \\uC911 \\uD558\\uB098\\uC5EC\\uC57C \\uD569\\uB2C8\\uB2E4`;case"too_big":{let v=t.inclusive?"\\uC774\\uD558":"\\uBBF8\\uB9CC",y=v==="\\uBBF8\\uB9CC"?"\\uC774\\uC5B4\\uC57C \\uD569\\uB2C8\\uB2E4":"\\uC5EC\\uC57C \\uD569\\uB2C8\\uB2E4",S=r(t.origin),w=(m=S==null?void 0:S.unit)!=null?m:"\\uC694\\uC18C";return S?`${(s=t.origin)!=null?s:"\\uAC12"}\\uC774 \\uB108\\uBB34 \\uD07D\\uB2C8\\uB2E4: ${t.maximum.toString()}${w} ${v}${y}`:`${(u=t.origin)!=null?u:"\\uAC12"}\\uC774 \\uB108\\uBB34 \\uD07D\\uB2C8\\uB2E4: ${t.maximum.toString()} ${v}${y}`}case"too_small":{let v=t.inclusive?"\\uC774\\uC0C1":"\\uCD08\\uACFC",y=v==="\\uC774\\uC0C1"?"\\uC774\\uC5B4\\uC57C \\uD569\\uB2C8\\uB2E4":"\\uC5EC\\uC57C \\uD569\\uB2C8\\uB2E4",S=r(t.origin),w=(d=S==null?void 0:S.unit)!=null?d:"\\uC694\\uC18C";return S?`${(i=t.origin)!=null?i:"\\uAC12"}\\uC774 \\uB108\\uBB34 \\uC791\\uC2B5\\uB2C8\\uB2E4: ${t.minimum.toString()}${w} ${v}${y}`:`${(l=t.origin)!=null?l:"\\uAC12"}\\uC774 \\uB108\\uBB34 \\uC791\\uC2B5\\uB2C8\\uB2E4: ${t.minimum.toString()} ${v}${y}`}case"invalid_format":{let v=t;return v.format==="starts_with"?`\\uC798\\uBABB\\uB41C \\uBB38\\uC790\\uC5F4: "${v.prefix}"(\\uC73C)\\uB85C \\uC2DC\\uC791\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4`:v.format==="ends_with"?`\\uC798\\uBABB\\uB41C \\uBB38\\uC790\\uC5F4: "${v.suffix}"(\\uC73C)\\uB85C \\uB05D\\uB098\\uC57C \\uD569\\uB2C8\\uB2E4`:v.format==="includes"?`\\uC798\\uBABB\\uB41C \\uBB38\\uC790\\uC5F4: "${v.includes}"\\uC744(\\uB97C) \\uD3EC\\uD568\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4`:v.format==="regex"?`\\uC798\\uBABB\\uB41C \\uBB38\\uC790\\uC5F4: \\uC815\\uADDC\\uC2DD ${v.pattern} \\uD328\\uD134\\uACFC \\uC77C\\uCE58\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4`:`\\uC798\\uBABB\\uB41C ${(p=n[v.format])!=null?p:t.format}`}case"not_multiple_of":return`\\uC798\\uBABB\\uB41C \\uC22B\\uC790: ${t.divisor}\\uC758 \\uBC30\\uC218\\uC5EC\\uC57C \\uD569\\uB2C8\\uB2E4`;case"unrecognized_keys":return`\\uC778\\uC2DD\\uD560 \\uC218 \\uC5C6\\uB294 \\uD0A4: ${h(t.keys,", ")}`;case"invalid_key":return`\\uC798\\uBABB\\uB41C \\uD0A4: ${t.origin}`;case"invalid_union":return"\\uC798\\uBABB\\uB41C \\uC785\\uB825";case"invalid_element":return`\\uC798\\uBABB\\uB41C \\uAC12: ${t.origin}`;default:return"\\uC798\\uBABB\\uB41C \\uC785\\uB825"}}};function yl(){return{localeError:kp()}}var ft=e=>e.charAt(0).toUpperCase()+e.slice(1);function $l(e){let r=Math.abs(e),n=r%10,o=r%100;return o>=11&&o<=19||n===0?"many":n===1?"one":"few"}var Ip=()=>{let e={string:{unit:{one:"simbolis",few:"simboliai",many:"simboli\\u0173"},verb:{smaller:{inclusive:"turi b\\u016Bti ne ilgesn\\u0117 kaip",notInclusive:"turi b\\u016Bti trumpesn\\u0117 kaip"},bigger:{inclusive:"turi b\\u016Bti ne trumpesn\\u0117 kaip",notInclusive:"turi b\\u016Bti ilgesn\\u0117 kaip"}}},file:{unit:{one:"baitas",few:"baitai",many:"bait\\u0173"},verb:{smaller:{inclusive:"turi b\\u016Bti ne didesnis kaip",notInclusive:"turi b\\u016Bti ma\\u017Eesnis kaip"},bigger:{inclusive:"turi b\\u016Bti ne ma\\u017Eesnis kaip",notInclusive:"turi b\\u016Bti didesnis kaip"}}},array:{unit:{one:"element\\u0105",few:"elementus",many:"element\\u0173"},verb:{smaller:{inclusive:"turi tur\\u0117ti ne daugiau kaip",notInclusive:"turi tur\\u0117ti ma\\u017Eiau kaip"},bigger:{inclusive:"turi tur\\u0117ti ne ma\\u017Eiau kaip",notInclusive:"turi tur\\u0117ti daugiau kaip"}}},set:{unit:{one:"element\\u0105",few:"elementus",many:"element\\u0173"},verb:{smaller:{inclusive:"turi tur\\u0117ti ne daugiau kaip",notInclusive:"turi tur\\u0117ti ma\\u017Eiau kaip"},bigger:{inclusive:"turi tur\\u0117ti ne ma\\u017Eiau kaip",notInclusive:"turi tur\\u0117ti daugiau kaip"}}}};function r(t,a,c,m){var u;let s=(u=e[t])!=null?u:null;return s===null?s:{unit:s.unit[a],verb:s.verb[m][c?"inclusive":"notInclusive"]}}let n={regex:"\\u012Fvestis",email:"el. pa\\u0161to adresas",url:"URL",emoji:"jaustukas",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO data ir laikas",date:"ISO data",time:"ISO laikas",duration:"ISO trukm\\u0117",ipv4:"IPv4 adresas",ipv6:"IPv6 adresas",cidrv4:"IPv4 tinklo prefiksas (CIDR)",cidrv6:"IPv6 tinklo prefiksas (CIDR)",base64:"base64 u\\u017Ekoduota eilut\\u0117",base64url:"base64url u\\u017Ekoduota eilut\\u0117",json_string:"JSON eilut\\u0117",e164:"E.164 numeris",jwt:"JWT",template_literal:"\\u012Fvestis"},o={nan:"NaN",number:"skai\\u010Dius",bigint:"sveikasis skai\\u010Dius",string:"eilut\\u0117",boolean:"login\\u0117 reik\\u0161m\\u0117",undefined:"neapibr\\u0117\\u017Eta reik\\u0161m\\u0117",function:"funkcija",symbol:"simbolis",array:"masyvas",object:"objektas",null:"nulin\\u0117 reik\\u0161m\\u0117"};return t=>{var a,c,m,s,u,d,i,l,p,v,y,S,w,D,N;switch(t.code){case"invalid_type":{let k=(a=o[t.expected])!=null?a:t.expected,T=x(t.input),U=(c=o[T])!=null?c:T;return/^[A-Z]/.test(t.expected)?`Gautas tipas ${U}, o tik\\u0117tasi - instanceof ${t.expected}`:`Gautas tipas ${U}, o tik\\u0117tasi - ${k}`}case"invalid_value":return t.values.length===1?`Privalo b\\u016Bti ${$(t.values[0])}`:`Privalo b\\u016Bti vienas i\\u0161 ${h(t.values,"|")} pasirinkim\\u0173`;case"too_big":{let k=(m=o[t.origin])!=null?m:t.origin,T=r(t.origin,$l(Number(t.maximum)),(s=t.inclusive)!=null?s:!1,"smaller");if(T!=null&&T.verb)return`${ft((u=k!=null?k:t.origin)!=null?u:"reik\\u0161m\\u0117")} ${T.verb} ${t.maximum.toString()} ${(d=T.unit)!=null?d:"element\\u0173"}`;let U=t.inclusive?"ne didesnis kaip":"ma\\u017Eesnis kaip";return`${ft((i=k!=null?k:t.origin)!=null?i:"reik\\u0161m\\u0117")} turi b\\u016Bti ${U} ${t.maximum.toString()} ${T==null?void 0:T.unit}`}case"too_small":{let k=(l=o[t.origin])!=null?l:t.origin,T=r(t.origin,$l(Number(t.minimum)),(p=t.inclusive)!=null?p:!1,"bigger");if(T!=null&&T.verb)return`${ft((v=k!=null?k:t.origin)!=null?v:"reik\\u0161m\\u0117")} ${T.verb} ${t.minimum.toString()} ${(y=T.unit)!=null?y:"element\\u0173"}`;let U=t.inclusive?"ne ma\\u017Eesnis kaip":"didesnis kaip";return`${ft((S=k!=null?k:t.origin)!=null?S:"reik\\u0161m\\u0117")} turi b\\u016Bti ${U} ${t.minimum.toString()} ${T==null?void 0:T.unit}`}case"invalid_format":{let k=t;return k.format==="starts_with"?`Eilut\\u0117 privalo prasid\\u0117ti "${k.prefix}"`:k.format==="ends_with"?`Eilut\\u0117 privalo pasibaigti "${k.suffix}"`:k.format==="includes"?`Eilut\\u0117 privalo \\u012Ftraukti "${k.includes}"`:k.format==="regex"?`Eilut\\u0117 privalo atitikti ${k.pattern}`:`Neteisingas ${(w=n[k.format])!=null?w:t.format}`}case"not_multiple_of":return`Skai\\u010Dius privalo b\\u016Bti ${t.divisor} kartotinis.`;case"unrecognized_keys":return`Neatpa\\u017Eint${t.keys.length>1?"i":"as"} rakt${t.keys.length>1?"ai":"as"}: ${h(t.keys,", ")}`;case"invalid_key":return"Rastas klaidingas raktas";case"invalid_union":return"Klaidinga \\u012Fvestis";case"invalid_element":{let k=(D=o[t.origin])!=null?D:t.origin;return`${ft((N=k!=null?k:t.origin)!=null?N:"reik\\u0161m\\u0117")} turi klaiding\\u0105 \\u012Fvest\\u012F`}default:return"Klaidinga \\u012Fvestis"}}};function xl(){return{localeError:Ip()}}var zp=()=>{let e={string:{unit:"\\u0437\\u043D\\u0430\\u0446\\u0438",verb:"\\u0434\\u0430 \\u0438\\u043C\\u0430\\u0430\\u0442"},file:{unit:"\\u0431\\u0430\\u0458\\u0442\\u0438",verb:"\\u0434\\u0430 \\u0438\\u043C\\u0430\\u0430\\u0442"},array:{unit:"\\u0441\\u0442\\u0430\\u0432\\u043A\\u0438",verb:"\\u0434\\u0430 \\u0438\\u043C\\u0430\\u0430\\u0442"},set:{unit:"\\u0441\\u0442\\u0430\\u0432\\u043A\\u0438",verb:"\\u0434\\u0430 \\u0438\\u043C\\u0430\\u0430\\u0442"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0432\\u043D\\u0435\\u0441",email:"\\u0430\\u0434\\u0440\\u0435\\u0441\\u0430 \\u043D\\u0430 \\u0435-\\u043F\\u043E\\u0448\\u0442\\u0430",url:"URL",emoji:"\\u0435\\u043C\\u043E\\u045F\\u0438",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO \\u0434\\u0430\\u0442\\u0443\\u043C \\u0438 \\u0432\\u0440\\u0435\\u043C\\u0435",date:"ISO \\u0434\\u0430\\u0442\\u0443\\u043C",time:"ISO \\u0432\\u0440\\u0435\\u043C\\u0435",duration:"ISO \\u0432\\u0440\\u0435\\u043C\\u0435\\u0442\\u0440\\u0430\\u0435\\u045A\\u0435",ipv4:"IPv4 \\u0430\\u0434\\u0440\\u0435\\u0441\\u0430",ipv6:"IPv6 \\u0430\\u0434\\u0440\\u0435\\u0441\\u0430",cidrv4:"IPv4 \\u043E\\u043F\\u0441\\u0435\\u0433",cidrv6:"IPv6 \\u043E\\u043F\\u0441\\u0435\\u0433",base64:"base64-\\u0435\\u043D\\u043A\\u043E\\u0434\\u0438\\u0440\\u0430\\u043D\\u0430 \\u043D\\u0438\\u0437\\u0430",base64url:"base64url-\\u0435\\u043D\\u043A\\u043E\\u0434\\u0438\\u0440\\u0430\\u043D\\u0430 \\u043D\\u0438\\u0437\\u0430",json_string:"JSON \\u043D\\u0438\\u0437\\u0430",e164:"E.164 \\u0431\\u0440\\u043E\\u0458",jwt:"JWT",template_literal:"\\u0432\\u043D\\u0435\\u0441"},o={nan:"NaN",number:"\\u0431\\u0440\\u043E\\u0458",array:"\\u043D\\u0438\\u0437\\u0430"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u0413\\u0440\\u0435\\u0448\\u0435\\u043D \\u0432\\u043D\\u0435\\u0441: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 instanceof ${t.expected}, \\u043F\\u0440\\u0438\\u043C\\u0435\\u043D\\u043E ${p}`:`\\u0413\\u0440\\u0435\\u0448\\u0435\\u043D \\u0432\\u043D\\u0435\\u0441: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 ${i}, \\u043F\\u0440\\u0438\\u043C\\u0435\\u043D\\u043E ${p}`}case"invalid_value":return t.values.length===1?`Invalid input: expected ${$(t.values[0])}`:`\\u0413\\u0440\\u0435\\u0448\\u0430\\u043D\\u0430 \\u043E\\u043F\\u0446\\u0438\\u0458\\u0430: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 \\u0435\\u0434\\u043D\\u0430 ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u041F\\u0440\\u0435\\u043C\\u043D\\u043E\\u0433\\u0443 \\u0433\\u043E\\u043B\\u0435\\u043C: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 ${(m=t.origin)!=null?m:"\\u0432\\u0440\\u0435\\u0434\\u043D\\u043E\\u0441\\u0442\\u0430"} \\u0434\\u0430 \\u0438\\u043C\\u0430 ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0438"}`:`\\u041F\\u0440\\u0435\\u043C\\u043D\\u043E\\u0433\\u0443 \\u0433\\u043E\\u043B\\u0435\\u043C: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 ${(u=t.origin)!=null?u:"\\u0432\\u0440\\u0435\\u0434\\u043D\\u043E\\u0441\\u0442\\u0430"} \\u0434\\u0430 \\u0431\\u0438\\u0434\\u0435 ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u041F\\u0440\\u0435\\u043C\\u043D\\u043E\\u0433\\u0443 \\u043C\\u0430\\u043B: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 ${t.origin} \\u0434\\u0430 \\u0438\\u043C\\u0430 ${i}${t.minimum.toString()} ${l.unit}`:`\\u041F\\u0440\\u0435\\u043C\\u043D\\u043E\\u0433\\u0443 \\u043C\\u0430\\u043B: \\u0441\\u0435 \\u043E\\u0447\\u0435\\u043A\\u0443\\u0432\\u0430 ${t.origin} \\u0434\\u0430 \\u0431\\u0438\\u0434\\u0435 ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u041D\\u0435\\u0432\\u0430\\u0436\\u0435\\u0447\\u043A\\u0430 \\u043D\\u0438\\u0437\\u0430: \\u043C\\u043E\\u0440\\u0430 \\u0434\\u0430 \\u0437\\u0430\\u043F\\u043E\\u0447\\u043D\\u0443\\u0432\\u0430 \\u0441\\u043E "${i.prefix}"`:i.format==="ends_with"?`\\u041D\\u0435\\u0432\\u0430\\u0436\\u0435\\u0447\\u043A\\u0430 \\u043D\\u0438\\u0437\\u0430: \\u043C\\u043E\\u0440\\u0430 \\u0434\\u0430 \\u0437\\u0430\\u0432\\u0440\\u0448\\u0443\\u0432\\u0430 \\u0441\\u043E "${i.suffix}"`:i.format==="includes"?`\\u041D\\u0435\\u0432\\u0430\\u0436\\u0435\\u0447\\u043A\\u0430 \\u043D\\u0438\\u0437\\u0430: \\u043C\\u043E\\u0440\\u0430 \\u0434\\u0430 \\u0432\\u043A\\u043B\\u0443\\u0447\\u0443\\u0432\\u0430 "${i.includes}"`:i.format==="regex"?`\\u041D\\u0435\\u0432\\u0430\\u0436\\u0435\\u0447\\u043A\\u0430 \\u043D\\u0438\\u0437\\u0430: \\u043C\\u043E\\u0440\\u0430 \\u0434\\u0430 \\u043E\\u0434\\u0433\\u043E\\u0430\\u0440\\u0430 \\u043D\\u0430 \\u043F\\u0430\\u0442\\u0435\\u0440\\u043D\\u043E\\u0442 ${i.pattern}`:`Invalid ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u0413\\u0440\\u0435\\u0448\\u0435\\u043D \\u0431\\u0440\\u043E\\u0458: \\u043C\\u043E\\u0440\\u0430 \\u0434\\u0430 \\u0431\\u0438\\u0434\\u0435 \\u0434\\u0435\\u043B\\u0438\\u0432 \\u0441\\u043E ${t.divisor}`;case"unrecognized_keys":return`${t.keys.length>1?"\\u041D\\u0435\\u043F\\u0440\\u0435\\u043F\\u043E\\u0437\\u043D\\u0430\\u0435\\u043D\\u0438 \\u043A\\u043B\\u0443\\u0447\\u0435\\u0432\\u0438":"\\u041D\\u0435\\u043F\\u0440\\u0435\\u043F\\u043E\\u0437\\u043D\\u0430\\u0435\\u043D \\u043A\\u043B\\u0443\\u0447"}: ${h(t.keys,", ")}`;case"invalid_key":return`\\u0413\\u0440\\u0435\\u0448\\u0435\\u043D \\u043A\\u043B\\u0443\\u0447 \\u0432\\u043E ${t.origin}`;case"invalid_union":return"\\u0413\\u0440\\u0435\\u0448\\u0435\\u043D \\u0432\\u043D\\u0435\\u0441";case"invalid_element":return`\\u0413\\u0440\\u0435\\u0448\\u043D\\u0430 \\u0432\\u0440\\u0435\\u0434\\u043D\\u043E\\u0441\\u0442 \\u0432\\u043E ${t.origin}`;default:return"\\u0413\\u0440\\u0435\\u0448\\u0435\\u043D \\u0432\\u043D\\u0435\\u0441"}}};function bl(){return{localeError:zp()}}var Tp=()=>{let e={string:{unit:"aksara",verb:"mempunyai"},file:{unit:"bait",verb:"mempunyai"},array:{unit:"elemen",verb:"mempunyai"},set:{unit:"elemen",verb:"mempunyai"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"input",email:"alamat e-mel",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"tarikh masa ISO",date:"tarikh ISO",time:"masa ISO",duration:"tempoh ISO",ipv4:"alamat IPv4",ipv6:"alamat IPv6",cidrv4:"julat IPv4",cidrv6:"julat IPv6",base64:"string dikodkan base64",base64url:"string dikodkan base64url",json_string:"string JSON",e164:"nombor E.164",jwt:"JWT",template_literal:"input"},o={nan:"NaN",number:"nombor"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Input tidak sah: dijangka instanceof ${t.expected}, diterima ${p}`:`Input tidak sah: dijangka ${i}, diterima ${p}`}case"invalid_value":return t.values.length===1?`Input tidak sah: dijangka ${$(t.values[0])}`:`Pilihan tidak sah: dijangka salah satu daripada ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Terlalu besar: dijangka ${(m=t.origin)!=null?m:"nilai"} ${l.verb} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elemen"}`:`Terlalu besar: dijangka ${(u=t.origin)!=null?u:"nilai"} adalah ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Terlalu kecil: dijangka ${t.origin} ${l.verb} ${i}${t.minimum.toString()} ${l.unit}`:`Terlalu kecil: dijangka ${t.origin} adalah ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`String tidak sah: mesti bermula dengan "${i.prefix}"`:i.format==="ends_with"?`String tidak sah: mesti berakhir dengan "${i.suffix}"`:i.format==="includes"?`String tidak sah: mesti mengandungi "${i.includes}"`:i.format==="regex"?`String tidak sah: mesti sepadan dengan corak ${i.pattern}`:`${(d=n[i.format])!=null?d:t.format} tidak sah`}case"not_multiple_of":return`Nombor tidak sah: perlu gandaan ${t.divisor}`;case"unrecognized_keys":return`Kunci tidak dikenali: ${h(t.keys,", ")}`;case"invalid_key":return`Kunci tidak sah dalam ${t.origin}`;case"invalid_union":return"Input tidak sah";case"invalid_element":return`Nilai tidak sah dalam ${t.origin}`;default:return"Input tidak sah"}}};function _l(){return{localeError:Tp()}}var wp=()=>{let e={string:{unit:"tekens",verb:"heeft"},file:{unit:"bytes",verb:"heeft"},array:{unit:"elementen",verb:"heeft"},set:{unit:"elementen",verb:"heeft"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"invoer",email:"emailadres",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO datum en tijd",date:"ISO datum",time:"ISO tijd",duration:"ISO duur",ipv4:"IPv4-adres",ipv6:"IPv6-adres",cidrv4:"IPv4-bereik",cidrv6:"IPv6-bereik",base64:"base64-gecodeerde tekst",base64url:"base64 URL-gecodeerde tekst",json_string:"JSON string",e164:"E.164-nummer",jwt:"JWT",template_literal:"invoer"},o={nan:"NaN",number:"getal"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Ongeldige invoer: verwacht instanceof ${t.expected}, ontving ${p}`:`Ongeldige invoer: verwacht ${i}, ontving ${p}`}case"invalid_value":return t.values.length===1?`Ongeldige invoer: verwacht ${$(t.values[0])}`:`Ongeldige optie: verwacht \\xE9\\xE9n van ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin),p=t.origin==="date"?"laat":t.origin==="string"?"lang":"groot";return l?`Te ${p}: verwacht dat ${(m=t.origin)!=null?m:"waarde"} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elementen"} ${l.verb}`:`Te ${p}: verwacht dat ${(u=t.origin)!=null?u:"waarde"} ${i}${t.maximum.toString()} is`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin),p=t.origin==="date"?"vroeg":t.origin==="string"?"kort":"klein";return l?`Te ${p}: verwacht dat ${t.origin} ${i}${t.minimum.toString()} ${l.unit} ${l.verb}`:`Te ${p}: verwacht dat ${t.origin} ${i}${t.minimum.toString()} is`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Ongeldige tekst: moet met "${i.prefix}" beginnen`:i.format==="ends_with"?`Ongeldige tekst: moet op "${i.suffix}" eindigen`:i.format==="includes"?`Ongeldige tekst: moet "${i.includes}" bevatten`:i.format==="regex"?`Ongeldige tekst: moet overeenkomen met patroon ${i.pattern}`:`Ongeldig: ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Ongeldig getal: moet een veelvoud van ${t.divisor} zijn`;case"unrecognized_keys":return`Onbekende key${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`Ongeldige key in ${t.origin}`;case"invalid_union":return"Ongeldige invoer";case"invalid_element":return`Ongeldige waarde in ${t.origin}`;default:return"Ongeldige invoer"}}};function Sl(){return{localeError:wp()}}var Pp=()=>{let e={string:{unit:"tegn",verb:"\\xE5 ha"},file:{unit:"bytes",verb:"\\xE5 ha"},array:{unit:"elementer",verb:"\\xE5 inneholde"},set:{unit:"elementer",verb:"\\xE5 inneholde"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"input",email:"e-postadresse",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO dato- og klokkeslett",date:"ISO-dato",time:"ISO-klokkeslett",duration:"ISO-varighet",ipv4:"IPv4-omr\\xE5de",ipv6:"IPv6-omr\\xE5de",cidrv4:"IPv4-spekter",cidrv6:"IPv6-spekter",base64:"base64-enkodet streng",base64url:"base64url-enkodet streng",json_string:"JSON-streng",e164:"E.164-nummer",jwt:"JWT",template_literal:"input"},o={nan:"NaN",number:"tall",array:"liste"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Ugyldig input: forventet instanceof ${t.expected}, fikk ${p}`:`Ugyldig input: forventet ${i}, fikk ${p}`}case"invalid_value":return t.values.length===1?`Ugyldig verdi: forventet ${$(t.values[0])}`:`Ugyldig valg: forventet en av ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`For stor(t): forventet ${(m=t.origin)!=null?m:"value"} til \\xE5 ha ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elementer"}`:`For stor(t): forventet ${(u=t.origin)!=null?u:"value"} til \\xE5 ha ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`For lite(n): forventet ${t.origin} til \\xE5 ha ${i}${t.minimum.toString()} ${l.unit}`:`For lite(n): forventet ${t.origin} til \\xE5 ha ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Ugyldig streng: m\\xE5 starte med "${i.prefix}"`:i.format==="ends_with"?`Ugyldig streng: m\\xE5 ende med "${i.suffix}"`:i.format==="includes"?`Ugyldig streng: m\\xE5 inneholde "${i.includes}"`:i.format==="regex"?`Ugyldig streng: m\\xE5 matche m\\xF8nsteret ${i.pattern}`:`Ugyldig ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Ugyldig tall: m\\xE5 v\\xE6re et multiplum av ${t.divisor}`;case"unrecognized_keys":return`${t.keys.length>1?"Ukjente n\\xF8kler":"Ukjent n\\xF8kkel"}: ${h(t.keys,", ")}`;case"invalid_key":return`Ugyldig n\\xF8kkel i ${t.origin}`;case"invalid_union":return"Ugyldig input";case"invalid_element":return`Ugyldig verdi i ${t.origin}`;default:return"Ugyldig input"}}};function kl(){return{localeError:Pp()}}var Dp=()=>{let e={string:{unit:"harf",verb:"olmal\\u0131d\\u0131r"},file:{unit:"bayt",verb:"olmal\\u0131d\\u0131r"},array:{unit:"unsur",verb:"olmal\\u0131d\\u0131r"},set:{unit:"unsur",verb:"olmal\\u0131d\\u0131r"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"giren",email:"epostag\\xE2h",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO heng\\xE2m\\u0131",date:"ISO tarihi",time:"ISO zaman\\u0131",duration:"ISO m\\xFCddeti",ipv4:"IPv4 ni\\u015F\\xE2n\\u0131",ipv6:"IPv6 ni\\u015F\\xE2n\\u0131",cidrv4:"IPv4 menzili",cidrv6:"IPv6 menzili",base64:"base64-\\u015Fifreli metin",base64url:"base64url-\\u015Fifreli metin",json_string:"JSON metin",e164:"E.164 say\\u0131s\\u0131",jwt:"JWT",template_literal:"giren"},o={nan:"NaN",number:"numara",array:"saf",null:"gayb"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`F\\xE2sit giren: umulan instanceof ${t.expected}, al\\u0131nan ${p}`:`F\\xE2sit giren: umulan ${i}, al\\u0131nan ${p}`}case"invalid_value":return t.values.length===1?`F\\xE2sit giren: umulan ${$(t.values[0])}`:`F\\xE2sit tercih: m\\xFBteberler ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Fazla b\\xFCy\\xFCk: ${(m=t.origin)!=null?m:"value"}, ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elements"} sahip olmal\\u0131yd\\u0131.`:`Fazla b\\xFCy\\xFCk: ${(u=t.origin)!=null?u:"value"}, ${i}${t.maximum.toString()} olmal\\u0131yd\\u0131.`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Fazla k\\xFC\\xE7\\xFCk: ${t.origin}, ${i}${t.minimum.toString()} ${l.unit} sahip olmal\\u0131yd\\u0131.`:`Fazla k\\xFC\\xE7\\xFCk: ${t.origin}, ${i}${t.minimum.toString()} olmal\\u0131yd\\u0131.`}case"invalid_format":{let i=t;return i.format==="starts_with"?`F\\xE2sit metin: "${i.prefix}" ile ba\\u015Flamal\\u0131.`:i.format==="ends_with"?`F\\xE2sit metin: "${i.suffix}" ile bitmeli.`:i.format==="includes"?`F\\xE2sit metin: "${i.includes}" ihtiv\\xE2 etmeli.`:i.format==="regex"?`F\\xE2sit metin: ${i.pattern} nak\\u015F\\u0131na uymal\\u0131.`:`F\\xE2sit ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`F\\xE2sit say\\u0131: ${t.divisor} kat\\u0131 olmal\\u0131yd\\u0131.`;case"unrecognized_keys":return`Tan\\u0131nmayan anahtar ${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`${t.origin} i\\xE7in tan\\u0131nmayan anahtar var.`;case"invalid_union":return"Giren tan\\u0131namad\\u0131.";case"invalid_element":return`${t.origin} i\\xE7in tan\\u0131nmayan k\\u0131ymet var.`;default:return"K\\u0131ymet tan\\u0131namad\\u0131."}}};function Il(){return{localeError:Dp()}}var jp=()=>{let e={string:{unit:"\\u062A\\u0648\\u06A9\\u064A",verb:"\\u0648\\u0644\\u0631\\u064A"},file:{unit:"\\u0628\\u0627\\u06CC\\u067C\\u0633",verb:"\\u0648\\u0644\\u0631\\u064A"},array:{unit:"\\u062A\\u0648\\u06A9\\u064A",verb:"\\u0648\\u0644\\u0631\\u064A"},set:{unit:"\\u062A\\u0648\\u06A9\\u064A",verb:"\\u0648\\u0644\\u0631\\u064A"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0648\\u0631\\u0648\\u062F\\u064A",email:"\\u0628\\u0631\\u06CC\\u069A\\u0646\\u0627\\u0644\\u06CC\\u06A9",url:"\\u06CC\\u0648 \\u0622\\u0631 \\u0627\\u0644",emoji:"\\u0627\\u06CC\\u0645\\u0648\\u062C\\u064A",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"\\u0646\\u06CC\\u067C\\u0647 \\u0627\\u0648 \\u0648\\u062E\\u062A",date:"\\u0646\\u06D0\\u067C\\u0647",time:"\\u0648\\u062E\\u062A",duration:"\\u0645\\u0648\\u062F\\u0647",ipv4:"\\u062F IPv4 \\u067E\\u062A\\u0647",ipv6:"\\u062F IPv6 \\u067E\\u062A\\u0647",cidrv4:"\\u062F IPv4 \\u0633\\u0627\\u062D\\u0647",cidrv6:"\\u062F IPv6 \\u0633\\u0627\\u062D\\u0647",base64:"base64-encoded \\u0645\\u062A\\u0646",base64url:"base64url-encoded \\u0645\\u062A\\u0646",json_string:"JSON \\u0645\\u062A\\u0646",e164:"\\u062F E.164 \\u0634\\u0645\\u06D0\\u0631\\u0647",jwt:"JWT",template_literal:"\\u0648\\u0631\\u0648\\u062F\\u064A"},o={nan:"NaN",number:"\\u0639\\u062F\\u062F",array:"\\u0627\\u0631\\u06D0"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u0646\\u0627\\u0633\\u0645 \\u0648\\u0631\\u0648\\u062F\\u064A: \\u0628\\u0627\\u06CC\\u062F instanceof ${t.expected} \\u0648\\u0627\\u06CC, \\u0645\\u06AB\\u0631 ${p} \\u062A\\u0631\\u0644\\u0627\\u0633\\u0647 \\u0634\\u0648`:`\\u0646\\u0627\\u0633\\u0645 \\u0648\\u0631\\u0648\\u062F\\u064A: \\u0628\\u0627\\u06CC\\u062F ${i} \\u0648\\u0627\\u06CC, \\u0645\\u06AB\\u0631 ${p} \\u062A\\u0631\\u0644\\u0627\\u0633\\u0647 \\u0634\\u0648`}case"invalid_value":return t.values.length===1?`\\u0646\\u0627\\u0633\\u0645 \\u0648\\u0631\\u0648\\u062F\\u064A: \\u0628\\u0627\\u06CC\\u062F ${$(t.values[0])} \\u0648\\u0627\\u06CC`:`\\u0646\\u0627\\u0633\\u0645 \\u0627\\u0646\\u062A\\u062E\\u0627\\u0628: \\u0628\\u0627\\u06CC\\u062F \\u06CC\\u0648 \\u0644\\u0647 ${h(t.values,"|")} \\u0685\\u062E\\u0647 \\u0648\\u0627\\u06CC`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u0689\\u06CC\\u0631 \\u0644\\u0648\\u06CC: ${(m=t.origin)!=null?m:"\\u0627\\u0631\\u0632\\u069A\\u062A"} \\u0628\\u0627\\u06CC\\u062F ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0639\\u0646\\u0635\\u0631\\u0648\\u0646\\u0647"} \\u0648\\u0644\\u0631\\u064A`:`\\u0689\\u06CC\\u0631 \\u0644\\u0648\\u06CC: ${(u=t.origin)!=null?u:"\\u0627\\u0631\\u0632\\u069A\\u062A"} \\u0628\\u0627\\u06CC\\u062F ${i}${t.maximum.toString()} \\u0648\\u064A`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u0689\\u06CC\\u0631 \\u06A9\\u0648\\u0686\\u0646\\u06CC: ${t.origin} \\u0628\\u0627\\u06CC\\u062F ${i}${t.minimum.toString()} ${l.unit} \\u0648\\u0644\\u0631\\u064A`:`\\u0689\\u06CC\\u0631 \\u06A9\\u0648\\u0686\\u0646\\u06CC: ${t.origin} \\u0628\\u0627\\u06CC\\u062F ${i}${t.minimum.toString()} \\u0648\\u064A`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u0646\\u0627\\u0633\\u0645 \\u0645\\u062A\\u0646: \\u0628\\u0627\\u06CC\\u062F \\u062F "${i.prefix}" \\u0633\\u0631\\u0647 \\u067E\\u06CC\\u0644 \\u0634\\u064A`:i.format==="ends_with"?`\\u0646\\u0627\\u0633\\u0645 \\u0645\\u062A\\u0646: \\u0628\\u0627\\u06CC\\u062F \\u062F "${i.suffix}" \\u0633\\u0631\\u0647 \\u067E\\u0627\\u06CC \\u062A\\u0647 \\u0648\\u0631\\u0633\\u064A\\u0696\\u064A`:i.format==="includes"?`\\u0646\\u0627\\u0633\\u0645 \\u0645\\u062A\\u0646: \\u0628\\u0627\\u06CC\\u062F "${i.includes}" \\u0648\\u0644\\u0631\\u064A`:i.format==="regex"?`\\u0646\\u0627\\u0633\\u0645 \\u0645\\u062A\\u0646: \\u0628\\u0627\\u06CC\\u062F \\u062F ${i.pattern} \\u0633\\u0631\\u0647 \\u0645\\u0637\\u0627\\u0628\\u0642\\u062A \\u0648\\u0644\\u0631\\u064A`:`${(d=n[i.format])!=null?d:t.format} \\u0646\\u0627\\u0633\\u0645 \\u062F\\u06CC`}case"not_multiple_of":return`\\u0646\\u0627\\u0633\\u0645 \\u0639\\u062F\\u062F: \\u0628\\u0627\\u06CC\\u062F \\u062F ${t.divisor} \\u0645\\u0636\\u0631\\u0628 \\u0648\\u064A`;case"unrecognized_keys":return`\\u0646\\u0627\\u0633\\u0645 ${t.keys.length>1?"\\u06A9\\u0644\\u06CC\\u0689\\u0648\\u0646\\u0647":"\\u06A9\\u0644\\u06CC\\u0689"}: ${h(t.keys,", ")}`;case"invalid_key":return`\\u0646\\u0627\\u0633\\u0645 \\u06A9\\u0644\\u06CC\\u0689 \\u067E\\u0647 ${t.origin} \\u06A9\\u06D0`;case"invalid_union":return"\\u0646\\u0627\\u0633\\u0645\\u0647 \\u0648\\u0631\\u0648\\u062F\\u064A";case"invalid_element":return`\\u0646\\u0627\\u0633\\u0645 \\u0639\\u0646\\u0635\\u0631 \\u067E\\u0647 ${t.origin} \\u06A9\\u06D0`;default:return"\\u0646\\u0627\\u0633\\u0645\\u0647 \\u0648\\u0631\\u0648\\u062F\\u064A"}}};function zl(){return{localeError:jp()}}var Op=()=>{let e={string:{unit:"znak\\xF3w",verb:"mie\\u0107"},file:{unit:"bajt\\xF3w",verb:"mie\\u0107"},array:{unit:"element\\xF3w",verb:"mie\\u0107"},set:{unit:"element\\xF3w",verb:"mie\\u0107"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"wyra\\u017Cenie",email:"adres email",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"data i godzina w formacie ISO",date:"data w formacie ISO",time:"godzina w formacie ISO",duration:"czas trwania ISO",ipv4:"adres IPv4",ipv6:"adres IPv6",cidrv4:"zakres IPv4",cidrv6:"zakres IPv6",base64:"ci\\u0105g znak\\xF3w zakodowany w formacie base64",base64url:"ci\\u0105g znak\\xF3w zakodowany w formacie base64url",json_string:"ci\\u0105g znak\\xF3w w formacie JSON",e164:"liczba E.164",jwt:"JWT",template_literal:"wej\\u015Bcie"},o={nan:"NaN",number:"liczba",array:"tablica"};return t=>{var a,c,m,s,u,d,i,l,p;switch(t.code){case"invalid_type":{let v=(a=o[t.expected])!=null?a:t.expected,y=x(t.input),S=(c=o[y])!=null?c:y;return/^[A-Z]/.test(t.expected)?`Nieprawid\\u0142owe dane wej\\u015Bciowe: oczekiwano instanceof ${t.expected}, otrzymano ${S}`:`Nieprawid\\u0142owe dane wej\\u015Bciowe: oczekiwano ${v}, otrzymano ${S}`}case"invalid_value":return t.values.length===1?`Nieprawid\\u0142owe dane wej\\u015Bciowe: oczekiwano ${$(t.values[0])}`:`Nieprawid\\u0142owa opcja: oczekiwano jednej z warto\\u015Bci ${h(t.values,"|")}`;case"too_big":{let v=t.inclusive?"<=":"<",y=r(t.origin);return y?`Za du\\u017Ca warto\\u015B\\u0107: oczekiwano, \\u017Ce ${(m=t.origin)!=null?m:"warto\\u015B\\u0107"} b\\u0119dzie mie\\u0107 ${v}${t.maximum.toString()} ${(s=y.unit)!=null?s:"element\\xF3w"}`:`Zbyt du\\u017C(y/a/e): oczekiwano, \\u017Ce ${(u=t.origin)!=null?u:"warto\\u015B\\u0107"} b\\u0119dzie wynosi\\u0107 ${v}${t.maximum.toString()}`}case"too_small":{let v=t.inclusive?">=":">",y=r(t.origin);return y?`Za ma\\u0142a warto\\u015B\\u0107: oczekiwano, \\u017Ce ${(d=t.origin)!=null?d:"warto\\u015B\\u0107"} b\\u0119dzie mie\\u0107 ${v}${t.minimum.toString()} ${(i=y.unit)!=null?i:"element\\xF3w"}`:`Zbyt ma\\u0142(y/a/e): oczekiwano, \\u017Ce ${(l=t.origin)!=null?l:"warto\\u015B\\u0107"} b\\u0119dzie wynosi\\u0107 ${v}${t.minimum.toString()}`}case"invalid_format":{let v=t;return v.format==="starts_with"?`Nieprawid\\u0142owy ci\\u0105g znak\\xF3w: musi zaczyna\\u0107 si\\u0119 od "${v.prefix}"`:v.format==="ends_with"?`Nieprawid\\u0142owy ci\\u0105g znak\\xF3w: musi ko\\u0144czy\\u0107 si\\u0119 na "${v.suffix}"`:v.format==="includes"?`Nieprawid\\u0142owy ci\\u0105g znak\\xF3w: musi zawiera\\u0107 "${v.includes}"`:v.format==="regex"?`Nieprawid\\u0142owy ci\\u0105g znak\\xF3w: musi odpowiada\\u0107 wzorcowi ${v.pattern}`:`Nieprawid\\u0142ow(y/a/e) ${(p=n[v.format])!=null?p:t.format}`}case"not_multiple_of":return`Nieprawid\\u0142owa liczba: musi by\\u0107 wielokrotno\\u015Bci\\u0105 ${t.divisor}`;case"unrecognized_keys":return`Nierozpoznane klucze${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`Nieprawid\\u0142owy klucz w ${t.origin}`;case"invalid_union":return"Nieprawid\\u0142owe dane wej\\u015Bciowe";case"invalid_element":return`Nieprawid\\u0142owa warto\\u015B\\u0107 w ${t.origin}`;default:return"Nieprawid\\u0142owe dane wej\\u015Bciowe"}}};function Tl(){return{localeError:Op()}}var Up=()=>{let e={string:{unit:"caracteres",verb:"ter"},file:{unit:"bytes",verb:"ter"},array:{unit:"itens",verb:"ter"},set:{unit:"itens",verb:"ter"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"padr\\xE3o",email:"endere\\xE7o de e-mail",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"data e hora ISO",date:"data ISO",time:"hora ISO",duration:"dura\\xE7\\xE3o ISO",ipv4:"endere\\xE7o IPv4",ipv6:"endere\\xE7o IPv6",cidrv4:"faixa de IPv4",cidrv6:"faixa de IPv6",base64:"texto codificado em base64",base64url:"URL codificada em base64",json_string:"texto JSON",e164:"n\\xFAmero E.164",jwt:"JWT",template_literal:"entrada"},o={nan:"NaN",number:"n\\xFAmero",null:"nulo"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Tipo inv\\xE1lido: esperado instanceof ${t.expected}, recebido ${p}`:`Tipo inv\\xE1lido: esperado ${i}, recebido ${p}`}case"invalid_value":return t.values.length===1?`Entrada inv\\xE1lida: esperado ${$(t.values[0])}`:`Op\\xE7\\xE3o inv\\xE1lida: esperada uma das ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Muito grande: esperado que ${(m=t.origin)!=null?m:"valor"} tivesse ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elementos"}`:`Muito grande: esperado que ${(u=t.origin)!=null?u:"valor"} fosse ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Muito pequeno: esperado que ${t.origin} tivesse ${i}${t.minimum.toString()} ${l.unit}`:`Muito pequeno: esperado que ${t.origin} fosse ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Texto inv\\xE1lido: deve come\\xE7ar com "${i.prefix}"`:i.format==="ends_with"?`Texto inv\\xE1lido: deve terminar com "${i.suffix}"`:i.format==="includes"?`Texto inv\\xE1lido: deve incluir "${i.includes}"`:i.format==="regex"?`Texto inv\\xE1lido: deve corresponder ao padr\\xE3o ${i.pattern}`:`${(d=n[i.format])!=null?d:t.format} inv\\xE1lido`}case"not_multiple_of":return`N\\xFAmero inv\\xE1lido: deve ser m\\xFAltiplo de ${t.divisor}`;case"unrecognized_keys":return`Chave${t.keys.length>1?"s":""} desconhecida${t.keys.length>1?"s":""}: ${h(t.keys,", ")}`;case"invalid_key":return`Chave inv\\xE1lida em ${t.origin}`;case"invalid_union":return"Entrada inv\\xE1lida";case"invalid_element":return`Valor inv\\xE1lido em ${t.origin}`;default:return"Campo inv\\xE1lido"}}};function wl(){return{localeError:Up()}}function Pl(e,r,n,o){let t=Math.abs(e),a=t%10,c=t%100;return c>=11&&c<=19?o:a===1?r:a>=2&&a<=4?n:o}var Np=()=>{let e={string:{unit:{one:"\\u0441\\u0438\\u043C\\u0432\\u043E\\u043B",few:"\\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u0430",many:"\\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u043E\\u0432"},verb:"\\u0438\\u043C\\u0435\\u0442\\u044C"},file:{unit:{one:"\\u0431\\u0430\\u0439\\u0442",few:"\\u0431\\u0430\\u0439\\u0442\\u0430",many:"\\u0431\\u0430\\u0439\\u0442"},verb:"\\u0438\\u043C\\u0435\\u0442\\u044C"},array:{unit:{one:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442",few:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430",many:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u043E\\u0432"},verb:"\\u0438\\u043C\\u0435\\u0442\\u044C"},set:{unit:{one:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442",few:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430",many:"\\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u043E\\u0432"},verb:"\\u0438\\u043C\\u0435\\u0442\\u044C"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0432\\u0432\\u043E\\u0434",email:"email \\u0430\\u0434\\u0440\\u0435\\u0441",url:"URL",emoji:"\\u044D\\u043C\\u043E\\u0434\\u0437\\u0438",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO \\u0434\\u0430\\u0442\\u0430 \\u0438 \\u0432\\u0440\\u0435\\u043C\\u044F",date:"ISO \\u0434\\u0430\\u0442\\u0430",time:"ISO \\u0432\\u0440\\u0435\\u043C\\u044F",duration:"ISO \\u0434\\u043B\\u0438\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u044C",ipv4:"IPv4 \\u0430\\u0434\\u0440\\u0435\\u0441",ipv6:"IPv6 \\u0430\\u0434\\u0440\\u0435\\u0441",cidrv4:"IPv4 \\u0434\\u0438\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D",cidrv6:"IPv6 \\u0434\\u0438\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D",base64:"\\u0441\\u0442\\u0440\\u043E\\u043A\\u0430 \\u0432 \\u0444\\u043E\\u0440\\u043C\\u0430\\u0442\\u0435 base64",base64url:"\\u0441\\u0442\\u0440\\u043E\\u043A\\u0430 \\u0432 \\u0444\\u043E\\u0440\\u043C\\u0430\\u0442\\u0435 base64url",json_string:"JSON \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430",e164:"\\u043D\\u043E\\u043C\\u0435\\u0440 E.164",jwt:"JWT",template_literal:"\\u0432\\u0432\\u043E\\u0434"},o={nan:"NaN",number:"\\u0447\\u0438\\u0441\\u043B\\u043E",array:"\\u043C\\u0430\\u0441\\u0441\\u0438\\u0432"};return t=>{var a,c,m,s,u;switch(t.code){case"invalid_type":{let d=(a=o[t.expected])!=null?a:t.expected,i=x(t.input),l=(c=o[i])!=null?c:i;return/^[A-Z]/.test(t.expected)?`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0439 \\u0432\\u0432\\u043E\\u0434: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C instanceof ${t.expected}, \\u043F\\u043E\\u043B\\u0443\\u0447\\u0435\\u043D\\u043E ${l}`:`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0439 \\u0432\\u0432\\u043E\\u0434: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C ${d}, \\u043F\\u043E\\u043B\\u0443\\u0447\\u0435\\u043D\\u043E ${l}`}case"invalid_value":return t.values.length===1?`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0439 \\u0432\\u0432\\u043E\\u0434: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C ${$(t.values[0])}`:`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0439 \\u0432\\u0430\\u0440\\u0438\\u0430\\u043D\\u0442: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C \\u043E\\u0434\\u043D\\u043E \\u0438\\u0437 ${h(t.values,"|")}`;case"too_big":{let d=t.inclusive?"<=":"<",i=r(t.origin);if(i){let l=Number(t.maximum),p=Pl(l,i.unit.one,i.unit.few,i.unit.many);return`\\u0421\\u043B\\u0438\\u0448\\u043A\\u043E\\u043C \\u0431\\u043E\\u043B\\u044C\\u0448\\u043E\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C, \\u0447\\u0442\\u043E ${(m=t.origin)!=null?m:"\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435"} \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0438\\u043C\\u0435\\u0442\\u044C ${d}${t.maximum.toString()} ${p}`}return`\\u0421\\u043B\\u0438\\u0448\\u043A\\u043E\\u043C \\u0431\\u043E\\u043B\\u044C\\u0448\\u043E\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C, \\u0447\\u0442\\u043E ${(s=t.origin)!=null?s:"\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435"} \\u0431\\u0443\\u0434\\u0435\\u0442 ${d}${t.maximum.toString()}`}case"too_small":{let d=t.inclusive?">=":">",i=r(t.origin);if(i){let l=Number(t.minimum),p=Pl(l,i.unit.one,i.unit.few,i.unit.many);return`\\u0421\\u043B\\u0438\\u0448\\u043A\\u043E\\u043C \\u043C\\u0430\\u043B\\u0435\\u043D\\u044C\\u043A\\u043E\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C, \\u0447\\u0442\\u043E ${t.origin} \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0438\\u043C\\u0435\\u0442\\u044C ${d}${t.minimum.toString()} ${p}`}return`\\u0421\\u043B\\u0438\\u0448\\u043A\\u043E\\u043C \\u043C\\u0430\\u043B\\u0435\\u043D\\u044C\\u043A\\u043E\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435: \\u043E\\u0436\\u0438\\u0434\\u0430\\u043B\\u043E\\u0441\\u044C, \\u0447\\u0442\\u043E ${t.origin} \\u0431\\u0443\\u0434\\u0435\\u0442 ${d}${t.minimum.toString()}`}case"invalid_format":{let d=t;return d.format==="starts_with"?`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u0430\\u044F \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430: \\u0434\\u043E\\u043B\\u0436\\u043D\\u0430 \\u043D\\u0430\\u0447\\u0438\\u043D\\u0430\\u0442\\u044C\\u0441\\u044F \\u0441 "${d.prefix}"`:d.format==="ends_with"?`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u0430\\u044F \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430: \\u0434\\u043E\\u043B\\u0436\\u043D\\u0430 \\u0437\\u0430\\u043A\\u0430\\u043D\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430 "${d.suffix}"`:d.format==="includes"?`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u0430\\u044F \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430: \\u0434\\u043E\\u043B\\u0436\\u043D\\u0430 \\u0441\\u043E\\u0434\\u0435\\u0440\\u0436\\u0430\\u0442\\u044C "${d.includes}"`:d.format==="regex"?`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u0430\\u044F \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430: \\u0434\\u043E\\u043B\\u0436\\u043D\\u0430 \\u0441\\u043E\\u043E\\u0442\\u0432\\u0435\\u0442\\u0441\\u0442\\u0432\\u043E\\u0432\\u0430\\u0442\\u044C \\u0448\\u0430\\u0431\\u043B\\u043E\\u043D\\u0443 ${d.pattern}`:`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0439 ${(u=n[d.format])!=null?u:t.format}`}case"not_multiple_of":return`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u043E\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E: \\u0434\\u043E\\u043B\\u0436\\u043D\\u043E \\u0431\\u044B\\u0442\\u044C \\u043A\\u0440\\u0430\\u0442\\u043D\\u044B\\u043C ${t.divisor}`;case"unrecognized_keys":return`\\u041D\\u0435\\u0440\\u0430\\u0441\\u043F\\u043E\\u0437\\u043D\\u0430\\u043D\\u043D${t.keys.length>1?"\\u044B\\u0435":"\\u044B\\u0439"} \\u043A\\u043B\\u044E\\u0447${t.keys.length>1?"\\u0438":""}: ${h(t.keys,", ")}`;case"invalid_key":return`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0439 \\u043A\\u043B\\u044E\\u0447 \\u0432 ${t.origin}`;case"invalid_union":return"\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435";case"invalid_element":return`\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u043E\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 \\u0432 ${t.origin}`;default:return"\\u041D\\u0435\\u0432\\u0435\\u0440\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435"}}};function Dl(){return{localeError:Np()}}var Ep=()=>{let e={string:{unit:"znakov",verb:"imeti"},file:{unit:"bajtov",verb:"imeti"},array:{unit:"elementov",verb:"imeti"},set:{unit:"elementov",verb:"imeti"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"vnos",email:"e-po\\u0161tni naslov",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO datum in \\u010Das",date:"ISO datum",time:"ISO \\u010Das",duration:"ISO trajanje",ipv4:"IPv4 naslov",ipv6:"IPv6 naslov",cidrv4:"obseg IPv4",cidrv6:"obseg IPv6",base64:"base64 kodiran niz",base64url:"base64url kodiran niz",json_string:"JSON niz",e164:"E.164 \\u0161tevilka",jwt:"JWT",template_literal:"vnos"},o={nan:"NaN",number:"\\u0161tevilo",array:"tabela"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Neveljaven vnos: pri\\u010Dakovano instanceof ${t.expected}, prejeto ${p}`:`Neveljaven vnos: pri\\u010Dakovano ${i}, prejeto ${p}`}case"invalid_value":return t.values.length===1?`Neveljaven vnos: pri\\u010Dakovano ${$(t.values[0])}`:`Neveljavna mo\\u017Enost: pri\\u010Dakovano eno izmed ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Preveliko: pri\\u010Dakovano, da bo ${(m=t.origin)!=null?m:"vrednost"} imelo ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"elementov"}`:`Preveliko: pri\\u010Dakovano, da bo ${(u=t.origin)!=null?u:"vrednost"} ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Premajhno: pri\\u010Dakovano, da bo ${t.origin} imelo ${i}${t.minimum.toString()} ${l.unit}`:`Premajhno: pri\\u010Dakovano, da bo ${t.origin} ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Neveljaven niz: mora se za\\u010Deti z "${i.prefix}"`:i.format==="ends_with"?`Neveljaven niz: mora se kon\\u010Dati z "${i.suffix}"`:i.format==="includes"?`Neveljaven niz: mora vsebovati "${i.includes}"`:i.format==="regex"?`Neveljaven niz: mora ustrezati vzorcu ${i.pattern}`:`Neveljaven ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Neveljavno \\u0161tevilo: mora biti ve\\u010Dkratnik ${t.divisor}`;case"unrecognized_keys":return`Neprepoznan${t.keys.length>1?"i klju\\u010Di":" klju\\u010D"}: ${h(t.keys,", ")}`;case"invalid_key":return`Neveljaven klju\\u010D v ${t.origin}`;case"invalid_union":return"Neveljaven vnos";case"invalid_element":return`Neveljavna vrednost v ${t.origin}`;default:return"Neveljaven vnos"}}};function jl(){return{localeError:Ep()}}var Zp=()=>{let e={string:{unit:"tecken",verb:"att ha"},file:{unit:"bytes",verb:"att ha"},array:{unit:"objekt",verb:"att inneh\\xE5lla"},set:{unit:"objekt",verb:"att inneh\\xE5lla"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"regulj\\xE4rt uttryck",email:"e-postadress",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO-datum och tid",date:"ISO-datum",time:"ISO-tid",duration:"ISO-varaktighet",ipv4:"IPv4-intervall",ipv6:"IPv6-intervall",cidrv4:"IPv4-spektrum",cidrv6:"IPv6-spektrum",base64:"base64-kodad str\\xE4ng",base64url:"base64url-kodad str\\xE4ng",json_string:"JSON-str\\xE4ng",e164:"E.164-nummer",jwt:"JWT",template_literal:"mall-literal"},o={nan:"NaN",number:"antal",array:"lista"};return t=>{var a,c,m,s,u,d,i,l,p,v;switch(t.code){case"invalid_type":{let y=(a=o[t.expected])!=null?a:t.expected,S=x(t.input),w=(c=o[S])!=null?c:S;return/^[A-Z]/.test(t.expected)?`Ogiltig inmatning: f\\xF6rv\\xE4ntat instanceof ${t.expected}, fick ${w}`:`Ogiltig inmatning: f\\xF6rv\\xE4ntat ${y}, fick ${w}`}case"invalid_value":return t.values.length===1?`Ogiltig inmatning: f\\xF6rv\\xE4ntat ${$(t.values[0])}`:`Ogiltigt val: f\\xF6rv\\xE4ntade en av ${h(t.values,"|")}`;case"too_big":{let y=t.inclusive?"<=":"<",S=r(t.origin);return S?`F\\xF6r stor(t): f\\xF6rv\\xE4ntade ${(m=t.origin)!=null?m:"v\\xE4rdet"} att ha ${y}${t.maximum.toString()} ${(s=S.unit)!=null?s:"element"}`:`F\\xF6r stor(t): f\\xF6rv\\xE4ntat ${(u=t.origin)!=null?u:"v\\xE4rdet"} att ha ${y}${t.maximum.toString()}`}case"too_small":{let y=t.inclusive?">=":">",S=r(t.origin);return S?`F\\xF6r lite(t): f\\xF6rv\\xE4ntade ${(d=t.origin)!=null?d:"v\\xE4rdet"} att ha ${y}${t.minimum.toString()} ${S.unit}`:`F\\xF6r lite(t): f\\xF6rv\\xE4ntade ${(i=t.origin)!=null?i:"v\\xE4rdet"} att ha ${y}${t.minimum.toString()}`}case"invalid_format":{let y=t;return y.format==="starts_with"?`Ogiltig str\\xE4ng: m\\xE5ste b\\xF6rja med "${y.prefix}"`:y.format==="ends_with"?`Ogiltig str\\xE4ng: m\\xE5ste sluta med "${y.suffix}"`:y.format==="includes"?`Ogiltig str\\xE4ng: m\\xE5ste inneh\\xE5lla "${y.includes}"`:y.format==="regex"?`Ogiltig str\\xE4ng: m\\xE5ste matcha m\\xF6nstret "${y.pattern}"`:`Ogiltig(t) ${(l=n[y.format])!=null?l:t.format}`}case"not_multiple_of":return`Ogiltigt tal: m\\xE5ste vara en multipel av ${t.divisor}`;case"unrecognized_keys":return`${t.keys.length>1?"Ok\\xE4nda nycklar":"Ok\\xE4nd nyckel"}: ${h(t.keys,", ")}`;case"invalid_key":return`Ogiltig nyckel i ${(p=t.origin)!=null?p:"v\\xE4rdet"}`;case"invalid_union":return"Ogiltig input";case"invalid_element":return`Ogiltigt v\\xE4rde i ${(v=t.origin)!=null?v:"v\\xE4rdet"}`;default:return"Ogiltig input"}}};function Ol(){return{localeError:Zp()}}var Lp=()=>{let e={string:{unit:"\\u0B8E\\u0BB4\\u0BC1\\u0BA4\\u0BCD\\u0BA4\\u0BC1\\u0B95\\u0BCD\\u0B95\\u0BB3\\u0BCD",verb:"\\u0B95\\u0BCA\\u0BA3\\u0BCD\\u0B9F\\u0BBF\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD"},file:{unit:"\\u0BAA\\u0BC8\\u0B9F\\u0BCD\\u0B9F\\u0BC1\\u0B95\\u0BB3\\u0BCD",verb:"\\u0B95\\u0BCA\\u0BA3\\u0BCD\\u0B9F\\u0BBF\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD"},array:{unit:"\\u0B89\\u0BB1\\u0BC1\\u0BAA\\u0BCD\\u0BAA\\u0BC1\\u0B95\\u0BB3\\u0BCD",verb:"\\u0B95\\u0BCA\\u0BA3\\u0BCD\\u0B9F\\u0BBF\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD"},set:{unit:"\\u0B89\\u0BB1\\u0BC1\\u0BAA\\u0BCD\\u0BAA\\u0BC1\\u0B95\\u0BB3\\u0BCD",verb:"\\u0B95\\u0BCA\\u0BA3\\u0BCD\\u0B9F\\u0BBF\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0BC0\\u0B9F\\u0BC1",email:"\\u0BAE\\u0BBF\\u0BA9\\u0BCD\\u0BA9\\u0B9E\\u0BCD\\u0B9A\\u0BB2\\u0BCD \\u0BAE\\u0BC1\\u0B95\\u0BB5\\u0BB0\\u0BBF",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO \\u0BA4\\u0BC7\\u0BA4\\u0BBF \\u0BA8\\u0BC7\\u0BB0\\u0BAE\\u0BCD",date:"ISO \\u0BA4\\u0BC7\\u0BA4\\u0BBF",time:"ISO \\u0BA8\\u0BC7\\u0BB0\\u0BAE\\u0BCD",duration:"ISO \\u0B95\\u0BBE\\u0BB2 \\u0B85\\u0BB3\\u0BB5\\u0BC1",ipv4:"IPv4 \\u0BAE\\u0BC1\\u0B95\\u0BB5\\u0BB0\\u0BBF",ipv6:"IPv6 \\u0BAE\\u0BC1\\u0B95\\u0BB5\\u0BB0\\u0BBF",cidrv4:"IPv4 \\u0BB5\\u0BB0\\u0BAE\\u0BCD\\u0BAA\\u0BC1",cidrv6:"IPv6 \\u0BB5\\u0BB0\\u0BAE\\u0BCD\\u0BAA\\u0BC1",base64:"base64-encoded \\u0B9A\\u0BB0\\u0BAE\\u0BCD",base64url:"base64url-encoded \\u0B9A\\u0BB0\\u0BAE\\u0BCD",json_string:"JSON \\u0B9A\\u0BB0\\u0BAE\\u0BCD",e164:"E.164 \\u0B8E\\u0BA3\\u0BCD",jwt:"JWT",template_literal:"input"},o={nan:"NaN",number:"\\u0B8E\\u0BA3\\u0BCD",array:"\\u0B85\\u0BA3\\u0BBF",null:"\\u0BB5\\u0BC6\\u0BB1\\u0BC1\\u0BAE\\u0BC8"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0BC0\\u0B9F\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 instanceof ${t.expected}, \\u0BAA\\u0BC6\\u0BB1\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${p}`:`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0BC0\\u0B9F\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${i}, \\u0BAA\\u0BC6\\u0BB1\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${p}`}case"invalid_value":return t.values.length===1?`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0BC0\\u0B9F\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${$(t.values[0])}`:`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0BB5\\u0BBF\\u0BB0\\u0BC1\\u0BAA\\u0BCD\\u0BAA\\u0BAE\\u0BCD: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${h(t.values,"|")} \\u0B87\\u0BB2\\u0BCD \\u0B92\\u0BA9\\u0BCD\\u0BB1\\u0BC1`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u0BAE\\u0BBF\\u0B95 \\u0BAA\\u0BC6\\u0BB0\\u0BBF\\u0BAF\\u0BA4\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${(m=t.origin)!=null?m:"\\u0BAE\\u0BA4\\u0BBF\\u0BAA\\u0BCD\\u0BAA\\u0BC1"} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0B89\\u0BB1\\u0BC1\\u0BAA\\u0BCD\\u0BAA\\u0BC1\\u0B95\\u0BB3\\u0BCD"} \\u0B86\\u0B95 \\u0B87\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`:`\\u0BAE\\u0BBF\\u0B95 \\u0BAA\\u0BC6\\u0BB0\\u0BBF\\u0BAF\\u0BA4\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${(u=t.origin)!=null?u:"\\u0BAE\\u0BA4\\u0BBF\\u0BAA\\u0BCD\\u0BAA\\u0BC1"} ${i}${t.maximum.toString()} \\u0B86\\u0B95 \\u0B87\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u0BAE\\u0BBF\\u0B95\\u0B9A\\u0BCD \\u0B9A\\u0BBF\\u0BB1\\u0BBF\\u0BAF\\u0BA4\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${t.origin} ${i}${t.minimum.toString()} ${l.unit} \\u0B86\\u0B95 \\u0B87\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`:`\\u0BAE\\u0BBF\\u0B95\\u0B9A\\u0BCD \\u0B9A\\u0BBF\\u0BB1\\u0BBF\\u0BAF\\u0BA4\\u0BC1: \\u0B8E\\u0BA4\\u0BBF\\u0BB0\\u0BCD\\u0BAA\\u0BBE\\u0BB0\\u0BCD\\u0B95\\u0BCD\\u0B95\\u0BAA\\u0BCD\\u0BAA\\u0B9F\\u0BCD\\u0B9F\\u0BA4\\u0BC1 ${t.origin} ${i}${t.minimum.toString()} \\u0B86\\u0B95 \\u0B87\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B9A\\u0BB0\\u0BAE\\u0BCD: "${i.prefix}" \\u0B87\\u0BB2\\u0BCD \\u0BA4\\u0BCA\\u0B9F\\u0B99\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`:i.format==="ends_with"?`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B9A\\u0BB0\\u0BAE\\u0BCD: "${i.suffix}" \\u0B87\\u0BB2\\u0BCD \\u0BAE\\u0BC1\\u0B9F\\u0BBF\\u0BB5\\u0B9F\\u0BC8\\u0BAF \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`:i.format==="includes"?`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B9A\\u0BB0\\u0BAE\\u0BCD: "${i.includes}" \\u0B90 \\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0B9F\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`:i.format==="regex"?`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B9A\\u0BB0\\u0BAE\\u0BCD: ${i.pattern} \\u0BAE\\u0BC1\\u0BB1\\u0BC8\\u0BAA\\u0BBE\\u0B9F\\u0BCD\\u0B9F\\u0BC1\\u0B9F\\u0BA9\\u0BCD \\u0BAA\\u0BCA\\u0BB0\\u0BC1\\u0BA8\\u0BCD\\u0BA4 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`:`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B8E\\u0BA3\\u0BCD: ${t.divisor} \\u0B87\\u0BA9\\u0BCD \\u0BAA\\u0BB2\\u0BAE\\u0BBE\\u0B95 \\u0B87\\u0BB0\\u0BC1\\u0B95\\u0BCD\\u0B95 \\u0BB5\\u0BC7\\u0BA3\\u0BCD\\u0B9F\\u0BC1\\u0BAE\\u0BCD`;case"unrecognized_keys":return`\\u0B85\\u0B9F\\u0BC8\\u0BAF\\u0BBE\\u0BB3\\u0BAE\\u0BCD \\u0BA4\\u0BC6\\u0BB0\\u0BBF\\u0BAF\\u0BBE\\u0BA4 \\u0BB5\\u0BBF\\u0B9A\\u0BC8${t.keys.length>1?"\\u0B95\\u0BB3\\u0BCD":""}: ${h(t.keys,", ")}`;case"invalid_key":return`${t.origin} \\u0B87\\u0BB2\\u0BCD \\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0BB5\\u0BBF\\u0B9A\\u0BC8`;case"invalid_union":return"\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0BC0\\u0B9F\\u0BC1";case"invalid_element":return`${t.origin} \\u0B87\\u0BB2\\u0BCD \\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0BAE\\u0BA4\\u0BBF\\u0BAA\\u0BCD\\u0BAA\\u0BC1`;default:return"\\u0BA4\\u0BB5\\u0BB1\\u0BBE\\u0BA9 \\u0B89\\u0BB3\\u0BCD\\u0BB3\\u0BC0\\u0B9F\\u0BC1"}}};function Ul(){return{localeError:Lp()}}var Cp=()=>{let e={string:{unit:"\\u0E15\\u0E31\\u0E27\\u0E2D\\u0E31\\u0E01\\u0E29\\u0E23",verb:"\\u0E04\\u0E27\\u0E23\\u0E21\\u0E35"},file:{unit:"\\u0E44\\u0E1A\\u0E15\\u0E4C",verb:"\\u0E04\\u0E27\\u0E23\\u0E21\\u0E35"},array:{unit:"\\u0E23\\u0E32\\u0E22\\u0E01\\u0E32\\u0E23",verb:"\\u0E04\\u0E27\\u0E23\\u0E21\\u0E35"},set:{unit:"\\u0E23\\u0E32\\u0E22\\u0E01\\u0E32\\u0E23",verb:"\\u0E04\\u0E27\\u0E23\\u0E21\\u0E35"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E17\\u0E35\\u0E48\\u0E1B\\u0E49\\u0E2D\\u0E19",email:"\\u0E17\\u0E35\\u0E48\\u0E2D\\u0E22\\u0E39\\u0E48\\u0E2D\\u0E35\\u0E40\\u0E21\\u0E25",url:"URL",emoji:"\\u0E2D\\u0E34\\u0E42\\u0E21\\u0E08\\u0E34",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"\\u0E27\\u0E31\\u0E19\\u0E17\\u0E35\\u0E48\\u0E40\\u0E27\\u0E25\\u0E32\\u0E41\\u0E1A\\u0E1A ISO",date:"\\u0E27\\u0E31\\u0E19\\u0E17\\u0E35\\u0E48\\u0E41\\u0E1A\\u0E1A ISO",time:"\\u0E40\\u0E27\\u0E25\\u0E32\\u0E41\\u0E1A\\u0E1A ISO",duration:"\\u0E0A\\u0E48\\u0E27\\u0E07\\u0E40\\u0E27\\u0E25\\u0E32\\u0E41\\u0E1A\\u0E1A ISO",ipv4:"\\u0E17\\u0E35\\u0E48\\u0E2D\\u0E22\\u0E39\\u0E48 IPv4",ipv6:"\\u0E17\\u0E35\\u0E48\\u0E2D\\u0E22\\u0E39\\u0E48 IPv6",cidrv4:"\\u0E0A\\u0E48\\u0E27\\u0E07 IP \\u0E41\\u0E1A\\u0E1A IPv4",cidrv6:"\\u0E0A\\u0E48\\u0E27\\u0E07 IP \\u0E41\\u0E1A\\u0E1A IPv6",base64:"\\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E41\\u0E1A\\u0E1A Base64",base64url:"\\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E41\\u0E1A\\u0E1A Base64 \\u0E2A\\u0E33\\u0E2B\\u0E23\\u0E31\\u0E1A URL",json_string:"\\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E41\\u0E1A\\u0E1A JSON",e164:"\\u0E40\\u0E1A\\u0E2D\\u0E23\\u0E4C\\u0E42\\u0E17\\u0E23\\u0E28\\u0E31\\u0E1E\\u0E17\\u0E4C\\u0E23\\u0E30\\u0E2B\\u0E27\\u0E48\\u0E32\\u0E07\\u0E1B\\u0E23\\u0E30\\u0E40\\u0E17\\u0E28 (E.164)",jwt:"\\u0E42\\u0E17\\u0E40\\u0E04\\u0E19 JWT",template_literal:"\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E17\\u0E35\\u0E48\\u0E1B\\u0E49\\u0E2D\\u0E19"},o={nan:"NaN",number:"\\u0E15\\u0E31\\u0E27\\u0E40\\u0E25\\u0E02",array:"\\u0E2D\\u0E32\\u0E23\\u0E4C\\u0E40\\u0E23\\u0E22\\u0E4C (Array)",null:"\\u0E44\\u0E21\\u0E48\\u0E21\\u0E35\\u0E04\\u0E48\\u0E32 (null)"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u0E1B\\u0E23\\u0E30\\u0E40\\u0E20\\u0E17\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E04\\u0E27\\u0E23\\u0E40\\u0E1B\\u0E47\\u0E19 instanceof ${t.expected} \\u0E41\\u0E15\\u0E48\\u0E44\\u0E14\\u0E49\\u0E23\\u0E31\\u0E1A ${p}`:`\\u0E1B\\u0E23\\u0E30\\u0E40\\u0E20\\u0E17\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E04\\u0E27\\u0E23\\u0E40\\u0E1B\\u0E47\\u0E19 ${i} \\u0E41\\u0E15\\u0E48\\u0E44\\u0E14\\u0E49\\u0E23\\u0E31\\u0E1A ${p}`}case"invalid_value":return t.values.length===1?`\\u0E04\\u0E48\\u0E32\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E04\\u0E27\\u0E23\\u0E40\\u0E1B\\u0E47\\u0E19 ${$(t.values[0])}`:`\\u0E15\\u0E31\\u0E27\\u0E40\\u0E25\\u0E37\\u0E2D\\u0E01\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E04\\u0E27\\u0E23\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E2B\\u0E19\\u0E36\\u0E48\\u0E07\\u0E43\\u0E19 ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"\\u0E44\\u0E21\\u0E48\\u0E40\\u0E01\\u0E34\\u0E19":"\\u0E19\\u0E49\\u0E2D\\u0E22\\u0E01\\u0E27\\u0E48\\u0E32",l=r(t.origin);return l?`\\u0E40\\u0E01\\u0E34\\u0E19\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14: ${(m=t.origin)!=null?m:"\\u0E04\\u0E48\\u0E32"} \\u0E04\\u0E27\\u0E23\\u0E21\\u0E35${i} ${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0E23\\u0E32\\u0E22\\u0E01\\u0E32\\u0E23"}`:`\\u0E40\\u0E01\\u0E34\\u0E19\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14: ${(u=t.origin)!=null?u:"\\u0E04\\u0E48\\u0E32"} \\u0E04\\u0E27\\u0E23\\u0E21\\u0E35${i} ${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?"\\u0E2D\\u0E22\\u0E48\\u0E32\\u0E07\\u0E19\\u0E49\\u0E2D\\u0E22":"\\u0E21\\u0E32\\u0E01\\u0E01\\u0E27\\u0E48\\u0E32",l=r(t.origin);return l?`\\u0E19\\u0E49\\u0E2D\\u0E22\\u0E01\\u0E27\\u0E48\\u0E32\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14: ${t.origin} \\u0E04\\u0E27\\u0E23\\u0E21\\u0E35${i} ${t.minimum.toString()} ${l.unit}`:`\\u0E19\\u0E49\\u0E2D\\u0E22\\u0E01\\u0E27\\u0E48\\u0E32\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14: ${t.origin} \\u0E04\\u0E27\\u0E23\\u0E21\\u0E35${i} ${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E02\\u0E36\\u0E49\\u0E19\\u0E15\\u0E49\\u0E19\\u0E14\\u0E49\\u0E27\\u0E22 "${i.prefix}"`:i.format==="ends_with"?`\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E25\\u0E07\\u0E17\\u0E49\\u0E32\\u0E22\\u0E14\\u0E49\\u0E27\\u0E22 "${i.suffix}"`:i.format==="includes"?`\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E21\\u0E35 "${i.includes}" \\u0E2D\\u0E22\\u0E39\\u0E48\\u0E43\\u0E19\\u0E02\\u0E49\\u0E2D\\u0E04\\u0E27\\u0E32\\u0E21`:i.format==="regex"?`\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E15\\u0E49\\u0E2D\\u0E07\\u0E15\\u0E23\\u0E07\\u0E01\\u0E31\\u0E1A\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E17\\u0E35\\u0E48\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14 ${i.pattern}`:`\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u0E15\\u0E31\\u0E27\\u0E40\\u0E25\\u0E02\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E15\\u0E49\\u0E2D\\u0E07\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E08\\u0E33\\u0E19\\u0E27\\u0E19\\u0E17\\u0E35\\u0E48\\u0E2B\\u0E32\\u0E23\\u0E14\\u0E49\\u0E27\\u0E22 ${t.divisor} \\u0E44\\u0E14\\u0E49\\u0E25\\u0E07\\u0E15\\u0E31\\u0E27`;case"unrecognized_keys":return`\\u0E1E\\u0E1A\\u0E04\\u0E35\\u0E22\\u0E4C\\u0E17\\u0E35\\u0E48\\u0E44\\u0E21\\u0E48\\u0E23\\u0E39\\u0E49\\u0E08\\u0E31\\u0E01: ${h(t.keys,", ")}`;case"invalid_key":return`\\u0E04\\u0E35\\u0E22\\u0E4C\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19 ${t.origin}`;case"invalid_union":return"\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07: \\u0E44\\u0E21\\u0E48\\u0E15\\u0E23\\u0E07\\u0E01\\u0E31\\u0E1A\\u0E23\\u0E39\\u0E1B\\u0E41\\u0E1A\\u0E1A\\u0E22\\u0E39\\u0E40\\u0E19\\u0E35\\u0E22\\u0E19\\u0E17\\u0E35\\u0E48\\u0E01\\u0E33\\u0E2B\\u0E19\\u0E14\\u0E44\\u0E27\\u0E49";case"invalid_element":return`\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E43\\u0E19 ${t.origin}`;default:return"\\u0E02\\u0E49\\u0E2D\\u0E21\\u0E39\\u0E25\\u0E44\\u0E21\\u0E48\\u0E16\\u0E39\\u0E01\\u0E15\\u0E49\\u0E2D\\u0E07"}}};function Nl(){return{localeError:Cp()}}var Rp=()=>{let e={string:{unit:"karakter",verb:"olmal\\u0131"},file:{unit:"bayt",verb:"olmal\\u0131"},array:{unit:"\\xF6\\u011Fe",verb:"olmal\\u0131"},set:{unit:"\\xF6\\u011Fe",verb:"olmal\\u0131"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"girdi",email:"e-posta adresi",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO tarih ve saat",date:"ISO tarih",time:"ISO saat",duration:"ISO s\\xFCre",ipv4:"IPv4 adresi",ipv6:"IPv6 adresi",cidrv4:"IPv4 aral\\u0131\\u011F\\u0131",cidrv6:"IPv6 aral\\u0131\\u011F\\u0131",base64:"base64 ile \\u015Fifrelenmi\\u015F metin",base64url:"base64url ile \\u015Fifrelenmi\\u015F metin",json_string:"JSON dizesi",e164:"E.164 say\\u0131s\\u0131",jwt:"JWT",template_literal:"\\u015Eablon dizesi"},o={nan:"NaN"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`Ge\\xE7ersiz de\\u011Fer: beklenen instanceof ${t.expected}, al\\u0131nan ${p}`:`Ge\\xE7ersiz de\\u011Fer: beklenen ${i}, al\\u0131nan ${p}`}case"invalid_value":return t.values.length===1?`Ge\\xE7ersiz de\\u011Fer: beklenen ${$(t.values[0])}`:`Ge\\xE7ersiz se\\xE7enek: a\\u015Fa\\u011F\\u0131dakilerden biri olmal\\u0131: ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\xC7ok b\\xFCy\\xFCk: beklenen ${(m=t.origin)!=null?m:"de\\u011Fer"} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\xF6\\u011Fe"}`:`\\xC7ok b\\xFCy\\xFCk: beklenen ${(u=t.origin)!=null?u:"de\\u011Fer"} ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\xC7ok k\\xFC\\xE7\\xFCk: beklenen ${t.origin} ${i}${t.minimum.toString()} ${l.unit}`:`\\xC7ok k\\xFC\\xE7\\xFCk: beklenen ${t.origin} ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Ge\\xE7ersiz metin: "${i.prefix}" ile ba\\u015Flamal\\u0131`:i.format==="ends_with"?`Ge\\xE7ersiz metin: "${i.suffix}" ile bitmeli`:i.format==="includes"?`Ge\\xE7ersiz metin: "${i.includes}" i\\xE7ermeli`:i.format==="regex"?`Ge\\xE7ersiz metin: ${i.pattern} desenine uymal\\u0131`:`Ge\\xE7ersiz ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`Ge\\xE7ersiz say\\u0131: ${t.divisor} ile tam b\\xF6l\\xFCnebilmeli`;case"unrecognized_keys":return`Tan\\u0131nmayan anahtar${t.keys.length>1?"lar":""}: ${h(t.keys,", ")}`;case"invalid_key":return`${t.origin} i\\xE7inde ge\\xE7ersiz anahtar`;case"invalid_union":return"Ge\\xE7ersiz de\\u011Fer";case"invalid_element":return`${t.origin} i\\xE7inde ge\\xE7ersiz de\\u011Fer`;default:return"Ge\\xE7ersiz de\\u011Fer"}}};function El(){return{localeError:Rp()}}var Ap=()=>{let e={string:{unit:"\\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u0456\\u0432",verb:"\\u043C\\u0430\\u0442\\u0438\\u043C\\u0435"},file:{unit:"\\u0431\\u0430\\u0439\\u0442\\u0456\\u0432",verb:"\\u043C\\u0430\\u0442\\u0438\\u043C\\u0435"},array:{unit:"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0456\\u0432",verb:"\\u043C\\u0430\\u0442\\u0438\\u043C\\u0435"},set:{unit:"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0456\\u0432",verb:"\\u043C\\u0430\\u0442\\u0438\\u043C\\u0435"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456",email:"\\u0430\\u0434\\u0440\\u0435\\u0441\\u0430 \\u0435\\u043B\\u0435\\u043A\\u0442\\u0440\\u043E\\u043D\\u043D\\u043E\\u0457 \\u043F\\u043E\\u0448\\u0442\\u0438",url:"URL",emoji:"\\u0435\\u043C\\u043E\\u0434\\u0437\\u0456",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"\\u0434\\u0430\\u0442\\u0430 \\u0442\\u0430 \\u0447\\u0430\\u0441 ISO",date:"\\u0434\\u0430\\u0442\\u0430 ISO",time:"\\u0447\\u0430\\u0441 ISO",duration:"\\u0442\\u0440\\u0438\\u0432\\u0430\\u043B\\u0456\\u0441\\u0442\\u044C ISO",ipv4:"\\u0430\\u0434\\u0440\\u0435\\u0441\\u0430 IPv4",ipv6:"\\u0430\\u0434\\u0440\\u0435\\u0441\\u0430 IPv6",cidrv4:"\\u0434\\u0456\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D IPv4",cidrv6:"\\u0434\\u0456\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D IPv6",base64:"\\u0440\\u044F\\u0434\\u043E\\u043A \\u0443 \\u043A\\u043E\\u0434\\u0443\\u0432\\u0430\\u043D\\u043D\\u0456 base64",base64url:"\\u0440\\u044F\\u0434\\u043E\\u043A \\u0443 \\u043A\\u043E\\u0434\\u0443\\u0432\\u0430\\u043D\\u043D\\u0456 base64url",json_string:"\\u0440\\u044F\\u0434\\u043E\\u043A JSON",e164:"\\u043D\\u043E\\u043C\\u0435\\u0440 E.164",jwt:"JWT",template_literal:"\\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456"},o={nan:"NaN",number:"\\u0447\\u0438\\u0441\\u043B\\u043E",array:"\\u043C\\u0430\\u0441\\u0438\\u0432"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0456 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F instanceof ${t.expected}, \\u043E\\u0442\\u0440\\u0438\\u043C\\u0430\\u043D\\u043E ${p}`:`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0456 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F ${i}, \\u043E\\u0442\\u0440\\u0438\\u043C\\u0430\\u043D\\u043E ${p}`}case"invalid_value":return t.values.length===1?`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0456 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F ${$(t.values[0])}`:`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0430 \\u043E\\u043F\\u0446\\u0456\\u044F: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F \\u043E\\u0434\\u043D\\u0435 \\u0437 ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u043E \\u0432\\u0435\\u043B\\u0438\\u043A\\u0435: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F, \\u0449\\u043E ${(m=t.origin)!=null?m:"\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F"} ${l.verb} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0435\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0456\\u0432"}`:`\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u043E \\u0432\\u0435\\u043B\\u0438\\u043A\\u0435: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F, \\u0449\\u043E ${(u=t.origin)!=null?u:"\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F"} \\u0431\\u0443\\u0434\\u0435 ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u043E \\u043C\\u0430\\u043B\\u0435: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F, \\u0449\\u043E ${t.origin} ${l.verb} ${i}${t.minimum.toString()} ${l.unit}`:`\\u0417\\u0430\\u043D\\u0430\\u0434\\u0442\\u043E \\u043C\\u0430\\u043B\\u0435: \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F, \\u0449\\u043E ${t.origin} \\u0431\\u0443\\u0434\\u0435 ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 \\u0440\\u044F\\u0434\\u043E\\u043A: \\u043F\\u043E\\u0432\\u0438\\u043D\\u0435\\u043D \\u043F\\u043E\\u0447\\u0438\\u043D\\u0430\\u0442\\u0438\\u0441\\u044F \\u0437 "${i.prefix}"`:i.format==="ends_with"?`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 \\u0440\\u044F\\u0434\\u043E\\u043A: \\u043F\\u043E\\u0432\\u0438\\u043D\\u0435\\u043D \\u0437\\u0430\\u043A\\u0456\\u043D\\u0447\\u0443\\u0432\\u0430\\u0442\\u0438\\u0441\\u044F \\u043D\\u0430 "${i.suffix}"`:i.format==="includes"?`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 \\u0440\\u044F\\u0434\\u043E\\u043A: \\u043F\\u043E\\u0432\\u0438\\u043D\\u0435\\u043D \\u043C\\u0456\\u0441\\u0442\\u0438\\u0442\\u0438 "${i.includes}"`:i.format==="regex"?`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 \\u0440\\u044F\\u0434\\u043E\\u043A: \\u043F\\u043E\\u0432\\u0438\\u043D\\u0435\\u043D \\u0432\\u0456\\u0434\\u043F\\u043E\\u0432\\u0456\\u0434\\u0430\\u0442\\u0438 \\u0448\\u0430\\u0431\\u043B\\u043E\\u043D\\u0443 ${i.pattern}`:`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E: \\u043F\\u043E\\u0432\\u0438\\u043D\\u043D\\u043E \\u0431\\u0443\\u0442\\u0438 \\u043A\\u0440\\u0430\\u0442\\u043D\\u0438\\u043C ${t.divisor}`;case"unrecognized_keys":return`\\u041D\\u0435\\u0440\\u043E\\u0437\\u043F\\u0456\\u0437\\u043D\\u0430\\u043D\\u0438\\u0439 \\u043A\\u043B\\u044E\\u0447${t.keys.length>1?"\\u0456":""}: ${h(t.keys,", ")}`;case"invalid_key":return`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0438\\u0439 \\u043A\\u043B\\u044E\\u0447 \\u0443 ${t.origin}`;case"invalid_union":return"\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0456 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456";case"invalid_element":return`\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F \\u0443 ${t.origin}`;default:return"\\u041D\\u0435\\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u0456 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456"}}};function xr(){return{localeError:Ap()}}function Zl(){return xr()}var Mp=()=>{let e={string:{unit:"\\u062D\\u0631\\u0648\\u0641",verb:"\\u06C1\\u0648\\u0646\\u0627"},file:{unit:"\\u0628\\u0627\\u0626\\u0679\\u0633",verb:"\\u06C1\\u0648\\u0646\\u0627"},array:{unit:"\\u0622\\u0626\\u0679\\u0645\\u0632",verb:"\\u06C1\\u0648\\u0646\\u0627"},set:{unit:"\\u0622\\u0626\\u0679\\u0645\\u0632",verb:"\\u06C1\\u0648\\u0646\\u0627"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0627\\u0646 \\u067E\\u0679",email:"\\u0627\\u06CC \\u0645\\u06CC\\u0644 \\u0627\\u06CC\\u0688\\u0631\\u06CC\\u0633",url:"\\u06CC\\u0648 \\u0622\\u0631 \\u0627\\u06CC\\u0644",emoji:"\\u0627\\u06CC\\u0645\\u0648\\u062C\\u06CC",uuid:"\\u06CC\\u0648 \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC",uuidv4:"\\u06CC\\u0648 \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC \\u0648\\u06CC 4",uuidv6:"\\u06CC\\u0648 \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC \\u0648\\u06CC 6",nanoid:"\\u0646\\u06CC\\u0646\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC",guid:"\\u062C\\u06CC \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC",cuid:"\\u0633\\u06CC \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC",cuid2:"\\u0633\\u06CC \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC 2",ulid:"\\u06CC\\u0648 \\u0627\\u06CC\\u0644 \\u0622\\u0626\\u06CC \\u0688\\u06CC",xid:"\\u0627\\u06CC\\u06A9\\u0633 \\u0622\\u0626\\u06CC \\u0688\\u06CC",ksuid:"\\u06A9\\u06D2 \\u0627\\u06CC\\u0633 \\u06CC\\u0648 \\u0622\\u0626\\u06CC \\u0688\\u06CC",datetime:"\\u0622\\u0626\\u06CC \\u0627\\u06CC\\u0633 \\u0627\\u0648 \\u0688\\u06CC\\u0679 \\u0679\\u0627\\u0626\\u0645",date:"\\u0622\\u0626\\u06CC \\u0627\\u06CC\\u0633 \\u0627\\u0648 \\u062A\\u0627\\u0631\\u06CC\\u062E",time:"\\u0622\\u0626\\u06CC \\u0627\\u06CC\\u0633 \\u0627\\u0648 \\u0648\\u0642\\u062A",duration:"\\u0622\\u0626\\u06CC \\u0627\\u06CC\\u0633 \\u0627\\u0648 \\u0645\\u062F\\u062A",ipv4:"\\u0622\\u0626\\u06CC \\u067E\\u06CC \\u0648\\u06CC 4 \\u0627\\u06CC\\u0688\\u0631\\u06CC\\u0633",ipv6:"\\u0622\\u0626\\u06CC \\u067E\\u06CC \\u0648\\u06CC 6 \\u0627\\u06CC\\u0688\\u0631\\u06CC\\u0633",cidrv4:"\\u0622\\u0626\\u06CC \\u067E\\u06CC \\u0648\\u06CC 4 \\u0631\\u06CC\\u0646\\u062C",cidrv6:"\\u0622\\u0626\\u06CC \\u067E\\u06CC \\u0648\\u06CC 6 \\u0631\\u06CC\\u0646\\u062C",base64:"\\u0628\\u06CC\\u0633 64 \\u0627\\u0646 \\u06A9\\u0648\\u0688\\u0688 \\u0633\\u0679\\u0631\\u0646\\u06AF",base64url:"\\u0628\\u06CC\\u0633 64 \\u06CC\\u0648 \\u0622\\u0631 \\u0627\\u06CC\\u0644 \\u0627\\u0646 \\u06A9\\u0648\\u0688\\u0688 \\u0633\\u0679\\u0631\\u0646\\u06AF",json_string:"\\u062C\\u06D2 \\u0627\\u06CC\\u0633 \\u0627\\u0648 \\u0627\\u06CC\\u0646 \\u0633\\u0679\\u0631\\u0646\\u06AF",e164:"\\u0627\\u06CC 164 \\u0646\\u0645\\u0628\\u0631",jwt:"\\u062C\\u06D2 \\u0688\\u0628\\u0644\\u06CC\\u0648 \\u0679\\u06CC",template_literal:"\\u0627\\u0646 \\u067E\\u0679"},o={nan:"NaN",number:"\\u0646\\u0645\\u0628\\u0631",array:"\\u0622\\u0631\\u06D2",null:"\\u0646\\u0644"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u063A\\u0644\\u0637 \\u0627\\u0646 \\u067E\\u0679: instanceof ${t.expected} \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u0627\\u060C ${p} \\u0645\\u0648\\u0635\\u0648\\u0644 \\u06C1\\u0648\\u0627`:`\\u063A\\u0644\\u0637 \\u0627\\u0646 \\u067E\\u0679: ${i} \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u0627\\u060C ${p} \\u0645\\u0648\\u0635\\u0648\\u0644 \\u06C1\\u0648\\u0627`}case"invalid_value":return t.values.length===1?`\\u063A\\u0644\\u0637 \\u0627\\u0646 \\u067E\\u0679: ${$(t.values[0])} \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u0627`:`\\u063A\\u0644\\u0637 \\u0622\\u067E\\u0634\\u0646: ${h(t.values,"|")} \\u0645\\u06CC\\u06BA \\u0633\\u06D2 \\u0627\\u06CC\\u06A9 \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u0627`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u0628\\u06C1\\u062A \\u0628\\u0691\\u0627: ${(m=t.origin)!=null?m:"\\u0648\\u06CC\\u0644\\u06CC\\u0648"} \\u06A9\\u06D2 ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u0639\\u0646\\u0627\\u0635\\u0631"} \\u06C1\\u0648\\u0646\\u06D2 \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u06D2`:`\\u0628\\u06C1\\u062A \\u0628\\u0691\\u0627: ${(u=t.origin)!=null?u:"\\u0648\\u06CC\\u0644\\u06CC\\u0648"} \\u06A9\\u0627 ${i}${t.maximum.toString()} \\u06C1\\u0648\\u0646\\u0627 \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u0627`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u0628\\u06C1\\u062A \\u0686\\u06BE\\u0648\\u0679\\u0627: ${t.origin} \\u06A9\\u06D2 ${i}${t.minimum.toString()} ${l.unit} \\u06C1\\u0648\\u0646\\u06D2 \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u06D2`:`\\u0628\\u06C1\\u062A \\u0686\\u06BE\\u0648\\u0679\\u0627: ${t.origin} \\u06A9\\u0627 ${i}${t.minimum.toString()} \\u06C1\\u0648\\u0646\\u0627 \\u0645\\u062A\\u0648\\u0642\\u0639 \\u062A\\u06BE\\u0627`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u063A\\u0644\\u0637 \\u0633\\u0679\\u0631\\u0646\\u06AF: "${i.prefix}" \\u0633\\u06D2 \\u0634\\u0631\\u0648\\u0639 \\u06C1\\u0648\\u0646\\u0627 \\u0686\\u0627\\u06C1\\u06CC\\u06D2`:i.format==="ends_with"?`\\u063A\\u0644\\u0637 \\u0633\\u0679\\u0631\\u0646\\u06AF: "${i.suffix}" \\u067E\\u0631 \\u062E\\u062A\\u0645 \\u06C1\\u0648\\u0646\\u0627 \\u0686\\u0627\\u06C1\\u06CC\\u06D2`:i.format==="includes"?`\\u063A\\u0644\\u0637 \\u0633\\u0679\\u0631\\u0646\\u06AF: "${i.includes}" \\u0634\\u0627\\u0645\\u0644 \\u06C1\\u0648\\u0646\\u0627 \\u0686\\u0627\\u06C1\\u06CC\\u06D2`:i.format==="regex"?`\\u063A\\u0644\\u0637 \\u0633\\u0679\\u0631\\u0646\\u06AF: \\u067E\\u06CC\\u0679\\u0631\\u0646 ${i.pattern} \\u0633\\u06D2 \\u0645\\u06CC\\u0686 \\u06C1\\u0648\\u0646\\u0627 \\u0686\\u0627\\u06C1\\u06CC\\u06D2`:`\\u063A\\u0644\\u0637 ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u063A\\u0644\\u0637 \\u0646\\u0645\\u0628\\u0631: ${t.divisor} \\u06A9\\u0627 \\u0645\\u0636\\u0627\\u0639\\u0641 \\u06C1\\u0648\\u0646\\u0627 \\u0686\\u0627\\u06C1\\u06CC\\u06D2`;case"unrecognized_keys":return`\\u063A\\u06CC\\u0631 \\u062A\\u0633\\u0644\\u06CC\\u0645 \\u0634\\u062F\\u06C1 \\u06A9\\u06CC${t.keys.length>1?"\\u0632":""}: ${h(t.keys,"\\u060C ")}`;case"invalid_key":return`${t.origin} \\u0645\\u06CC\\u06BA \\u063A\\u0644\\u0637 \\u06A9\\u06CC`;case"invalid_union":return"\\u063A\\u0644\\u0637 \\u0627\\u0646 \\u067E\\u0679";case"invalid_element":return`${t.origin} \\u0645\\u06CC\\u06BA \\u063A\\u0644\\u0637 \\u0648\\u06CC\\u0644\\u06CC\\u0648`;default:return"\\u063A\\u0644\\u0637 \\u0627\\u0646 \\u067E\\u0679"}}};function Ll(){return{localeError:Mp()}}var Fp=()=>{let e={string:{unit:"belgi",verb:"bo\\u2018lishi kerak"},file:{unit:"bayt",verb:"bo\\u2018lishi kerak"},array:{unit:"element",verb:"bo\\u2018lishi kerak"},set:{unit:"element",verb:"bo\\u2018lishi kerak"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"kirish",email:"elektron pochta manzili",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO sana va vaqti",date:"ISO sana",time:"ISO vaqt",duration:"ISO davomiylik",ipv4:"IPv4 manzil",ipv6:"IPv6 manzil",mac:"MAC manzil",cidrv4:"IPv4 diapazon",cidrv6:"IPv6 diapazon",base64:"base64 kodlangan satr",base64url:"base64url kodlangan satr",json_string:"JSON satr",e164:"E.164 raqam",jwt:"JWT",template_literal:"kirish"},o={nan:"NaN",number:"raqam",array:"massiv"};return t=>{var a,c,m,s,u;switch(t.code){case"invalid_type":{let d=(a=o[t.expected])!=null?a:t.expected,i=x(t.input),l=(c=o[i])!=null?c:i;return/^[A-Z]/.test(t.expected)?`Noto\\u2018g\\u2018ri kirish: kutilgan instanceof ${t.expected}, qabul qilingan ${l}`:`Noto\\u2018g\\u2018ri kirish: kutilgan ${d}, qabul qilingan ${l}`}case"invalid_value":return t.values.length===1?`Noto\\u2018g\\u2018ri kirish: kutilgan ${$(t.values[0])}`:`Noto\\u2018g\\u2018ri variant: quyidagilardan biri kutilgan ${h(t.values,"|")}`;case"too_big":{let d=t.inclusive?"<=":"<",i=r(t.origin);return i?`Juda katta: kutilgan ${(m=t.origin)!=null?m:"qiymat"} ${d}${t.maximum.toString()} ${i.unit} ${i.verb}`:`Juda katta: kutilgan ${(s=t.origin)!=null?s:"qiymat"} ${d}${t.maximum.toString()}`}case"too_small":{let d=t.inclusive?">=":">",i=r(t.origin);return i?`Juda kichik: kutilgan ${t.origin} ${d}${t.minimum.toString()} ${i.unit} ${i.verb}`:`Juda kichik: kutilgan ${t.origin} ${d}${t.minimum.toString()}`}case"invalid_format":{let d=t;return d.format==="starts_with"?`Noto\\u2018g\\u2018ri satr: "${d.prefix}" bilan boshlanishi kerak`:d.format==="ends_with"?`Noto\\u2018g\\u2018ri satr: "${d.suffix}" bilan tugashi kerak`:d.format==="includes"?`Noto\\u2018g\\u2018ri satr: "${d.includes}" ni o\\u2018z ichiga olishi kerak`:d.format==="regex"?`Noto\\u2018g\\u2018ri satr: ${d.pattern} shabloniga mos kelishi kerak`:`Noto\\u2018g\\u2018ri ${(u=n[d.format])!=null?u:t.format}`}case"not_multiple_of":return`Noto\\u2018g\\u2018ri raqam: ${t.divisor} ning karralisi bo\\u2018lishi kerak`;case"unrecognized_keys":return`Noma\\u2019lum kalit${t.keys.length>1?"lar":""}: ${h(t.keys,", ")}`;case"invalid_key":return`${t.origin} dagi kalit noto\\u2018g\\u2018ri`;case"invalid_union":return"Noto\\u2018g\\u2018ri kirish";case"invalid_element":return`${t.origin} da noto\\u2018g\\u2018ri qiymat`;default:return"Noto\\u2018g\\u2018ri kirish"}}};function Cl(){return{localeError:Fp()}}var Vp=()=>{let e={string:{unit:"k\\xFD t\\u1EF1",verb:"c\\xF3"},file:{unit:"byte",verb:"c\\xF3"},array:{unit:"ph\\u1EA7n t\\u1EED",verb:"c\\xF3"},set:{unit:"ph\\u1EA7n t\\u1EED",verb:"c\\xF3"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u0111\\u1EA7u v\\xE0o",email:"\\u0111\\u1ECBa ch\\u1EC9 email",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ng\\xE0y gi\\u1EDD ISO",date:"ng\\xE0y ISO",time:"gi\\u1EDD ISO",duration:"kho\\u1EA3ng th\\u1EDDi gian ISO",ipv4:"\\u0111\\u1ECBa ch\\u1EC9 IPv4",ipv6:"\\u0111\\u1ECBa ch\\u1EC9 IPv6",cidrv4:"d\\u1EA3i IPv4",cidrv6:"d\\u1EA3i IPv6",base64:"chu\\u1ED7i m\\xE3 h\\xF3a base64",base64url:"chu\\u1ED7i m\\xE3 h\\xF3a base64url",json_string:"chu\\u1ED7i JSON",e164:"s\\u1ED1 E.164",jwt:"JWT",template_literal:"\\u0111\\u1EA7u v\\xE0o"},o={nan:"NaN",number:"s\\u1ED1",array:"m\\u1EA3ng"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u0110\\u1EA7u v\\xE0o kh\\xF4ng h\\u1EE3p l\\u1EC7: mong \\u0111\\u1EE3i instanceof ${t.expected}, nh\\u1EADn \\u0111\\u01B0\\u1EE3c ${p}`:`\\u0110\\u1EA7u v\\xE0o kh\\xF4ng h\\u1EE3p l\\u1EC7: mong \\u0111\\u1EE3i ${i}, nh\\u1EADn \\u0111\\u01B0\\u1EE3c ${p}`}case"invalid_value":return t.values.length===1?`\\u0110\\u1EA7u v\\xE0o kh\\xF4ng h\\u1EE3p l\\u1EC7: mong \\u0111\\u1EE3i ${$(t.values[0])}`:`T\\xF9y ch\\u1ECDn kh\\xF4ng h\\u1EE3p l\\u1EC7: mong \\u0111\\u1EE3i m\\u1ED9t trong c\\xE1c gi\\xE1 tr\\u1ECB ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`Qu\\xE1 l\\u1EDBn: mong \\u0111\\u1EE3i ${(m=t.origin)!=null?m:"gi\\xE1 tr\\u1ECB"} ${l.verb} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"ph\\u1EA7n t\\u1EED"}`:`Qu\\xE1 l\\u1EDBn: mong \\u0111\\u1EE3i ${(u=t.origin)!=null?u:"gi\\xE1 tr\\u1ECB"} ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`Qu\\xE1 nh\\u1ECF: mong \\u0111\\u1EE3i ${t.origin} ${l.verb} ${i}${t.minimum.toString()} ${l.unit}`:`Qu\\xE1 nh\\u1ECF: mong \\u0111\\u1EE3i ${t.origin} ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`Chu\\u1ED7i kh\\xF4ng h\\u1EE3p l\\u1EC7: ph\\u1EA3i b\\u1EAFt \\u0111\\u1EA7u b\\u1EB1ng "${i.prefix}"`:i.format==="ends_with"?`Chu\\u1ED7i kh\\xF4ng h\\u1EE3p l\\u1EC7: ph\\u1EA3i k\\u1EBFt th\\xFAc b\\u1EB1ng "${i.suffix}"`:i.format==="includes"?`Chu\\u1ED7i kh\\xF4ng h\\u1EE3p l\\u1EC7: ph\\u1EA3i bao g\\u1ED3m "${i.includes}"`:i.format==="regex"?`Chu\\u1ED7i kh\\xF4ng h\\u1EE3p l\\u1EC7: ph\\u1EA3i kh\\u1EDBp v\\u1EDBi m\\u1EABu ${i.pattern}`:`${(d=n[i.format])!=null?d:t.format} kh\\xF4ng h\\u1EE3p l\\u1EC7`}case"not_multiple_of":return`S\\u1ED1 kh\\xF4ng h\\u1EE3p l\\u1EC7: ph\\u1EA3i l\\xE0 b\\u1ED9i s\\u1ED1 c\\u1EE7a ${t.divisor}`;case"unrecognized_keys":return`Kh\\xF3a kh\\xF4ng \\u0111\\u01B0\\u1EE3c nh\\u1EADn d\\u1EA1ng: ${h(t.keys,", ")}`;case"invalid_key":return`Kh\\xF3a kh\\xF4ng h\\u1EE3p l\\u1EC7 trong ${t.origin}`;case"invalid_union":return"\\u0110\\u1EA7u v\\xE0o kh\\xF4ng h\\u1EE3p l\\u1EC7";case"invalid_element":return`Gi\\xE1 tr\\u1ECB kh\\xF4ng h\\u1EE3p l\\u1EC7 trong ${t.origin}`;default:return"\\u0110\\u1EA7u v\\xE0o kh\\xF4ng h\\u1EE3p l\\u1EC7"}}};function Rl(){return{localeError:Vp()}}var Kp=()=>{let e={string:{unit:"\\u5B57\\u7B26",verb:"\\u5305\\u542B"},file:{unit:"\\u5B57\\u8282",verb:"\\u5305\\u542B"},array:{unit:"\\u9879",verb:"\\u5305\\u542B"},set:{unit:"\\u9879",verb:"\\u5305\\u542B"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u8F93\\u5165",email:"\\u7535\\u5B50\\u90AE\\u4EF6",url:"URL",emoji:"\\u8868\\u60C5\\u7B26\\u53F7",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO\\u65E5\\u671F\\u65F6\\u95F4",date:"ISO\\u65E5\\u671F",time:"ISO\\u65F6\\u95F4",duration:"ISO\\u65F6\\u957F",ipv4:"IPv4\\u5730\\u5740",ipv6:"IPv6\\u5730\\u5740",cidrv4:"IPv4\\u7F51\\u6BB5",cidrv6:"IPv6\\u7F51\\u6BB5",base64:"base64\\u7F16\\u7801\\u5B57\\u7B26\\u4E32",base64url:"base64url\\u7F16\\u7801\\u5B57\\u7B26\\u4E32",json_string:"JSON\\u5B57\\u7B26\\u4E32",e164:"E.164\\u53F7\\u7801",jwt:"JWT",template_literal:"\\u8F93\\u5165"},o={nan:"NaN",number:"\\u6570\\u5B57",array:"\\u6570\\u7EC4",null:"\\u7A7A\\u503C(null)"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u65E0\\u6548\\u8F93\\u5165\\uFF1A\\u671F\\u671B instanceof ${t.expected}\\uFF0C\\u5B9E\\u9645\\u63A5\\u6536 ${p}`:`\\u65E0\\u6548\\u8F93\\u5165\\uFF1A\\u671F\\u671B ${i}\\uFF0C\\u5B9E\\u9645\\u63A5\\u6536 ${p}`}case"invalid_value":return t.values.length===1?`\\u65E0\\u6548\\u8F93\\u5165\\uFF1A\\u671F\\u671B ${$(t.values[0])}`:`\\u65E0\\u6548\\u9009\\u9879\\uFF1A\\u671F\\u671B\\u4EE5\\u4E0B\\u4E4B\\u4E00 ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u6570\\u503C\\u8FC7\\u5927\\uFF1A\\u671F\\u671B ${(m=t.origin)!=null?m:"\\u503C"} ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u4E2A\\u5143\\u7D20"}`:`\\u6570\\u503C\\u8FC7\\u5927\\uFF1A\\u671F\\u671B ${(u=t.origin)!=null?u:"\\u503C"} ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u6570\\u503C\\u8FC7\\u5C0F\\uFF1A\\u671F\\u671B ${t.origin} ${i}${t.minimum.toString()} ${l.unit}`:`\\u6570\\u503C\\u8FC7\\u5C0F\\uFF1A\\u671F\\u671B ${t.origin} ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u65E0\\u6548\\u5B57\\u7B26\\u4E32\\uFF1A\\u5FC5\\u987B\\u4EE5 "${i.prefix}" \\u5F00\\u5934`:i.format==="ends_with"?`\\u65E0\\u6548\\u5B57\\u7B26\\u4E32\\uFF1A\\u5FC5\\u987B\\u4EE5 "${i.suffix}" \\u7ED3\\u5C3E`:i.format==="includes"?`\\u65E0\\u6548\\u5B57\\u7B26\\u4E32\\uFF1A\\u5FC5\\u987B\\u5305\\u542B "${i.includes}"`:i.format==="regex"?`\\u65E0\\u6548\\u5B57\\u7B26\\u4E32\\uFF1A\\u5FC5\\u987B\\u6EE1\\u8DB3\\u6B63\\u5219\\u8868\\u8FBE\\u5F0F ${i.pattern}`:`\\u65E0\\u6548${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u65E0\\u6548\\u6570\\u5B57\\uFF1A\\u5FC5\\u987B\\u662F ${t.divisor} \\u7684\\u500D\\u6570`;case"unrecognized_keys":return`\\u51FA\\u73B0\\u672A\\u77E5\\u7684\\u952E(key): ${h(t.keys,", ")}`;case"invalid_key":return`${t.origin} \\u4E2D\\u7684\\u952E(key)\\u65E0\\u6548`;case"invalid_union":return"\\u65E0\\u6548\\u8F93\\u5165";case"invalid_element":return`${t.origin} \\u4E2D\\u5305\\u542B\\u65E0\\u6548\\u503C(value)`;default:return"\\u65E0\\u6548\\u8F93\\u5165"}}};function Al(){return{localeError:Kp()}}var Jp=()=>{let e={string:{unit:"\\u5B57\\u5143",verb:"\\u64C1\\u6709"},file:{unit:"\\u4F4D\\u5143\\u7D44",verb:"\\u64C1\\u6709"},array:{unit:"\\u9805\\u76EE",verb:"\\u64C1\\u6709"},set:{unit:"\\u9805\\u76EE",verb:"\\u64C1\\u6709"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u8F38\\u5165",email:"\\u90F5\\u4EF6\\u5730\\u5740",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"ISO \\u65E5\\u671F\\u6642\\u9593",date:"ISO \\u65E5\\u671F",time:"ISO \\u6642\\u9593",duration:"ISO \\u671F\\u9593",ipv4:"IPv4 \\u4F4D\\u5740",ipv6:"IPv6 \\u4F4D\\u5740",cidrv4:"IPv4 \\u7BC4\\u570D",cidrv6:"IPv6 \\u7BC4\\u570D",base64:"base64 \\u7DE8\\u78BC\\u5B57\\u4E32",base64url:"base64url \\u7DE8\\u78BC\\u5B57\\u4E32",json_string:"JSON \\u5B57\\u4E32",e164:"E.164 \\u6578\\u503C",jwt:"JWT",template_literal:"\\u8F38\\u5165"},o={nan:"NaN"};return t=>{var a,c,m,s,u,d;switch(t.code){case"invalid_type":{let i=(a=o[t.expected])!=null?a:t.expected,l=x(t.input),p=(c=o[l])!=null?c:l;return/^[A-Z]/.test(t.expected)?`\\u7121\\u6548\\u7684\\u8F38\\u5165\\u503C\\uFF1A\\u9810\\u671F\\u70BA instanceof ${t.expected}\\uFF0C\\u4F46\\u6536\\u5230 ${p}`:`\\u7121\\u6548\\u7684\\u8F38\\u5165\\u503C\\uFF1A\\u9810\\u671F\\u70BA ${i}\\uFF0C\\u4F46\\u6536\\u5230 ${p}`}case"invalid_value":return t.values.length===1?`\\u7121\\u6548\\u7684\\u8F38\\u5165\\u503C\\uFF1A\\u9810\\u671F\\u70BA ${$(t.values[0])}`:`\\u7121\\u6548\\u7684\\u9078\\u9805\\uFF1A\\u9810\\u671F\\u70BA\\u4EE5\\u4E0B\\u5176\\u4E2D\\u4E4B\\u4E00 ${h(t.values,"|")}`;case"too_big":{let i=t.inclusive?"<=":"<",l=r(t.origin);return l?`\\u6578\\u503C\\u904E\\u5927\\uFF1A\\u9810\\u671F ${(m=t.origin)!=null?m:"\\u503C"} \\u61C9\\u70BA ${i}${t.maximum.toString()} ${(s=l.unit)!=null?s:"\\u500B\\u5143\\u7D20"}`:`\\u6578\\u503C\\u904E\\u5927\\uFF1A\\u9810\\u671F ${(u=t.origin)!=null?u:"\\u503C"} \\u61C9\\u70BA ${i}${t.maximum.toString()}`}case"too_small":{let i=t.inclusive?">=":">",l=r(t.origin);return l?`\\u6578\\u503C\\u904E\\u5C0F\\uFF1A\\u9810\\u671F ${t.origin} \\u61C9\\u70BA ${i}${t.minimum.toString()} ${l.unit}`:`\\u6578\\u503C\\u904E\\u5C0F\\uFF1A\\u9810\\u671F ${t.origin} \\u61C9\\u70BA ${i}${t.minimum.toString()}`}case"invalid_format":{let i=t;return i.format==="starts_with"?`\\u7121\\u6548\\u7684\\u5B57\\u4E32\\uFF1A\\u5FC5\\u9808\\u4EE5 "${i.prefix}" \\u958B\\u982D`:i.format==="ends_with"?`\\u7121\\u6548\\u7684\\u5B57\\u4E32\\uFF1A\\u5FC5\\u9808\\u4EE5 "${i.suffix}" \\u7D50\\u5C3E`:i.format==="includes"?`\\u7121\\u6548\\u7684\\u5B57\\u4E32\\uFF1A\\u5FC5\\u9808\\u5305\\u542B "${i.includes}"`:i.format==="regex"?`\\u7121\\u6548\\u7684\\u5B57\\u4E32\\uFF1A\\u5FC5\\u9808\\u7B26\\u5408\\u683C\\u5F0F ${i.pattern}`:`\\u7121\\u6548\\u7684 ${(d=n[i.format])!=null?d:t.format}`}case"not_multiple_of":return`\\u7121\\u6548\\u7684\\u6578\\u5B57\\uFF1A\\u5FC5\\u9808\\u70BA ${t.divisor} \\u7684\\u500D\\u6578`;case"unrecognized_keys":return`\\u7121\\u6CD5\\u8B58\\u5225\\u7684\\u9375\\u503C${t.keys.length>1?"\\u5011":""}\\uFF1A${h(t.keys,"\\u3001")}`;case"invalid_key":return`${t.origin} \\u4E2D\\u6709\\u7121\\u6548\\u7684\\u9375\\u503C`;case"invalid_union":return"\\u7121\\u6548\\u7684\\u8F38\\u5165\\u503C";case"invalid_element":return`${t.origin} \\u4E2D\\u6709\\u7121\\u6548\\u7684\\u503C`;default:return"\\u7121\\u6548\\u7684\\u8F38\\u5165\\u503C"}}};function Ml(){return{localeError:Jp()}}var Bp=()=>{let e={string:{unit:"\\xE0mi",verb:"n\\xED"},file:{unit:"bytes",verb:"n\\xED"},array:{unit:"nkan",verb:"n\\xED"},set:{unit:"nkan",verb:"n\\xED"}};function r(t){var a;return(a=e[t])!=null?a:null}let n={regex:"\\u1EB9\\u0300r\\u1ECD \\xECb\\xE1w\\u1ECDl\\xE9",email:"\\xE0d\\xEDr\\u1EB9\\u0301s\\xEC \\xECm\\u1EB9\\u0301l\\xEC",url:"URL",emoji:"emoji",uuid:"UUID",uuidv4:"UUIDv4",uuidv6:"UUIDv6",nanoid:"nanoid",guid:"GUID",cuid:"cuid",cuid2:"cuid2",ulid:"ULID",xid:"XID",ksuid:"KSUID",datetime:"\\xE0k\\xF3k\\xF2 ISO",date:"\\u1ECDj\\u1ECD\\u0301 ISO",time:"\\xE0k\\xF3k\\xF2 ISO",duration:"\\xE0k\\xF3k\\xF2 t\\xF3 p\\xE9 ISO",ipv4:"\\xE0d\\xEDr\\u1EB9\\u0301s\\xEC IPv4",ipv6:"\\xE0d\\xEDr\\u1EB9\\u0301s\\xEC IPv6",cidrv4:"\\xE0gb\\xE8gb\\xE8 IPv4",cidrv6:"\\xE0gb\\xE8gb\\xE8 IPv6",base64:"\\u1ECD\\u0300r\\u1ECD\\u0300 t\\xED a k\\u1ECD\\u0301 n\\xED base64",base64url:"\\u1ECD\\u0300r\\u1ECD\\u0300 base64url",json_string:"\\u1ECD\\u0300r\\u1ECD\\u0300 JSON",e164:"n\\u1ECD\\u0301mb\\xE0 E.164",jwt:"JWT",template_literal:"\\u1EB9\\u0300r\\u1ECD \\xECb\\xE1w\\u1ECDl\\xE9"},o={nan:"NaN",number:"n\\u1ECD\\u0301mb\\xE0",array:"akop\\u1ECD"};return t=>{var a,c,m,s;switch(t.code){case"invalid_type":{let u=(a=o[t.expected])!=null?a:t.expected,d=x(t.input),i=(c=o[d])!=null?c:d;return/^[A-Z]/.test(t.expected)?`\\xCCb\\xE1w\\u1ECDl\\xE9 a\\u1E63\\xEC\\u1E63e: a n\\xED l\\xE1ti fi instanceof ${t.expected}, \\xE0m\\u1ECD\\u0300 a r\\xED ${i}`:`\\xCCb\\xE1w\\u1ECDl\\xE9 a\\u1E63\\xEC\\u1E63e: a n\\xED l\\xE1ti fi ${u}, \\xE0m\\u1ECD\\u0300 a r\\xED ${i}`}case"invalid_value":return t.values.length===1?`\\xCCb\\xE1w\\u1ECDl\\xE9 a\\u1E63\\xEC\\u1E63e: a n\\xED l\\xE1ti fi ${$(t.values[0])}`:`\\xC0\\u1E63\\xE0y\\xE0n a\\u1E63\\xEC\\u1E63e: yan \\u1ECD\\u0300kan l\\xE1ra ${h(t.values,"|")}`;case"too_big":{let u=t.inclusive?"<=":"<",d=r(t.origin);return d?`T\\xF3 p\\u1ECD\\u0300 j\\xF9: a n\\xED l\\xE1ti j\\u1EB9\\u0301 p\\xE9 ${(m=t.origin)!=null?m:"iye"} ${d.verb} ${u}${t.maximum} ${d.unit}`:`T\\xF3 p\\u1ECD\\u0300 j\\xF9: a n\\xED l\\xE1ti j\\u1EB9\\u0301 ${u}${t.maximum}`}case"too_small":{let u=t.inclusive?">=":">",d=r(t.origin);return d?`K\\xE9r\\xE9 ju: a n\\xED l\\xE1ti j\\u1EB9\\u0301 p\\xE9 ${t.origin} ${d.verb} ${u}${t.minimum} ${d.unit}`:`K\\xE9r\\xE9 ju: a n\\xED l\\xE1ti j\\u1EB9\\u0301 ${u}${t.minimum}`}case"invalid_format":{let u=t;return u.format==="starts_with"?`\\u1ECC\\u0300r\\u1ECD\\u0300 a\\u1E63\\xEC\\u1E63e: gb\\u1ECD\\u0301d\\u1ECD\\u0300 b\\u1EB9\\u0300r\\u1EB9\\u0300 p\\u1EB9\\u0300l\\xFA "${u.prefix}"`:u.format==="ends_with"?`\\u1ECC\\u0300r\\u1ECD\\u0300 a\\u1E63\\xEC\\u1E63e: gb\\u1ECD\\u0301d\\u1ECD\\u0300 par\\xED p\\u1EB9\\u0300l\\xFA "${u.suffix}"`:u.format==="includes"?`\\u1ECC\\u0300r\\u1ECD\\u0300 a\\u1E63\\xEC\\u1E63e: gb\\u1ECD\\u0301d\\u1ECD\\u0300 n\\xED "${u.includes}"`:u.format==="regex"?`\\u1ECC\\u0300r\\u1ECD\\u0300 a\\u1E63\\xEC\\u1E63e: gb\\u1ECD\\u0301d\\u1ECD\\u0300 b\\xE1 \\xE0p\\u1EB9\\u1EB9r\\u1EB9 mu ${u.pattern}`:`A\\u1E63\\xEC\\u1E63e: ${(s=n[u.format])!=null?s:t.format}`}case"not_multiple_of":return`N\\u1ECD\\u0301mb\\xE0 a\\u1E63\\xEC\\u1E63e: gb\\u1ECD\\u0301d\\u1ECD\\u0300 j\\u1EB9\\u0301 \\xE8y\\xE0 p\\xEDp\\xEDn ti ${t.divisor}`;case"unrecognized_keys":return`B\\u1ECDt\\xECn\\xEC \\xE0\\xECm\\u1ECD\\u0300: ${h(t.keys,", ")}`;case"invalid_key":return`B\\u1ECDt\\xECn\\xEC a\\u1E63\\xEC\\u1E63e n\\xEDn\\xFA ${t.origin}`;case"invalid_union":return"\\xCCb\\xE1w\\u1ECDl\\xE9 a\\u1E63\\xEC\\u1E63e";case"invalid_element":return`Iye a\\u1E63\\xEC\\u1E63e n\\xEDn\\xFA ${t.origin}`;default:return"\\xCCb\\xE1w\\u1ECDl\\xE9 a\\u1E63\\xEC\\u1E63e"}}};function Fl(){return{localeError:Bp()}}var Vl,Jl=Symbol("ZodOutput"),Bl=Symbol("ZodInput"),br=class{constructor(){this._map=new WeakMap,this._idmap=new Map}add(r,...n){let o=n[0];return this._map.set(r,o),o&&typeof o=="object"&&"id"in o&&this._idmap.set(o.id,r),this}clear(){return this._map=new WeakMap,this._idmap=new Map,this}remove(r){let n=this._map.get(r);return n&&typeof n=="object"&&"id"in n&&this._idmap.delete(n.id),this._map.delete(r),this}get(r){var o;let n=r._zod.parent;if(n){let t=f({},(o=this.get(n))!=null?o:{});delete t.id;let a=f(f({},t),this._map.get(r));return Object.keys(a).length?a:void 0}return this._map.get(r)}has(r){return this._map.has(r)}};function Oi(){return new br}var Kl;(Kl=(Vl=globalThis).__zod_globalRegistry)!=null||(Vl.__zod_globalRegistry=Oi());var F=globalThis.__zod_globalRegistry;function Ui(e,r){return new e(f({type:"string"},_(r)))}function Ni(e,r){return new e(f({type:"string",coerce:!0},_(r)))}function _r(e,r){return new e(f({type:"string",format:"email",check:"string_format",abort:!1},_(r)))}function gt(e,r){return new e(f({type:"string",format:"guid",check:"string_format",abort:!1},_(r)))}function Sr(e,r){return new e(f({type:"string",format:"uuid",check:"string_format",abort:!1},_(r)))}function kr(e,r){return new e(f({type:"string",format:"uuid",check:"string_format",abort:!1,version:"v4"},_(r)))}function Ir(e,r){return new e(f({type:"string",format:"uuid",check:"string_format",abort:!1,version:"v6"},_(r)))}function zr(e,r){return new e(f({type:"string",format:"uuid",check:"string_format",abort:!1,version:"v7"},_(r)))}function vt(e,r){return new e(f({type:"string",format:"url",check:"string_format",abort:!1},_(r)))}function Tr(e,r){return new e(f({type:"string",format:"emoji",check:"string_format",abort:!1},_(r)))}function wr(e,r){return new e(f({type:"string",format:"nanoid",check:"string_format",abort:!1},_(r)))}function Pr(e,r){return new e(f({type:"string",format:"cuid",check:"string_format",abort:!1},_(r)))}function Dr(e,r){return new e(f({type:"string",format:"cuid2",check:"string_format",abort:!1},_(r)))}function jr(e,r){return new e(f({type:"string",format:"ulid",check:"string_format",abort:!1},_(r)))}function Or(e,r){return new e(f({type:"string",format:"xid",check:"string_format",abort:!1},_(r)))}function Ur(e,r){return new e(f({type:"string",format:"ksuid",check:"string_format",abort:!1},_(r)))}function Nr(e,r){return new e(f({type:"string",format:"ipv4",check:"string_format",abort:!1},_(r)))}function Er(e,r){return new e(f({type:"string",format:"ipv6",check:"string_format",abort:!1},_(r)))}function Ei(e,r){return new e(f({type:"string",format:"mac",check:"string_format",abort:!1},_(r)))}function Zr(e,r){return new e(f({type:"string",format:"cidrv4",check:"string_format",abort:!1},_(r)))}function Lr(e,r){return new e(f({type:"string",format:"cidrv6",check:"string_format",abort:!1},_(r)))}function Cr(e,r){return new e(f({type:"string",format:"base64",check:"string_format",abort:!1},_(r)))}function Rr(e,r){return new e(f({type:"string",format:"base64url",check:"string_format",abort:!1},_(r)))}function Ar(e,r){return new e(f({type:"string",format:"e164",check:"string_format",abort:!1},_(r)))}function Mr(e,r){return new e(f({type:"string",format:"jwt",check:"string_format",abort:!1},_(r)))}var Gl={Any:null,Minute:-1,Second:0,Millisecond:3,Microsecond:6};function Zi(e,r){return new e(f({type:"string",format:"datetime",check:"string_format",offset:!1,local:!1,precision:null},_(r)))}function Li(e,r){return new e(f({type:"string",format:"date",check:"string_format"},_(r)))}function Ci(e,r){return new e(f({type:"string",format:"time",check:"string_format",precision:null},_(r)))}function Ri(e,r){return new e(f({type:"string",format:"duration",check:"string_format"},_(r)))}function Ai(e,r){return new e(f({type:"number",checks:[]},_(r)))}function Mi(e,r){return new e(f({type:"number",coerce:!0,checks:[]},_(r)))}function Fi(e,r){return new e(f({type:"number",check:"number_format",abort:!1,format:"safeint"},_(r)))}function Vi(e,r){return new e(f({type:"number",check:"number_format",abort:!1,format:"float32"},_(r)))}function Ki(e,r){return new e(f({type:"number",check:"number_format",abort:!1,format:"float64"},_(r)))}function Ji(e,r){return new e(f({type:"number",check:"number_format",abort:!1,format:"int32"},_(r)))}function Bi(e,r){return new e(f({type:"number",check:"number_format",abort:!1,format:"uint32"},_(r)))}function Gi(e,r){return new e(f({type:"boolean"},_(r)))}function Wi(e,r){return new e(f({type:"boolean",coerce:!0},_(r)))}function qi(e,r){return new e(f({type:"bigint"},_(r)))}function Xi(e,r){return new e(f({type:"bigint",coerce:!0},_(r)))}function Qi(e,r){return new e(f({type:"bigint",check:"bigint_format",abort:!1,format:"int64"},_(r)))}function Yi(e,r){return new e(f({type:"bigint",check:"bigint_format",abort:!1,format:"uint64"},_(r)))}function Hi(e,r){return new e(f({type:"symbol"},_(r)))}function ea(e,r){return new e(f({type:"undefined"},_(r)))}function ta(e,r){return new e(f({type:"null"},_(r)))}function ra(e){return new e({type:"any"})}function na(e){return new e({type:"unknown"})}function oa(e,r){return new e(f({type:"never"},_(r)))}function ia(e,r){return new e(f({type:"void"},_(r)))}function aa(e,r){return new e(f({type:"date"},_(r)))}function ca(e,r){return new e(f({type:"date",coerce:!0},_(r)))}function ua(e,r){return new e(f({type:"nan"},_(r)))}function se(e,r){return new cr(I(f({check:"less_than"},_(r)),{value:e,inclusive:!1}))}function te(e,r){return new cr(I(f({check:"less_than"},_(r)),{value:e,inclusive:!0}))}function de(e,r){return new ur(I(f({check:"greater_than"},_(r)),{value:e,inclusive:!1}))}function W(e,r){return new ur(I(f({check:"greater_than"},_(r)),{value:e,inclusive:!0}))}function la(e){return de(0,e)}function sa(e){return se(0,e)}function da(e){return te(0,e)}function ma(e){return W(0,e)}function je(e,r){return new ro(I(f({check:"multiple_of"},_(r)),{value:e}))}function Oe(e,r){return new io(I(f({check:"max_size"},_(r)),{maximum:e}))}function me(e,r){return new ao(I(f({check:"min_size"},_(r)),{minimum:e}))}function Ge(e,r){return new co(I(f({check:"size_equals"},_(r)),{size:e}))}function We(e,r){return new uo(I(f({check:"max_length"},_(r)),{maximum:e}))}function _e(e,r){return new lo(I(f({check:"min_length"},_(r)),{minimum:e}))}function qe(e,r){return new so(I(f({check:"length_equals"},_(r)),{length:e}))}function ht(e,r){return new mo(I(f({check:"string_format",format:"regex"},_(r)),{pattern:e}))}function yt(e){return new po(f({check:"string_format",format:"lowercase"},_(e)))}function $t(e){return new fo(f({check:"string_format",format:"uppercase"},_(e)))}function xt(e,r){return new go(I(f({check:"string_format",format:"includes"},_(r)),{includes:e}))}function bt(e,r){return new vo(I(f({check:"string_format",format:"starts_with"},_(r)),{prefix:e}))}function _t(e,r){return new ho(I(f({check:"string_format",format:"ends_with"},_(r)),{suffix:e}))}function pa(e,r,n){return new yo(f({check:"property",property:e,schema:r},_(n)))}function St(e,r){return new $o(f({check:"mime_type",mime:e},_(r)))}function ie(e){return new xo({check:"overwrite",tx:e})}function kt(e){return ie(r=>r.normalize(e))}function It(){return ie(e=>e.trim())}function zt(){return ie(e=>e.toLowerCase())}function Tt(){return ie(e=>e.toUpperCase())}function wt(){return ie(e=>$n(e))}function fa(e,r,n){return new e(f({type:"array",element:r},_(n)))}function Wp(e,r,n){return new e(f({type:"union",options:r},_(n)))}function qp(e,r,n){return new e(f({type:"union",options:r,inclusive:!1},_(n)))}function Xp(e,r,n,o){return new e(f({type:"union",options:n,discriminator:r},_(o)))}function Qp(e,r,n){return new e({type:"intersection",left:r,right:n})}function Yp(e,r,n,o){let t=n instanceof P,a=t?o:n,c=t?n:null;return new e(f({type:"tuple",items:r,rest:c},_(a)))}function Hp(e,r,n,o){return new e(f({type:"record",keyType:r,valueType:n},_(o)))}function ef(e,r,n,o){return new e(f({type:"map",keyType:r,valueType:n},_(o)))}function tf(e,r,n){return new e(f({type:"set",valueType:r},_(n)))}function rf(e,r,n){let o=Array.isArray(r)?Object.fromEntries(r.map(t=>[t,t])):r;return new e(f({type:"enum",entries:o},_(n)))}function nf(e,r,n){return new e(f({type:"enum",entries:r},_(n)))}function of(e,r,n){return new e(f({type:"literal",values:Array.isArray(r)?r:[r]},_(n)))}function ga(e,r){return new e(f({type:"file"},_(r)))}function af(e,r){return new e({type:"transform",transform:r})}function cf(e,r){return new e({type:"optional",innerType:r})}function uf(e,r){return new e({type:"nullable",innerType:r})}function lf(e,r,n){return new e({type:"default",innerType:r,get defaultValue(){return typeof n=="function"?n():bn(n)}})}function sf(e,r,n){return new e(f({type:"nonoptional",innerType:r},_(n)))}function df(e,r){return new e({type:"success",innerType:r})}function mf(e,r,n){return new e({type:"catch",innerType:r,catchValue:typeof n=="function"?n:()=>n})}function pf(e,r,n){return new e({type:"pipe",in:r,out:n})}function ff(e,r){return new e({type:"readonly",innerType:r})}function gf(e,r,n){return new e(f({type:"template_literal",parts:r},_(n)))}function vf(e,r){return new e({type:"lazy",getter:r})}function hf(e,r){return new e({type:"promise",innerType:r})}function va(e,r,n){var a;let o=_(n);return(a=o.abort)!=null||(o.abort=!0),new e(f({type:"custom",check:"custom",fn:r},o))}function ha(e,r,n){return new e(f({type:"custom",check:"custom",fn:r},_(n)))}function ya(e){let r=Wl(n=>(n.addIssue=o=>{var t,a,c,m;if(typeof o=="string")n.issues.push(Re(o,n.value,r._zod.def));else{let s=o;s.fatal&&(s.continue=!1),(t=s.code)!=null||(s.code="custom"),(a=s.input)!=null||(s.input=n.value),(c=s.inst)!=null||(s.inst=r),(m=s.continue)!=null||(s.continue=!r._zod.def.abort),n.issues.push(Re(s))}},e(n.value,n)));return r}function Wl(e,r){let n=new L(f({check:"custom"},_(r)));return n._zod.check=e,n}function $a(e){let r=new L({check:"describe"});return r._zod.onattach=[n=>{var t;let o=(t=F.get(n))!=null?t:{};F.add(n,I(f({},o),{description:e}))}],r._zod.check=()=>{},r}function xa(e){let r=new L({check:"meta"});return r._zod.onattach=[n=>{var t;let o=(t=F.get(n))!=null?t:{};F.add(n,f(f({},o),e))}],r._zod.check=()=>{},r}function ba(e,r){var p,v,y,S,w;let n=_(r),o=(p=n.truthy)!=null?p:["true","1","yes","on","y","enabled"],t=(v=n.falsy)!=null?v:["false","0","no","off","n","disabled"];n.case!=="sensitive"&&(o=o.map(D=>typeof D=="string"?D.toLowerCase():D),t=t.map(D=>typeof D=="string"?D.toLowerCase():D));let a=new Set(o),c=new Set(t),m=(y=e.Codec)!=null?y:pt,s=(S=e.Boolean)!=null?S:dt,u=(w=e.String)!=null?w:De,d=new u({type:"string",error:n.error}),i=new s({type:"boolean",error:n.error}),l=new m({type:"pipe",in:d,out:i,transform:((D,N)=>{let k=D;return n.case!=="sensitive"&&(k=k.toLowerCase()),a.has(k)?!0:c.has(k)?!1:(N.issues.push({code:"invalid_value",expected:"stringbool",values:[...a,...c],input:N.value,inst:l,continue:!1}),{})}),reverseTransform:((D,N)=>D===!0?o[0]||"true":t[0]||"false"),error:n.error});return l}function Xe(e,r,n,o={}){let t=_(o),a=f(I(f({},_(o)),{check:"string_format",type:"string",format:r,fn:typeof n=="function"?n:m=>n.test(m)}),t);return n instanceof RegExp&&(a.pattern=n),new e(a)}function Se(e){var n,o,t,a,c,m,s,u,d;let r=(n=e==null?void 0:e.target)!=null?n:"draft-2020-12";return r==="draft-4"&&(r="draft-04"),r==="draft-7"&&(r="draft-07"),{processors:(o=e.processors)!=null?o:{},metadataRegistry:(t=e==null?void 0:e.metadata)!=null?t:F,target:r,unrepresentable:(a=e==null?void 0:e.unrepresentable)!=null?a:"throw",override:(c=e==null?void 0:e.override)!=null?c:(()=>{}),io:(m=e==null?void 0:e.io)!=null?m:"output",counter:0,seen:new Map,cycles:(s=e==null?void 0:e.cycles)!=null?s:"ref",reused:(u=e==null?void 0:e.reused)!=null?u:"inline",external:(d=e==null?void 0:e.external)!=null?d:void 0}}function E(e,r,n={path:[],schemaPath:[]}){var d,i,l;var o;let t=e._zod.def,a=r.seen.get(e);if(a)return a.count++,n.schemaPath.includes(e)&&(a.cycle=n.path),a.schema;let c={schema:{},count:1,cycle:void 0,path:n.path};r.seen.set(e,c);let m=(i=(d=e._zod).toJSONSchema)==null?void 0:i.call(d);if(m)c.schema=m;else{let p=I(f({},n),{schemaPath:[...n.schemaPath,e],path:n.path});if(e._zod.processJSONSchema)e._zod.processJSONSchema(r,c.schema,p);else{let y=c.schema,S=r.processors[t.type];if(!S)throw new Error(`[toJSONSchema]: Non-representable type encountered: ${t.type}`);S(e,r,y,p)}let v=e._zod.parent;v&&(c.ref||(c.ref=v),E(v,r,p),r.seen.get(v).isParent=!0)}let s=r.metadataRegistry.get(e);return s&&Object.assign(c.schema,s),r.io==="input"&&V(e)&&(delete c.schema.examples,delete c.schema.default),r.io==="input"&&c.schema._prefault&&((l=(o=c.schema).default)!=null||(o.default=c.schema._prefault)),delete c.schema._prefault,r.seen.get(e).schema}function ke(e,r){var c,m,s,u;let n=e.seen.get(r);if(!n)throw new Error("Unprocessed schema. This is a bug in Zod.");let o=new Map;for(let d of e.seen.entries()){let i=(c=e.metadataRegistry.get(d[0]))==null?void 0:c.id;if(i){let l=o.get(i);if(l&&l!==d[0])throw new Error(`Duplicate schema id "${i}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);o.set(i,d[0])}}let t=d=>{var y,S,w,D,N;let i=e.target==="draft-2020-12"?"$defs":"definitions";if(e.external){let k=(y=e.external.registry.get(d[0]))==null?void 0:y.id,T=(S=e.external.uri)!=null?S:(R=>R);if(k)return{ref:T(k)};let U=(D=(w=d[1].defId)!=null?w:d[1].schema.id)!=null?D:`schema${e.counter++}`;return d[1].defId=U,{defId:U,ref:`${T("__shared")}#/${i}/${U}`}}if(d[1]===n)return{ref:"#"};let p=`#/${i}/`,v=(N=d[1].schema.id)!=null?N:`__schema${e.counter++}`;return{defId:v,ref:p+v}},a=d=>{if(d[1].schema.$ref)return;let i=d[1],{ref:l,defId:p}=t(d);i.def=f({},i.schema),p&&(i.defId=p);let v=i.schema;for(let y in v)delete v[y];v.$ref=l};if(e.cycles==="throw")for(let d of e.seen.entries()){let i=d[1];if(i.cycle)throw new Error(`Cycle detected: #/${(m=i.cycle)==null?void 0:m.join("/")}/<root>\n\nSet the \\`cycles\\` parameter to \\`"ref"\\` to resolve cyclical schemas with defs.`)}for(let d of e.seen.entries()){let i=d[1];if(r===d[0]){a(d);continue}if(e.external){let p=(s=e.external.registry.get(d[0]))==null?void 0:s.id;if(r!==d[0]&&p){a(d);continue}}if((u=e.metadataRegistry.get(d[0]))==null?void 0:u.id){a(d);continue}if(i.cycle){a(d);continue}if(i.count>1&&e.reused==="ref"){a(d);continue}}}function Ie(e,r){var c,m,s,u,d;let n=e.seen.get(r);if(!n)throw new Error("Unprocessed schema. This is a bug in Zod.");let o=i=>{var w,D,N;let l=e.seen.get(i);if(l.ref===null)return;let p=(w=l.def)!=null?w:l.schema,v=f({},p),y=l.ref;if(l.ref=null,y){o(y);let k=e.seen.get(y),T=k.schema;if(T.$ref&&(e.target==="draft-07"||e.target==="draft-04"||e.target==="openapi-3.0")?(p.allOf=(D=p.allOf)!=null?D:[],p.allOf.push(T)):Object.assign(p,T),Object.assign(p,v),i._zod.parent===y)for(let R in p)R==="$ref"||R==="allOf"||R in v||delete p[R];if(T.$ref&&k.def)for(let R in p)R==="$ref"||R==="allOf"||R in k.def&&JSON.stringify(p[R])===JSON.stringify(k.def[R])&&delete p[R]}let S=i._zod.parent;if(S&&S!==y){o(S);let k=e.seen.get(S);if(k!=null&&k.schema.$ref&&(p.$ref=k.schema.$ref,k.def))for(let T in p)T==="$ref"||T==="allOf"||T in k.def&&JSON.stringify(p[T])===JSON.stringify(k.def[T])&&delete p[T]}e.override({zodSchema:i,jsonSchema:p,path:(N=l.path)!=null?N:[]})};for(let i of[...e.seen.entries()].reverse())o(i[0]);let t={};if(e.target==="draft-2020-12"?t.$schema="https://json-schema.org/draft/2020-12/schema":e.target==="draft-07"?t.$schema="http://json-schema.org/draft-07/schema#":e.target==="draft-04"?t.$schema="http://json-schema.org/draft-04/schema#":e.target,(c=e.external)!=null&&c.uri){let i=(m=e.external.registry.get(r))==null?void 0:m.id;if(!i)throw new Error("Schema is missing an `id` property");t.$id=e.external.uri(i)}Object.assign(t,(s=n.def)!=null?s:n.schema);let a=(d=(u=e.external)==null?void 0:u.defs)!=null?d:{};for(let i of e.seen.entries()){let l=i[1];l.def&&l.defId&&(a[l.defId]=l.def)}e.external||Object.keys(a).length>0&&(e.target==="draft-2020-12"?t.$defs=a:t.definitions=a);try{let i=JSON.parse(JSON.stringify(t));return Object.defineProperty(i,"~standard",{value:I(f({},r["~standard"]),{jsonSchema:{input:Qe(r,"input",e.processors),output:Qe(r,"output",e.processors)}}),enumerable:!1,writable:!1}),i}catch(i){throw new Error("Error converting schema to JSON.")}}function V(e,r){let n=r!=null?r:{seen:new Set};if(n.seen.has(e))return!1;n.seen.add(e);let o=e._zod.def;if(o.type==="transform")return!0;if(o.type==="array")return V(o.element,n);if(o.type==="set")return V(o.valueType,n);if(o.type==="lazy")return V(o.getter(),n);if(o.type==="promise"||o.type==="optional"||o.type==="nonoptional"||o.type==="nullable"||o.type==="readonly"||o.type==="default"||o.type==="prefault")return V(o.innerType,n);if(o.type==="intersection")return V(o.left,n)||V(o.right,n);if(o.type==="record"||o.type==="map")return V(o.keyType,n)||V(o.valueType,n);if(o.type==="pipe")return V(o.in,n)||V(o.out,n);if(o.type==="object"){for(let t in o.shape)if(V(o.shape[t],n))return!0;return!1}if(o.type==="union"){for(let t of o.options)if(V(t,n))return!0;return!1}if(o.type==="tuple"){for(let t of o.items)if(V(t,n))return!0;return!!(o.rest&&V(o.rest,n))}return!1}var _a=(e,r={})=>n=>{let o=Se(I(f({},n),{processors:r}));return E(e,o),ke(o,e),Ie(o,e)},Qe=(e,r,n={})=>o=>{let{libraryOptions:t,target:a}=o!=null?o:{},c=Se(I(f({},t!=null?t:{}),{target:a,io:r,processors:n}));return E(e,c),ke(c,e),Ie(c,e)};var yf={guid:"uuid",url:"uri",datetime:"date-time",json_string:"json-string",regex:""},Sa=(e,r,n,o)=>{var d;let t=n;t.type="string";let{minimum:a,maximum:c,format:m,patterns:s,contentEncoding:u}=e._zod.bag;if(typeof a=="number"&&(t.minLength=a),typeof c=="number"&&(t.maxLength=c),m&&(t.format=(d=yf[m])!=null?d:m,t.format===""&&delete t.format,m==="time"&&delete t.format),u&&(t.contentEncoding=u),s&&s.size>0){let i=[...s];i.length===1?t.pattern=i[0].source:i.length>1&&(t.allOf=[...i.map(l=>I(f({},r.target==="draft-07"||r.target==="draft-04"||r.target==="openapi-3.0"?{type:"string"}:{}),{pattern:l.source}))])}},ka=(e,r,n,o)=>{let t=n,{minimum:a,maximum:c,format:m,multipleOf:s,exclusiveMaximum:u,exclusiveMinimum:d}=e._zod.bag;typeof m=="string"&&m.includes("int")?t.type="integer":t.type="number",typeof d=="number"&&(r.target==="draft-04"||r.target==="openapi-3.0"?(t.minimum=d,t.exclusiveMinimum=!0):t.exclusiveMinimum=d),typeof a=="number"&&(t.minimum=a,typeof d=="number"&&r.target!=="draft-04"&&(d>=a?delete t.minimum:delete t.exclusiveMinimum)),typeof u=="number"&&(r.target==="draft-04"||r.target==="openapi-3.0"?(t.maximum=u,t.exclusiveMaximum=!0):t.exclusiveMaximum=u),typeof c=="number"&&(t.maximum=c,typeof u=="number"&&r.target!=="draft-04"&&(u<=c?delete t.maximum:delete t.exclusiveMaximum)),typeof s=="number"&&(t.multipleOf=s)},Ia=(e,r,n,o)=>{n.type="boolean"},za=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("BigInt cannot be represented in JSON Schema")},Ta=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Symbols cannot be represented in JSON Schema")},wa=(e,r,n,o)=>{r.target==="openapi-3.0"?(n.type="string",n.nullable=!0,n.enum=[null]):n.type="null"},Pa=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Undefined cannot be represented in JSON Schema")},Da=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Void cannot be represented in JSON Schema")},ja=(e,r,n,o)=>{n.not={}},Oa=(e,r,n,o)=>{},Ua=(e,r,n,o)=>{},Na=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Date cannot be represented in JSON Schema")},Ea=(e,r,n,o)=>{let t=e._zod.def,a=rt(t.entries);a.every(c=>typeof c=="number")&&(n.type="number"),a.every(c=>typeof c=="string")&&(n.type="string"),n.enum=a},Za=(e,r,n,o)=>{let t=e._zod.def,a=[];for(let c of t.values)if(c===void 0){if(r.unrepresentable==="throw")throw new Error("Literal `undefined` cannot be represented in JSON Schema")}else if(typeof c=="bigint"){if(r.unrepresentable==="throw")throw new Error("BigInt literals cannot be represented in JSON Schema");a.push(Number(c))}else a.push(c);if(a.length!==0)if(a.length===1){let c=a[0];n.type=c===null?"null":typeof c,r.target==="draft-04"||r.target==="openapi-3.0"?n.enum=[c]:n.const=c}else a.every(c=>typeof c=="number")&&(n.type="number"),a.every(c=>typeof c=="string")&&(n.type="string"),a.every(c=>typeof c=="boolean")&&(n.type="boolean"),a.every(c=>c===null)&&(n.type="null"),n.enum=a},La=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("NaN cannot be represented in JSON Schema")},Ca=(e,r,n,o)=>{let t=n,a=e._zod.pattern;if(!a)throw new Error("Pattern not found in template literal");t.type="string",t.pattern=a.source},Ra=(e,r,n,o)=>{let t=n,a={type:"string",format:"binary",contentEncoding:"binary"},{minimum:c,maximum:m,mime:s}=e._zod.bag;c!==void 0&&(a.minLength=c),m!==void 0&&(a.maxLength=m),s?s.length===1?(a.contentMediaType=s[0],Object.assign(t,a)):(Object.assign(t,a),t.anyOf=s.map(u=>({contentMediaType:u}))):Object.assign(t,a)},Aa=(e,r,n,o)=>{n.type="boolean"},Ma=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Custom types cannot be represented in JSON Schema")},Fa=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Function types cannot be represented in JSON Schema")},Va=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Transforms cannot be represented in JSON Schema")},Ka=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Map cannot be represented in JSON Schema")},Ja=(e,r,n,o)=>{if(r.unrepresentable==="throw")throw new Error("Set cannot be represented in JSON Schema")},Ba=(e,r,n,o)=>{let t=n,a=e._zod.def,{minimum:c,maximum:m}=e._zod.bag;typeof c=="number"&&(t.minItems=c),typeof m=="number"&&(t.maxItems=m),t.type="array",t.items=E(a.element,r,I(f({},o),{path:[...o.path,"items"]}))},Ga=(e,r,n,o)=>{var u;let t=n,a=e._zod.def;t.type="object",t.properties={};let c=a.shape;for(let d in c)t.properties[d]=E(c[d],r,I(f({},o),{path:[...o.path,"properties",d]}));let m=new Set(Object.keys(c)),s=new Set([...m].filter(d=>{let i=a.shape[d]._zod;return r.io==="input"?i.optin===void 0:i.optout===void 0}));s.size>0&&(t.required=Array.from(s)),((u=a.catchall)==null?void 0:u._zod.def.type)==="never"?t.additionalProperties=!1:a.catchall?a.catchall&&(t.additionalProperties=E(a.catchall,r,I(f({},o),{path:[...o.path,"additionalProperties"]}))):r.io==="output"&&(t.additionalProperties=!1)},Vr=(e,r,n,o)=>{let t=e._zod.def,a=t.inclusive===!1,c=t.options.map((m,s)=>E(m,r,I(f({},o),{path:[...o.path,a?"oneOf":"anyOf",s]})));a?n.oneOf=c:n.anyOf=c},Wa=(e,r,n,o)=>{let t=e._zod.def,a=E(t.left,r,I(f({},o),{path:[...o.path,"allOf",0]})),c=E(t.right,r,I(f({},o),{path:[...o.path,"allOf",1]})),m=u=>"allOf"in u&&Object.keys(u).length===1,s=[...m(a)?a.allOf:[a],...m(c)?c.allOf:[c]];n.allOf=s},qa=(e,r,n,o)=>{let t=n,a=e._zod.def;t.type="array";let c=r.target==="draft-2020-12"?"prefixItems":"items",m=r.target==="draft-2020-12"||r.target==="openapi-3.0"?"items":"additionalItems",s=a.items.map((l,p)=>E(l,r,I(f({},o),{path:[...o.path,c,p]}))),u=a.rest?E(a.rest,r,I(f({},o),{path:[...o.path,m,...r.target==="openapi-3.0"?[a.items.length]:[]]})):null;r.target==="draft-2020-12"?(t.prefixItems=s,u&&(t.items=u)):r.target==="openapi-3.0"?(t.items={anyOf:s},u&&t.items.anyOf.push(u),t.minItems=s.length,u||(t.maxItems=s.length)):(t.items=s,u&&(t.additionalItems=u));let{minimum:d,maximum:i}=e._zod.bag;typeof d=="number"&&(t.minItems=d),typeof i=="number"&&(t.maxItems=i)},Xa=(e,r,n,o)=>{let t=n,a=e._zod.def;t.type="object";let c=a.keyType,m=c._zod.bag,s=m==null?void 0:m.patterns;if(a.mode==="loose"&&s&&s.size>0){let d=E(a.valueType,r,I(f({},o),{path:[...o.path,"patternProperties","*"]}));t.patternProperties={};for(let i of s)t.patternProperties[i.source]=d}else(r.target==="draft-07"||r.target==="draft-2020-12")&&(t.propertyNames=E(a.keyType,r,I(f({},o),{path:[...o.path,"propertyNames"]}))),t.additionalProperties=E(a.valueType,r,I(f({},o),{path:[...o.path,"additionalProperties"]}));let u=c._zod.values;if(u){let d=[...u].filter(i=>typeof i=="string"||typeof i=="number");d.length>0&&(t.required=d)}},Qa=(e,r,n,o)=>{let t=e._zod.def,a=E(t.innerType,r,o),c=r.seen.get(e);r.target==="openapi-3.0"?(c.ref=t.innerType,n.nullable=!0):n.anyOf=[a,{type:"null"}]},Ya=(e,r,n,o)=>{let t=e._zod.def;E(t.innerType,r,o);let a=r.seen.get(e);a.ref=t.innerType},Ha=(e,r,n,o)=>{let t=e._zod.def;E(t.innerType,r,o);let a=r.seen.get(e);a.ref=t.innerType,n.default=JSON.parse(JSON.stringify(t.defaultValue))},ec=(e,r,n,o)=>{let t=e._zod.def;E(t.innerType,r,o);let a=r.seen.get(e);a.ref=t.innerType,r.io==="input"&&(n._prefault=JSON.parse(JSON.stringify(t.defaultValue)))},tc=(e,r,n,o)=>{let t=e._zod.def;E(t.innerType,r,o);let a=r.seen.get(e);a.ref=t.innerType;let c;try{c=t.catchValue(void 0)}catch(m){throw new Error("Dynamic catch values are not supported in JSON Schema")}n.default=c},rc=(e,r,n,o)=>{let t=e._zod.def,a=r.io==="input"?t.in._zod.def.type==="transform"?t.out:t.in:t.out;E(a,r,o);let c=r.seen.get(e);c.ref=a},nc=(e,r,n,o)=>{let t=e._zod.def;E(t.innerType,r,o);let a=r.seen.get(e);a.ref=t.innerType,n.readOnly=!0},oc=(e,r,n,o)=>{let t=e._zod.def;E(t.innerType,r,o);let a=r.seen.get(e);a.ref=t.innerType},Kr=(e,r,n,o)=>{let t=e._zod.def;E(t.innerType,r,o);let a=r.seen.get(e);a.ref=t.innerType},ic=(e,r,n,o)=>{let t=e._zod.innerType;E(t,r,o);let a=r.seen.get(e);a.ref=t},Fr={string:Sa,number:ka,boolean:Ia,bigint:za,symbol:Ta,null:wa,undefined:Pa,void:Da,never:ja,any:Oa,unknown:Ua,date:Na,enum:Ea,literal:Za,nan:La,template_literal:Ca,file:Ra,success:Aa,custom:Ma,function:Fa,transform:Va,map:Ka,set:Ja,array:Ba,object:Ga,union:Vr,intersection:Wa,tuple:qa,record:Xa,nullable:Qa,nonoptional:Ya,default:Ha,prefault:ec,catch:tc,pipe:rc,readonly:nc,promise:oc,optional:Kr,lazy:ic};function ac(e,r){if("_idmap"in e){let o=e,t=Se(I(f({},r),{processors:Fr})),a={};for(let s of o._idmap.entries()){let[u,d]=s;E(d,t)}let c={},m={registry:o,uri:r==null?void 0:r.uri,defs:a};t.external=m;for(let s of o._idmap.entries()){let[u,d]=s;ke(t,d),c[u]=Ie(t,d)}if(Object.keys(a).length>0){let s=t.target==="draft-2020-12"?"$defs":"definitions";c.__shared={[s]:a}}return{schemas:c}}let n=Se(I(f({},r),{processors:Fr}));return E(e,n),ke(n,e),Ie(n,e)}var Jr=class{get metadataRegistry(){return this.ctx.metadataRegistry}get target(){return this.ctx.target}get unrepresentable(){return this.ctx.unrepresentable}get override(){return this.ctx.override}get io(){return this.ctx.io}get counter(){return this.ctx.counter}set counter(r){this.ctx.counter=r}get seen(){return this.ctx.seen}constructor(r){var o;let n=(o=r==null?void 0:r.target)!=null?o:"draft-2020-12";n==="draft-4"&&(n="draft-04"),n==="draft-7"&&(n="draft-07"),this.ctx=Se(f(f(f(f({processors:Fr,target:n},(r==null?void 0:r.metadata)&&{metadata:r.metadata}),(r==null?void 0:r.unrepresentable)&&{unrepresentable:r.unrepresentable}),(r==null?void 0:r.override)&&{override:r.override}),(r==null?void 0:r.io)&&{io:r.io}))}process(r,n={path:[],schemaPath:[]}){return E(r,this.ctx,n)}emit(r,n){n&&(n.cycles&&(this.ctx.cycles=n.cycles),n.reused&&(this.ctx.reused=n.reused),n.external&&(this.ctx.external=n.external)),ke(this.ctx,r);let c=Ie(this.ctx,r),{"~standard":t}=c;return cu(c,["~standard"])}};var cc={};var Pt={};ve(Pt,{ZodAny:()=>ps,ZodArray:()=>hs,ZodBase64:()=>Dc,ZodBase64URL:()=>jc,ZodBigInt:()=>Et,ZodBigIntFormat:()=>Nc,ZodBoolean:()=>Nt,ZodCIDRv4:()=>wc,ZodCIDRv6:()=>Pc,ZodCUID:()=>bc,ZodCUID2:()=>_c,ZodCatch:()=>Rs,ZodCodec:()=>Mc,ZodCustom:()=>rn,ZodCustomStringFormat:()=>Ot,ZodDate:()=>Yr,ZodDefault:()=>Us,ZodDiscriminatedUnion:()=>$s,ZodE164:()=>Oc,ZodEmail:()=>yc,ZodEmoji:()=>$c,ZodEnum:()=>Dt,ZodExactOptional:()=>Ds,ZodFile:()=>ws,ZodFunction:()=>Ws,ZodGUID:()=>Gr,ZodIPv4:()=>zc,ZodIPv6:()=>Tc,ZodIntersection:()=>xs,ZodJWT:()=>Uc,ZodKSUID:()=>Ic,ZodLazy:()=>Js,ZodLiteral:()=>Ts,ZodMAC:()=>us,ZodMap:()=>Is,ZodNaN:()=>Ms,ZodNanoID:()=>xc,ZodNever:()=>gs,ZodNonOptional:()=>Rc,ZodNull:()=>ds,ZodNullable:()=>Os,ZodNumber:()=>Ut,ZodNumberFormat:()=>He,ZodObject:()=>Hr,ZodOptional:()=>Cc,ZodPipe:()=>Ac,ZodPrefault:()=>Es,ZodPromise:()=>Gs,ZodReadonly:()=>Fs,ZodRecord:()=>tn,ZodSet:()=>zs,ZodString:()=>jt,ZodStringFormat:()=>C,ZodSuccess:()=>Cs,ZodSymbol:()=>ls,ZodTemplateLiteral:()=>Ks,ZodTransform:()=>Ps,ZodTuple:()=>_s,ZodType:()=>j,ZodULID:()=>Sc,ZodURL:()=>Qr,ZodUUID:()=>fe,ZodUndefined:()=>ss,ZodUnion:()=>en,ZodUnknown:()=>fs,ZodVoid:()=>vs,ZodXID:()=>kc,ZodXor:()=>ys,_ZodString:()=>hc,_default:()=>Ns,_function:()=>Ig,any:()=>og,array:()=>ce,base64:()=>Mf,base64url:()=>Ff,bigint:()=>Hf,boolean:()=>Ue,catch:()=>As,check:()=>zg,cidrv4:()=>Rf,cidrv6:()=>Af,codec:()=>_g,cuid:()=>jf,cuid2:()=>Of,custom:()=>Tg,date:()=>ag,describe:()=>wg,discriminatedUnion:()=>dg,e164:()=>Vf,email:()=>bf,emoji:()=>Pf,enum:()=>ze,exactOptional:()=>js,file:()=>yg,float32:()=>qf,float64:()=>Xf,function:()=>Ig,guid:()=>_f,hash:()=>Wf,hex:()=>Gf,hostname:()=>Bf,httpUrl:()=>wf,instanceof:()=>Dg,int:()=>vc,int32:()=>Qf,int64:()=>eg,intersection:()=>bs,ipv4:()=>Zf,ipv6:()=>Cf,json:()=>Og,jwt:()=>Kf,keyof:()=>cg,ksuid:()=>Ef,lazy:()=>Bs,literal:()=>hg,looseObject:()=>lg,looseRecord:()=>pg,mac:()=>Lf,map:()=>fg,meta:()=>Pg,nan:()=>bg,nanoid:()=>Df,nativeEnum:()=>vg,never:()=>Ec,nonoptional:()=>Ls,null:()=>ms,nullable:()=>qr,nullish:()=>$g,number:()=>ae,object:()=>ge,optional:()=>Wr,partialRecord:()=>mg,pipe:()=>Xr,prefault:()=>Zs,preprocess:()=>Ug,promise:()=>kg,readonly:()=>Vs,record:()=>ks,refine:()=>qs,set:()=>gg,strictObject:()=>ug,string:()=>K,stringFormat:()=>Jf,stringbool:()=>jg,success:()=>xg,superRefine:()=>Xs,symbol:()=>rg,templateLiteral:()=>Sg,transform:()=>Lc,tuple:()=>Ss,uint32:()=>Yf,uint64:()=>tg,ulid:()=>Uf,undefined:()=>ng,union:()=>Zc,unknown:()=>Q,url:()=>Tf,uuid:()=>Sf,uuidv4:()=>kf,uuidv6:()=>If,uuidv7:()=>zf,void:()=>ig,xid:()=>Nf,xor:()=>sg});var Br={};ve(Br,{endsWith:()=>_t,gt:()=>de,gte:()=>W,includes:()=>xt,length:()=>qe,lowercase:()=>yt,lt:()=>se,lte:()=>te,maxLength:()=>We,maxSize:()=>Oe,mime:()=>St,minLength:()=>_e,minSize:()=>me,multipleOf:()=>je,negative:()=>sa,nonnegative:()=>ma,nonpositive:()=>da,normalize:()=>kt,overwrite:()=>ie,positive:()=>la,property:()=>pa,regex:()=>ht,size:()=>Ge,slugify:()=>wt,startsWith:()=>bt,toLowerCase:()=>zt,toUpperCase:()=>Tt,trim:()=>It,uppercase:()=>$t});var Ye={};ve(Ye,{ZodISODate:()=>sc,ZodISODateTime:()=>uc,ZodISODuration:()=>fc,ZodISOTime:()=>mc,date:()=>dc,datetime:()=>lc,duration:()=>gc,time:()=>pc});var uc=g("ZodISODateTime",(e,r)=>{No.init(e,r),C.init(e,r)});function lc(e){return Zi(uc,e)}var sc=g("ZodISODate",(e,r)=>{Eo.init(e,r),C.init(e,r)});function dc(e){return Li(sc,e)}var mc=g("ZodISOTime",(e,r)=>{Zo.init(e,r),C.init(e,r)});function pc(e){return Ci(mc,e)}var fc=g("ZodISODuration",(e,r)=>{Lo.init(e,r),C.init(e,r)});function gc(e){return Ri(fc,e)}var ql=(e,r)=>{ct.init(e,r),e.name="ZodError",Object.defineProperties(e,{format:{value:n=>Wt(e,n)},flatten:{value:n=>Gt(e,n)},addIssue:{value:n=>{e.issues.push(n),e.message=JSON.stringify(e.issues,Le,2)}},addIssues:{value:n=>{e.issues.push(...n),e.message=JSON.stringify(e.issues,Le,2)}},isEmpty:{get(){return e.issues.length===0}}})},n$=g("ZodError",ql),X=g("ZodError",ql,{Parent:Error});var Xl=Ae(X),Ql=Me(X),Yl=Fe(X),Hl=Ve(X),es=Qt(X),ts=Yt(X),rs=Ht(X),ns=er(X),os=tr(X),is=rr(X),as=nr(X),cs=or(X);var j=g("ZodType",(e,r)=>(P.init(e,r),Object.assign(e["~standard"],{jsonSchema:{input:Qe(e,"input"),output:Qe(e,"output")}}),e.toJSONSchema=_a(e,{}),e.def=r,e.type=r.type,Object.defineProperty(e,"_def",{value:r}),e.check=(...n)=>{var o;return e.clone(b.mergeDefs(r,{checks:[...(o=r.checks)!=null?o:[],...n.map(t=>typeof t=="function"?{_zod:{check:t,def:{check:"custom"},onattach:[]}}:t)]}),{parent:!0})},e.with=e.check,e.clone=(n,o)=>J(e,n,o),e.brand=()=>e,e.register=((n,o)=>(n.add(e,o),e)),e.parse=(n,o)=>Xl(e,n,o,{callee:e.parse}),e.safeParse=(n,o)=>Yl(e,n,o),e.parseAsync=async(n,o)=>Ql(e,n,o,{callee:e.parseAsync}),e.safeParseAsync=async(n,o)=>Hl(e,n,o),e.spa=e.safeParseAsync,e.encode=(n,o)=>es(e,n,o),e.decode=(n,o)=>ts(e,n,o),e.encodeAsync=async(n,o)=>rs(e,n,o),e.decodeAsync=async(n,o)=>ns(e,n,o),e.safeEncode=(n,o)=>os(e,n,o),e.safeDecode=(n,o)=>is(e,n,o),e.safeEncodeAsync=async(n,o)=>as(e,n,o),e.safeDecodeAsync=async(n,o)=>cs(e,n,o),e.refine=(n,o)=>e.check(qs(n,o)),e.superRefine=n=>e.check(Xs(n)),e.overwrite=n=>e.check(ie(n)),e.optional=()=>Wr(e),e.exactOptional=()=>js(e),e.nullable=()=>qr(e),e.nullish=()=>Wr(qr(e)),e.nonoptional=n=>Ls(e,n),e.array=()=>ce(e),e.or=n=>Zc([e,n]),e.and=n=>bs(e,n),e.transform=n=>Xr(e,Lc(n)),e.default=n=>Ns(e,n),e.prefault=n=>Zs(e,n),e.catch=n=>As(e,n),e.pipe=n=>Xr(e,n),e.readonly=()=>Vs(e),e.describe=n=>{let o=e.clone();return F.add(o,{description:n}),o},Object.defineProperty(e,"description",{get(){var n;return(n=F.get(e))==null?void 0:n.description},configurable:!0}),e.meta=(...n)=>{if(n.length===0)return F.get(e);let o=e.clone();return F.add(o,n[0]),o},e.isOptional=()=>e.safeParse(void 0).success,e.isNullable=()=>e.safeParse(null).success,e.apply=n=>n(e),e)),hc=g("_ZodString",(e,r)=>{var o,t,a;De.init(e,r),j.init(e,r),e._zod.processJSONSchema=(c,m,s)=>Sa(e,c,m,s);let n=e._zod.bag;e.format=(o=n.format)!=null?o:null,e.minLength=(t=n.minimum)!=null?t:null,e.maxLength=(a=n.maximum)!=null?a:null,e.regex=(...c)=>e.check(ht(...c)),e.includes=(...c)=>e.check(xt(...c)),e.startsWith=(...c)=>e.check(bt(...c)),e.endsWith=(...c)=>e.check(_t(...c)),e.min=(...c)=>e.check(_e(...c)),e.max=(...c)=>e.check(We(...c)),e.length=(...c)=>e.check(qe(...c)),e.nonempty=(...c)=>e.check(_e(1,...c)),e.lowercase=c=>e.check(yt(c)),e.uppercase=c=>e.check($t(c)),e.trim=()=>e.check(It()),e.normalize=(...c)=>e.check(kt(...c)),e.toLowerCase=()=>e.check(zt()),e.toUpperCase=()=>e.check(Tt()),e.slugify=()=>e.check(wt())}),jt=g("ZodString",(e,r)=>{De.init(e,r),hc.init(e,r),e.email=n=>e.check(_r(yc,n)),e.url=n=>e.check(vt(Qr,n)),e.jwt=n=>e.check(Mr(Uc,n)),e.emoji=n=>e.check(Tr($c,n)),e.guid=n=>e.check(gt(Gr,n)),e.uuid=n=>e.check(Sr(fe,n)),e.uuidv4=n=>e.check(kr(fe,n)),e.uuidv6=n=>e.check(Ir(fe,n)),e.uuidv7=n=>e.check(zr(fe,n)),e.nanoid=n=>e.check(wr(xc,n)),e.guid=n=>e.check(gt(Gr,n)),e.cuid=n=>e.check(Pr(bc,n)),e.cuid2=n=>e.check(Dr(_c,n)),e.ulid=n=>e.check(jr(Sc,n)),e.base64=n=>e.check(Cr(Dc,n)),e.base64url=n=>e.check(Rr(jc,n)),e.xid=n=>e.check(Or(kc,n)),e.ksuid=n=>e.check(Ur(Ic,n)),e.ipv4=n=>e.check(Nr(zc,n)),e.ipv6=n=>e.check(Er(Tc,n)),e.cidrv4=n=>e.check(Zr(wc,n)),e.cidrv6=n=>e.check(Lr(Pc,n)),e.e164=n=>e.check(Ar(Oc,n)),e.datetime=n=>e.check(lc(n)),e.date=n=>e.check(dc(n)),e.time=n=>e.check(pc(n)),e.duration=n=>e.check(gc(n))});function K(e){return Ui(jt,e)}var C=g("ZodStringFormat",(e,r)=>{Z.init(e,r),hc.init(e,r)}),yc=g("ZodEmail",(e,r)=>{Io.init(e,r),C.init(e,r)});function bf(e){return _r(yc,e)}var Gr=g("ZodGUID",(e,r)=>{So.init(e,r),C.init(e,r)});function _f(e){return gt(Gr,e)}var fe=g("ZodUUID",(e,r)=>{ko.init(e,r),C.init(e,r)});function Sf(e){return Sr(fe,e)}function kf(e){return kr(fe,e)}function If(e){return Ir(fe,e)}function zf(e){return zr(fe,e)}var Qr=g("ZodURL",(e,r)=>{zo.init(e,r),C.init(e,r)});function Tf(e){return vt(Qr,e)}function wf(e){return vt(Qr,f({protocol:/^https?$/,hostname:ee.domain},b.normalizeParams(e)))}var $c=g("ZodEmoji",(e,r)=>{To.init(e,r),C.init(e,r)});function Pf(e){return Tr($c,e)}var xc=g("ZodNanoID",(e,r)=>{wo.init(e,r),C.init(e,r)});function Df(e){return wr(xc,e)}var bc=g("ZodCUID",(e,r)=>{Po.init(e,r),C.init(e,r)});function jf(e){return Pr(bc,e)}var _c=g("ZodCUID2",(e,r)=>{Do.init(e,r),C.init(e,r)});function Of(e){return Dr(_c,e)}var Sc=g("ZodULID",(e,r)=>{jo.init(e,r),C.init(e,r)});function Uf(e){return jr(Sc,e)}var kc=g("ZodXID",(e,r)=>{Oo.init(e,r),C.init(e,r)});function Nf(e){return Or(kc,e)}var Ic=g("ZodKSUID",(e,r)=>{Uo.init(e,r),C.init(e,r)});function Ef(e){return Ur(Ic,e)}var zc=g("ZodIPv4",(e,r)=>{Co.init(e,r),C.init(e,r)});function Zf(e){return Nr(zc,e)}var us=g("ZodMAC",(e,r)=>{Ao.init(e,r),C.init(e,r)});function Lf(e){return Ei(us,e)}var Tc=g("ZodIPv6",(e,r)=>{Ro.init(e,r),C.init(e,r)});function Cf(e){return Er(Tc,e)}var wc=g("ZodCIDRv4",(e,r)=>{Mo.init(e,r),C.init(e,r)});function Rf(e){return Zr(wc,e)}var Pc=g("ZodCIDRv6",(e,r)=>{Fo.init(e,r),C.init(e,r)});function Af(e){return Lr(Pc,e)}var Dc=g("ZodBase64",(e,r)=>{Ko.init(e,r),C.init(e,r)});function Mf(e){return Cr(Dc,e)}var jc=g("ZodBase64URL",(e,r)=>{Jo.init(e,r),C.init(e,r)});function Ff(e){return Rr(jc,e)}var Oc=g("ZodE164",(e,r)=>{Bo.init(e,r),C.init(e,r)});function Vf(e){return Ar(Oc,e)}var Uc=g("ZodJWT",(e,r)=>{Go.init(e,r),C.init(e,r)});function Kf(e){return Mr(Uc,e)}var Ot=g("ZodCustomStringFormat",(e,r)=>{Wo.init(e,r),C.init(e,r)});function Jf(e,r,n={}){return Xe(Ot,e,r,n)}function Bf(e){return Xe(Ot,"hostname",ee.hostname,e)}function Gf(e){return Xe(Ot,"hex",ee.hex,e)}function Wf(e,r){var a;let n=(a=r==null?void 0:r.enc)!=null?a:"hex",o=`${e}_${n}`,t=ee[o];if(!t)throw new Error(`Unrecognized hash format: ${o}`);return Xe(Ot,o,t,r)}var Ut=g("ZodNumber",(e,r)=>{var o,t,a,c,m,s,u,d,i;fr.init(e,r),j.init(e,r),e._zod.processJSONSchema=(l,p,v)=>ka(e,l,p,v),e.gt=(l,p)=>e.check(de(l,p)),e.gte=(l,p)=>e.check(W(l,p)),e.min=(l,p)=>e.check(W(l,p)),e.lt=(l,p)=>e.check(se(l,p)),e.lte=(l,p)=>e.check(te(l,p)),e.max=(l,p)=>e.check(te(l,p)),e.int=l=>e.check(vc(l)),e.safe=l=>e.check(vc(l)),e.positive=l=>e.check(de(0,l)),e.nonnegative=l=>e.check(W(0,l)),e.negative=l=>e.check(se(0,l)),e.nonpositive=l=>e.check(te(0,l)),e.multipleOf=(l,p)=>e.check(je(l,p)),e.step=(l,p)=>e.check(je(l,p)),e.finite=()=>e;let n=e._zod.bag;e.minValue=(a=Math.max((o=n.minimum)!=null?o:Number.NEGATIVE_INFINITY,(t=n.exclusiveMinimum)!=null?t:Number.NEGATIVE_INFINITY))!=null?a:null,e.maxValue=(s=Math.min((c=n.maximum)!=null?c:Number.POSITIVE_INFINITY,(m=n.exclusiveMaximum)!=null?m:Number.POSITIVE_INFINITY))!=null?s:null,e.isInt=((u=n.format)!=null?u:"").includes("int")||Number.isSafeInteger((d=n.multipleOf)!=null?d:.5),e.isFinite=!0,e.format=(i=n.format)!=null?i:null});function ae(e){return Ai(Ut,e)}var He=g("ZodNumberFormat",(e,r)=>{qo.init(e,r),Ut.init(e,r)});function vc(e){return Fi(He,e)}function qf(e){return Vi(He,e)}function Xf(e){return Ki(He,e)}function Qf(e){return Ji(He,e)}function Yf(e){return Bi(He,e)}var Nt=g("ZodBoolean",(e,r)=>{dt.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ia(e,n,o,t)});function Ue(e){return Gi(Nt,e)}var Et=g("ZodBigInt",(e,r)=>{var o,t,a;gr.init(e,r),j.init(e,r),e._zod.processJSONSchema=(c,m,s)=>za(e,c,m,s),e.gte=(c,m)=>e.check(W(c,m)),e.min=(c,m)=>e.check(W(c,m)),e.gt=(c,m)=>e.check(de(c,m)),e.gte=(c,m)=>e.check(W(c,m)),e.min=(c,m)=>e.check(W(c,m)),e.lt=(c,m)=>e.check(se(c,m)),e.lte=(c,m)=>e.check(te(c,m)),e.max=(c,m)=>e.check(te(c,m)),e.positive=c=>e.check(de(BigInt(0),c)),e.negative=c=>e.check(se(BigInt(0),c)),e.nonpositive=c=>e.check(te(BigInt(0),c)),e.nonnegative=c=>e.check(W(BigInt(0),c)),e.multipleOf=(c,m)=>e.check(je(c,m));let n=e._zod.bag;e.minValue=(o=n.minimum)!=null?o:null,e.maxValue=(t=n.maximum)!=null?t:null,e.format=(a=n.format)!=null?a:null});function Hf(e){return qi(Et,e)}var Nc=g("ZodBigIntFormat",(e,r)=>{Xo.init(e,r),Et.init(e,r)});function eg(e){return Qi(Nc,e)}function tg(e){return Yi(Nc,e)}var ls=g("ZodSymbol",(e,r)=>{Qo.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ta(e,n,o,t)});function rg(e){return Hi(ls,e)}var ss=g("ZodUndefined",(e,r)=>{Yo.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Pa(e,n,o,t)});function ng(e){return ea(ss,e)}var ds=g("ZodNull",(e,r)=>{Ho.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>wa(e,n,o,t)});function ms(e){return ta(ds,e)}var ps=g("ZodAny",(e,r)=>{ei.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Oa(e,n,o,t)});function og(){return ra(ps)}var fs=g("ZodUnknown",(e,r)=>{ti.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ua(e,n,o,t)});function Q(){return na(fs)}var gs=g("ZodNever",(e,r)=>{ri.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>ja(e,n,o,t)});function Ec(e){return oa(gs,e)}var vs=g("ZodVoid",(e,r)=>{ni.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Da(e,n,o,t)});function ig(e){return ia(vs,e)}var Yr=g("ZodDate",(e,r)=>{oi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(o,t,a)=>Na(e,o,t,a),e.min=(o,t)=>e.check(W(o,t)),e.max=(o,t)=>e.check(te(o,t));let n=e._zod.bag;e.minDate=n.minimum?new Date(n.minimum):null,e.maxDate=n.maximum?new Date(n.maximum):null});function ag(e){return aa(Yr,e)}var hs=g("ZodArray",(e,r)=>{ii.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ba(e,n,o,t),e.element=r.element,e.min=(n,o)=>e.check(_e(n,o)),e.nonempty=n=>e.check(_e(1,n)),e.max=(n,o)=>e.check(We(n,o)),e.length=(n,o)=>e.check(qe(n,o)),e.unwrap=()=>e.element});function ce(e,r){return fa(hs,e,r)}function cg(e){let r=e._zod.def.shape;return ze(Object.keys(r))}var Hr=g("ZodObject",(e,r)=>{ai.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ga(e,n,o,t),b.defineLazy(e,"shape",()=>r.shape),e.keyof=()=>ze(Object.keys(e._zod.def.shape)),e.catchall=n=>e.clone(I(f({},e._zod.def),{catchall:n})),e.passthrough=()=>e.clone(I(f({},e._zod.def),{catchall:Q()})),e.loose=()=>e.clone(I(f({},e._zod.def),{catchall:Q()})),e.strict=()=>e.clone(I(f({},e._zod.def),{catchall:Ec()})),e.strip=()=>e.clone(I(f({},e._zod.def),{catchall:void 0})),e.extend=n=>b.extend(e,n),e.safeExtend=n=>b.safeExtend(e,n),e.merge=n=>b.merge(e,n),e.pick=n=>b.pick(e,n),e.omit=n=>b.omit(e,n),e.partial=(...n)=>b.partial(Cc,e,n[0]),e.required=(...n)=>b.required(Rc,e,n[0])});function ge(e,r){let n=f({type:"object",shape:e!=null?e:{}},b.normalizeParams(r));return new Hr(n)}function ug(e,r){return new Hr(f({type:"object",shape:e,catchall:Ec()},b.normalizeParams(r)))}function lg(e,r){return new Hr(f({type:"object",shape:e,catchall:Q()},b.normalizeParams(r)))}var en=g("ZodUnion",(e,r)=>{mt.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Vr(e,n,o,t),e.options=r.options});function Zc(e,r){return new en(f({type:"union",options:e},b.normalizeParams(r)))}var ys=g("ZodXor",(e,r)=>{en.init(e,r),ci.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Vr(e,n,o,t),e.options=r.options});function sg(e,r){return new ys(f({type:"union",options:e,inclusive:!1},b.normalizeParams(r)))}var $s=g("ZodDiscriminatedUnion",(e,r)=>{en.init(e,r),ui.init(e,r)});function dg(e,r,n){return new $s(f({type:"union",options:r,discriminator:e},b.normalizeParams(n)))}var xs=g("ZodIntersection",(e,r)=>{li.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Wa(e,n,o,t)});function bs(e,r){return new xs({type:"intersection",left:e,right:r})}var _s=g("ZodTuple",(e,r)=>{vr.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>qa(e,n,o,t),e.rest=n=>e.clone(I(f({},e._zod.def),{rest:n}))});function Ss(e,r,n){let o=r instanceof P,t=o?n:r,a=o?r:null;return new _s(f({type:"tuple",items:e,rest:a},b.normalizeParams(t)))}var tn=g("ZodRecord",(e,r)=>{si.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Xa(e,n,o,t),e.keyType=r.keyType,e.valueType=r.valueType});function ks(e,r,n){return new tn(f({type:"record",keyType:e,valueType:r},b.normalizeParams(n)))}function mg(e,r,n){let o=J(e);return o._zod.values=void 0,new tn(f({type:"record",keyType:o,valueType:r},b.normalizeParams(n)))}function pg(e,r,n){return new tn(f({type:"record",keyType:e,valueType:r,mode:"loose"},b.normalizeParams(n)))}var Is=g("ZodMap",(e,r)=>{di.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ka(e,n,o,t),e.keyType=r.keyType,e.valueType=r.valueType,e.min=(...n)=>e.check(me(...n)),e.nonempty=n=>e.check(me(1,n)),e.max=(...n)=>e.check(Oe(...n)),e.size=(...n)=>e.check(Ge(...n))});function fg(e,r,n){return new Is(f({type:"map",keyType:e,valueType:r},b.normalizeParams(n)))}var zs=g("ZodSet",(e,r)=>{mi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ja(e,n,o,t),e.min=(...n)=>e.check(me(...n)),e.nonempty=n=>e.check(me(1,n)),e.max=(...n)=>e.check(Oe(...n)),e.size=(...n)=>e.check(Ge(...n))});function gg(e,r){return new zs(f({type:"set",valueType:e},b.normalizeParams(r)))}var Dt=g("ZodEnum",(e,r)=>{pi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(o,t,a)=>Ea(e,o,t,a),e.enum=r.entries,e.options=Object.values(r.entries);let n=new Set(Object.keys(r.entries));e.extract=(o,t)=>{let a={};for(let c of o)if(n.has(c))a[c]=r.entries[c];else throw new Error(`Key ${c} not found in enum`);return new Dt(I(f(I(f({},r),{checks:[]}),b.normalizeParams(t)),{entries:a}))},e.exclude=(o,t)=>{let a=f({},r.entries);for(let c of o)if(n.has(c))delete a[c];else throw new Error(`Key ${c} not found in enum`);return new Dt(I(f(I(f({},r),{checks:[]}),b.normalizeParams(t)),{entries:a}))}});function ze(e,r){let n=Array.isArray(e)?Object.fromEntries(e.map(o=>[o,o])):e;return new Dt(f({type:"enum",entries:n},b.normalizeParams(r)))}function vg(e,r){return new Dt(f({type:"enum",entries:e},b.normalizeParams(r)))}var Ts=g("ZodLiteral",(e,r)=>{fi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Za(e,n,o,t),e.values=new Set(r.values),Object.defineProperty(e,"value",{get(){if(r.values.length>1)throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");return r.values[0]}})});function hg(e,r){return new Ts(f({type:"literal",values:Array.isArray(e)?e:[e]},b.normalizeParams(r)))}var ws=g("ZodFile",(e,r)=>{gi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ra(e,n,o,t),e.min=(n,o)=>e.check(me(n,o)),e.max=(n,o)=>e.check(Oe(n,o)),e.mime=(n,o)=>e.check(St(Array.isArray(n)?n:[n],o))});function yg(e){return ga(ws,e)}var Ps=g("ZodTransform",(e,r)=>{vi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Va(e,n,o,t),e._zod.parse=(n,o)=>{if(o.direction==="backward")throw new he(e.constructor.name);n.addIssue=a=>{var c,m,s;if(typeof a=="string")n.issues.push(b.issue(a,n.value,r));else{let u=a;u.fatal&&(u.continue=!1),(c=u.code)!=null||(u.code="custom"),(m=u.input)!=null||(u.input=n.value),(s=u.inst)!=null||(u.inst=e),n.issues.push(b.issue(u))}};let t=r.transform(n.value,n);return t instanceof Promise?t.then(a=>(n.value=a,n)):(n.value=t,n)}});function Lc(e){return new Ps({type:"transform",transform:e})}var Cc=g("ZodOptional",(e,r)=>{hr.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Kr(e,n,o,t),e.unwrap=()=>e._zod.def.innerType});function Wr(e){return new Cc({type:"optional",innerType:e})}var Ds=g("ZodExactOptional",(e,r)=>{hi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Kr(e,n,o,t),e.unwrap=()=>e._zod.def.innerType});function js(e){return new Ds({type:"optional",innerType:e})}var Os=g("ZodNullable",(e,r)=>{yi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Qa(e,n,o,t),e.unwrap=()=>e._zod.def.innerType});function qr(e){return new Os({type:"nullable",innerType:e})}function $g(e){return Wr(qr(e))}var Us=g("ZodDefault",(e,r)=>{$i.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ha(e,n,o,t),e.unwrap=()=>e._zod.def.innerType,e.removeDefault=e.unwrap});function Ns(e,r){return new Us({type:"default",innerType:e,get defaultValue(){return typeof r=="function"?r():b.shallowClone(r)}})}var Es=g("ZodPrefault",(e,r)=>{xi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>ec(e,n,o,t),e.unwrap=()=>e._zod.def.innerType});function Zs(e,r){return new Es({type:"prefault",innerType:e,get defaultValue(){return typeof r=="function"?r():b.shallowClone(r)}})}var Rc=g("ZodNonOptional",(e,r)=>{bi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ya(e,n,o,t),e.unwrap=()=>e._zod.def.innerType});function Ls(e,r){return new Rc(f({type:"nonoptional",innerType:e},b.normalizeParams(r)))}var Cs=g("ZodSuccess",(e,r)=>{_i.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Aa(e,n,o,t),e.unwrap=()=>e._zod.def.innerType});function xg(e){return new Cs({type:"success",innerType:e})}var Rs=g("ZodCatch",(e,r)=>{Si.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>tc(e,n,o,t),e.unwrap=()=>e._zod.def.innerType,e.removeCatch=e.unwrap});function As(e,r){return new Rs({type:"catch",innerType:e,catchValue:typeof r=="function"?r:()=>r})}var Ms=g("ZodNaN",(e,r)=>{ki.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>La(e,n,o,t)});function bg(e){return ua(Ms,e)}var Ac=g("ZodPipe",(e,r)=>{Ii.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>rc(e,n,o,t),e.in=r.in,e.out=r.out});function Xr(e,r){return new Ac({type:"pipe",in:e,out:r})}var Mc=g("ZodCodec",(e,r)=>{Ac.init(e,r),pt.init(e,r)});function _g(e,r,n){return new Mc({type:"pipe",in:e,out:r,transform:n.decode,reverseTransform:n.encode})}var Fs=g("ZodReadonly",(e,r)=>{zi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>nc(e,n,o,t),e.unwrap=()=>e._zod.def.innerType});function Vs(e){return new Fs({type:"readonly",innerType:e})}var Ks=g("ZodTemplateLiteral",(e,r)=>{Ti.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ca(e,n,o,t)});function Sg(e,r){return new Ks(f({type:"template_literal",parts:e},b.normalizeParams(r)))}var Js=g("ZodLazy",(e,r)=>{Di.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>ic(e,n,o,t),e.unwrap=()=>e._zod.def.getter()});function Bs(e){return new Js({type:"lazy",getter:e})}var Gs=g("ZodPromise",(e,r)=>{Pi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>oc(e,n,o,t),e.unwrap=()=>e._zod.def.innerType});function kg(e){return new Gs({type:"promise",innerType:e})}var Ws=g("ZodFunction",(e,r)=>{wi.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Fa(e,n,o,t)});function Ig(e){var r,n;return new Ws({type:"function",input:Array.isArray(e==null?void 0:e.input)?Ss(e==null?void 0:e.input):(r=e==null?void 0:e.input)!=null?r:ce(Q()),output:(n=e==null?void 0:e.output)!=null?n:Q()})}var rn=g("ZodCustom",(e,r)=>{ji.init(e,r),j.init(e,r),e._zod.processJSONSchema=(n,o,t)=>Ma(e,n,o,t)});function zg(e){let r=new L({check:"custom"});return r._zod.check=e,r}function Tg(e,r){return va(rn,e!=null?e:(()=>!0),r)}function qs(e,r={}){return ha(rn,e,r)}function Xs(e){return ya(e)}var wg=$a,Pg=xa;function Dg(e,r={}){let n=new rn(f({type:"custom",check:"custom",fn:o=>o instanceof e,abort:!0},b.normalizeParams(r)));return n._zod.bag.Class=e,n._zod.check=o=>{var t;o.value instanceof e||o.issues.push({code:"invalid_type",expected:e.name,input:o.value,inst:n,path:[...(t=n._zod.def.path)!=null?t:[]]})},n}var jg=(...e)=>ba({Codec:Mc,Boolean:Nt,String:jt},...e);function Og(e){let r=Bs(()=>Zc([K(e),ae(),Ue(),ms(),ce(r),ks(K(),r)]));return r}function Ug(e,r){return Xr(Lc(e),r)}var Qs;Qs||(Qs={});var m$=I(f(f({},Pt),Br),{iso:Ye});var Fc={};ve(Fc,{bigint:()=>Lg,boolean:()=>Zg,date:()=>Cg,number:()=>Eg,string:()=>Ng});function Ng(e){return Ni(jt,e)}function Eg(e){return Mi(Ut,e)}function Zg(e){return Wi(Nt,e)}function Lg(e){return Xi(Et,e)}function Cg(e){return ca(Yr,e)}M(yr());var Rg=ze(["DETAILED"]),Ag=ze(["GYM","POKESTOP","POWERSPOT"]),Mg=ze(["HOLOHOLO"]),Fg=ze(["ACTIVE","INACTIVE"]),Ys=/^\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)\\s*\\)$/,Hs=K().transform((e,r)=>{let n=Ys.exec(e);return n?{lat:Number(n[1]),lng:Number(n[2])}:(r.addIssue({code:"invalid_format",message:"Invalid point format. Expected `(${number},${number})",format:"custom",pattern:Ys.source,input:e}),Kt)}),ed=ge({ne:Hs,sw:Hs}),Vg=ge({s2CellLevel:ae(),s2CellId:K(),generatedTimestamp:K(),count:ae(),format:Rg}),Kg=ge({gameBrand:Mg,entity:Ag,status:Fg}),Jg=ge({poiId:K(),latE6:ae(),lngE6:ae(),title:K(),description:K(),address:K(),categoryTags:ce(Q()),mainImage:K(),hasAdditionalImages:Ue(),gmo:ce(Kg),isCommunityContributed:Ue()}),Bg=ge({metadata:Vg,pois:ce(Jg),clusters:ce(Q())}),Gg=ge({success:Ue(),data:ce(Bg),cellsQueried:ae(),cellsLoaded:ae(),snapshot:K(),cellLevel:ae()}),td=ge({result:Gg,message:Q(),code:K(),errorsWithIcon:Q(),fieldErrors:Q(),errorDetails:Q(),version:K(),captcha:Ue()});function rd(){return{sw:{lat:1/0,lng:1/0},ne:{lat:-1/0,lng:-1/0}}}function Wg(e,r,n,o){return{sw:{lat:e,lng:r},ne:{lat:n,lng:o}}}function nd(e,r){return Wg(e.lat,e.lng,r.lat,r.lng)}function od(e){return{lat:(e.sw.lat+e.ne.lat)/2,lng:(e.sw.lng+e.ne.lng)/2}}function id(e,r){return{sw:{lat:Math.min(e.sw.lat,r.lat),lng:Math.min(e.sw.lng,r.lng)},ne:{lat:Math.max(e.ne.lat,r.lat),lng:Math.max(e.ne.lng,r.lng)}}}function ad(e,r){return e.sw.lat<=r.ne.lat&&e.ne.lat>=r.sw.lat&&e.sw.lng<=r.ne.lng&&e.ne.lng>=r.sw.lng}function Ne(e){return e}function ud(...e){}var Vc=class extends Error{constructor(n){super(n);this.name="AbortError"}};function ld(e="The operation was aborted."){return typeof DOMException=="function"?new DOMException(e,"AbortError"):new Vc(e)}function Xg(e,r){for(let[n,o]of Object.entries(r)){let t=e.createObjectStore(n,{keyPath:o.key.slice()});for(let[a,c]of Object.entries(o.indexes))t.createIndex(a,c.key,c)}}function sd(e,r,n){return new Promise((o,t)=>{let a=indexedDB.open(e,r);a.addEventListener("upgradeneeded",()=>Xg(a.result,n)),a.addEventListener("blocked",()=>t(new Error("database blocked"))),a.addEventListener("error",()=>t(a.error)),a.addEventListener("success",()=>o(a.result))})}var Kc=class{constructor(r,n,o){this.source=r;this.query=n;this.action=o}};function dd(e,{mode:r,signal:n},o,...t){return new Promise((a,c)=>{if(n!=null&&n.aborted){c(ld());return}let m=!1,s,u=e.transaction(t,r),d=n?()=>{m||u.abort()}:ud;u.addEventListener("complete",()=>{n==null||n.removeEventListener("abort",d),m?a(s):c(new Error("internal error"))}),u.addEventListener("error",k=>{n==null||n.removeEventListener("abort",d),c(k.target.error)}),n==null||n.addEventListener("abort",d);let i={};for(let k of t)i[k]=u.objectStore(k);let l=o(i),p,v,y,S,w,D;function N(){let k;switch(p){case void 0:k=l.next();break;case"Request":{let U=v.result;p=void 0,v=void 0,k=l.next(U);break}case"WaitRequests":{let U=y,R=S,Ee=R[U.length].result;if(U.push(Ee),U.length!==R.length)return;p=void 0,S=void 0,y=void 0,k=l.next(U);break}case"OpenCursor":{let U=w.result;if(U===null||D(U.value)==="break")p=void 0,w=void 0,D=void 0,k=l.next(void 0);else{U.continue();return}break}default:{c(new Error(`Invalid resolving kind: ${p}`));return}}if(k.done){m=!0,s=k.value;return}let T=k.value;if(T instanceof IDBRequest){p="Request",v=T,T.onsuccess=N;return}if(T instanceof Kc){p="OpenCursor",w=T.source.openCursor(T.query),D=T.action,w.onsuccess=N;return}p="WaitRequests",S=T,y=[];for(let U of T)U.onsuccess=N}N()})}function nn(e,r){return e.index(r)}function Qg(e,r){let n=[];for(let o of r)n.push(e.get(o));return n}function*md(e,r){let n=Qg(e,r);return n.length===0?[]:yield n}function*pd(e,r,n){return yield e.getAll(r,n)}function*Jc(e,r){let n;for(let o of r)n=e.put(o);n!=null&&(yield n)}function*fd(e,r){let n;for(let o of r)n=e.delete(o);n!=null&&(yield n)}function Hg(e){"use strict";var r=e.S2={L:{}};r.L.LatLng=function(s,u,d){var i=parseFloat(s,10),l=parseFloat(u,10);if(isNaN(i)||isNaN(l))throw new Error("Invalid LatLng object: ("+s+", "+u+")");return d!==!0&&(i=Math.max(Math.min(i,90),-90),l=(l+180)%360+(l<-180||l===180?180:-180)),{lat:i,lng:l}},r.L.LatLng.DEG_TO_RAD=Math.PI/180,r.L.LatLng.RAD_TO_DEG=180/Math.PI,r.LatLngToXYZ=function(s){var u=r.L.LatLng.DEG_TO_RAD,d=s.lat*u,i=s.lng*u,l=Math.cos(d);return[Math.cos(i)*l,Math.sin(i)*l,Math.sin(d)]},r.XYZToLatLng=function(s){var u=r.L.LatLng.RAD_TO_DEG,d=Math.atan2(s[2],Math.sqrt(s[0]*s[0]+s[1]*s[1])),i=Math.atan2(s[1],s[0]);return r.L.LatLng(d*u,i*u)};var n=function(s){var u=[Math.abs(s[0]),Math.abs(s[1]),Math.abs(s[2])];return u[0]>u[1]?u[0]>u[2]?0:2:u[1]>u[2]?1:2},o=function(s,u){var d,i;switch(s){case 0:d=u[1]/u[0],i=u[2]/u[0];break;case 1:d=-u[0]/u[1],i=u[2]/u[1];break;case 2:d=-u[0]/u[2],i=-u[1]/u[2];break;case 3:d=u[2]/u[0],i=u[1]/u[0];break;case 4:d=u[2]/u[1],i=-u[0]/u[1];break;case 5:d=-u[1]/u[2],i=-u[0]/u[2];break;default:throw{error:"Invalid face"}}return[d,i]};r.XYZToFaceUV=function(s){var u=n(s);s[u]<0&&(u+=3);var d=o(u,s);return[u,d]},r.FaceUVToXYZ=function(s,u){var d=u[0],i=u[1];switch(s){case 0:return[1,d,i];case 1:return[-d,1,i];case 2:return[-d,-i,1];case 3:return[-1,-i,-d];case 4:return[i,-1,-d];case 5:return[i,d,-1];default:throw{error:"Invalid face"}}};var t=function(s){return s>=.5?1/3*(4*s*s-1):1/3*(1-4*(1-s)*(1-s))};r.STToUV=function(s){return[t(s[0]),t(s[1])]};var a=function(s){return s>=0?.5*Math.sqrt(1+3*s):1-.5*Math.sqrt(1-3*s)};r.UVToST=function(s){return[a(s[0]),a(s[1])]},r.STToIJ=function(s,u){var d=1<<u,i=function(l){var p=Math.floor(l*d);return Math.max(0,Math.min(d-1,p))};return[i(s[0]),i(s[1])]},r.IJToST=function(s,u,d){var i=1<<u;return[(s[0]+d[0])/i,(s[1]+d[1])/i]};var c=function(s,u,d,i){var l,p;if(i==0){d==1&&(u.x=s-1-u.x,u.y=s-1-u.y);var v=u.x;u.x=u.y,u.y=v}},m=function(s,u,d,i){var l={a:[[0,"d"],[1,"a"],[3,"b"],[2,"a"]],b:[[2,"b"],[1,"b"],[3,"a"],[0,"c"]],c:[[2,"c"],[3,"d"],[1,"c"],[0,"b"]],d:[[0,"a"],[3,"c"],[1,"d"],[2,"d"]]};typeof i!="number"&&console.warn(new Error("called pointToHilbertQuadList without face value, defaulting to \'0\'").stack);for(var p=i%2?"d":"a",v=[],y=d-1;y>=0;y--){var S=1<<y,w=s&S?1:0,D=u&S?1:0,N=l[p][w*2+D];v.push(N[0]),p=N[1]}return v};return r.S2Cell=function(){},r.S2Cell.FromHilbertQuadKey=function(s){var u=s.split("/"),d=parseInt(u[0]),i=u[1],l=i.length,p={x:0,y:0},v,y,S,w,D,N;for(v=l-1;v>=0;v--)y=l-v,S=i[v],w=0,D=0,S==="1"?D=1:S==="2"?(w=1,D=1):S==="3"&&(w=1),N=Math.pow(2,y-1),c(N,p,w,D),p.x+=N*w,p.y+=N*D;if(d%2===1){var k=p.x;p.x=p.y,p.y=k}return r.S2Cell.FromFaceIJ(parseInt(d),[p.x,p.y],y)},r.S2Cell.FromLatLng=function(s,u){if(!s.lat&&s.lat!==0||!s.lng&&s.lng!==0)throw new Error("Pass { lat: lat, lng: lng } to S2.S2Cell.FromLatLng");var d=r.LatLngToXYZ(s),i=r.XYZToFaceUV(d),l=r.UVToST(i[1]),p=r.STToIJ(l,u);return r.S2Cell.FromFaceIJ(i[0],p,u)},r.S2Cell.FromFaceIJ=function(s,u,d){var i=new r.S2Cell;return i.face=s,i.ij=u,i.level=d,i},r.S2Cell.prototype.toString=function(){return"F"+this.face+"ij["+this.ij[0]+","+this.ij[1]+"]@"+this.level},r.S2Cell.prototype.getLatLng=function(){var s=r.IJToST(this.ij,this.level,[.5,.5]),u=r.STToUV(s),d=r.FaceUVToXYZ(this.face,u);return r.XYZToLatLng(d)},r.S2Cell.prototype.getCornerLatLngs=function(){for(var s=[],u=[[0,0],[0,1],[1,1],[1,0]],d=0;d<4;d++){var i=r.IJToST(this.ij,this.level,u[d]),l=r.STToUV(i),p=r.FaceUVToXYZ(this.face,l);s.push(r.XYZToLatLng(p))}return s},r.S2Cell.prototype.getFaceAndQuads=function(){var s=m(this.ij[0],this.ij[1],this.level,this.face);return[this.face,s]},r.S2Cell.prototype.toHilbertQuadkey=function(){var s=m(this.ij[0],this.ij[1],this.level,this.face);return this.face.toString(10)+"/"+s.join("")},r.latLngToNeighborKeys=r.S2Cell.latLngToNeighborKeys=function(s,u,d){return r.S2Cell.FromLatLng({lat:s,lng:u},d).getNeighbors().map(function(i){return i.toHilbertQuadkey()})},r.S2Cell.prototype.getNeighbors=function(){var s=function(p,v,y){var S=1<<y;if(v[0]>=0&&v[1]>=0&&v[0]<S&&v[1]<S)return r.S2Cell.FromFaceIJ(p,v,y);var w=r.IJToST(v,y,[.5,.5]),D=r.STToUV(w),N=r.FaceUVToXYZ(p,D),k=r.XYZToFaceUV(N);return p=k[0],D=k[1],w=r.UVToST(D),v=r.STToIJ(w,y),r.S2Cell.FromFaceIJ(p,v,y)},u=this.face,d=this.ij[0],i=this.ij[1],l=this.level;return[s(u,[d-1,i],l),s(u,[d,i-1],l),s(u,[d+1,i],l),s(u,[d,i+1],l)]},r.FACE_BITS=3,r.MAX_LEVEL=30,r.POS_BITS=2*r.MAX_LEVEL+1,r.facePosLevelToId=r.S2Cell.facePosLevelToId=r.fromFacePosLevel=function(s,u,d){var i=e.dcodeIO&&e.dcodeIO.Long,l,p,v;for(d||(d=u.length),u.length>d&&(u=u.substr(0,d)),l=i.fromString(s.toString(10),!0,10).toString(2);l.length<r.FACE_BITS;)l="0"+l;for(p=i.fromString(u,!0,4).toString(2);p.length<2*d;)p="0"+p;for(v=l+p,v+="1";v.length<r.FACE_BITS+r.POS_BITS;)v+="0";return i.fromString(v,!0,2).toString(10)},r.keyToId=r.S2Cell.keyToId=r.toId=r.toCellId=r.fromKey=function(s){var u=s.split("/");return r.fromFacePosLevel(u[0],u[1],u[1].length)},r.idToKey=r.S2Cell.idToKey=r.S2Cell.toKey=r.toKey=r.fromId=r.fromCellId=r.S2Cell.toHilbertQuadkey=r.toHilbertQuadkey=function(s){for(var u=e.dcodeIO&&e.dcodeIO.Long,d=u.fromString(s,!0,10).toString(2);d.length<r.FACE_BITS+r.POS_BITS;)d="0"+d;for(var i=d.lastIndexOf("1"),l=d.substring(0,3),p=d.substring(3,i),v=p.length/2,y=u.fromString(l,!0,2).toString(10),S=u.fromString(p,!0,2).toString(4);S.length<v;)S="0"+S;return y+"/"+S},r.keyToLatLng=r.S2Cell.keyToLatLng=function(s){var u=r.S2Cell.FromHilbertQuadKey(s);return u.getLatLng()},r.idToLatLng=r.S2Cell.idToLatLng=function(s){var u=r.idToKey(s);return r.keyToLatLng(u)},r.S2Cell.latLngToKey=r.latLngToKey=r.latLngToQuadkey=function(s,u,d){if(isNaN(d)||d<1||d>30)throw new Error("\'level\' is not a number between 1 and 30 (but it should be)");return r.S2Cell.FromLatLng({lat:s,lng:u},d).toHilbertQuadkey()},r.stepKey=function(s,u){var d=e.dcodeIO&&e.dcodeIO.Long,i=s.split("/"),l=i[0],p=i[1],v=i[1].length,y=d.fromString(p,!0,4),S;u>0?S=y.add(Math.abs(u)):u<0&&(S=y.subtract(Math.abs(u)));var w=S.toString(4);for(w==="0"&&console.warning(new Error("face/position wrapping is not yet supported"));w.length<v;)w="0"+w;return l+"/"+w},r.S2Cell.prevKey=r.prevKey=function(s){return r.stepKey(s,-1)},r.S2Cell.nextKey=r.nextKey=function(s){return r.stepKey(s,1)},r}var Zt=Hg(typeof module!="undefined"&&module.exports?module.exports:typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:typeof window!="undefined"?window:void 0);function Bc(e,r){return Zt.S2Cell.FromLatLng(e,r)}function ev(e){return Zt.S2Cell.FromHilbertQuadKey(e)}function cn(e,r){return Bc(e,r).toString()}var tv=Object.freeze(["0","1","2","3"]);function un(e){let r=e.level;if(Zt.MAX_LEVEL<=r)throw new Error("Cannot get children for a cell at MAX_LEVEL (30).");let n=e.toHilbertQuadkey(),o=[];for(let t of tv){let a=n+t;o.push(ev(a))}return o}function gd(e){let r=e.padEnd(16,"0"),n=BigInt(`0x${r}`),o=nv(n);return Zt.S2Cell.FromHilbertQuadKey(o)}var Gc=new BigUint64Array(1),an=new Uint32Array(Gc.buffer);function rv(e){Gc[0]=e;let r=an[0],n=an[1];return r!==0?31-Math.clz32(r&-r):n!==0?32+(31-Math.clz32(n&-n)):64}var on=[];function nv(e){Gc[0]=e;let r=an[0],n=an[1],o=n>>>29,t=ov(e);on.length=0,on.push(o,"/");for(let a=1;a<=t;a++){let c=61-2*a,m;c>=32?m=n>>>c-32&3:c===31?m=(n&1)<<1|r>>>31:m=r>>>c&3,on.push(m)}return on.join("")}function ov(e){let r=rv(e);if(r>60||(r&1)!==0)throw new Error("Invalid S2CellID");return 60-r>>1}function vd(e=1024){let r=new Array(e),n=e-1,o=0,t=0;return{enqueue(a){r[t&n]=a,t++},dequeue(){if(o===t)return;let a=r[o&n];return o++,a}}}var iv={pois:{recordType:Ne,key:"guid",indexes:{coordinates:{key:["lat","lng"]},cellIds:{key:"cellIds",multiEntry:!0}}},cells:{recordType:Ne,key:"cellId",indexes:{ancestorIds:{key:"ancestorIds",multiEntry:!0}}}},ln=Symbol("_pois"),hd=Symbol("_cells"),av=Symbol("_coordinatesIndex"),yd=Symbol("_cellIdsIndex"),cv=Symbol("_ancestorIdsIndexSymbol");var uv="poi-records-e232930d-7282-4c02-aeef-bb9508576d2e",lv=1,$d=Symbol("_database");async function xd(){return{[$d]:await sd(uv,lv,iv)}}function sv(e,r,n,o){return dd(e[$d],{mode:r,signal:n==null?void 0:n.signal},({pois:t,cells:a})=>{let c={[ln]:t,[hd]:a,[av]:nn(t,"coordinates"),[yd]:nn(t,"cellIds"),[cv]:nn(a,"ancestorIds")};return o(c)},"pois","cells")}function dv(e,r){let n=[],o=new Set,t=vd();t.enqueue(Bc(od(e),r));for(let a;a=t.dequeue();){let c=a.toString();if(o.has(c))continue;o.add(c);let m=rd();for(let s of a.getCornerLatLngs())m=id(m,s);if(ad(e,m)){n.push(a);for(let s of a.getNeighbors())t.enqueue(s)}}return n}function mv(e,r,n,o){let t=n.latE6/1e6,a=n.lngE6/1e6,c=n.title,m={lat:t,lng:a},s=[cn(m,14),cn(m,15)],u=e!=null?e:{guid:r,lat:t,lng:a,name:c,data:n,cellIds:s,firstFetchDate:o,lastFetchDate:o};return I(f({},u),{name:c!==""?c:u.name,lat:t,lng:a,data:n,cellIds:s,lastFetchDate:o})}async function bd(e,r,n,o,t){let a=new Map;for(let c of n)for(let m of dv(c,Wc)){let s=m.toString();r.has(s)||a.set(s,{cell:m})}await sv(e,"readwrite",{signal:t},function*(c){yield*ue(pv(c,r)),yield*ue(fv(r,c,o)),yield*ue(gv(c,r,a,o))})}function*pv(e,r){let n=[];for(let[o,{pois:t}]of r){let a=new Set;for(let m of t)a.add(m.poiId);let c=yield*ue(pd(e[yd],o));for(let{guid:m}of c)a.has(m)||n.push(m)}yield*ue(fd(e[ln],n))}function*fv(e,r,n){let o=[],t=[];for(let{pois:m}of e.values())for(let s of m)o.push(s.poiId),t.push(s);let c=(yield*ue(md(r[ln],o))).map((m,s)=>{let u=t[s];return mv(m,u.poiId,u,n)});yield*ue(Jc(r[ln],c))}function*gv(e,r,n,o){let t=[];for(let{cell:a}of[...r.values(),...n.values()])for(let c of un(a))for(let m of un(c))for(let s of un(m)){let u=s.getLatLng();t.push({cellId:s.toString(),centerLat:u.lat,centerLng:u.lng,level:s.level,ancestorIds:[cn(u,14)],firstFetchDate:o,lastFetchDate:o})}yield*ue(Jc(e[hd],t))}function _d(){return new EventTarget}function Sd(e,r){return new CustomEvent(e,{detail:r})}function vv(e){let r={};return e.searchParams.forEach((n,o)=>{r[o]=n}),r}async function hv(e,r,{cells:n,bounds:o},t){await bd(e,n,o,Date.now(),t),r.dispatchEvent(Sd("gcs-saved",void 0))}var Wc=14;async function yv(e,r){let n=new Map,o=[];for(let{queries:t,responseText:a}of e){await r.yield();let c=td.parse(JSON.parse(a));if(c.captcha||!c.result.success)continue;let m=ed.parse(t);o.push(nd(m.sw,m.ne));for(let{metadata:s,pois:u}of c.result.data){if(s.s2CellLevel!==Wc)continue;let d=gd(s.s2CellId),i=d.toString();n.set(i,{pois:u,cell:d})}}return{cells:n,bounds:o}}async function kd(e,r){let n=await xd(),o=gu(async t=>{let{signal:a}=new AbortController,c=hu(a),m=await yv(t,c);await hv(n,e,m,a)},r);return(t,a)=>{o.push({queries:vv(t),responseText:a})}}function qc(e,r){return e}var $v=[qc("config-changed",Ne),qc("gcs-received",Ne),qc("gcs-saved",Ne)],Id=$v;function Xc(e){console.error("An error occurred during asynchronous processing:",e)}async function xv(){let e=fn(self),r=_d(),n=a=>{e.dispatchEvent(a.type,a.detail).catch(Xc)};Id.forEach(a=>r.addEventListener(a,n));let o=await kd(r,Xc);Vt({hello(a){return`Worker received: ${a}`},onGcsReceived(a,c){o(new URL(a),c)}})}xv().catch(Xc);\n/*! Bundled license information:\n\ncomlink/dist/esm/comlink.mjs:\n  (**\n   * @license\n   * Copyright 2019 Google LLC\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n*/\n');
  }

  // node_modules/comlink/dist/esm/comlink.mjs
  var proxyMarker = /* @__PURE__ */ Symbol("Comlink.proxy");
  var createEndpoint = /* @__PURE__ */ Symbol("Comlink.endpoint");
  var releaseProxy = /* @__PURE__ */ Symbol("Comlink.releaseProxy");
  var finalizer = /* @__PURE__ */ Symbol("Comlink.finalizer");
  var throwMarker = /* @__PURE__ */ Symbol("Comlink.thrown");
  var isObject2 = (val) => typeof val === "object" && val !== null || typeof val === "function";
  var proxyTransferHandler = {
    canHandle: (val) => isObject2(val) && val[proxyMarker],
    serialize(obj) {
      const { port1, port2 } = new MessageChannel();
      expose(obj, port1);
      return [port2, [port2]];
    },
    deserialize(port) {
      port.start();
      return wrap2(port);
    }
  };
  var throwTransferHandler = {
    canHandle: (value) => isObject2(value) && throwMarker in value,
    serialize({ value }) {
      let serialized;
      if (value instanceof Error) {
        serialized = {
          isError: true,
          value: {
            message: value.message,
            name: value.name,
            stack: value.stack
          }
        };
      } else {
        serialized = { isError: false, value };
      }
      return [serialized, []];
    },
    deserialize(serialized) {
      if (serialized.isError) {
        throw Object.assign(new Error(serialized.value.message), serialized.value);
      }
      throw serialized.value;
    }
  };
  var transferHandlers = /* @__PURE__ */ new Map([
    ["proxy", proxyTransferHandler],
    ["throw", throwTransferHandler]
  ]);
  function isAllowedOrigin(allowedOrigins, origin) {
    for (const allowedOrigin of allowedOrigins) {
      if (origin === allowedOrigin || allowedOrigin === "*") {
        return true;
      }
      if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
        return true;
      }
    }
    return false;
  }
  function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
    ep.addEventListener("message", function callback(ev) {
      if (!ev || !ev.data) {
        return;
      }
      if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
        console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
        return;
      }
      const { id: id2, type, path } = Object.assign({ path: [] }, ev.data);
      const argumentList = (ev.data.argumentList || []).map(fromWireValue);
      let returnValue;
      try {
        const parent = path.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
        const rawValue = path.reduce((obj2, prop) => obj2[prop], obj);
        switch (type) {
          case "GET":
            {
              returnValue = rawValue;
            }
            break;
          case "SET":
            {
              parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
              returnValue = true;
            }
            break;
          case "APPLY":
            {
              returnValue = rawValue.apply(parent, argumentList);
            }
            break;
          case "CONSTRUCT":
            {
              const value = new rawValue(...argumentList);
              returnValue = proxy(value);
            }
            break;
          case "ENDPOINT":
            {
              const { port1, port2 } = new MessageChannel();
              expose(obj, port2);
              returnValue = transfer(port1, [port1]);
            }
            break;
          case "RELEASE":
            {
              returnValue = void 0;
            }
            break;
          default:
            return;
        }
      } catch (value) {
        returnValue = { value, [throwMarker]: 0 };
      }
      Promise.resolve(returnValue).catch((value) => {
        return { value, [throwMarker]: 0 };
      }).then((returnValue2) => {
        const [wireValue, transferables] = toWireValue(returnValue2);
        ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
        if (type === "RELEASE") {
          ep.removeEventListener("message", callback);
          closeEndPoint(ep);
          if (finalizer in obj && typeof obj[finalizer] === "function") {
            obj[finalizer]();
          }
        }
      }).catch((error48) => {
        const [wireValue, transferables] = toWireValue({
          value: new TypeError("Unserializable return value"),
          [throwMarker]: 0
        });
        ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
      });
    });
    if (ep.start) {
      ep.start();
    }
  }
  function isMessagePort(endpoint) {
    return endpoint.constructor.name === "MessagePort";
  }
  function closeEndPoint(endpoint) {
    if (isMessagePort(endpoint))
      endpoint.close();
  }
  function wrap2(ep, target) {
    const pendingListeners = /* @__PURE__ */ new Map();
    ep.addEventListener("message", function handleMessage(ev) {
      const { data } = ev;
      if (!data || !data.id) {
        return;
      }
      const resolver = pendingListeners.get(data.id);
      if (!resolver) {
        return;
      }
      try {
        resolver(data);
      } finally {
        pendingListeners.delete(data.id);
      }
    });
    return createProxy(ep, pendingListeners, [], target);
  }
  function throwIfProxyReleased(isReleased) {
    if (isReleased) {
      throw new Error("Proxy has been released and is not useable");
    }
  }
  function releaseEndpoint(ep) {
    return requestResponseMessage(ep, /* @__PURE__ */ new Map(), {
      type: "RELEASE"
    }).then(() => {
      closeEndPoint(ep);
    });
  }
  var proxyCounter = /* @__PURE__ */ new WeakMap();
  var proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
    const newCount = (proxyCounter.get(ep) || 0) - 1;
    proxyCounter.set(ep, newCount);
    if (newCount === 0) {
      releaseEndpoint(ep);
    }
  });
  function registerProxy(proxy2, ep) {
    const newCount = (proxyCounter.get(ep) || 0) + 1;
    proxyCounter.set(ep, newCount);
    if (proxyFinalizers) {
      proxyFinalizers.register(proxy2, ep, proxy2);
    }
  }
  function unregisterProxy(proxy2) {
    if (proxyFinalizers) {
      proxyFinalizers.unregister(proxy2);
    }
  }
  function createProxy(ep, pendingListeners, path = [], target = function() {
  }) {
    let isProxyReleased = false;
    const proxy2 = new Proxy(target, {
      get(_target, prop) {
        throwIfProxyReleased(isProxyReleased);
        if (prop === releaseProxy) {
          return () => {
            unregisterProxy(proxy2);
            releaseEndpoint(ep);
            pendingListeners.clear();
            isProxyReleased = true;
          };
        }
        if (prop === "then") {
          if (path.length === 0) {
            return { then: () => proxy2 };
          }
          const r = requestResponseMessage(ep, pendingListeners, {
            type: "GET",
            path: path.map((p) => p.toString())
          }).then(fromWireValue);
          return r.then.bind(r);
        }
        return createProxy(ep, pendingListeners, [...path, prop]);
      },
      set(_target, prop, rawValue) {
        throwIfProxyReleased(isProxyReleased);
        const [value, transferables] = toWireValue(rawValue);
        return requestResponseMessage(ep, pendingListeners, {
          type: "SET",
          path: [...path, prop].map((p) => p.toString()),
          value
        }, transferables).then(fromWireValue);
      },
      apply(_target, _thisArg, rawArgumentList) {
        throwIfProxyReleased(isProxyReleased);
        const last = path[path.length - 1];
        if (last === createEndpoint) {
          return requestResponseMessage(ep, pendingListeners, {
            type: "ENDPOINT"
          }).then(fromWireValue);
        }
        if (last === "bind") {
          return createProxy(ep, pendingListeners, path.slice(0, -1));
        }
        const [argumentList, transferables] = processArguments(rawArgumentList);
        return requestResponseMessage(ep, pendingListeners, {
          type: "APPLY",
          path: path.map((p) => p.toString()),
          argumentList
        }, transferables).then(fromWireValue);
      },
      construct(_target, rawArgumentList) {
        throwIfProxyReleased(isProxyReleased);
        const [argumentList, transferables] = processArguments(rawArgumentList);
        return requestResponseMessage(ep, pendingListeners, {
          type: "CONSTRUCT",
          path: path.map((p) => p.toString()),
          argumentList
        }, transferables).then(fromWireValue);
      }
    });
    registerProxy(proxy2, ep);
    return proxy2;
  }
  function myFlat(arr) {
    return Array.prototype.concat.apply([], arr);
  }
  function processArguments(argumentList) {
    const processed = argumentList.map(toWireValue);
    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
  }
  var transferCache = /* @__PURE__ */ new WeakMap();
  function transfer(obj, transfers) {
    transferCache.set(obj, transfers);
    return obj;
  }
  function proxy(obj) {
    return Object.assign(obj, { [proxyMarker]: true });
  }
  function toWireValue(value) {
    for (const [name, handler] of transferHandlers) {
      if (handler.canHandle(value)) {
        const [serializedValue, transferables] = handler.serialize(value);
        return [
          {
            type: "HANDLER",
            name,
            value: serializedValue
          },
          transferables
        ];
      }
    }
    return [
      {
        type: "RAW",
        value
      },
      transferCache.get(value) || []
    ];
  }
  function fromWireValue(value) {
    switch (value.type) {
      case "HANDLER":
        return transferHandlers.get(value.name).deserialize(value.value);
      case "RAW":
        return value.value;
    }
  }
  function requestResponseMessage(ep, pendingListeners, msg, transfers) {
    return new Promise((resolve) => {
      const id2 = generateUUID();
      pendingListeners.set(id2, resolve);
      if (ep.start) {
        ep.start();
      }
      ep.postMessage(Object.assign({ id: id2 }, msg), transfers);
    });
  }
  function generateUUID() {
    return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
  }

  // source/drafts-view/dialog.module.css
  var cssText3 = '.dialog-59a53fe03e3575e542ce8529fd0df0730794d761 {\n    --initial-height-495e116479cd0a7f6c7e692d6f9bdccbce49be36: min(300px, 50%);\n    --initial-width-34ea83cc4f4c691432fc64a891f4be0f53ecd5fa: min(400px, 80%);\n    --border-radius-e5129cde634ebedc5b44d3c50a36d58b65129a1e: 6px;\n\n    position: fixed;\n    top: var(--drag-top-737ad0c0838ca0307f6d25b24cebb7846196db72, calc(100% - var(--initial-height-495e116479cd0a7f6c7e692d6f9bdccbce49be36)));\n    left: var(--drag-left-0481d18ee27dc8bdf676134913f1eab609bbb7f7, calc(100% - var(--initial-width-34ea83cc4f4c691432fc64a891f4be0f53ecd5fa)));\n    height: var(--initial-height-495e116479cd0a7f6c7e692d6f9bdccbce49be36);\n    width: var(--initial-width-34ea83cc4f4c691432fc64a891f4be0f53ecd5fa);\n\n    --foreground-color-58da031e86887b92a1feaf5e8052dd5c83e23b4d: var(--external-foreground-color-5de188c61cf6701393a6300181cad2c723ea246c, #717171);\n    --background-color-b3200fc721c2f9f2b2d7b295b0ef23343df6f092: var(\n        --external-background-color-bb20739c0fcb55a95dfe902adb5bd01a0380425f,\n        rgba(247, 251, 255, 0.8)\n    );\n\n    color: var(--foreground-color-58da031e86887b92a1feaf5e8052dd5c83e23b4d);\n    background: var(--background-color-b3200fc721c2f9f2b2d7b295b0ef23343df6f092);\n    backdrop-filter: blur(6px);\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);\n    z-index: 10000;\n    border-radius: var(--border-radius-e5129cde634ebedc5b44d3c50a36d58b65129a1e);\n\n    overflow: auto;\n    resize: both;\n    display: flex;\n    flex-direction: column;\n}\n\n.dialog-59a53fe03e3575e542ce8529fd0df0730794d761.maximized-153d4ccb93d0dc13d48f201dd533f39d0bbc8ced {\n    /* resize: both \u306B\u3088\u3063\u3066\u30D6\u30E9\u30A6\u30B6\u306B\u3088\u3063\u3066\u8A2D\u5B9A\u3055\u308C\u305F\u30A4\u30F3\u30E9\u30A4\u30F3\u30B9\u30BF\u30A4\u30EB\u3092\u4E0A\u66F8\u304D\u3059\u308B\u305F\u3081 */\n    width: 100% !important;\n    height: 100% !important;\n    left: 0;\n    top: 0;\n    resize: none;\n}\n\n.dialog-59a53fe03e3575e542ce8529fd0df0730794d761.minimized-b1fe5ca90f7af0d447dd92c120b85309a6bffdfe {\n    resize: none;\n\n    /* resize: both \u306B\u3088\u3063\u3066\u30D6\u30E9\u30A6\u30B6\u306B\u3088\u3063\u3066\u8A2D\u5B9A\u3055\u308C\u305F\u30A4\u30F3\u30E9\u30A4\u30F3\u30B9\u30BF\u30A4\u30EB\u3092\u4E0A\u66F8\u304D\u3059\u308B\u305F\u3081 */\n    width: auto !important;\n    height: auto !important;\n}\n\n.titlebar-77f4f2a0b714f05efd6878ddb3f8362533a260f1 {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    align-content: center;\n    user-select: none;\n    touch-action: none;\n\n    padding: 2px 4px;\n\n    background-color: #e5e7eb;\n    border-radius: var(--border-radius-e5129cde634ebedc5b44d3c50a36d58b65129a1e) var(--border-radius-e5129cde634ebedc5b44d3c50a36d58b65129a1e) 0 0;\n}\n\n.titlebar-icon-412b1d35c34f2f49f26bd6a3dc81001c27e0fe4b {\n    width: 16px;\n    height: 16px;\n    margin-right: 8px;\n}\n\n.titlebar-title-140e5b86835d843d6f9a7c022dae1a3bf76fd116 {\n    display: flex;\n    justify-content: center;\n    flex-grow: 1;\n\n    cursor: move;\n}\n\n.titlebar-right-controls-b99876a673652ed87e84d15f17ba6f9b394c2846 {\n    display: flex;\n    align-items: center;\n}\n\n.titlebar-button-2acc5baf768eb39ffacca5d5359121c9ce7ee90f {\n    color: var(--foreground-color-58da031e86887b92a1feaf5e8052dd5c83e23b4d);\n    background: none;\n    border: none;\n    cursor: pointer;\n    padding: 0 12px;\n}\n\n.titlebar-button-2acc5baf768eb39ffacca5d5359121c9ce7ee90f::before {\n    color: var(--foreground-color-58da031e86887b92a1feaf5e8052dd5c83e23b4d);\n}\n\n.maximize-toggle-button-7fa903373c55bc3db348e90f211001c4f117f7d1::before {\n    content: "\u25A1";\n}\n\n.maximized-153d4ccb93d0dc13d48f201dd533f39d0bbc8ced .maximize-toggle-button-7fa903373c55bc3db348e90f211001c4f117f7d1::before {\n    content: "\u2750";\n}\n\n.minimize-toggle-button-bca3fbdc7dd23b6c26035e7111aeb869dd28182e::before {\n    content: "\uFF3F";\n}\n\n.minimized-b1fe5ca90f7af0d447dd92c120b85309a6bffdfe .minimize-toggle-button-bca3fbdc7dd23b6c26035e7111aeb869dd28182e::before {\n    content: "\u2750";\n}\n\n.minimized-b1fe5ca90f7af0d447dd92c120b85309a6bffdfe .titlebar-button-2acc5baf768eb39ffacca5d5359121c9ce7ee90f:not(.minimize-toggle-button-bca3fbdc7dd23b6c26035e7111aeb869dd28182e) {\n    display: none;\n}\n\n.inner-container-606dc1192fb95b445129198ee621c32f887ea204 {\n    flex-grow: 1;\n    overflow: auto;\n}\n\n.minimized-b1fe5ca90f7af0d447dd92c120b85309a6bffdfe .inner-container-606dc1192fb95b445129198ee621c32f887ea204 {\n    display: none;\n}\n';
  var variables = {
    "--initial-height": "--initial-height-495e116479cd0a7f6c7e692d6f9bdccbce49be36",
    "--initial-width": "--initial-width-34ea83cc4f4c691432fc64a891f4be0f53ecd5fa",
    "--border-radius": "--border-radius-e5129cde634ebedc5b44d3c50a36d58b65129a1e",
    "--drag-top": "--drag-top-737ad0c0838ca0307f6d25b24cebb7846196db72",
    "--drag-left": "--drag-left-0481d18ee27dc8bdf676134913f1eab609bbb7f7",
    "--foreground-color": "--foreground-color-58da031e86887b92a1feaf5e8052dd5c83e23b4d",
    "--external-foreground-color": "--external-foreground-color-5de188c61cf6701393a6300181cad2c723ea246c",
    "--background-color": "--background-color-b3200fc721c2f9f2b2d7b295b0ef23343df6f092",
    "--external-background-color": "--external-background-color-bb20739c0fcb55a95dfe902adb5bd01a0380425f"
  };
  var dialog_default = {
    dialog: "dialog-59a53fe03e3575e542ce8529fd0df0730794d761",
    maximized: "maximized-153d4ccb93d0dc13d48f201dd533f39d0bbc8ced",
    minimized: "minimized-b1fe5ca90f7af0d447dd92c120b85309a6bffdfe",
    titlebar: "titlebar-77f4f2a0b714f05efd6878ddb3f8362533a260f1",
    "titlebar-icon": "titlebar-icon-412b1d35c34f2f49f26bd6a3dc81001c27e0fe4b",
    "titlebar-title": "titlebar-title-140e5b86835d843d6f9a7c022dae1a3bf76fd116",
    "titlebar-right-controls": "titlebar-right-controls-b99876a673652ed87e84d15f17ba6f9b394c2846",
    "titlebar-button": "titlebar-button-2acc5baf768eb39ffacca5d5359121c9ce7ee90f",
    "maximize-toggle-button": "maximize-toggle-button-7fa903373c55bc3db348e90f211001c4f117f7d1",
    "minimize-toggle-button": "minimize-toggle-button-bca3fbdc7dd23b6c26035e7111aeb869dd28182e",
    "inner-container": "inner-container-606dc1192fb95b445129198ee621c32f887ea204"
  };

  // source/document-jsx/jsx-runtime.ts
  function jsxs(name, properties, _option) {
    if (name === Fragment) {
      return createFragment(
        properties.children
      );
    }
    const element = document.createElement(name);
    for (const [key, value] of Object.entries(properties ?? {})) {
      if (key === "children") continue;
      if (key.startsWith("on") && typeof value === "function") {
        const eventName = key.substring(2).toLowerCase();
        element.addEventListener(eventName, value);
        continue;
      }
      if (key === "style" && typeof value === "function") {
        value(element.style);
        continue;
      }
      if (key === "classList" && value) {
        const classes = Array.isArray(value) ? value : [value];
        for (const c of classes) {
          if (typeof c === "string" && c) {
            element.classList.add(c);
          }
        }
        continue;
      }
      if (value !== void 0 && value !== null) {
        element.setAttribute(key, String(value));
      }
    }
    const children = properties?.children;
    if (children) {
      if (Array.isArray(children)) {
        for (const child of children) {
          if (!child) continue;
          element.append(child);
        }
      } else {
        element.append(children);
      }
    }
    return element;
  }
  var jsx = jsxs;
  var Fragment = /* @__PURE__ */ Symbol("Fragment");
  function createFragment(children) {
    const fragment = document.createDocumentFragment();
    if (children != null) {
      if (Array.isArray(children)) {
        for (const child of children) {
          fragment.appendChild(child);
        }
      } else {
        fragment.appendChild(children);
      }
    }
    return fragment;
  }

  // source/drafts-view/dialog.tsx
  function makeDraggable(element, handleElement = element, options) {
    let offsetX = 0, offsetY = 0;
    function setPosition(left, top) {
      const rect = element.getBoundingClientRect();
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      left = Math.max(0, Math.min(left, windowWidth - rect.width));
      top = Math.max(0, Math.min(top, windowHeight - rect.height));
      if (options?.propertyNames) {
        const { left: leftName, top: topName } = options.propertyNames;
        element.style.setProperty(leftName, `${left}px`);
        element.style.setProperty(topName, `${top}px`);
      } else {
        element.style.left = `${left}px`;
        element.style.top = `${top}px`;
      }
    }
    const onPointerMove = (e) => {
      setPosition(e.clientX - offsetX, e.clientY - offsetY);
    };
    handleElement.addEventListener("pointerdown", (e) => {
      handleElement.addEventListener("pointermove", onPointerMove);
      handleElement.setPointerCapture(e.pointerId);
      offsetX = e.clientX - element.offsetLeft;
      offsetY = e.clientY - element.offsetTop;
    });
    handleElement.addEventListener("pointerup", (e) => {
      handleElement.removeEventListener("pointermove", onPointerMove);
      handleElement.releasePointerCapture(e.pointerId);
    });
    function adjustSize() {
      const rect = element.getBoundingClientRect();
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      if (rect.width > windowWidth) {
        element.style.width = `${windowWidth}px`;
      }
      if (rect.height > windowHeight) {
        element.style.height = `${windowHeight}px`;
      }
      setPosition(rect.left, rect.top);
    }
    window.addEventListener("resize", adjustSize);
    adjustSize();
  }
  var setStyle3 = styleSetter(cssText3);
  function createDialog(innerElement, options) {
    setStyle3();
    const titleSpan = /* @__PURE__ */ jsx("div", { class: dialog_default["titlebar-title"], children: options?.title ?? "" });
    const dialogElement = /* @__PURE__ */ jsxs("div", { class: dialog_default["dialog"], children: [
      /* @__PURE__ */ jsxs(
        "div",
        {
          class: dialog_default["titlebar"],
          ondblclick: toggleMaximizedState,
          children: [
            titleSpan,
            /* @__PURE__ */ jsxs("div", { class: dialog_default["titlebar-right-controls"], children: [
              /* @__PURE__ */ jsx(
                "button",
                {
                  classList: [
                    dialog_default["titlebar-button"],
                    dialog_default["minimize-toggle-button"]
                  ],
                  title: "minimize",
                  onclick: toggleMinimizedState
                }
              ),
              /* @__PURE__ */ jsx(
                "button",
                {
                  classList: [
                    dialog_default["titlebar-button"],
                    dialog_default["maximize-toggle-button"]
                  ],
                  title: "maximize",
                  onclick: toggleMaximizedState
                }
              ),
              /* @__PURE__ */ jsx(
                "button",
                {
                  class: dialog_default["titlebar-button"],
                  title: "close",
                  onclick: hide,
                  children: "\xD7"
                }
              )
            ] })
          ]
        }
      ),
      /* @__PURE__ */ jsx("div", { class: dialog_default["inner-container"], children: innerElement })
    ] });
    makeDraggable(dialogElement, titleSpan, {
      propertyNames: {
        left: variables["--drag-left"],
        top: variables["--drag-top"]
      }
    });
    function show() {
      document.body.appendChild(dialogElement);
    }
    function hide() {
      document.body.removeChild(dialogElement);
    }
    function toggleMaximizedState() {
      dialogElement.classList.remove(dialog_default["minimized"]);
      dialogElement.classList.toggle(dialog_default["maximized"]);
    }
    function toggleMinimizedState() {
      dialogElement.classList.remove(dialog_default["maximized"]);
      dialogElement.classList.toggle(dialog_default["minimized"]);
    }
    return {
      show,
      hide,
      element: dialogElement,
      setTitle(title) {
        titleSpan.innerHTML = "";
        titleSpan.append(title);
      },
      setForegroundColor(cssColorText) {
        dialogElement.style.setProperty(
          variables["--external-foreground-color"],
          cssColorText
        );
      },
      setBackgroundColor(cssColorText) {
        dialogElement.style.setProperty(
          variables["--external-background-color"],
          cssColorText
        );
      }
    };
  }

  // source/drafts-view/draft-list.module.css
  var cssText4 = ':root {\n    --border-color-51631c833743ba2a62500c30df9174e36f9b9673: #ccc;\n    --selected-background-color-1bc6cb676d23da8289c0d6a0b3bb2cdf3610faee: #2563eb;\n    --selected-text-color-5e45dd64c7efb30e9b0c2c3c63b17f0dd093bdfd: #fff;\n    --text-muted-022faf9d53e3d59f9848f2691abf286e5ee97d8e: #666;\n    --background-color-light-f430ca9112788979e76b190123afd7a26a88e9c9: #f8f9fa;\n    --primary-color-68a3ef2f2c6d3344d237a9856025adfe18fd107c: #2563eb;\n    --primary-color-dark-be35b3b230419a40a8bdc9ef9018e8a06e7d5f66: #0056b3;\n}\n\n.container-bcca77d95a0c238b622ad40e7361a62dc25cd3d3 {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n}\n\n.input-field-319235de682839e4738c9ef400f355f6631287b5 {\n    border: 1px solid;\n    border-color: rgba(255, 255, 255, 0.514) rgba(255, 255, 255, 0.726) white;\n    background-color: rgba(255, 255, 255, 0.25);\n    outline: none;\n}\n\n.input-field-319235de682839e4738c9ef400f355f6631287b5:focus {\n    background-color: #ffffff;\n    border-color: #cbd5e1;\n    box-shadow: 0 0 0 3px rgba(203, 213, 225, 0.35);\n}\n\n.input-error-9992f803f35644f2d22186012a38d080999233f3 {\n    border: 1px solid red;\n}\n\n.list-container-b9ec8abc5ee696908aa8198c1fed3c63294688b3 {\n    flex-grow: 1;\n    overflow-y: auto;\n    border: 1px solid var(--border-color-51631c833743ba2a62500c30df9174e36f9b9673);\n    border-radius: 4px;\n}\n\n.item-53f6e8c2e4ae94556a783051b8d2e0f75243ab80 {\n    height: 100%;\n    display: flex;\n    align-items: center;\n    flex-grow: 1;\n    min-width: 0;\n    padding: 4px;\n    border-bottom: 1px solid var(--border-color-51631c833743ba2a62500c30df9174e36f9b9673);\n    cursor: pointer;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n\n.item-53f6e8c2e4ae94556a783051b8d2e0f75243ab80:last-child {\n    border-bottom: none;\n}\n\n.item-53f6e8c2e4ae94556a783051b8d2e0f75243ab80.selected-82f59d7114a0c5666cae0781a1f3b436c4c1d446 {\n    background-color: var(--selected-background-color-1bc6cb676d23da8289c0d6a0b3bb2cdf3610faee);\n    color: var(--selected-text-color-5e45dd64c7efb30e9b0c2c3c63b17f0dd093bdfd);\n}\n\n.item-53f6e8c2e4ae94556a783051b8d2e0f75243ab80.selected-82f59d7114a0c5666cae0781a1f3b436c4c1d446 .item-note-364dd75c466d5cbe30232b5aea6c4a84bc40b518 {\n    color: var(--selected-text-color-5e45dd64c7efb30e9b0c2c3c63b17f0dd093bdfd);\n}\n\n.item-name-d565d6e49fc154926305fcf6100601a298cc223a {\n    font-weight: bold;\n    flex-shrink: 0;\n    margin-right: 4px;\n}\n\n.item-note-364dd75c466d5cbe30232b5aea6c4a84bc40b518 {\n    font-size: 0.8em;\n    color: var(--text-muted-022faf9d53e3d59f9848f2691abf286e5ee97d8e);\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.detail-pane-34aa27f0b608fb8f69c007db534ce96870f96eca {\n    box-shadow: 0px 0px 4px 0px rgba(0, 0, 0, 0.5);\n    border: 1px solid var(--border-color-51631c833743ba2a62500c30df9174e36f9b9673);\n    border-radius: 4px;\n    flex-shrink: 0;\n    padding: 0;\n}\n\n.detail-summary-2bce7072691ec97815d24dd4fbd692422322ddd1 {\n    list-style: none;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    cursor: pointer;\n    padding: 16px;\n}\n\n/* Webkit\u30D6\u30E9\u30A6\u30B6\u306E\u30C7\u30D5\u30A9\u30EB\u30C8\u30DE\u30FC\u30AB\u30FC\u3092\u975E\u8868\u793A\u306B\u3059\u308B */\n.detail-summary-2bce7072691ec97815d24dd4fbd692422322ddd1::-webkit-details-marker {\n    display: none;\n}\n\n/* \u9589\u3058\u305F\u3068\u304D\u306E\u30A2\u30A4\u30B3\u30F3 */\n.detail-summary-2bce7072691ec97815d24dd4fbd692422322ddd1::after {\n    content: "+";\n    font-size: 1.5em;\n    line-height: 1;\n    margin-left: 10px;\n}\n\n/* \u958B\u3044\u305F\u3068\u304D\u306E\u30A2\u30A4\u30B3\u30F3 */\n.detail-pane-34aa27f0b608fb8f69c007db534ce96870f96eca[open] > .detail-summary-2bce7072691ec97815d24dd4fbd692422322ddd1::after {\n    content: "\u2212";\n}\n\n.detail-name-068298090b376b2e49849d1866736a9c17833d13 {\n    flex-grow: 1;\n    font-size: 1.2em;\n    font-weight: bold;\n    margin-bottom: 0;\n}\n\n.detail-description-c585478c67fd2886b55072144a65681cb2110f7d,\n.detail-note-0a41dc9710d7c916f069cfdbfd5f3f890bf15e44,\n.detail-coordinates-1bcea9690df40975a760d07d77861165f2b74873 {\n    margin-bottom: 4px;\n    padding: 0;\n    width: 100%;\n    box-sizing: border-box;\n}\n\n.detail-content-wrapper-dfe140a008e33f532dbc0a6511c731307b56a5b4 {\n    padding: 0 16px 16px 16px;\n    display: flex;\n    flex-wrap: wrap;\n    gap: 8px;\n}\n\n.map-button-908d4aa41c19b78316d582a681067fd5d9c8c515,\n.create-button-3ea22a965c69c8451c019dc09bf6578724443113,\n.delete-button-25c3a2ec4558be37b257180f32e60df742dad553,\n.template-button-9c4bd97db3e61d62a4ece62bbbd83ae975bf4a2c,\n.config-button-fbedbd8bad00446b85fd186f85264068c070686e {\n    margin-top: 8px;\n    padding: 8px 12px;\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n}\n\n.map-button-908d4aa41c19b78316d582a681067fd5d9c8c515,\n.create-button-3ea22a965c69c8451c019dc09bf6578724443113,\n.template-button-9c4bd97db3e61d62a4ece62bbbd83ae975bf4a2c,\n.config-button-fbedbd8bad00446b85fd186f85264068c070686e {\n    background-color: var(--primary-color-68a3ef2f2c6d3344d237a9856025adfe18fd107c);\n}\n\n.map-button-908d4aa41c19b78316d582a681067fd5d9c8c515:hover,\n.create-button-3ea22a965c69c8451c019dc09bf6578724443113:hover,\n.template-button-9c4bd97db3e61d62a4ece62bbbd83ae975bf4a2c:hover,\n.config-button-fbedbd8bad00446b85fd186f85264068c070686e:hover {\n    background-color: var(--primary-color-dark-be35b3b230419a40a8bdc9ef9018e8a06e7d5f66);\n}\n\n.delete-button-25c3a2ec4558be37b257180f32e60df742dad553 {\n    background-color: #dc3545;\n}\n\n.delete-button-25c3a2ec4558be37b257180f32e60df742dad553:hover {\n    background-color: #c82333;\n}\n\n.template-button-9c4bd97db3e61d62a4ece62bbbd83ae975bf4a2c.is-template-a3d4766334eaaa9ff04666eed54ef572d8cd166e {\n    background-color: #28a745;\n}\n\n.template-button-9c4bd97db3e61d62a4ece62bbbd83ae975bf4a2c.is-template-a3d4766334eaaa9ff04666eed54ef572d8cd166e:hover {\n    background-color: #218838;\n}\n\n.input-error-9992f803f35644f2d22186012a38d080999233f3 {\n    border: 1px solid red;\n    background-color: #c82333;\n}\n';
  var draft_list_default = {
    container: "container-bcca77d95a0c238b622ad40e7361a62dc25cd3d3",
    "input-field": "input-field-319235de682839e4738c9ef400f355f6631287b5",
    "input-error": "input-error-9992f803f35644f2d22186012a38d080999233f3",
    "list-container": "list-container-b9ec8abc5ee696908aa8198c1fed3c63294688b3",
    item: "item-53f6e8c2e4ae94556a783051b8d2e0f75243ab80",
    selected: "selected-82f59d7114a0c5666cae0781a1f3b436c4c1d446",
    "item-note": "item-note-364dd75c466d5cbe30232b5aea6c4a84bc40b518",
    "item-name": "item-name-d565d6e49fc154926305fcf6100601a298cc223a",
    "detail-pane": "detail-pane-34aa27f0b608fb8f69c007db534ce96870f96eca",
    "detail-summary": "detail-summary-2bce7072691ec97815d24dd4fbd692422322ddd1",
    "detail-name": "detail-name-068298090b376b2e49849d1866736a9c17833d13",
    "detail-description": "detail-description-c585478c67fd2886b55072144a65681cb2110f7d",
    "detail-note": "detail-note-0a41dc9710d7c916f069cfdbfd5f3f890bf15e44",
    "detail-coordinates": "detail-coordinates-1bcea9690df40975a760d07d77861165f2b74873",
    "detail-content-wrapper": "detail-content-wrapper-dfe140a008e33f532dbc0a6511c731307b56a5b4",
    "map-button": "map-button-908d4aa41c19b78316d582a681067fd5d9c8c515",
    "create-button": "create-button-3ea22a965c69c8451c019dc09bf6578724443113",
    "delete-button": "delete-button-25c3a2ec4558be37b257180f32e60df742dad553",
    "template-button": "template-button-9c4bd97db3e61d62a4ece62bbbd83ae975bf4a2c",
    "config-button": "config-button-fbedbd8bad00446b85fd186f85264068c070686e",
    "is-template": "is-template-a3d4766334eaaa9ff04666eed54ef572d8cd166e"
  };

  // source/drafts-view/virtual-list.module.css
  var cssText5 = ".list-window-bcd08fce6b1a595356880a5a598137912e379aee {\n    height: 100%;\n    overflow: auto;\n}\n\n.list-spacer-32059099ba781e882b7ae69bcd971a9b66d151a8 {\n    box-sizing: border-box;\n    height: var(--list-height-601758becf7d7867f70930534784cc2ddcc8fb22);\n    padding-top: var(--list-offset-top-fcb56bf845280fbeb22cda5501878b68a331e405);\n}\n\n.list-fffb82a022c6017f97dfdac45113ef61fa81fe9c {\n    list-style-type: none;\n    margin: 0;\n    padding: 0;\n}\n\n.item-519dd442a3657bdc57c1e482401f339cee8003a2 {\n    height: var(--item-height-c5da2f0d91ae8c90a7f14e92fce1ba40bfd0b3ec);\n}\n";
  var variables2 = {
    "--list-height": "--list-height-601758becf7d7867f70930534784cc2ddcc8fb22",
    "--list-offset-top": "--list-offset-top-fcb56bf845280fbeb22cda5501878b68a331e405",
    "--item-height": "--item-height-c5da2f0d91ae8c90a7f14e92fce1ba40bfd0b3ec"
  };
  var virtual_list_default = {
    "list-window": "list-window-bcd08fce6b1a595356880a5a598137912e379aee",
    "list-spacer": "list-spacer-32059099ba781e882b7ae69bcd971a9b66d151a8",
    list: "list-fffb82a022c6017f97dfdac45113ef61fa81fe9c",
    item: "item-519dd442a3657bdc57c1e482401f339cee8003a2"
  };

  // source/drafts-view/virtual-list.tsx
  var setStyle4 = styleSetter(cssText5);
  function createEmptyElements() {
    return {
      itemHeight: 0,
      count: 0,
      get() {
        return void 0;
      }
    };
  }
  function createVirtualList() {
    setStyle4();
    const list = /* @__PURE__ */ jsx("ul", { class: virtual_list_default["list"] });
    const listSpacer = /* @__PURE__ */ jsx("div", { class: virtual_list_default["list-spacer"], children: list });
    const listWindow = /* @__PURE__ */ jsx("div", { class: virtual_list_default["list-window"], onscroll: update, children: listSpacer });
    let items = createEmptyElements();
    let redrawRequested = true;
    let lastStart = null;
    let lastCount = null;
    function update() {
      const { scrollTop, offsetHeight: windowHeight } = listWindow;
      const { itemHeight, count: itemCount } = items;
      const start = Math.floor(scrollTop / itemHeight);
      const count = Math.min(
        itemCount,
        Math.ceil((scrollTop + windowHeight) / itemHeight)
      ) - start;
      redrawRequested = redrawRequested || lastStart !== start || lastCount !== count;
      lastStart = start;
      lastCount = count;
      if (!redrawRequested) return;
      redrawRequested = false;
      list.innerHTML = "";
      for (let i = 0; i < count; i++) {
        list.append(
          /* @__PURE__ */ jsx("li", { class: virtual_list_default.item, children: items.get(start + i) })
        );
      }
      listWindow.style.setProperty(
        variables2["--item-height"],
        itemHeight + "px"
      );
      listWindow.style.setProperty(
        variables2["--list-height"],
        itemHeight * itemCount + "px"
      );
      listWindow.style.setProperty(
        variables2["--list-offset-top"],
        start * itemHeight + "px"
      );
    }
    function setItems(newItems) {
      items = newItems;
      redrawRequested = true;
      return update();
    }
    new ResizeObserver((entries) => {
      for (const _ of entries) void update();
    }).observe(listWindow);
    return {
      element: listWindow,
      setItems
    };
  }

  // source/draft.ts
  function setDraftIsTemplate(draft, isTemplate) {
    draft.data["isTemplate"] = isTemplate || void 0;
  }
  function getDraftIsTemplate(draft) {
    return draft.data["isTemplate"] === true;
  }
  function pad2(value) {
    return ("00" + value).slice(-2);
  }
  function getIsoTodayString(date5) {
    const yyyy = date5.getFullYear();
    const mm = pad2(date5.getMonth() + 1);
    const dd = pad2(date5.getDate());
    return `${yyyy}-${mm}-${dd}`;
  }
  function getIsoTimeString(date5) {
    const hours = pad2(date5.getHours());
    const minutes = pad2(date5.getMinutes());
    const seconds = pad2(date5.getSeconds());
    return `${hours}:${minutes}:${seconds}`;
  }
  function getIsoTimeZoneString(date5) {
    const offset = -date5.getTimezoneOffset();
    const sign = offset >= 0 ? "+" : "-";
    const hours = pad2(offset / 60);
    const minutes = pad2(offset % 60);
    return `${sign}${hours}:${minutes}`;
  }
  function getIsoDateTimeString(date5, withTimeZone = false) {
    return `${getIsoTodayString(date5)}T${getIsoTimeString(date5)}${withTimeZone ? getIsoTimeZoneString(date5) : ""}`;
  }
  function resolveStandardVariable(name) {
    switch (name) {
      case "today":
        return getIsoTodayString(/* @__PURE__ */ new Date());
      case "now":
        return getIsoDateTimeString(/* @__PURE__ */ new Date());
      case "nowWithTimeZone":
        return getIsoDateTimeString(/* @__PURE__ */ new Date(), true);
    }
  }
  var interpolationPattern = /\\\(\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)/g;
  function applyTemplate(template, resolve) {
    return template.replace(
      interpolationPattern,
      (interpolation, variableName) => resolve?.(variableName) ?? resolveStandardVariable(variableName) ?? interpolation
    );
  }

  // source/local-config-view/local-config-view.module.css
  var cssText6 = ".container-f1dab241a09bb3df58f56a71a1860677b51f2515 {\n    box-sizing: border-box;\n}\n\n.container-f1dab241a09bb3df58f56a71a1860677b51f2515 {\n    width: 100%;\n    height: 100%;\n    padding: 24px;\n    color: #1f2937;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.form-scroll-2e3ac2fd8bc51e6f171db04ef7d943ff85b90020 {\n    overflow-y: auto;\n    padding-right: 4px;\n    margin-right: -4px;\n    flex: 1 1 auto;\n}\n\n.status-message-c256dff5faa609e9d6ec55dc16d17267529c8bdc {\n    margin-top: auto;\n    font-size: 13px;\n    color: #6b7280;\n    padding-top: 10px;\n    border-radius: 8px;\n    transition:\n        background-color 0.2s ease,\n        color 0.2s ease,\n        border-color 0.2s ease;\n}\n\n.status-message-c256dff5faa609e9d6ec55dc16d17267529c8bdc.success-2e73314ef49e2ec643b73bff4583ac0097498f92 {\n    color: #065f46;\n    background-color: #ecfdf5;\n    border: 1px solid #a7f3d0;\n    padding: 10px 12px;\n}\n\n.status-message-c256dff5faa609e9d6ec55dc16d17267529c8bdc.error-683e02068e71c66e6211aa9a1b8738688ff5ad26 {\n    color: #7f1d1d;\n    background-color: #fef2f2;\n    border: 1px solid #fecaca;\n    padding: 10px 12px;\n}\n";
  var local_config_view_default = {
    container: "container-f1dab241a09bb3df58f56a71a1860677b51f2515",
    "form-scroll": "form-scroll-2e3ac2fd8bc51e6f171db04ef7d943ff85b90020",
    "status-message": "status-message-c256dff5faa609e9d6ec55dc16d17267529c8bdc",
    success: "success-2e73314ef49e2ec643b73bff4583ac0097498f92",
    error: "error-683e02068e71c66e6211aa9a1b8738688ff5ad26"
  };

  // source/local-config-view/item-input.module.css
  var cssText7 = ".form-group-e5a3430126ab0369fd7ee8a6a30580ffad360df7 {\n    width: 100%;\n    margin-bottom: 18px;\n    display: flex;\n    flex-direction: column;\n    flex-shrink: 0;\n}\n\n.form-group-e5a3430126ab0369fd7ee8a6a30580ffad360df7 {\n    width: 100%;\n    margin-bottom: 18px;\n    display: flex;\n    flex-direction: column;\n    flex-shrink: 0;\n}\n\n.label-5d97d2385d3fe4f8201f867470d9a372143c929f {\n    font-size: 13px;\n    font-weight: 500;\n    margin-bottom: 6px;\n    color: #374151;\n}\n\n.input-d67df4267ce56bfa6a39eaade32c4f8c68e12ce0,\n.textarea-f6272e46e885340c7cfafd8e922bfd093e4269d4 {\n    width: 100%;\n    border: 1px solid #e5e7eb;\n    background-color: #ffffff;\n    border-radius: 8px;\n    padding: 10px 12px;\n    font-size: 14px;\n    color: #111827;\n    outline: none;\n    transition:\n        border-color 0.2s ease,\n        box-shadow 0.2s ease;\n}\n\n.input-d67df4267ce56bfa6a39eaade32c4f8c68e12ce0:focus,\n.textarea-f6272e46e885340c7cfafd8e922bfd093e4269d4:focus {\n    border-color: #cbd5e1;\n    box-shadow: 0 0 0 3px rgba(203, 213, 225, 0.35);\n}\n\n.checkbox-40de0e9fd90c64b05aa39b0981eff0ac2c2c3b16 {\n    width: 16px;\n    height: 16px;\n    margin-right: 8px;\n    vertical-align: middle;\n}\n\n.textarea-f6272e46e885340c7cfafd8e922bfd093e4269d4 {\n    min-height: 120px;\n    resize: vertical;\n    line-height: 1.5;\n}\n";
  var item_input_default = {
    "form-group": "form-group-e5a3430126ab0369fd7ee8a6a30580ffad360df7",
    label: "label-5d97d2385d3fe4f8201f867470d9a372143c929f",
    input: "input-d67df4267ce56bfa6a39eaade32c4f8c68e12ce0",
    textarea: "textarea-f6272e46e885340c7cfafd8e922bfd093e4269d4",
    checkbox: "checkbox-40de0e9fd90c64b05aa39b0981eff0ac2c2c3b16"
  };

  // source/local-config-view/item-input-string.tsx
  var setStyle5 = styleSetter(cssText7);
  function createStringItemInput(label) {
    setStyle5();
    const events = createTypedEventTarget();
    const dispatchChanged = () => events.dispatchEvent(createTypedCustomEvent("changed", void 0));
    const input = /* @__PURE__ */ jsx(
      "input",
      {
        type: "text",
        class: item_input_default["input"],
        oninput: dispatchChanged
      }
    );
    const enabledCheckbox = /* @__PURE__ */ jsx(
      "input",
      {
        type: "checkbox",
        class: item_input_default["checkbox"],
        onchange: () => {
          const isChecked = enabledCheckbox.checked;
          input.disabled = !isChecked;
          inputContainer.style.display = isChecked ? "" : "none";
          dispatchChanged();
        }
      }
    );
    const inputContainer = /* @__PURE__ */ jsx("div", { class: item_input_default["form-group"], children: /* @__PURE__ */ jsx("label", { class: item_input_default["label"], children: input }) });
    const element = /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx("div", { class: item_input_default["form-group"], children: /* @__PURE__ */ jsxs("label", { class: item_input_default["label"], children: [
        enabledCheckbox,
        /* @__PURE__ */ jsx("span", { children: label })
      ] }) }),
      inputContainer
    ] });
    function setValue(value) {
      const hasUserId = value !== void 0;
      enabledCheckbox.checked = hasUserId;
      input.disabled = !hasUserId;
      inputContainer.style.display = hasUserId ? "" : "none";
      input.value = hasUserId ? value ?? "" : "";
    }
    function getValue2() {
      if (enabledCheckbox.checked) {
        return input.value;
      }
    }
    return {
      element,
      events,
      setValue,
      getValue: getValue2
    };
  }

  // source/local-config-view/item-input-json.tsx
  var setStyle6 = styleSetter(cssText7);
  function createJsonItemInput(label) {
    setStyle6();
    const events = createTypedEventTarget();
    const dispatchChange = () => events.dispatchEvent(createTypedCustomEvent("changed", void 0));
    const textarea = /* @__PURE__ */ jsx(
      "textarea",
      {
        class: item_input_default["textarea"],
        oninput: dispatchChange
      }
    );
    const enabledCheckbox = /* @__PURE__ */ jsx(
      "input",
      {
        type: "checkbox",
        class: item_input_default["checkbox"],
        onchange: () => {
          const isChecked = enabledCheckbox.checked;
          textarea.disabled = !isChecked;
          inputContainer.style.display = isChecked ? "" : "none";
          dispatchChange();
        }
      }
    );
    const inputContainer = /* @__PURE__ */ jsx("div", { class: item_input_default["form-group"], children: /* @__PURE__ */ jsx("label", { class: item_input_default["label"], children: textarea }) });
    const element = /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx("div", { class: item_input_default["form-group"], children: /* @__PURE__ */ jsxs("label", { class: item_input_default["label"], children: [
        enabledCheckbox,
        /* @__PURE__ */ jsx("span", { children: label })
      ] }) }),
      inputContainer
    ] });
    function setValue(value) {
      const hasValue = value !== void 0;
      enabledCheckbox.checked = hasValue;
      textarea.disabled = !hasValue;
      inputContainer.style.display = hasValue ? "" : "none";
      textarea.value = hasValue ? JSON.stringify(value, null, 2) : "";
    }
    function getValue2() {
      if (enabledCheckbox.checked) {
        try {
          const parsedJson = JSON.parse(textarea.value);
          return parsedJson;
        } catch {
          throw new Error("Invalid JSON. Please check the syntax.");
        }
      }
    }
    return {
      element,
      events,
      setValue,
      getValue: getValue2
    };
  }

  // source/local-config-view/local-config-view.tsx
  var setStyle7 = styleSetter(cssText6);
  function debounce(f, ms) {
    let timeout;
    const debounced = (...args) => {
      if (timeout !== void 0) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(() => {
        timeout = void 0;
        f(...args);
      }, ms);
    };
    const cancel = () => {
      if (timeout !== void 0) {
        clearTimeout(timeout);
        timeout = void 0;
      }
    };
    return {
      debounced,
      cancel
    };
  }
  function createLocalConfigView(configAccessor) {
    setStyle7();
    const userIdInput = createStringItemInput("User ID");
    const apiRootInput = createStringItemInput("API Root");
    const dictionariesInput = createJsonItemInput("Dictionaries(JSON)");
    const statusMessageElement = /* @__PURE__ */ jsx("div", { class: local_config_view_default["status-message"], children: "Loading configuration..." });
    const element = /* @__PURE__ */ jsxs("div", { class: local_config_view_default["container"], children: [
      /* @__PURE__ */ jsxs("div", { class: local_config_view_default["form-scroll"], children: [
        userIdInput.element,
        apiRootInput.element,
        dictionariesInput.element
      ] }),
      statusMessageElement
    ] });
    const loadConfig = () => {
      const currentConfig = configAccessor.getConfig();
      userIdInput.setValue(currentConfig.userId);
      apiRootInput.setValue(currentConfig.apiRoot);
      dictionariesInput.setValue(currentConfig.dictionaries);
    };
    const { debounced: saveConfig } = debounce(() => {
      statusMessageElement.textContent = "Changes pending...";
      statusMessageElement.className = local_config_view_default["status-message"];
      try {
        let newConfig = configAccessor.getConfig();
        newConfig = { ...newConfig, userId: userIdInput.getValue() };
        newConfig = { ...newConfig, apiRoot: apiRootInput.getValue() };
        newConfig = {
          ...newConfig,
          dictionaries: dictionariesInput.getValue()
        };
        ConfigSchema.parse(newConfig);
        configAccessor.setConfig(newConfig);
        statusMessageElement.textContent = "Saved successfully!";
        statusMessageElement.classList.add(local_config_view_default.success);
      } catch (error48) {
        let errorMessage = "Unknown error";
        if (error48 instanceof Error) {
          errorMessage = error48.message;
        }
        statusMessageElement.textContent = `Error saving configuration: ${errorMessage}`;
        statusMessageElement.classList.add(local_config_view_default.error);
      }
    }, 500);
    userIdInput.events.addEventListener("changed", saveConfig);
    apiRootInput.events.addEventListener("changed", saveConfig);
    dictionariesInput.events.addEventListener("changed", saveConfig);
    loadConfig();
    return {
      element
    };
  }

  // source/drafts-view/query-view/filter-bar.module.css
  var cssText8 = ".wrapper-1127d7f98522db31ea6e2d9ebde2e6f989e09c50 {\n    display: flex;\n    align-items: center;\n    border-radius: 14px;\n    box-shadow: 0 4px 14px rgba(0, 0, 0, 0.08);\n    padding: 6px 8px 6px 14px;\n    transition:\n        box-shadow 0.2s ease,\n        transform 0.15s ease;\n}\n\n.wrapper-1127d7f98522db31ea6e2d9ebde2e6f989e09c50:focus-within {\n    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);\n    background: #ffffff;\n    transform: translateY(-1px);\n}\n\n.input-c8987b531e2f53a0aa08ad6c358fe761a37a7e68 {\n    flex: 1;\n    border: none;\n    outline: none;\n    font-size: 15px;\n    padding: 10px 8px;\n    background: transparent;\n}\n\n.input-c8987b531e2f53a0aa08ad6c358fe761a37a7e68::placeholder {\n    color: #9aa0a6;\n}\n\n.buttons-db006727adfac2106ebab10ff34478280c4d1409 {\n    display: flex;\n    gap: 6px;\n}\n\n.button-503025e02322df0b9123077f2cf5d579b81f603f {\n    border: none;\n    background: #f1f3f4;\n    border-radius: 10px;\n    padding: 8px 10px;\n    cursor: pointer;\n    font-size: 16px;\n    transition:\n        background 0.2s ease,\n        transform 0.1s ease;\n}\n\n.button-503025e02322df0b9123077f2cf5d579b81f603f:hover {\n    background: #e3e6e8;\n}\n\n.button-503025e02322df0b9123077f2cf5d579b81f603f:active {\n    transform: scale(0.96);\n}\n\n.multi-line-indicator-fae52819e070d6d15651ab1f5fbb63ada4c2a5f3 {\n    margin-left: 5px;\n    font-weight: bold;\n    color: #888;\n}\n\n.hidden-d10c12e79073622c37eb2546648b946ac2b6b7a8 {\n    display: none;\n}";
  var filter_bar_default = {
    wrapper: "wrapper-1127d7f98522db31ea6e2d9ebde2e6f989e09c50",
    input: "input-c8987b531e2f53a0aa08ad6c358fe761a37a7e68",
    buttons: "buttons-db006727adfac2106ebab10ff34478280c4d1409",
    button: "button-503025e02322df0b9123077f2cf5d579b81f603f",
    "multi-line-indicator": "multi-line-indicator-fae52819e070d6d15651ab1f5fbb63ada4c2a5f3",
    hidden: "hidden-d10c12e79073622c37eb2546648b946ac2b6b7a8"
  };

  // source/drafts-view/query-view/filter-bar.tsx
  var setStyle8 = styleSetter(cssText8);
  function createFilterBar({ value: initialValue }) {
    setStyle8();
    const events = createTypedEventTarget();
    const input = /* @__PURE__ */ jsx(
      "input",
      {
        type: "text",
        oninput: () => events.dispatchEvent(
          createTypedCustomEvent("input-changed", void 0)
        ),
        classList: [filter_bar_default.input],
        placeholder: "\u{1F50D}\u30AD\u30FC\u30EF\u30FC\u30C9\u3067\u7D5E\u308A\u8FBC\u307F\u2026"
      }
    );
    const multiLineIndicator = /* @__PURE__ */ jsx(
      "span",
      {
        classList: [
          filter_bar_default["multi-line-indicator"],
          filter_bar_default["hidden"]
        ],
        children: "..."
      }
    );
    const element = /* @__PURE__ */ jsxs("div", { classList: [filter_bar_default.wrapper], children: [
      input,
      multiLineIndicator,
      /* @__PURE__ */ jsxs("div", { class: filter_bar_default.buttons, children: [
        /* @__PURE__ */ jsx(
          "button",
          {
            class: filter_bar_default.button,
            onclick: () => {
              events.dispatchEvent(
                createTypedCustomEvent(
                  "click-list-button",
                  void 0
                )
              );
            },
            "aria-label": "\u691C\u7D22\u5F0F\u4E00\u89A7",
            children: "\u{1F4C2}"
          }
        ),
        /* @__PURE__ */ jsx(
          "button",
          {
            class: filter_bar_default.button,
            onclick: () => {
              events.dispatchEvent(
                createTypedCustomEvent(
                  "click-edit-button",
                  void 0
                )
              );
            },
            "aria-label": "\u691C\u7D22\u5F0F\u3092\u7DE8\u96C6",
            children: "\u270F"
          }
        )
      ] })
    ] });
    let value = "";
    function getValue2() {
      const index = value.indexOf("\n");
      if (index < 0) return input.value;
      return input.value + "\n" + value.slice(index + 1);
    }
    function setValue(newValue) {
      value = newValue;
      const isMultiLine = newValue.includes("\n");
      if (isMultiLine) {
        multiLineIndicator.classList.remove(filter_bar_default["hidden"]);
      } else {
        multiLineIndicator.classList.add(filter_bar_default["hidden"]);
      }
      input.value = newValue?.split("\n")[0] ?? "";
    }
    setValue(initialValue);
    return { element, events, getValue: getValue2, setValue };
  }

  // source/drafts-view/query-view/source-list.module.css
  var cssText9 = ".wrapper-12ea3675915522e27cfe3356addfb9ac5a8e4fe2 {\r\n    flex: 1;\r\n    display: flex;\r\n    flex-direction: column;\r\n    height: 100%;\r\n}\r\n\r\n.item-6f81a84ee10d38ca107998be1d9a5cf01d0eed91 {\r\n    height: 100%;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: space-between;\r\n    padding: 12px 14px;\r\n    border-radius: 12px;\r\n    cursor: pointer;\r\n    user-select: none;\r\n    transition:\r\n        background 0.15s ease,\r\n        transform 0.05s ease;\r\n    font-size: 14px;\r\n}\r\n\r\n.item-6f81a84ee10d38ca107998be1d9a5cf01d0eed91:hover {\r\n    background: #f1f3f4;\r\n}\r\n\r\n.item-6f81a84ee10d38ca107998be1d9a5cf01d0eed91.active-5cfd7acb0e1f0f2c1ae1509ff7114f29aecf222b {\r\n    background: #e8f0fe;\r\n    font-weight: 600;\r\n}\r\n\r\n.item-6f81a84ee10d38ca107998be1d9a5cf01d0eed91:active {\r\n    transform: scale(0.98);\r\n}\r\n\r\n.item-label-aa6d3639738d866205ef3f6db063315d6b23659f {\r\n    pointer-events: none;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    white-space: nowrap;\r\n}\r\n\r\n.delete-button-04b39470f8b9cde6122641ba127dae02e389ce94 {\r\n    display: none;\r\n    border: none;\r\n    background: #ffdede;\r\n    color: #b00020;\r\n    border-radius: 8px;\r\n    padding: 4px 8px;\r\n    font-size: 12px;\r\n    cursor: pointer;\r\n}\r\n\r\n.item-6f81a84ee10d38ca107998be1d9a5cf01d0eed91.active-5cfd7acb0e1f0f2c1ae1509ff7114f29aecf222b .delete-button-04b39470f8b9cde6122641ba127dae02e389ce94 {\r\n    display: inline-block;\r\n}\r\n\r\n.add-button-a69146193c33e23bae778ebbed5c56d136253b50 {\r\n    margin-top: 10px;\r\n    border: none;\r\n    background: #f1f3f4;\r\n    border-radius: 12px;\r\n    padding: 12px;\r\n    cursor: pointer;\r\n    font-size: 14px;\r\n    transition:\r\n        background 0.2s ease,\r\n        transform 0.1s ease;\r\n    flex-shrink: 0;\r\n}\r\n\r\n.add-button-a69146193c33e23bae778ebbed5c56d136253b50:hover {\r\n    background: #e3e6e8;\r\n}\r\n\r\n.add-button-a69146193c33e23bae778ebbed5c56d136253b50:active {\r\n    transform: scale(0.97);\r\n}\r\n";
  var source_list_default = {
    wrapper: "wrapper-12ea3675915522e27cfe3356addfb9ac5a8e4fe2",
    item: "item-6f81a84ee10d38ca107998be1d9a5cf01d0eed91",
    active: "active-5cfd7acb0e1f0f2c1ae1509ff7114f29aecf222b",
    "item-label": "item-label-aa6d3639738d866205ef3f6db063315d6b23659f",
    "delete-button": "delete-button-04b39470f8b9cde6122641ba127dae02e389ce94",
    "add-button": "add-button-a69146193c33e23bae778ebbed5c56d136253b50"
  };

  // source/drafts-view/query-view/source-list.tsx
  var setStyle9 = styleSetter(cssText9);
  function createSourceList({
    initialList
  }) {
    setStyle9();
    const events = createTypedEventTarget();
    const list = createVirtualList();
    const element = /* @__PURE__ */ jsxs("div", { class: source_list_default.wrapper, children: [
      list.element,
      /* @__PURE__ */ jsx(
        "button",
        {
          class: source_list_default["add-button"],
          onclick: () => events.dispatchEvent(
            createTypedCustomEvent("add", void 0)
          ),
          children: "\uFF0B \u9805\u76EE\u3092\u8FFD\u52A0"
        }
      )
    ] });
    function createListItem(sources, index) {
      const contents = sources.sources[index]?.contents;
      if (contents == null) return;
      const classList = [source_list_default.item];
      if (sources.selectedIndex === index) {
        classList.push(source_list_default.active);
      }
      return /* @__PURE__ */ jsxs(
        "div",
        {
          classList,
          onclick: () => {
            events.dispatchEvent(
              createTypedCustomEvent("select", index)
            );
          },
          children: [
            /* @__PURE__ */ jsx("span", { class: source_list_default["item-label"], children: contents === "" ? "<empty>" : contents }),
            /* @__PURE__ */ jsx(
              "button",
              {
                class: source_list_default["delete-button"],
                onclick: (e) => {
                  events.dispatchEvent(
                    createTypedCustomEvent("delete", index)
                  );
                  e.stopPropagation();
                },
                children: "\u524A\u9664"
              }
            )
          ]
        }
      );
    }
    function setSources(sources) {
      list.setItems({
        itemHeight: 52,
        count: sources.sources.length,
        get(index) {
          return createListItem(sources, index);
        }
      });
    }
    setSources(initialList);
    return {
      element,
      events,
      setSources
    };
  }

  // source/sal/effective.ts
  function* done(x) {
    return x;
  }
  var EffectiveRequest = class {
  };
  var AwaitPromiseRequest = class extends EffectiveRequest {
    constructor(promise2) {
      super();
      this.promise = promise2;
    }
  };
  function* awaitPromise(promise2) {
    return yield new AwaitPromiseRequest(promise2);
  }
  var privateGetAbortSignalSymbol = /* @__PURE__ */ Symbol("privateGetAbortSignal");
  function* getCancel() {
    return yield privateGetAbortSignalSymbol;
  }
  async function forceAsPromise(g, signal) {
    let nextInput = void 0;
    let nextResult;
    for (; nextResult = g.next(nextInput), !nextResult.done; ) {
      const nextOutput = nextResult.value;
      if (nextOutput === privateGetAbortSignalSymbol) {
        nextInput = signal;
        continue;
      }
      if (nextOutput instanceof AwaitPromiseRequest) {
        nextInput = await nextOutput.promise;
        continue;
      }
      return raise`unknown effect: ${nextOutput}`;
    }
    return nextResult.value;
  }

  // source/query/standard-queries.ts
  function buildDraftMap(drafts) {
    const cell14s = /* @__PURE__ */ new Map();
    for (const draft of drafts) {
      const p = draft.coordinates[0];
      const cell14 = createCellFromCoordinates(p, 14);
      const cell14Id = cell14.toString();
      let cell17Drafts = cell14s.get(cell14Id)?.cell17Drafts;
      if (cell17Drafts == null) {
        cell14s.set(cell14Id, {
          cell14,
          cell17Drafts: cell17Drafts = /* @__PURE__ */ new Set()
        });
      }
      cell17Drafts.add(getCellId(p, 17));
    }
    return cell14s;
  }
  function hasTermInString(text, term) {
    return text.toLowerCase().includes(term);
  }
  function hasTermInDraft({ name, description, note }, term) {
    return hasTermInString(name, term) || hasTermInString(description, term) || hasTermInString(note, term);
  }
  function queryAsBuilder(query) {
    return {
      isIgnorable: false,
      initialize() {
        return done(query);
      }
    };
  }
  function builderAsValue(builder) {
    return builder;
  }
  function valueAsBuilder(v) {
    return v;
  }
  function stringTermQuery(text) {
    return builderAsValue({
      isIgnorable: false,
      initialize() {
        const term = text.toLocaleLowerCase();
        return done({
          isVisible(d) {
            return done(hasTermInDraft(d, term));
          }
        });
      }
    });
  }
  function any3() {
    return builderAsValue(
      queryAsBuilder({
        isVisible() {
          return done(true);
        }
      })
    );
  }
  function not(b) {
    if (b.isIgnorable) return builderAsValue(b);
    return builderAsValue({
      isIgnorable: false,
      *initialize(e) {
        const q = yield* b.initialize(e);
        return {
          *isVisible(d) {
            return !(yield* q.isVisible(d));
          },
          isAny: false
        };
      }
    });
  }
  function fromString(x) {
    return done(stringTermQuery(String(x)));
  }
  function and(b1, b2) {
    if (b2.isIgnorable) return b1;
    if (b1.isIgnorable) return b2;
    return {
      isIgnorable: false,
      *initialize(e) {
        const q1 = yield* b1.initialize(e);
        const q2 = yield* b2.initialize(e);
        return {
          *isVisible(draft) {
            return (yield* q1.isVisible(draft)) && (yield* q2.isVisible(draft));
          }
        };
      }
    };
  }
  function or(b1, b2) {
    if (b2.isIgnorable) return b1;
    if (b1.isIgnorable) return b2;
    return {
      isIgnorable: false,
      *initialize(e) {
        const q1 = yield* b1.initialize(e);
        const q2 = yield* b2.initialize(e);
        return {
          *isVisible(d) {
            return (yield* q1.isVisible(d)) || (yield* q2.isVisible(d));
          }
        };
      }
    };
  }
  function reachableWith(center, radius) {
    return {
      isIgnorable: false,
      initialize() {
        const p1 = { lat: center[0], lng: center[1] };
        return done({
          isVisible(d) {
            const [p2] = d.coordinates;
            return done(distance(p1, p2) <= radius);
          }
        });
      }
    };
  }
  function builderOfPredicate(predicate) {
    return {
      isIgnorable: false,
      initialize(e) {
        return done({
          isVisible(d) {
            return predicate(e, d);
          }
        });
      }
    };
  }
  function* getFreshCell17(e, d) {
    const minFetchDate = yield* e.getMinFreshDate();
    const stat17 = yield* e.getCell17Stat(d);
    if (stat17 == null || stat17.lastFetchDate == null || stat17.lastFetchDate < minFetchDate) {
      return;
    }
    return stat17;
  }
  function builderOfCellPredicate(predicate) {
    return {
      isIgnorable: false,
      initialize(e) {
        return done({
          *isVisible(d) {
            const stat17 = yield* getFreshCell17(e, d);
            if (stat17 == null) return true;
            const stat14 = yield* e.getCell14Stat(d);
            if (stat14 == null) return true;
            return predicate(stat14, stat17, d);
          }
        });
      }
    };
  }
  function hasPokestopOrGymInCell17() {
    return builderOfPredicate(function* (e, d) {
      const stat17 = yield* getFreshCell17(e, d);
      if (stat17 == null) return true;
      const count = (stat17.kindToCount.get("GYM") ?? 0) + (stat17.kindToCount.get("POKESTOP") ?? 0);
      return 0 < count;
    });
  }
  var gymThresholds = Object.freeze([2, 6, 20]);
  function getGymCount(stopCount) {
    for (let i = 0; i < gymThresholds.length; i++) {
      const threshold = gymThresholds[i];
      if (stopCount < threshold) {
        return i;
      }
    }
    return gymThresholds.length;
  }
  function getPokestopCountForNextGym(current) {
    let next = Infinity;
    for (const threshold of gymThresholds) {
      if (current < threshold) {
        next = threshold;
        break;
      }
    }
    return next - current;
  }
  function stopsForNextGym(expectedCount) {
    return builderOfPredicate(function* (e, d) {
      const stat14 = yield* e.getCell14Stat(d);
      if (stat14 == null) return true;
      const gymCount = stat14.kindToPois.get("GYM")?.length ?? 0;
      const pokestopCount = stat14.kindToPois.get("POKESTOP")?.length ?? 0;
      const stopCount = gymCount + pokestopCount;
      const draftStat14 = yield* e.getCell14DraftStat(d);
      if (draftStat14 == null) return true;
      return (
        // 
        getPokestopCountForNextGym(stopCount) === expectedCount && // 
        expectedCount <= draftStat14.potentialStops && // 
        getGymCount(stopCount) === gymCount
      );
    });
  }
  function cell14Stops(expectedCount) {
    return builderOfCellPredicate((stat14, _stat17) => {
      return stat14.pois.size === expectedCount;
    });
  }
  function binaryBuilder(f) {
    return (x) => {
      return done((y) => {
        const b = f(valueAsBuilder(x), valueAsBuilder(y));
        return done(builderAsValue(b));
      });
    };
  }
  function binaryFunction(f) {
    return (x) => done((y) => done(f(x, y)));
  }
  function createStandardQueries() {
    const all = any3();
    const ignorableAll = builderAsValue({
      isIgnorable: true,
      initialize() {
        return done({
          isVisible() {
            return done(true);
          }
        });
      }
    });
    const seq = binaryBuilder(and);
    const duplicated = builderAsValue(hasPokestopOrGymInCell17());
    const dict = {
      fromVoid(_) {
        return done(all);
      },
      fromMissing(_) {
        return done(ignorableAll);
      },
      fromNumber(x) {
        return done(stringTermQuery(String(x)));
      },
      fromString,
      fromWord: fromString,
      not_(x) {
        return done(not(valueAsBuilder(x)));
      },
      _seq_: seq,
      _and_: seq,
      _or_: binaryBuilder(or),
      reachableWith: binaryFunction((center, distanceMeter) => {
        return builderAsValue(
          reachableWith(
            center,
            distanceMeter
          )
        );
      }),
      duplicated,
      hasStopInCell17: duplicated,
      stopsForNextGym(x) {
        return done(builderAsValue(stopsForNextGym(x)));
      },
      cell14Stops(x) {
        return done(builderAsValue(cell14Stops(x)));
      }
    };
    return new Map(Object.entries(dict));
  }

  // source/sal/evaluator.ts
  var import_antlr4ts = __toESM(require_antlr4ts());

  // source/sal/.antlr-generated/SalLexer.ts
  var import_ATNDeserializer = __toESM(require_ATNDeserializer());
  var import_Lexer = __toESM(require_Lexer());
  var import_LexerATNSimulator = __toESM(require_LexerATNSimulator());
  var import_VocabularyImpl = __toESM(require_VocabularyImpl());
  var Utils = __toESM(require_Utils());
  var SalLexer = class _SalLexer extends import_Lexer.Lexer {
    static {
      this.T__0 = 1;
    }
    static {
      this.T__1 = 2;
    }
    static {
      this.T__2 = 3;
    }
    static {
      this.T__3 = 4;
    }
    static {
      this.T__4 = 5;
    }
    static {
      this.OR = 6;
    }
    static {
      this.AND = 7;
    }
    static {
      this.WHERE = 8;
    }
    static {
      this.FUNCTION = 9;
    }
    static {
      this.PAREN_BEGIN = 10;
    }
    static {
      this.PAREN_END = 11;
    }
    static {
      this.COLON = 12;
    }
    static {
      this.SLASH = 13;
    }
    static {
      this.AT = 14;
    }
    static {
      this.MINUS = 15;
    }
    static {
      this.EQUALS = 16;
    }
    static {
      this.NUMBER = 17;
    }
    static {
      this.STRING = 18;
    }
    static {
      this.WORD = 19;
    }
    static {
      this.LINE_COMMENT = 20;
    }
    static {
      this.BLOCK_COMMENT = 21;
    }
    static {
      this.WS = 22;
    }
    static {
      // tslint:disable:no-trailing-whitespace
      this.channelNames = [
        "DEFAULT_TOKEN_CHANNEL",
        "HIDDEN"
      ];
    }
    static {
      // tslint:disable:no-trailing-whitespace
      this.modeNames = [
        "DEFAULT_MODE"
      ];
    }
    static {
      this.ruleNames = [
        "T__0",
        "T__1",
        "T__2",
        "T__3",
        "T__4",
        "OR",
        "AND",
        "WHERE",
        "FUNCTION",
        "PAREN_BEGIN",
        "PAREN_END",
        "COLON",
        "SLASH",
        "AT",
        "MINUS",
        "EQUALS",
        "NUMBER",
        "STRING",
        "WORD_START",
        "WORD_PART",
        "WORD",
        "LINE_COMMENT",
        "BLOCK_COMMENT",
        "WS"
      ];
    }
    static {
      this._LITERAL_NAMES = [
        void 0,
        "'['",
        "','",
        "']'",
        "'{'",
        "'}'",
        "'or'",
        "'and'",
        "'where'",
        void 0,
        "'('",
        "')'",
        "':'",
        "'/'",
        "'@'",
        "'-'",
        "'='"
      ];
    }
    static {
      this._SYMBOLIC_NAMES = [
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        "OR",
        "AND",
        "WHERE",
        "FUNCTION",
        "PAREN_BEGIN",
        "PAREN_END",
        "COLON",
        "SLASH",
        "AT",
        "MINUS",
        "EQUALS",
        "NUMBER",
        "STRING",
        "WORD",
        "LINE_COMMENT",
        "BLOCK_COMMENT",
        "WS"
      ];
    }
    static {
      this.VOCABULARY = new import_VocabularyImpl.VocabularyImpl(_SalLexer._LITERAL_NAMES, _SalLexer._SYMBOLIC_NAMES, []);
    }
    // @Override
    // @NotNull
    get vocabulary() {
      return _SalLexer.VOCABULARY;
    }
    // tslint:enable:no-trailing-whitespace
    constructor(input) {
      super(input);
      this._interp = new import_LexerATNSimulator.LexerATNSimulator(_SalLexer._ATN, this);
    }
    // @Override
    get grammarFileName() {
      return "Sal.g4";
    }
    // @Override
    get ruleNames() {
      return _SalLexer.ruleNames;
    }
    // @Override
    get serializedATN() {
      return _SalLexer._serializedATN;
    }
    // @Override
    get channelNames() {
      return _SalLexer.channelNames;
    }
    // @Override
    get modeNames() {
      return _SalLexer.modeNames;
    }
    static {
      this._serializedATNSegments = 2;
    }
    static {
      this._serializedATNSegment0 = '\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\xB8\b					\x07	\x07\b	\b			\n	\n\v	\v\f	\f\r	\r												\x07\x07\x07\b\b\b\b						\n\n\n\n\n\n\n\n\n\n\nU\n\n\v\v\f\f\r\rf\ni\n\rjo\n\rps\nw\nz\n\r{~\n\x07\x84\n\f\x87\v\x8F\n\x07\x93\n\f\x96\v\x07\x9C\n\f\x9F\v\x07\xA8\n\f\xAB\v\xB3\n\r\xB4\xA9\x07	\v\x07\r\b	\n\v\f\r\x1B!#%\')+-/1\x072;GGgg$$^^))/0\f\f\u028D"$$)+.1<@BB]]__}}\x7F\x7F\x81\xA2\xAF\xAF\u037A\u037B\u0382\u0385\u038D\u038D\u038F\u038F\u03A4\u03A4\u0532\u0532\u0559\u055A\u0562\u0562\u058A\u058A\u058D\u058E\u0592\u0592\u05CA\u05D1\u05ED\u05F1\u05F7\u0607\u061E\u061F\u06DF\u06DF\u0710\u0711\u074D\u074E\u07B4\u07C1\u07FD\u0801\u0830\u0831\u0841\u0841\u085E\u085F\u0861\u08A1\u08B7\u08B7\u08C0\u08D5\u08E4\u08E4\u0986\u0986\u098F\u0990\u0993\u0994\u09AB\u09AB\u09B3\u09B3\u09B5\u09B7\u09BC\u09BD\u09C7\u09C8\u09CB\u09CC\u09D1\u09D8\u09DA\u09DD\u09E0\u09E0\u09E6\u09E7\u09FE\u0A02\u0A06\u0A06\u0A0D\u0A10\u0A13\u0A14\u0A2B\u0A2B\u0A33\u0A33\u0A36\u0A36\u0A39\u0A39\u0A3C\u0A3D\u0A3F\u0A3F\u0A45\u0A48\u0A4B\u0A4C\u0A50\u0A52\u0A54\u0A5A\u0A5F\u0A5F\u0A61\u0A67\u0A78\u0A82\u0A86\u0A86\u0A90\u0A90\u0A94\u0A94\u0AAB\u0AAB\u0AB3\u0AB3\u0AB6\u0AB6\u0ABC\u0ABD\u0AC8\u0AC8\u0ACC\u0ACC\u0AD0\u0AD1\u0AD3\u0AE1\u0AE6\u0AE7\u0AF4\u0AFA\u0AFC\u0B02\u0B06\u0B06\u0B0F\u0B10\u0B13\u0B14\u0B2B\u0B2B\u0B33\u0B33\u0B36\u0B36\u0B3C\u0B3D\u0B47\u0B48\u0B4B\u0B4C\u0B50\u0B57\u0B5A\u0B5D\u0B60\u0B60\u0B66\u0B67\u0B7A\u0B83\u0B86\u0B86\u0B8D\u0B8F\u0B93\u0B93\u0B98\u0B9A\u0B9D\u0B9D\u0B9F\u0B9F\u0BA2\u0BA4\u0BA7\u0BA9\u0BAD\u0BAF\u0BBC\u0BBF\u0BC5\u0BC7\u0BCB\u0BCB\u0BD0\u0BD1\u0BD3\u0BD8\u0BDA\u0BE7\u0BFD\u0C01\u0C06\u0C06\u0C0F\u0C0F\u0C13\u0C13\u0C2B\u0C2B\u0C3C\u0C3E\u0C47\u0C47\u0C4B\u0C4B\u0C50\u0C56\u0C59\u0C59\u0C5D\u0C61\u0C66\u0C67\u0C72\u0C79\u0C86\u0C86\u0C8F\u0C8F\u0C93\u0C93\u0CAB\u0CAB\u0CB6\u0CB6\u0CBC\u0CBD\u0CC7\u0CC7\u0CCB\u0CCB\u0CD0\u0CD6\u0CD9\u0CDF\u0CE1\u0CE1\u0CE6\u0CE7\u0CF2\u0CF2\u0CF5\u0D02\u0D06\u0D06\u0D0F\u0D0F\u0D13\u0D13\u0D3D\u0D3E\u0D47\u0D47\u0D4B\u0D4B\u0D52\u0D55\u0D66\u0D67\u0D82\u0D83\u0D86\u0D86\u0D99\u0D9B\u0DB4\u0DB4\u0DBE\u0DBE\u0DC0\u0DC1\u0DC9\u0DCB\u0DCD\u0DD0\u0DD7\u0DD7\u0DD9\u0DD9\u0DE2\u0DE7\u0DF2\u0DF3\u0DF7\u0E02\u0E3D\u0E40\u0E5E\u0E82\u0E85\u0E85\u0E87\u0E88\u0E8B\u0E8B\u0E8D\u0E8E\u0E90\u0E95\u0E9A\u0E9A\u0EA2\u0EA2\u0EA6\u0EA6\u0EA8\u0EA8\u0EAA\u0EAB\u0EAE\u0EAE\u0EBC\u0EBC\u0EC0\u0EC1\u0EC7\u0EC7\u0EC9\u0EC9\u0ED0\u0ED1\u0EDC\u0EDD\u0EE2\u0F01\u0F4A\u0F4A\u0F6F\u0F72\u0F9A\u0F9A\u0FBF\u0FBF\u0FCF\u0FCF\u0FDD\u1001\u10C8\u10C8\u10CA\u10CE\u10D0\u10D1\u124B\u124B\u1250\u1251\u1259\u1259\u125B\u125B\u1260\u1261\u128B\u128B\u1290\u1291\u12B3\u12B3\u12B8\u12B9\u12C1\u12C1\u12C3\u12C3\u12C8\u12C9\u12D9\u12D9\u1313\u1313\u1318\u1319\u135D\u135E\u137F\u1381\u139C\u13A1\u13F8\u13F9\u1400\u1401\u1682\u1682\u169F\u16A1\u16FB\u1701\u170F\u170F\u1717\u1721\u1739\u1741\u1756\u1761\u176F\u176F\u1773\u1773\u1776\u1781\u17E0\u17E1\u17EC\u17F1\u17FC\u1801\u1810\u1811\u181C\u1821\u187A\u1881\u18AD\u18B1\u18F8\u1901\u1921\u1921\u192E\u1931\u193E\u1941\u1943\u1945\u1970\u1971\u1977\u1981\u19AE\u19B1\u19CC\u19D1\u19DD\u19DF\u1A1E\u1A1F\u1A61\u1A61\u1A7F\u1A80\u1A8C\u1A91\u1A9C\u1AA1\u1AB0\u1AB1\u1AC1\u1B01\u1B4E\u1B51\u1B7F\u1B81\u1BF6\u1BFD\u1C3A\u1C3C\u1C4C\u1C4E\u1C8B\u1CC1\u1CCA\u1CD1\u1CF9\u1CF9\u1CFC\u1D01\u1DF8\u1DFC\u1F18\u1F19\u1F20\u1F21\u1F48\u1F49\u1F50\u1F51\u1F5A\u1F5A\u1F5C\u1F5C\u1F5E\u1F5E\u1F60\u1F60\u1F80\u1F81\u1FB7\u1FB7\u1FC7\u1FC7\u1FD6\u1FD7\u1FDE\u1FDE\u1FF2\u1FF3\u1FF7\u1FF7\u2001\u2011\u202A\u2031\u2061\u2071\u2074\u2075\u2091\u2091\u209F\u20A1\u20C1\u20D1\u20F3\u2101\u218E\u2191\u2401\u2401\u2429\u2441\u244D\u2461\u2B76\u2B77\u2B98\u2B99\u2BBC\u2BBE\u2BCB\u2BCB\u2BD4\u2BED\u2BF2\u2C01\u2C31\u2C31\u2C61\u2C61\u2CF6\u2CFA\u2D28\u2D28\u2D2A\u2D2E\u2D30\u2D31\u2D6A\u2D70\u2D73\u2D80\u2D99\u2DA1\u2DA9\u2DA9\u2DB1\u2DB1\u2DB9\u2DB9\u2DC1\u2DC1\u2DC9\u2DC9\u2DD1\u2DD1\u2DD9\u2DD9\u2DE1\u2DE1\u2E47\u2E81\u2E9C\u2E9C\u2EF6\u2F01\u2FD8\u2FF1\u2FFE\u3002\u3042\u3042\u3099\u309A\u3102\u3106\u3130\u3132\u3191\u3191\u31BD\u31C1\u31E6\u31F1\u3221\u3221\u3301\u3301\u4DB8\u4DC1\u9FD8\uA001\uA48F\uA491\uA4C9\uA4D1\uA62E\uA641\uA6FA\uA701\uA7B1\uA7B1\uA7BA\uA7F8\uA82E\uA831\uA83C\uA841\uA87A\uA881\uA8C8\uA8CF\uA8DC\uA8E1\uA900\uA901\uA956\uA960\uA97F\uA981\uA9D0\uA9D0\uA9DC\uA9DF\uAA01\uAA01\uAA39\uAA41\uAA50\uAA51\uAA5C\uAA5D\uAAC5\uAADC\uAAF9\uAB02\uAB09\uAB0A\uAB11\uAB12\uAB19\uAB21\uAB29\uAB29\uAB31\uAB31\uAB68\uAB71\uABF0\uABF1\uABFC\uAC01\uD7A6\uD7B1\uD7C9\uD7CC\uD7FE\uF901\uFA70\uFA71\uFADC\uFB01\uFB09\uFB14\uFB1A\uFB1E\uFB39\uFB39\uFB3F\uFB3F\uFB41\uFB41\uFB44\uFB44\uFB47\uFB47\uFBC4\uFBD4\uFD42\uFD51\uFD92\uFD93\uFDCA\uFDF1\uFE00\uFE01\uFE1C\uFE21\uFE55\uFE55\uFE69\uFE69\uFE6E\uFE71\uFE77\uFE77\uFEFF\uFF02\uFFC1\uFFC3\uFFCA\uFFCB\uFFD2\uFFD3\uFFDA\uFFDB\uFFDF\uFFE1\uFFE9\uFFE9\uFFF1\uFFFD\0))==@@PQ`\x81\xFD\u0101\u0105\u0108\u0136\u0138\u0191\u0191\u019E\u01A1\u01A3\u01D1\u0200\u0281\u029F\u02A1\u02D3\u02E1\u02FE\u0301\u0326\u0331\u034D\u0351\u037D\u0381\u03A0\u03A0\u03C6\u03C9\u03D8\u0401\u04A0\u04A1\u04AC\u04B1\u04D6\u04D9\u04FE\u0501\u052A\u0531\u0566\u0570\u0572\u0601\u0739\u0741\u0758\u0761\u076A\u0801\u0808\u0809\u080B\u080B\u0838\u0838\u083B\u083D\u083F\u0840\u0858\u0858\u08A1\u08A8\u08B2\u08E1\u08F5\u08F5\u08F8\u08FC\u091E\u0920\u093C\u0940\u0942\u0981\u09BA\u09BD\u09D2\u09D3\u0A06\u0A06\u0A09\u0A0D\u0A16\u0A16\u0A1A\u0A1A\u0A36\u0A39\u0A3D\u0A40\u0A4A\u0A51\u0A5B\u0A61\u0AA2\u0AC1\u0AE9\u0AEC\u0AF9\u0B01\u0B38\u0B3A\u0B58\u0B59\u0B75\u0B79\u0B94\u0B9A\u0B9F\u0BAA\u0BB2\u0C01\u0C4B\u0C81\u0CB5\u0CC1\u0CF5\u0CFB\u0D02\u0E61\u0E81\u1001\u1050\u1053\u1072\u1080\u10BF\u10BF\u10C4\u10D1\u10EB\u10F1\u10FC\u1101\u1137\u1137\u1146\u1151\u1179\u1181\u11D0\u11D1\u11E2\u11E2\u11F7\u1201\u1214\u1214\u1241\u1281\u1289\u1289\u128B\u128B\u1290\u1290\u12A0\u12A0\u12AC\u12B1\u12ED\u12F1\u12FC\u1301\u1306\u1306\u130F\u1310\u1313\u1314\u132B\u132B\u1333\u1333\u1336\u1336\u133C\u133D\u1347\u1348\u134B\u134C\u1350\u1351\u1353\u1358\u135A\u135E\u1366\u1367\u136F\u1371\u1377\u1401\u145C\u145C\u145E\u145E\u1460\u1481\u14CA\u14D1\u14DC\u1581\u15B8\u15B9\u15E0\u1601\u1647\u1651\u165C\u1661\u166F\u1681\u16BA\u16C1\u16CC\u1701\u171C\u171E\u172E\u1731\u1742\u18A1\u18F5\u1900\u1902\u1AC1\u1AFB\u1C01\u1C0B\u1C0B\u1C39\u1C39\u1C48\u1C51\u1C6F\u1C71\u1C92\u1C93\u1CAA\u1CAA\u1CB9\u2001\u239C\u2401\u2471\u2471\u2477\u2481\u2546\u3001\u3431\u4401\u4649\u6801\u6A3B\u6A41\u6A61\u6A61\u6A6C\u6A6F\u6A72\u6AD1\u6AF0\u6AF1\u6AF8\u6B01\u6B48\u6B51\u6B5C\u6B5C\u6B64\u6B64\u6B7A\u6B7E\u6B92\u6F01\u6F47\u6F51\u6F81\u6F90\u6FA2\u6FE1\u6FE3\u7001\u87EF\u8801\u8AF5\uB001\uB004\uBC01\uBC6D\uBC71\uBC7F\uBC81\uBC8B\uBC91\uBC9C\uBC9D\uBCA2\uD001\uD0F8\uD101\uD129\uD12A\uD175\uD17C\uD1EB\uD201\uD248\uD301\uD359\uD361\uD374\uD401\uD457\uD457\uD49F\uD49F\uD4A2\uD4A3\uD4A5\uD4A6\uD4A9\uD4AA\uD4AF\uD4AF\uD4BC\uD4BC\uD4BE\uD4BE\uD4C6\uD4C6\uD508\uD508\uD50D\uD50E\uD517\uD517\uD51F\uD51F\uD53C\uD53C\uD541\uD541\uD547\uD547\uD549\uD54B\uD553\uD553\uD6A8\uD6A9\uD7CE\uD7CF\uDA8E\uDA9C\uDAA2\uDAA2\uDAB2\uE001\uE009\uE009\uE01B\uE01C\uE024\uE024\uE027\uE027\uE02D\uE801\uE8C7\uE8C8\uE8D9\uE901\uE94D\uE951\uE95C\uE95F\uE962\uEE01\uEE06\uEE06\uEE22\uEE22\uEE25\uEE25\uEE27\uEE28\uEE2A\uEE2A\uEE35\uEE35\uEE3A\uEE3A\uEE3C\uEE3C\uEE3E\uEE43\uEE45\uEE48\uEE4A\uEE4A\uEE4C\uEE4C\uEE4E\uEE4E\uEE52\uEE52\uEE55\uEE55\uEE57\uEE58\uEE5A\uEE5A\uEE5C\uEE5C\uEE5E\uEE5E\uEE60\uEE60\uEE62\uEE62\uEE65\uEE65\uEE67\uEE68\uEE6D\uEE6D\uEE75\uEE75\uEE7A\uEE7A\uEE7F\uEE7F\uEE81\uEE81\uEE8C\uEE8C\uEE9E\uEEA2\uEEA6\uEEA6\uEEAC\uEEAC\uEEBE\uEEF1\uEEF4\uF001\uF02E\uF031\uF096\uF0A1\uF0B1\uF0B2\uF0C2\uF0C2\uF0D2\uF0D2\uF0F8\uF101\uF10F\uF111\uF131\uF131\uF16E\uF171\uF1AF\uF1E7\uF205\uF211\uF23E\uF241\uF24B\uF251\uF254\uF301\uF6D5\uF6E1\uF6EF\uF6F1\uF6F9\uF701\uF776\uF781\uF7D7\uF801\uF80E\uF811\uF84A\uF851\uF85C\uF861\uF88A\uF891\uF8B0\uF911\uF921\uF921\uF92A\uF931\uF933\uF934\uF941\uF941\uF94E\uF951\uF961\uF981\uF994\uF9C1\uF9C3\uA6D9\uA701\uB737\uB741\uB820\uB821\uCEA4\uF801\uFA20\u0101\u01F2\u0284"\x81\xA2\xAF\xAF\u037A\u037B\u0382\u0385\u038D\u038D\u038F\u038F\u03A4\u03A4\u0532\u0532\u0559\u055A\u0562\u0562\u058A\u058A\u058D\u058E\u0592\u0592\u05CA\u05D1\u05ED\u05F1\u05F7\u0607\u061E\u061F\u06DF\u06DF\u0710\u0711\u074D\u074E\u07B4\u07C1\u07FD\u0801\u0830\u0831\u0841\u0841\u085E\u085F\u0861\u08A1\u08B7\u08B7\u08C0\u08D5\u08E4\u08E4\u0986\u0986\u098F\u0990\u0993\u0994\u09AB\u09AB\u09B3\u09B3\u09B5\u09B7\u09BC\u09BD\u09C7\u09C8\u09CB\u09CC\u09D1\u09D8\u09DA\u09DD\u09E0\u09E0\u09E6\u09E7\u09FE\u0A02\u0A06\u0A06\u0A0D\u0A10\u0A13\u0A14\u0A2B\u0A2B\u0A33\u0A33\u0A36\u0A36\u0A39\u0A39\u0A3C\u0A3D\u0A3F\u0A3F\u0A45\u0A48\u0A4B\u0A4C\u0A50\u0A52\u0A54\u0A5A\u0A5F\u0A5F\u0A61\u0A67\u0A78\u0A82\u0A86\u0A86\u0A90\u0A90\u0A94\u0A94\u0AAB\u0AAB\u0AB3\u0AB3\u0AB6\u0AB6\u0ABC\u0ABD\u0AC8\u0AC8\u0ACC\u0ACC\u0AD0\u0AD1\u0AD3\u0AE1\u0AE6\u0AE7\u0AF4\u0AFA\u0AFC\u0B02\u0B06\u0B06\u0B0F\u0B10\u0B13\u0B14\u0B2B\u0B2B\u0B33\u0B33\u0B36\u0B36\u0B3C\u0B3D\u0B47\u0B48\u0B4B\u0B4C\u0B50\u0B57\u0B5A\u0B5D\u0B60\u0B60\u0B66\u0B67\u0B7A\u0B83\u0B86\u0B86\u0B8D\u0B8F\u0B93\u0B93\u0B98\u0B9A\u0B9D\u0B9D\u0B9F\u0B9F\u0BA2\u0BA4\u0BA7\u0BA9\u0BAD\u0BAF\u0BBC\u0BBF\u0BC5\u0BC7\u0BCB\u0BCB\u0BD0\u0BD1\u0BD3\u0BD8\u0BDA\u0BE7\u0BFD\u0C01\u0C06\u0C06\u0C0F\u0C0F\u0C13\u0C13\u0C2B\u0C2B\u0C3C\u0C3E\u0C47\u0C47\u0C4B\u0C4B\u0C50\u0C56\u0C59\u0C59\u0C5D\u0C61\u0C66\u0C67\u0C72\u0C79\u0C86\u0C86\u0C8F\u0C8F\u0C93\u0C93\u0CAB\u0CAB\u0CB6\u0CB6\u0CBC\u0CBD\u0CC7\u0CC7\u0CCB\u0CCB\u0CD0\u0CD6\u0CD9\u0CDF\u0CE1\u0CE1\u0CE6\u0CE7\u0CF2\u0CF2\u0CF5\u0D02\u0D06\u0D06\u0D0F\u0D0F\u0D13\u0D13\u0D3D\u0D3E\u0D47\u0D47\u0D4B\u0D4B\u0D52\u0D55\u0D66\u0D67\u0D82\u0D83\u0D86\u0D86\u0D99\u0D9B\u0DB4\u0DB4\u0DBE\u0DBE\u0DC0\u0DC1\u0DC9\u0DCB\u0DCD\u0DD0\u0DD7\u0DD7\u0DD9\u0DD9\u0DE2\u0DE7\u0DF2\u0DF3\u0DF7\u0E02\u0E3D\u0E40\u0E5E\u0E82\u0E85\u0E85\u0E87\u0E88\u0E8B\u0E8B\u0E8D\u0E8E\u0E90\u0E95\u0E9A\u0E9A\u0EA2\u0EA2\u0EA6\u0EA6\u0EA8\u0EA8\u0EAA\u0EAB\u0EAE\u0EAE\u0EBC\u0EBC\u0EC0\u0EC1\u0EC7\u0EC7\u0EC9\u0EC9\u0ED0\u0ED1\u0EDC\u0EDD\u0EE2\u0F01\u0F4A\u0F4A\u0F6F\u0F72\u0F9A\u0F9A\u0FBF\u0FBF\u0FCF\u0FCF\u0FDD\u1001\u10C8\u10C8\u10CA\u10CE\u10D0\u10D1\u124B\u124B\u1250\u1251\u1259\u1259\u125B\u125B\u1260\u1261\u128B\u128B\u1290\u1291\u12B3\u12B3\u12B8\u12B9\u12C1\u12C1\u12C3\u12C3\u12C8\u12C9\u12D9\u12D9\u1313\u1313\u1318\u1319\u135D\u135E\u137F\u1381\u139C\u13A1\u13F8\u13F9\u1400\u1401\u1682\u1682\u169F\u16A1\u16FB\u1701\u170F\u170F\u1717\u1721\u1739\u1741\u1756\u1761\u176F\u176F\u1773\u1773\u1776\u1781\u17E0\u17E1\u17EC\u17F1\u17FC\u1801\u1810\u1811\u181C\u1821\u187A\u1881\u18AD\u18B1\u18F8\u1901\u1921\u1921\u192E\u1931\u193E\u1941\u1943\u1945\u1970\u1971\u1977\u1981\u19AE\u19B1\u19CC\u19D1\u19DD\u19DF\u1A1E\u1A1F\u1A61\u1A61\u1A7F\u1A80\u1A8C\u1A91\u1A9C\u1AA1\u1AB0\u1AB1\u1AC1\u1B01\u1B4E\u1B51\u1B7F\u1B81\u1BF6\u1BFD\u1C3A\u1C3C\u1C4C\u1C4E\u1C8B\u1CC1\u1CCA\u1CD1\u1CF9\u1CF9\u1CFC\u1D01\u1DF8\u1DFC\u1F18\u1F19\u1F20\u1F21\u1F48\u1F49\u1F50\u1F51\u1F5A\u1F5A\u1F5C\u1F5C\u1F5E\u1F5E\u1F60\u1F60\u1F80\u1F81\u1FB7\u1FB7\u1FC7\u1FC7\u1FD6\u1FD7\u1FDE\u1FDE\u1FF2\u1FF3\u1FF7\u1FF7\u2001\u2011\u202A\u2031\u2061\u2071\u2074\u2075\u2091\u2091\u209F\u20A1\u20C1\u20D1\u20F3\u2101\u218E\u2191\u2401\u2401\u2429\u2441\u244D\u2461\u2B76\u2B77\u2B98\u2B99\u2BBC\u2BBE\u2BCB\u2BCB\u2BD4\u2BED\u2BF2\u2C01\u2C31\u2C31\u2C61\u2C61\u2CF6\u2CFA\u2D28\u2D28\u2D2A\u2D2E\u2D30\u2D31\u2D6A\u2D70\u2D73\u2D80\u2D99\u2DA1\u2DA9\u2DA9\u2DB1\u2DB1\u2DB9\u2DB9\u2DC1\u2DC1\u2DC9\u2DC9\u2DD1\u2DD1\u2DD9\u2DD9\u2DE1\u2DE1\u2E47\u2E81\u2E9C\u2E9C\u2EF6\u2F01\u2FD8\u2FF1\u2FFE\u3002\u3042\u3042\u3099\u309A\u3102\u3106\u3130\u3132\u3191\u3191\u31BD\u31C1\u31E6\u31F1\u3221\u3221\u3301\u3301\u4DB8\u4DC1\u9FD8\uA001\uA48F\uA491\uA4C9\uA4D1\uA62E\uA641\uA6FA\uA701\uA7B1\uA7B1\uA7BA\uA7F8\uA82E\uA831\uA83C\uA841\uA87A\uA881\uA8C8\uA8CF\uA8DC\uA8E1\uA900\uA901\uA956\uA960\uA97F\uA981\uA9D0\uA9D0\uA9DC\uA9DF\uAA01\uAA01\uAA39\uAA41\uAA50\uAA51\uAA5C\uAA5D\uAAC5\uAADC\uAAF9\uAB02\uAB09\uAB0A\uAB11\uAB12\uAB19\uAB21\uAB29\uAB29\uAB31\uAB31\uAB68\uAB71\uABF0\uABF1\uABFC\uAC01\uD7A6\uD7B1\uD7C9\uD7CC\uD7FE\uF901\uFA70\uFA71\uFADC\uFB01\uFB09\uFB14\uFB1A\uFB1E\uFB39\uFB39\uFB3F\uFB3F\uFB41\uFB41\uFB44\uFB44\uFB47\uFB47\uFBC4\uFBD4\uFD42\uFD51\uFD92\uFD93\uFDCA\uFDF1\uFE00\uFE01\uFE1C\uFE21\uFE55\uFE55\uFE69\uFE69\uFE6E\uFE71\uFE77\uFE77\uFEFF\uFF02\uFFC1\uFFC3\uFFCA\uFFCB\uFFD2\uFFD3\uFFDA\uFFDB\uFFDF\uFFE1\uFFE9\uFFE9\uFFF1\uFFFD\0))==@@PQ`\x81\xFD\u0101\u0105\u0108\u0136\u0138\u0191\u0191\u019E\u01A1\u01A3\u01D1\u0200\u0281\u029F\u02A1\u02D3\u02E1\u02FE\u0301\u0326\u0331\u034D\u0351\u037D\u0381\u03A0\u03A0\u03C6\u03C9\u03D8\u0401\u04A0\u04A1\u04AC\u04B1\u04D6\u04D9\u04FE\u0501\u052A\u0531\u0566\u0570\u0572\u0601\u0739\u0741\u0758\u0761\u076A\u0801\u0808\u0809\u080B\u080B\u0838\u0838\u083B\u083D\u083F\u0840\u0858\u0858\u08A1\u08A8\u08B2\u08E1\u08F5\u08F5\u08F8\u08FC\u091E\u0920\u093C\u0940\u0942\u0981\u09BA\u09BD\u09D2\u09D3\u0A06\u0A06\u0A09\u0A0D\u0A16\u0A16\u0A1A\u0A1A\u0A36\u0A39\u0A3D\u0A40\u0A4A\u0A51\u0A5B\u0A61\u0AA2\u0AC1\u0AE9\u0AEC\u0AF9\u0B01\u0B38\u0B3A\u0B58\u0B59\u0B75\u0B79\u0B94\u0B9A\u0B9F\u0BAA\u0BB2\u0C01\u0C4B\u0C81\u0CB5\u0CC1\u0CF5\u0CFB\u0D02\u0E61\u0E81\u1001\u1050\u1053\u1072\u1080\u10BF\u10BF\u10C4\u10D1\u10EB\u10F1\u10FC\u1101\u1137\u1137\u1146\u1151\u1179\u1181\u11D0\u11D1\u11E2\u11E2\u11F7\u1201\u1214\u1214\u1241\u1281\u1289\u1289\u128B\u128B\u1290\u1290\u12A0\u12A0\u12AC\u12B1\u12ED\u12F1\u12FC\u1301\u1306\u1306\u130F\u1310\u1313\u1314\u132B\u132B\u1333\u1333\u1336\u1336\u133C\u133D\u1347\u1348\u134B\u134C\u1350\u1351\u1353';
    }
    static {
      this._serializedATNSegment1 = "\u1358\u135A\u135E\u1366\u1367\u136F\u1371\u1377\u1401\u145C\u145C\u145E\u145E\u1460\u1481\u14CA\u14D1\u14DC\u1581\u15B8\u15B9\u15E0\u1601\u1647\u1651\u165C\u1661\u166F\u1681\u16BA\u16C1\u16CC\u1701\u171C\u171E\u172E\u1731\u1742\u18A1\u18F5\u1900\u1902\u1AC1\u1AFB\u1C01\u1C0B\u1C0B\u1C39\u1C39\u1C48\u1C51\u1C6F\u1C71\u1C92\u1C93\u1CAA\u1CAA\u1CB9\u2001\u239C\u2401\u2471\u2471\u2477\u2481\u2546\u3001\u3431\u4401\u4649\u6801\u6A3B\u6A41\u6A61\u6A61\u6A6C\u6A6F\u6A72\u6AD1\u6AF0\u6AF1\u6AF8\u6B01\u6B48\u6B51\u6B5C\u6B5C\u6B64\u6B64\u6B7A\u6B7E\u6B92\u6F01\u6F47\u6F51\u6F81\u6F90\u6FA2\u6FE1\u6FE3\u7001\u87EF\u8801\u8AF5\uB001\uB004\uBC01\uBC6D\uBC71\uBC7F\uBC81\uBC8B\uBC91\uBC9C\uBC9D\uBCA2\uD001\uD0F8\uD101\uD129\uD12A\uD175\uD17C\uD1EB\uD201\uD248\uD301\uD359\uD361\uD374\uD401\uD457\uD457\uD49F\uD49F\uD4A2\uD4A3\uD4A5\uD4A6\uD4A9\uD4AA\uD4AF\uD4AF\uD4BC\uD4BC\uD4BE\uD4BE\uD4C6\uD4C6\uD508\uD508\uD50D\uD50E\uD517\uD517\uD51F\uD51F\uD53C\uD53C\uD541\uD541\uD547\uD547\uD549\uD54B\uD553\uD553\uD6A8\uD6A9\uD7CE\uD7CF\uDA8E\uDA9C\uDAA2\uDAA2\uDAB2\uE001\uE009\uE009\uE01B\uE01C\uE024\uE024\uE027\uE027\uE02D\uE801\uE8C7\uE8C8\uE8D9\uE901\uE94D\uE951\uE95C\uE95F\uE962\uEE01\uEE06\uEE06\uEE22\uEE22\uEE25\uEE25\uEE27\uEE28\uEE2A\uEE2A\uEE35\uEE35\uEE3A\uEE3A\uEE3C\uEE3C\uEE3E\uEE43\uEE45\uEE48\uEE4A\uEE4A\uEE4C\uEE4C\uEE4E\uEE4E\uEE52\uEE52\uEE55\uEE55\uEE57\uEE58\uEE5A\uEE5A\uEE5C\uEE5C\uEE5E\uEE5E\uEE60\uEE60\uEE62\uEE62\uEE65\uEE65\uEE67\uEE68\uEE6D\uEE6D\uEE75\uEE75\uEE7A\uEE7A\uEE7F\uEE7F\uEE81\uEE81\uEE8C\uEE8C\uEE9E\uEEA2\uEEA6\uEEA6\uEEAC\uEEAC\uEEBE\uEEF1\uEEF4\uF001\uF02E\uF031\uF096\uF0A1\uF0B1\uF0B2\uF0C2\uF0C2\uF0D2\uF0D2\uF0F8\uF101\uF10F\uF111\uF131\uF131\uF16E\uF171\uF1AF\uF1E7\uF205\uF211\uF23E\uF241\uF24B\uF251\uF254\uF301\uF6D5\uF6E1\uF6EF\uF6F1\uF6F9\uF701\uF776\uF781\uF7D7\uF801\uF80E\uF811\uF84A\uF851\uF85C\uF861\uF88A\uF891\uF8B0\uF911\uF921\uF921\uF92A\uF931\uF933\uF934\uF941\uF941\uF94E\uF951\uF961\uF981\uF994\uF9C1\uF9C3\uA6D9\uA701\uB737\uB741\uB820\uB821\uCEA4\uF801\uFA20\u0101\u01F2\xC5\x07	\v\r\x1B!#%+-/135\x077	9\v;\r=@DTVXZ\x1B\\^`!b#e%\x7F'\x8A)\x8E+\x90-\x97/\xA21\xB234\x07]456\x07.678\x07_8\b9:\x07}:\n;<\x07\x7F<\f=>\x07q>?\x07t?@A\x07cAB\x07pBC\x07fCDE\x07yEF\x07jFG\x07gGH\x07tHI\x07gIJK\x07hKL\x07wLM\x07pMN\x07eNO\x07vOP\x07kPQ\x07qQU\x07pRS\x07hSU\x07pTJTRUVW\x07*WXY\x07+YZ[\x07<[\\]\x071]^_\x07B_`a\x07/a bc\x07?c\"df\x07/edeffhgi	hgijjhjkkrln\x070mo	nmoppnpqqsrlrss}tv	uw\x07/vuvwwyxz	yxz{{y{||~}t}~~$\x7F\x85\x07$\x80\x81\x07^\x81\x84\v\x82\x84\n\x83\x80\x83\x82\x84\x87\x85\x83\x85\x86\x86\x88\x87\x85\x88\x89\x07$\x89&\x8A\x8B\n\x07\x8B(\x8C\x8F'\x8D\x8F	\x8E\x8C\x8E\x8D\x8F*\x90\x94'\x91\x93)\x92\x91\x93\x96\x94\x92\x94\x95\x95,\x96\x94\x97\x98\x071\x98\x99\x071\x99\x9D\x9A\x9C\n\x9B\x9A\x9C\x9F\x9D\x9B\x9D\x9E\x9E\xA0\x9F\x9D\xA0\xA1\b\xA1.\xA2\xA3\x071\xA3\xA4\x07,\xA4\xA9\xA5\xA8/\xA6\xA8\v\xA7\xA5\xA7\xA6\xA8\xAB\xA9\xAA\xA9\xA7\xAA\xAC\xAB\xA9\xAC\xAD\x07,\xAD\xAE\x071\xAE\xAF\xAF\xB0\b\xB00\xB1\xB3	\b\xB2\xB1\xB3\xB4\xB4\xB2\xB4\xB5\xB5\xB6\xB6\xB7\b\xB72Tejprv{}\x83\x85\x8E\x94\x9D\xA7\xA9\xB4\b";
    }
    static {
      this._serializedATN = Utils.join(
        [
          _SalLexer._serializedATNSegment0,
          _SalLexer._serializedATNSegment1
        ],
        ""
      );
    }
    static get _ATN() {
      if (!_SalLexer.__ATN) {
        _SalLexer.__ATN = new import_ATNDeserializer.ATNDeserializer().deserialize(Utils.toCharArray(_SalLexer._serializedATN));
      }
      return _SalLexer.__ATN;
    }
  };

  // source/sal/.antlr-generated/SalParser.ts
  var import_ATN = __toESM(require_ATN());
  var import_ATNDeserializer2 = __toESM(require_ATNDeserializer());
  var import_FailedPredicateException = __toESM(require_FailedPredicateException());
  var import_NoViableAltException = __toESM(require_NoViableAltException());
  var import_Parser = __toESM(require_Parser());
  var import_ParserRuleContext = __toESM(require_ParserRuleContext());
  var import_ParserATNSimulator = __toESM(require_ParserATNSimulator());
  var import_RecognitionException = __toESM(require_RecognitionException());
  var import_Token = __toESM(require_Token());
  var import_VocabularyImpl2 = __toESM(require_VocabularyImpl());
  var Utils2 = __toESM(require_Utils());
  var SalParser = class _SalParser extends import_Parser.Parser {
    static {
      this.T__0 = 1;
    }
    static {
      this.T__1 = 2;
    }
    static {
      this.T__2 = 3;
    }
    static {
      this.T__3 = 4;
    }
    static {
      this.T__4 = 5;
    }
    static {
      this.OR = 6;
    }
    static {
      this.AND = 7;
    }
    static {
      this.WHERE = 8;
    }
    static {
      this.FUNCTION = 9;
    }
    static {
      this.PAREN_BEGIN = 10;
    }
    static {
      this.PAREN_END = 11;
    }
    static {
      this.COLON = 12;
    }
    static {
      this.SLASH = 13;
    }
    static {
      this.AT = 14;
    }
    static {
      this.MINUS = 15;
    }
    static {
      this.EQUALS = 16;
    }
    static {
      this.NUMBER = 17;
    }
    static {
      this.STRING = 18;
    }
    static {
      this.WORD = 19;
    }
    static {
      this.LINE_COMMENT = 20;
    }
    static {
      this.BLOCK_COMMENT = 21;
    }
    static {
      this.WS = 22;
    }
    static {
      this.RULE_sourceFile = 0;
    }
    static {
      this.RULE_word = 1;
    }
    static {
      this.RULE_parameter = 2;
    }
    static {
      this.RULE_entry = 3;
    }
    static {
      this.RULE_expression = 4;
    }
    static {
      // tslint:disable:no-trailing-whitespace
      this.ruleNames = [
        "sourceFile",
        "word",
        "parameter",
        "entry",
        "expression"
      ];
    }
    static {
      this._LITERAL_NAMES = [
        void 0,
        "'['",
        "','",
        "']'",
        "'{'",
        "'}'",
        "'or'",
        "'and'",
        "'where'",
        void 0,
        "'('",
        "')'",
        "':'",
        "'/'",
        "'@'",
        "'-'",
        "'='"
      ];
    }
    static {
      this._SYMBOLIC_NAMES = [
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        "OR",
        "AND",
        "WHERE",
        "FUNCTION",
        "PAREN_BEGIN",
        "PAREN_END",
        "COLON",
        "SLASH",
        "AT",
        "MINUS",
        "EQUALS",
        "NUMBER",
        "STRING",
        "WORD",
        "LINE_COMMENT",
        "BLOCK_COMMENT",
        "WS"
      ];
    }
    static {
      this.VOCABULARY = new import_VocabularyImpl2.VocabularyImpl(_SalParser._LITERAL_NAMES, _SalParser._SYMBOLIC_NAMES, []);
    }
    // @Override
    // @NotNull
    get vocabulary() {
      return _SalParser.VOCABULARY;
    }
    // tslint:enable:no-trailing-whitespace
    // @Override
    get grammarFileName() {
      return "Sal.g4";
    }
    // @Override
    get ruleNames() {
      return _SalParser.ruleNames;
    }
    // @Override
    get serializedATN() {
      return _SalParser._serializedATN;
    }
    createFailedPredicateException(predicate, message) {
      return new import_FailedPredicateException.FailedPredicateException(this, predicate, message);
    }
    constructor(input) {
      super(input);
      this._interp = new import_ParserATNSimulator.ParserATNSimulator(_SalParser._ATN, this);
    }
    // @RuleVersion(0)
    sourceFile() {
      let _localctx = new SourceFileContext(this._ctx, this.state);
      this.enterRule(_localctx, 0, _SalParser.RULE_sourceFile);
      let _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 11;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if ((_la & ~31) === 0 && (1 << _la & (1 << _SalParser.T__0 | 1 << _SalParser.T__3 | 1 << _SalParser.WHERE | 1 << _SalParser.FUNCTION | 1 << _SalParser.PAREN_BEGIN | 1 << _SalParser.AT | 1 << _SalParser.MINUS | 1 << _SalParser.NUMBER | 1 << _SalParser.STRING | 1 << _SalParser.WORD)) !== 0) {
            {
              this.state = 10;
              this.expression(0);
            }
          }
          this.state = 13;
          this.match(_SalParser.EOF);
        }
      } catch (re) {
        if (re instanceof import_RecognitionException.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
    word() {
      let _localctx = new WordContext(this._ctx, this.state);
      this.enterRule(_localctx, 2, _SalParser.RULE_word);
      let _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 15;
          _la = this._input.LA(1);
          if (!((_la & ~31) === 0 && (1 << _la & (1 << _SalParser.WHERE | 1 << _SalParser.FUNCTION | 1 << _SalParser.WORD)) !== 0)) {
            this._errHandler.recoverInline(this);
          } else {
            if (this._input.LA(1) === import_Token.Token.EOF) {
              this.matchedEOF = true;
            }
            this._errHandler.reportMatch(this);
            this.consume();
          }
        }
      } catch (re) {
        if (re instanceof import_RecognitionException.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
    parameter() {
      let _localctx = new ParameterContext(this._ctx, this.state);
      this.enterRule(_localctx, 4, _SalParser.RULE_parameter);
      let _la;
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 18;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _SalParser.AT) {
            {
              this.state = 17;
              this.match(_SalParser.AT);
            }
          }
          this.state = 20;
          this.word();
        }
      } catch (re) {
        if (re instanceof import_RecognitionException.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
    entry() {
      let _localctx = new EntryContext(this._ctx, this.state);
      this.enterRule(_localctx, 6, _SalParser.RULE_entry);
      try {
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 24;
          this._errHandler.sync(this);
          switch (this._input.LA(1)) {
            case _SalParser.WHERE:
            case _SalParser.FUNCTION:
            case _SalParser.WORD:
              {
                this.state = 22;
                this.word();
              }
              break;
            case _SalParser.STRING:
              {
                this.state = 23;
                this.match(_SalParser.STRING);
              }
              break;
            default:
              throw new import_NoViableAltException.NoViableAltException(this);
          }
          this.state = 26;
          this.match(_SalParser.COLON);
          this.state = 27;
          this.expression(0);
        }
      } catch (re) {
        if (re instanceof import_RecognitionException.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return _localctx;
    }
    // @RuleVersion(0)
    expression(_p) {
      if (_p === void 0) {
        _p = 0;
      }
      let _parentctx = this._ctx;
      let _parentState = this.state;
      let _localctx = new ExpressionContext(this._ctx, _parentState);
      let _prevctx = _localctx;
      let _startState = 8;
      this.enterRecursionRule(_localctx, 8, _SalParser.RULE_expression, _p);
      let _la;
      try {
        let _alt;
        this.enterOuterAlt(_localctx, 1);
        {
          this.state = 87;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 12, this._ctx)) {
            case 1:
              {
                _localctx = new NotExpressionContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 30;
                this.match(_SalParser.MINUS);
                this.state = 31;
                this.expression(14);
              }
              break;
            case 2:
              {
                _localctx = new LambdaExpressionContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 32;
                this.match(_SalParser.AT);
                this.state = 33;
                this.match(_SalParser.FUNCTION);
                this.state = 35;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                do {
                  {
                    {
                      this.state = 34;
                      this.parameter();
                    }
                  }
                  this.state = 37;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                } while ((_la & ~31) === 0 && (1 << _la & (1 << _SalParser.WHERE | 1 << _SalParser.FUNCTION | 1 << _SalParser.AT | 1 << _SalParser.WORD)) !== 0);
                this.state = 39;
                this.match(_SalParser.COLON);
                this.state = 40;
                this.expression(8);
              }
              break;
            case 3:
              {
                _localctx = new NumberContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 43;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _SalParser.AT) {
                  {
                    this.state = 42;
                    this.match(_SalParser.AT);
                  }
                }
                this.state = 45;
                this.match(_SalParser.NUMBER);
              }
              break;
            case 4:
              {
                _localctx = new StringContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 47;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _SalParser.AT) {
                  {
                    this.state = 46;
                    this.match(_SalParser.AT);
                  }
                }
                this.state = 49;
                this.match(_SalParser.STRING);
              }
              break;
            case 5:
              {
                _localctx = new VariableContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 50;
                this.match(_SalParser.AT);
                this.state = 51;
                this.word();
              }
              break;
            case 6:
              {
                _localctx = new WordExpressionContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 52;
                this.word();
              }
              break;
            case 7:
              {
                _localctx = new ListLiteralExpressionContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 53;
                this.match(_SalParser.T__0);
                this.state = 62;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & (1 << _SalParser.T__0 | 1 << _SalParser.T__3 | 1 << _SalParser.WHERE | 1 << _SalParser.FUNCTION | 1 << _SalParser.PAREN_BEGIN | 1 << _SalParser.AT | 1 << _SalParser.MINUS | 1 << _SalParser.NUMBER | 1 << _SalParser.STRING | 1 << _SalParser.WORD)) !== 0) {
                  {
                    this.state = 54;
                    this.expression(0);
                    this.state = 59;
                    this._errHandler.sync(this);
                    _alt = this.interpreter.adaptivePredict(this._input, 6, this._ctx);
                    while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
                      if (_alt === 1) {
                        {
                          {
                            this.state = 55;
                            this.match(_SalParser.T__1);
                            this.state = 56;
                            this.expression(0);
                          }
                        }
                      }
                      this.state = 61;
                      this._errHandler.sync(this);
                      _alt = this.interpreter.adaptivePredict(this._input, 6, this._ctx);
                    }
                  }
                }
                this.state = 65;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _SalParser.T__1) {
                  {
                    this.state = 64;
                    this.match(_SalParser.T__1);
                  }
                }
                this.state = 67;
                this.match(_SalParser.T__2);
              }
              break;
            case 8:
              {
                _localctx = new RecordLiteralExpressionContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 68;
                this.match(_SalParser.T__3);
                this.state = 77;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & (1 << _SalParser.WHERE | 1 << _SalParser.FUNCTION | 1 << _SalParser.STRING | 1 << _SalParser.WORD)) !== 0) {
                  {
                    this.state = 69;
                    this.entry();
                    this.state = 74;
                    this._errHandler.sync(this);
                    _alt = this.interpreter.adaptivePredict(this._input, 9, this._ctx);
                    while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
                      if (_alt === 1) {
                        {
                          {
                            this.state = 70;
                            this.match(_SalParser.T__1);
                            this.state = 71;
                            this.entry();
                          }
                        }
                      }
                      this.state = 76;
                      this._errHandler.sync(this);
                      _alt = this.interpreter.adaptivePredict(this._input, 9, this._ctx);
                    }
                  }
                }
                this.state = 80;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _SalParser.T__1) {
                  {
                    this.state = 79;
                    this.match(_SalParser.T__1);
                  }
                }
                this.state = 82;
                this.match(_SalParser.T__4);
              }
              break;
            case 9:
              {
                _localctx = new ParenthesizedExpressionContext(_localctx);
                this._ctx = _localctx;
                _prevctx = _localctx;
                this.state = 83;
                this.match(_SalParser.PAREN_BEGIN);
                this.state = 84;
                this.expression(0);
                this.state = 85;
                this.match(_SalParser.PAREN_END);
              }
              break;
          }
          this._ctx._stop = this._input.tryLT(-1);
          this.state = 118;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 15, this._ctx);
          while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
            if (_alt === 1) {
              if (this._parseListeners != null) {
                this.triggerExitRuleEvent();
              }
              _prevctx = _localctx;
              {
                this.state = 116;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 14, this._ctx)) {
                  case 1:
                    {
                      _localctx = new ApplyExpressionContext(new ExpressionContext(_parentctx, _parentState));
                      _localctx._left = _prevctx;
                      this.pushNewRecursionContext(_localctx, _startState, _SalParser.RULE_expression);
                      this.state = 89;
                      if (!this.precpred(this._ctx, 15)) {
                        throw this.createFailedPredicateException("this.precpred(this._ctx, 15)");
                      }
                      this.state = 90;
                      this.match(_SalParser.COLON);
                      this.state = 91;
                      _localctx._right = this.expression(16);
                    }
                    break;
                  case 2:
                    {
                      _localctx = new SequenceExpressionContext(new ExpressionContext(_parentctx, _parentState));
                      _localctx._left = _prevctx;
                      this.pushNewRecursionContext(_localctx, _startState, _SalParser.RULE_expression);
                      this.state = 92;
                      if (!this.precpred(this._ctx, 13)) {
                        throw this.createFailedPredicateException("this.precpred(this._ctx, 13)");
                      }
                      this.state = 93;
                      _localctx._right = this.expression(14);
                    }
                    break;
                  case 3:
                    {
                      _localctx = new OrExpressionContext(new ExpressionContext(_parentctx, _parentState));
                      _localctx._left = _prevctx;
                      this.pushNewRecursionContext(_localctx, _startState, _SalParser.RULE_expression);
                      this.state = 94;
                      if (!this.precpred(this._ctx, 12)) {
                        throw this.createFailedPredicateException("this.precpred(this._ctx, 12)");
                      }
                      this.state = 95;
                      this.match(_SalParser.OR);
                      this.state = 96;
                      _localctx._right = this.expression(13);
                    }
                    break;
                  case 4:
                    {
                      _localctx = new AndExpressionContext(new ExpressionContext(_parentctx, _parentState));
                      _localctx._left = _prevctx;
                      this.pushNewRecursionContext(_localctx, _startState, _SalParser.RULE_expression);
                      this.state = 97;
                      if (!this.precpred(this._ctx, 11)) {
                        throw this.createFailedPredicateException("this.precpred(this._ctx, 11)");
                      }
                      this.state = 98;
                      this.match(_SalParser.AND);
                      this.state = 99;
                      _localctx._right = this.expression(12);
                    }
                    break;
                  case 5:
                    {
                      _localctx = new BinaryExpressionContext(new ExpressionContext(_parentctx, _parentState));
                      _localctx._left = _prevctx;
                      this.pushNewRecursionContext(_localctx, _startState, _SalParser.RULE_expression);
                      this.state = 100;
                      if (!this.precpred(this._ctx, 10)) {
                        throw this.createFailedPredicateException("this.precpred(this._ctx, 10)");
                      }
                      this.state = 101;
                      this.match(_SalParser.SLASH);
                      this.state = 102;
                      this.word();
                      this.state = 103;
                      _localctx._right = this.expression(11);
                    }
                    break;
                  case 6:
                    {
                      _localctx = new WhereExpressionContext(new ExpressionContext(_parentctx, _parentState));
                      _localctx._scope = _prevctx;
                      this.pushNewRecursionContext(_localctx, _startState, _SalParser.RULE_expression);
                      this.state = 105;
                      if (!this.precpred(this._ctx, 9)) {
                        throw this.createFailedPredicateException("this.precpred(this._ctx, 9)");
                      }
                      this.state = 106;
                      this.match(_SalParser.AT);
                      this.state = 107;
                      this.match(_SalParser.WHERE);
                      this.state = 109;
                      this._errHandler.sync(this);
                      _la = this._input.LA(1);
                      do {
                        {
                          {
                            this.state = 108;
                            this.parameter();
                          }
                        }
                        this.state = 111;
                        this._errHandler.sync(this);
                        _la = this._input.LA(1);
                      } while ((_la & ~31) === 0 && (1 << _la & (1 << _SalParser.WHERE | 1 << _SalParser.FUNCTION | 1 << _SalParser.AT | 1 << _SalParser.WORD)) !== 0);
                      this.state = 113;
                      this.match(_SalParser.EQUALS);
                      this.state = 114;
                      _localctx._value = this.expression(10);
                    }
                    break;
                }
              }
            }
            this.state = 120;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 15, this._ctx);
          }
        }
      } catch (re) {
        if (re instanceof import_RecognitionException.RecognitionException) {
          _localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.unrollRecursionContexts(_parentctx);
      }
      return _localctx;
    }
    sempred(_localctx, ruleIndex, predIndex) {
      switch (ruleIndex) {
        case 4:
          return this.expression_sempred(_localctx, predIndex);
      }
      return true;
    }
    expression_sempred(_localctx, predIndex) {
      switch (predIndex) {
        case 0:
          return this.precpred(this._ctx, 15);
        case 1:
          return this.precpred(this._ctx, 13);
        case 2:
          return this.precpred(this._ctx, 12);
        case 3:
          return this.precpred(this._ctx, 11);
        case 4:
          return this.precpred(this._ctx, 10);
        case 5:
          return this.precpred(this._ctx, 9);
      }
      return true;
    }
    static {
      this._serializedATN = "\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241|					\n\n\x1B\n&\n\r'.\n2\n\x07<\n\f?\vA\nD\n\x07K\n\fN\vP\nS\nZ\np\n\rq\x07w\n\fz\v\n\x07\b\n\n\v\x91\r\b\nY\f\n\r\f\r\x07	\x07\x07\x1B\x1B\x07\x1B\x07\n	 \b !\x07!Z\n\"#\x07#%\x07\v$&%$&''%'(())*\x07*+\n\n+Z,.\x07-,-..//Z\x0702\x071012233Z\x0745\x075Z6Z7@\x078=\n9:\x07:<\n;9<?=;=>>A?=@8@AACBD\x07CBCDDEEZ\x07FO\x07GL\bHI\x07IK\bJHKNLJLMMPNLOGOPPRQS\x07RQRSSTTZ\x07\x07UV\x07\fVW\nWX\x07\rXZYY\"Y-Y1Y4Y6Y7YFYUZx[\\\f\\]\x07]w\n^_\f_w\n`a\fab\x07\bbw\ncd\f\rde\x07	ew\nfg\f\fgh\x07hiij\n\rjwkl\f\vlm\x07mo\x07\nnponpqqoqrrsst\x07tu\n\fuwv[v^v`vcvfvkwzxvxyy\vzx\r'-1=@CLORYqvx";
    }
    static get _ATN() {
      if (!_SalParser.__ATN) {
        _SalParser.__ATN = new import_ATNDeserializer2.ATNDeserializer().deserialize(Utils2.toCharArray(_SalParser._serializedATN));
      }
      return _SalParser.__ATN;
    }
  };
  var SourceFileContext = class extends import_ParserRuleContext.ParserRuleContext {
    EOF() {
      return this.getToken(SalParser.EOF, 0);
    }
    expression() {
      return this.tryGetRuleContext(0, ExpressionContext);
    }
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    // @Override
    get ruleIndex() {
      return SalParser.RULE_sourceFile;
    }
    // @Override
    enterRule(listener) {
      if (listener.enterSourceFile) {
        listener.enterSourceFile(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitSourceFile) {
        listener.exitSourceFile(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitSourceFile) {
        return visitor.visitSourceFile(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var WordContext = class extends import_ParserRuleContext.ParserRuleContext {
    WHERE() {
      return this.tryGetToken(SalParser.WHERE, 0);
    }
    FUNCTION() {
      return this.tryGetToken(SalParser.FUNCTION, 0);
    }
    WORD() {
      return this.tryGetToken(SalParser.WORD, 0);
    }
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    // @Override
    get ruleIndex() {
      return SalParser.RULE_word;
    }
    // @Override
    enterRule(listener) {
      if (listener.enterWord) {
        listener.enterWord(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitWord) {
        listener.exitWord(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitWord) {
        return visitor.visitWord(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var ParameterContext = class extends import_ParserRuleContext.ParserRuleContext {
    word() {
      return this.getRuleContext(0, WordContext);
    }
    AT() {
      return this.tryGetToken(SalParser.AT, 0);
    }
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    // @Override
    get ruleIndex() {
      return SalParser.RULE_parameter;
    }
    // @Override
    enterRule(listener) {
      if (listener.enterParameter) {
        listener.enterParameter(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitParameter) {
        listener.exitParameter(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitParameter) {
        return visitor.visitParameter(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var EntryContext = class extends import_ParserRuleContext.ParserRuleContext {
    COLON() {
      return this.getToken(SalParser.COLON, 0);
    }
    expression() {
      return this.getRuleContext(0, ExpressionContext);
    }
    word() {
      return this.tryGetRuleContext(0, WordContext);
    }
    STRING() {
      return this.tryGetToken(SalParser.STRING, 0);
    }
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    // @Override
    get ruleIndex() {
      return SalParser.RULE_entry;
    }
    // @Override
    enterRule(listener) {
      if (listener.enterEntry) {
        listener.enterEntry(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitEntry) {
        listener.exitEntry(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitEntry) {
        return visitor.visitEntry(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var ExpressionContext = class extends import_ParserRuleContext.ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    // @Override
    get ruleIndex() {
      return SalParser.RULE_expression;
    }
    copyFrom(ctx) {
      super.copyFrom(ctx);
    }
  };
  var ApplyExpressionContext = class extends ExpressionContext {
    COLON() {
      return this.getToken(SalParser.COLON, 0);
    }
    expression(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExpressionContext);
      } else {
        return this.getRuleContext(i, ExpressionContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterApplyExpression) {
        listener.enterApplyExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitApplyExpression) {
        listener.exitApplyExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitApplyExpression) {
        return visitor.visitApplyExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var NotExpressionContext = class extends ExpressionContext {
    MINUS() {
      return this.getToken(SalParser.MINUS, 0);
    }
    expression() {
      return this.getRuleContext(0, ExpressionContext);
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterNotExpression) {
        listener.enterNotExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitNotExpression) {
        listener.exitNotExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitNotExpression) {
        return visitor.visitNotExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var SequenceExpressionContext = class extends ExpressionContext {
    expression(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExpressionContext);
      } else {
        return this.getRuleContext(i, ExpressionContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterSequenceExpression) {
        listener.enterSequenceExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitSequenceExpression) {
        listener.exitSequenceExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitSequenceExpression) {
        return visitor.visitSequenceExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var OrExpressionContext = class extends ExpressionContext {
    OR() {
      return this.getToken(SalParser.OR, 0);
    }
    expression(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExpressionContext);
      } else {
        return this.getRuleContext(i, ExpressionContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterOrExpression) {
        listener.enterOrExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitOrExpression) {
        listener.exitOrExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitOrExpression) {
        return visitor.visitOrExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var AndExpressionContext = class extends ExpressionContext {
    AND() {
      return this.getToken(SalParser.AND, 0);
    }
    expression(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExpressionContext);
      } else {
        return this.getRuleContext(i, ExpressionContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterAndExpression) {
        listener.enterAndExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitAndExpression) {
        listener.exitAndExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitAndExpression) {
        return visitor.visitAndExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var BinaryExpressionContext = class extends ExpressionContext {
    SLASH() {
      return this.getToken(SalParser.SLASH, 0);
    }
    word() {
      return this.getRuleContext(0, WordContext);
    }
    expression(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExpressionContext);
      } else {
        return this.getRuleContext(i, ExpressionContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterBinaryExpression) {
        listener.enterBinaryExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitBinaryExpression) {
        listener.exitBinaryExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitBinaryExpression) {
        return visitor.visitBinaryExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var WhereExpressionContext = class extends ExpressionContext {
    AT() {
      return this.getToken(SalParser.AT, 0);
    }
    WHERE() {
      return this.getToken(SalParser.WHERE, 0);
    }
    EQUALS() {
      return this.getToken(SalParser.EQUALS, 0);
    }
    expression(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExpressionContext);
      } else {
        return this.getRuleContext(i, ExpressionContext);
      }
    }
    parameter(i) {
      if (i === void 0) {
        return this.getRuleContexts(ParameterContext);
      } else {
        return this.getRuleContext(i, ParameterContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterWhereExpression) {
        listener.enterWhereExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitWhereExpression) {
        listener.exitWhereExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitWhereExpression) {
        return visitor.visitWhereExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var LambdaExpressionContext = class extends ExpressionContext {
    AT() {
      return this.getToken(SalParser.AT, 0);
    }
    FUNCTION() {
      return this.getToken(SalParser.FUNCTION, 0);
    }
    COLON() {
      return this.getToken(SalParser.COLON, 0);
    }
    expression() {
      return this.getRuleContext(0, ExpressionContext);
    }
    parameter(i) {
      if (i === void 0) {
        return this.getRuleContexts(ParameterContext);
      } else {
        return this.getRuleContext(i, ParameterContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterLambdaExpression) {
        listener.enterLambdaExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitLambdaExpression) {
        listener.exitLambdaExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitLambdaExpression) {
        return visitor.visitLambdaExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var NumberContext = class extends ExpressionContext {
    NUMBER() {
      return this.getToken(SalParser.NUMBER, 0);
    }
    AT() {
      return this.tryGetToken(SalParser.AT, 0);
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterNumber) {
        listener.enterNumber(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitNumber) {
        listener.exitNumber(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitNumber) {
        return visitor.visitNumber(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var StringContext = class extends ExpressionContext {
    STRING() {
      return this.getToken(SalParser.STRING, 0);
    }
    AT() {
      return this.tryGetToken(SalParser.AT, 0);
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterString) {
        listener.enterString(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitString) {
        listener.exitString(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitString) {
        return visitor.visitString(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var VariableContext = class extends ExpressionContext {
    AT() {
      return this.getToken(SalParser.AT, 0);
    }
    word() {
      return this.getRuleContext(0, WordContext);
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterVariable) {
        listener.enterVariable(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitVariable) {
        listener.exitVariable(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitVariable) {
        return visitor.visitVariable(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var WordExpressionContext = class extends ExpressionContext {
    word() {
      return this.getRuleContext(0, WordContext);
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterWordExpression) {
        listener.enterWordExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitWordExpression) {
        listener.exitWordExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitWordExpression) {
        return visitor.visitWordExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var ListLiteralExpressionContext = class extends ExpressionContext {
    expression(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExpressionContext);
      } else {
        return this.getRuleContext(i, ExpressionContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterListLiteralExpression) {
        listener.enterListLiteralExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitListLiteralExpression) {
        listener.exitListLiteralExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitListLiteralExpression) {
        return visitor.visitListLiteralExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var RecordLiteralExpressionContext = class extends ExpressionContext {
    entry(i) {
      if (i === void 0) {
        return this.getRuleContexts(EntryContext);
      } else {
        return this.getRuleContext(i, EntryContext);
      }
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterRecordLiteralExpression) {
        listener.enterRecordLiteralExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitRecordLiteralExpression) {
        listener.exitRecordLiteralExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitRecordLiteralExpression) {
        return visitor.visitRecordLiteralExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };
  var ParenthesizedExpressionContext = class extends ExpressionContext {
    PAREN_BEGIN() {
      return this.getToken(SalParser.PAREN_BEGIN, 0);
    }
    expression() {
      return this.getRuleContext(0, ExpressionContext);
    }
    PAREN_END() {
      return this.getToken(SalParser.PAREN_END, 0);
    }
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      this.copyFrom(ctx);
    }
    // @Override
    enterRule(listener) {
      if (listener.enterParenthesizedExpression) {
        listener.enterParenthesizedExpression(this);
      }
    }
    // @Override
    exitRule(listener) {
      if (listener.exitParenthesizedExpression) {
        listener.exitParenthesizedExpression(this);
      }
    }
    // @Override
    accept(visitor) {
      if (visitor.visitParenthesizedExpression) {
        return visitor.visitParenthesizedExpression(this);
      } else {
        return visitor.visitChildren(this);
      }
    }
  };

  // source/sal/evaluator.ts
  var import_TerminalNode = __toESM(require_TerminalNode());
  var import_ErrorNode = __toESM(require_ErrorNode());
  var import_ParseTree = __toESM(require_ParseTree());
  var import_RuleNode = __toESM(require_RuleNode());
  var unreachable = (node) => {
    if (node instanceof import_TerminalNode.TerminalNode) {
      const symbol2 = node.symbol;
      const position = {
        line: symbol2.line,
        column: symbol2.charPositionInLine
      };
      return raise`unreachable: ${JSON.stringify(position)}, ${node.toString()}`;
    }
    return raise`unreachable: ${node.toStringTree()}`;
  };
  function getNumberValue(v) {
    return JSON.parse(v.text);
  }
  function getStringValue(v) {
    return JSON.parse(v.text);
  }
  function getWordValue(v) {
    return v.text;
  }
  function getNameOfWordOrString(e) {
    const v = e.STRING();
    if (v != null) return getStringValue(v);
    const w = e.word();
    if (w != null) return getWordValue(w);
    return unreachable(e);
  }
  function getParameterName(e) {
    return getWordValue(e.word());
  }
  function createNestedFunctionOrValue(scope, parameterNames, body) {
    const [p, ...ps] = parameterNames;
    if (p == void 0) return scope.visitExpression(body);
    return done((v) => {
      scope.environment.set(p, v);
      return createNestedFunctionOrValue(scope, ps, body);
    });
  }
  function forceAsFunction(x) {
    if (typeof x !== "function") return raise`${x} is not function`;
    return x;
  }
  var SalEvaluationVisitor = class _SalEvaluationVisitor {
    constructor(tryResolveParentVariable) {
      this.tryResolveParentVariable = tryResolveParentVariable;
      this.visit = unreachable;
      this.visitChildren = unreachable;
      this.visitTerminal = unreachable;
      this.visitErrorNode = unreachable;
      this.environment = /* @__PURE__ */ new Map();
      this.tryResolveVariable = (k) => {
        const v = this.environment.get(k);
        return v === void 0 ? tryResolveParentVariable(k) : v;
      };
    }
    resolveVariable(name) {
      const v = this.tryResolveVariable(name);
      if (v === void 0) throw new Error(`undefined variable: ${name}`);
      return v;
    }
    *evaluateBinaryLikeExpression(left, opName, right) {
      const l = yield* this.visitExpression(left);
      const f = forceAsFunction(
        this.resolveVariable(opName)
      );
      const r = yield* this.visitExpression(right);
      return yield* (yield* f(l))(r);
    }
    *visitExpression(e) {
      if (e.exception) {
        const fromVoid = forceAsFunction(
          this.resolveVariable("fromMissing")
        );
        return yield* fromVoid(null);
      }
      try {
        return yield* e.accept(this);
      } catch (error48) {
        let showPosition2 = function({ line, charPositionInLine }) {
          return `${line}:${charPositionInLine}`;
        };
        var showPosition = showPosition2;
        const start = showPosition2(e.start);
        const stop = e.stop ? `,${showPosition2(e.stop)}` : "";
        return raise`[${start}${stop}]: ${error48}`;
      }
    }
    visitSourceFile(e) {
      const body = e.expression();
      if (body == null) {
        const fromEmpty = forceAsFunction(this.resolveVariable("fromVoid"));
        return fromEmpty(null);
      }
      return this.visitExpression(body);
    }
    visitLambdaExpression(e) {
      const newScope = new _SalEvaluationVisitor(this.tryResolveVariable);
      const ps = e.parameter().map(getParameterName);
      const body = e.expression();
      return createNestedFunctionOrValue(newScope, ps, body);
    }
    *visitNotExpression(e) {
      const not2 = forceAsFunction(this.resolveVariable("not_"));
      const v = yield* this.visitExpression(e.expression());
      return yield* not2(v);
    }
    *visitApplyExpression(e) {
      const f = forceAsFunction(yield* this.visitExpression(e._left));
      const x = yield* this.visitExpression(e._right);
      return yield* f(x);
    }
    visitSequenceExpression(e) {
      return this.evaluateBinaryLikeExpression(e._left, "_seq_", e._right);
    }
    visitOrExpression(e) {
      return this.evaluateBinaryLikeExpression(e._left, "_or_", e._right);
    }
    visitAndExpression(e) {
      return this.evaluateBinaryLikeExpression(e._left, "_and_", e._right);
    }
    *visitBinaryExpression(e) {
      const l = yield* this.visitExpression(e._left);
      const op = forceAsFunction(
        this.resolveVariable(getWordValue(e.word()))
      );
      const r = yield* this.visitExpression(e._right);
      return yield* (yield* op(l))(r);
    }
    *visitWhereExpression(e) {
      const newScope = new _SalEvaluationVisitor(this.tryResolveVariable);
      const [param0, ...params] = e.parameter();
      const id2 = getParameterName(param0);
      const ps = params.map(getParameterName);
      const value = yield* createNestedFunctionOrValue(
        newScope,
        ps,
        e._value
      );
      newScope.environment.set(id2, value);
      return yield* newScope.visitExpression(e._scope);
    }
    visitNumber(e) {
      const value = getNumberValue(e.NUMBER());
      if (e.AT() != null) return done(value);
      const fromNumber = forceAsFunction(
        this.resolveVariable("fromNumber")
      );
      return fromNumber(value);
    }
    visitString(e) {
      const value = getStringValue(e.STRING());
      if (e.AT() != null) return done(value);
      const fromString2 = forceAsFunction(
        this.resolveVariable("fromString")
      );
      return fromString2(value);
    }
    visitVariable(e) {
      const name = getWordValue(e.word());
      return done(this.resolveVariable(name));
    }
    visitWordExpression(e) {
      return e.word().accept(this);
    }
    visitWord(e) {
      const name = getWordValue(e);
      const value = this.tryResolveVariable(name);
      if (value !== void 0) return done(value);
      const fromWord = forceAsFunction(
        this.resolveVariable("fromWord")
      );
      return fromWord(name);
    }
    visitParenthesizedExpression(e) {
      return this.visitExpression(e.expression());
    }
    evaluateExpressionAsLiteral(e) {
      if (e instanceof NumberContext) {
        return done(getNumberValue(e.NUMBER()));
      }
      if (e instanceof StringContext) {
        return done(getStringValue(e.STRING()));
      }
      return this.visitExpression(e);
    }
    *visitListLiteralExpression(e) {
      const getEmptyList = forceAsFunction(
        this.resolveVariable("getEmptyList")
      );
      let list = yield* getEmptyList(null);
      let consList;
      for (const item of e.expression()) {
        const x = yield* this.evaluateExpressionAsLiteral(item);
        consList ??= forceAsFunction(
          this.resolveVariable("consList")
        );
        list = yield* (yield* consList(list))(x);
      }
      return list;
    }
    *visitRecordLiteralExpression(e) {
      const getEmptyRecord = forceAsFunction(
        this.resolveVariable("getEmptyRecord")
      );
      let record3 = yield* getEmptyRecord(null);
      let consRecord;
      for (const entry of e.entry()) {
        const key = getNameOfWordOrString(entry);
        const value = yield* this.evaluateExpressionAsLiteral(
          entry.expression()
        );
        consRecord ??= forceAsFunction(this.resolveVariable("consRecord"));
        record3 = yield* (yield* (yield* consRecord(record3))(key))(value);
      }
      return record3;
    }
  };
  function createStandardGlobals() {
    const globals = {
      fromVoid(_) {
        return done("fromVoid");
      },
      fromMissing(_) {
        return done("fromMissing");
      },
      fromWord(x) {
        return done(`fromWord(${x})`);
      },
      fromString(x) {
        return done(`fromString(${x})`);
      },
      fromNumber(x) {
        return done(`fromNumber(${x})`);
      },
      getEmptyList(_) {
        return done([]);
      },
      consList(list) {
        return done((item) => {
          list.push(item);
          return done(list);
        });
      },
      getEmptyRecord(_) {
        const x = /* @__PURE__ */ Object.create(null);
        return done(x);
      },
      consRecord(record3) {
        return done((k) => {
          return done((v) => {
            record3[k] = v;
            return done(record3);
          });
        });
      },
      not_(x) {
        return done(`not(${x})`);
      },
      _seq_(x) {
        return done((y) => done(`seq(${x}, ${y})`));
      },
      _or_(x) {
        return done((y) => done(`or(${x}, ${y})`));
      },
      _and_(x) {
        return done((y) => done(`and(${x}, ${y})`));
      }
    };
    return new Map(Object.entries(globals));
  }
  function evaluateExpression(source, resolveGlobal) {
    const chars = import_antlr4ts.CharStreams.fromString(source);
    const lexer = new SalLexer(chars);
    const tokens = new import_antlr4ts.CommonTokenStream(lexer);
    const parser = new SalParser(tokens);
    const tree = parser.sourceFile();
    const globals = createStandardGlobals();
    const tryResolveGlobalVariable = (k) => {
      const v = resolveGlobal(k);
      if (v !== void 0) return v;
      return globals.get(k);
    };
    return tree.accept(new SalEvaluationVisitor(tryResolveGlobalVariable));
  }

  // source/drafts-view/draft-filter.ts
  async function getDraftStat(source, cell14, signal) {
    const cell14Drafts = source.cell14DraftsLazy();
    const cell14Id = cell14.toString();
    const draft14 = cell14Drafts.get(cell14Id);
    if (draft14 == null) return;
    const stat14 = await source.cell14StatMemoized(cell14, signal);
    if (stat14 == null) return;
    let potentialStops = 0;
    for (const cell17IdOnDraft of draft14.cell17Drafts) {
      const stat17 = stat14.cell17s.get(cell17IdOnDraft);
      const stopCount = (stat17?.kindToCount.get("POKESTOP") ?? 0) + (stat17?.kindToCount.get("GYM") ?? 0);
      if (stopCount === 0) {
        potentialStops++;
      }
    }
    return {
      potentialStops
    };
  }
  async function getCell17(resource, cell, signal) {
    const cell14 = createCellFromCoordinates(cell.getLatLng(), 14);
    const stat = await resource.cell14StatMemoized(cell14, signal);
    if (stat == null) return;
    const cell17Id = getCellId(cell.getLatLng(), 17);
    return stat.cell17s.get(cell17Id);
  }
  function createEnvironment(records, drafts) {
    const resource = {
      records,
      cell14DraftsLazy: cached(() => buildDraftMap(drafts)),
      cell14StatMemoized: memoizeWith(
        (cell, _) => cell.toString(),
        (_, cell, signal) => getCell14Stats(records, cell, signal)
      ),
      draftStatMemoized: memoizeWith(
        (cell, _) => cell.toString(),
        (_, cell, signal) => getDraftStat(resource, cell, signal)
      )
    };
    const duration3 = 60 * 60 * 24 * 7;
    const minFreshDate = Date.now() - duration3 * 1e3;
    return {
      getUserLocation() {
        return done({
          lat: 0,
          lng: 0
        });
      },
      *getCell14Stat(d) {
        const signal = yield* getCancel();
        return yield* awaitPromise(
          resource.cell14StatMemoized(
            createCellFromCoordinates(d.coordinates[0], 14),
            signal
          )
        );
      },
      *getCell17Stat(d) {
        const signal = yield* getCancel();
        return yield* awaitPromise(
          getCell17(
            resource,
            createCellFromCoordinates(d.coordinates[0], 17),
            signal
          )
        );
      },
      *getCell14DraftStat(d) {
        const signal = yield* getCancel();
        return yield* awaitPromise(
          resource.draftStatMemoized(
            createCellFromCoordinates(d.coordinates[0], 14),
            signal
          )
        );
      },
      getMinFreshDate() {
        return done(minFreshDate);
      }
    };
  }
  async function filterDrafts(records, drafts, source, signal) {
    const queryGlobals = createStandardQueries();
    const effective = evaluateExpression(source, (k) => queryGlobals.get(k));
    const filter = await forceAsPromise(effective, signal);
    const queryBuilder = filter;
    const environment = createEnvironment(records, drafts);
    const query = await forceAsPromise(
      queryBuilder.initialize(environment),
      signal
    );
    const result = [];
    let error48 = null;
    for (const d of drafts) {
      let isVisible = false;
      try {
        isVisible = await forceAsPromise(query.isVisible(d), signal);
      } catch (e) {
        error48 ??= e;
      }
      if (isVisible) {
        result.push(d);
      }
    }
    if (error48) console.error(error48);
    return result;
  }

  // source/drafts-view/query-view/editor.module.css
  var cssText10 = '.container-d2884e1bfe18458a2c14f99c2858b84b0436b9fe {\r\n    height: 100%;\r\n    width: 100%;\r\n    overflow: hidden;\r\n}\r\n.textarea-9ee51246f4e15195eb839d111a36d9a96536f0f4 {\r\n    height: 100%;\r\n    width: 100%;\r\n    resize: none;\r\n    font-family: "Courier New", Courier, monospace;\r\n\r\n    background-color: transparent;\r\n}\r\n';
  var editor_default = {
    container: "container-d2884e1bfe18458a2c14f99c2858b84b0436b9fe",
    textarea: "textarea-9ee51246f4e15195eb839d111a36d9a96536f0f4"
  };

  // source/drafts-view/query-view/editor.tsx
  var setStyle10 = styleSetter(cssText10);
  function createEditor({ initialText }) {
    setStyle10();
    const events = createTypedEventTarget();
    const textarea = /* @__PURE__ */ jsx(
      "textarea",
      {
        class: editor_default.textarea,
        oninput: (e) => {
          const target = e.target;
          events.dispatchEvent(
            createTypedCustomEvent("input", target.value)
          );
        },
        children: initialText
      }
    );
    const element = /* @__PURE__ */ jsx("div", { class: editor_default.container, children: textarea });
    function setSource(value) {
      textarea.value = value;
    }
    return {
      element,
      events,
      setSource
    };
  }

  // source/drafts-view/draft-list.tsx
  function newFreshId(baseName, definedIds) {
    const names = new Set(definedIds);
    for (let i = 2; ; i++) {
      const id2 = `${baseName}${i}`;
      if (!names.has(id2)) return id2;
    }
  }
  function toSpliced(array3, start, deleteCount, ...items) {
    const result = [...array3];
    result.splice(start, deleteCount, ...items);
    return result;
  }
  function hasMinLength(items, length) {
    return items.length >= length;
  }
  function isTrivial({ id: id2, contents }, { sources }) {
    return contents === "" || contents.length <= 1 || sources.find((s) => s.id !== id2 && s.contents === contents);
  }
  var setStyle11 = styleSetter(cssText4);
  function createDraftList({
    overlay,
    remote,
    records,
    local,
    handleAsyncError: handleAsyncError2
  }) {
    setStyle11();
    const events = createTypedEventTarget();
    let allDrafts = Array.from(overlay.drafts.values()).map(
      (view) => view.draft
    );
    let filteredDrafts = [...allDrafts];
    let selectedDraft = null;
    let currentSources = local.getConfig().sources || {
      selectedIndex: 0,
      sources: [{ id: "source0", contents: "" }]
    };
    const sourceList = createSourceList({ initialList: currentSources });
    const sourceListDialog = createDialog(sourceList.element, {
      title: "\u691C\u7D22\u4E00\u89A7"
    });
    const editor = createEditor({ initialText: getSelectedSource() ?? "" });
    const editorDialog = createDialog(editor.element, {
      title: "\u691C\u7D22\u30EF\u30FC\u30C9\u3092\u7DE8\u96C6"
    });
    sourceList.events.addEventListener("select", ({ detail: index }) => {
      setCurrentSourcesAndNotify({
        ...currentSources,
        selectedIndex: index
      });
    });
    sourceList.events.addEventListener("delete", ({ detail: index }) => {
      const oldSource = currentSources.sources[index];
      if (oldSource == null || !hasMinLength(currentSources.sources, 2)) {
        return;
      }
      const oldSources = currentSources.sources;
      if (!isTrivial(oldSource, currentSources) && !confirm(
        `\u672C\u5F53\u306B ${JSON.stringify(
          oldSource.contents
        )} (id: ${JSON.stringify(oldSource.id)}) \u3092\u524A\u9664\u3057\u307E\u3059\u304B\uFF1F`
      )) {
        return;
      }
      const newSources = toSpliced(oldSources, index, 1);
      const newIndex = currentSources.sources.length === 0 ? null : currentSources.sources.length <= index + 1 ? index - 1 : index;
      setCurrentSourcesAndNotify({
        ...currentSources,
        selectedIndex: newIndex,
        sources: newSources
      });
    });
    sourceList.events.addEventListener("add", () => {
      const id2 = newFreshId(
        "source",
        currentSources.sources.map((s) => s.id)
      );
      const contents = getSelectedSource() ?? "";
      const newSource = { id: id2, contents };
      const index = currentSources.selectedIndex === null ? 0 : currentSources.selectedIndex + 1;
      const sources = toSpliced(currentSources.sources, index, 0, newSource);
      setCurrentSourcesAndNotify({
        ...currentSources,
        selectedIndex: index,
        sources
      });
    });
    editor.events.addEventListener("input", ({ detail: value }) => {
      setSelectedSourceAndNotify(value);
    });
    function setCurrentSourcesAndNotify(newSources) {
      currentSources = newSources;
      sourceList.setSources(currentSources);
      const selectedSource = getSelectedSource() ?? "";
      filterInput.setValue(selectedSource);
      requestFilterUpdate();
      editor.setSource(selectedSource);
      local.setConfig({ ...local.getConfig(), sources: currentSources });
    }
    function getSelectedSource() {
      return currentSources.sources[currentSources.selectedIndex ?? -1]?.contents;
    }
    function setSelectedSourceAndNotify(newContents) {
      const index = currentSources.selectedIndex ?? -1;
      const source = currentSources.sources[index];
      if (source == null) return;
      const sources = toSpliced(currentSources.sources, index, 1, {
        ...source,
        contents: newContents
      });
      setCurrentSourcesAndNotify({ ...currentSources, sources });
    }
    overlay.events.addEventListener("selection-changed", ({ detail: id2 }) => {
      if (id2 == null) {
        selectedDraft = null;
      } else {
        const draft = allDrafts.find((x) => x.id === id2);
        if (draft == null) return;
        selectedDraft = draft;
      }
      updateDetailPane();
      updateVirtualList();
    });
    overlay.events.addEventListener("draft-updated", ({ detail: id2 }) => {
      const draft = allDrafts.find((x) => x.id === id2);
      if (draft == null) return;
      updateDetailPane();
      updateVirtualList();
      saveDraftChanges(draft);
    });
    const dispatchCountUpdatedEvent = () => {
      events.dispatchEvent(
        createTypedCustomEvent("count-changed", {
          totalCount: allDrafts.length,
          filteredCount: filteredDrafts.length
        })
      );
    };
    dispatchCountUpdatedEvent();
    const saveDraftChanges = (draft) => {
      const { apiRoot, userId } = local.getConfig();
      if (!apiRoot || !userId) return;
      remote.set(
        {
          type: "route",
          "user-id": userId,
          "route-id": draft.id,
          "route-name": draft.name,
          coordinates: coordinatesToString(draft.coordinates),
          description: draft.description,
          note: draft.note,
          data: JSON.stringify(draft.data)
        },
        apiRoot
      );
    };
    const { element: virtualListElement, setItems: setVirtualListItems } = createVirtualList();
    const filterInput = createFilterBar({ value: getSelectedSource() ?? "" });
    filterInput.events.addEventListener("input-changed", () => {
      setSelectedSourceAndNotify(filterInput.getValue());
    });
    filterInput.events.addEventListener("click-list-button", () => {
      sourceListDialog.show();
    });
    filterInput.events.addEventListener("click-edit-button", () => {
      editorDialog.show();
    });
    const detailName = /* @__PURE__ */ jsx(
      "input",
      {
        type: "text",
        value: "",
        classList: [draft_list_default["detail-name"], draft_list_default["input-field"]],
        oninput: (event) => {
          if (!selectedDraft) return;
          selectedDraft.name = event.target.value;
          overlay.updateDraftTitle(selectedDraft);
          saveDraftChanges(selectedDraft);
        }
      }
    );
    const detailDescription = /* @__PURE__ */ jsx(
      "textarea",
      {
        value: "",
        classList: [
          draft_list_default["detail-description"],
          draft_list_default["input-field"]
        ],
        oninput: (event) => {
          if (!selectedDraft) return;
          selectedDraft.description = event.target.value;
          saveDraftChanges(selectedDraft);
        }
      }
    );
    const detailNote = /* @__PURE__ */ jsx(
      "textarea",
      {
        classList: [draft_list_default["detail-note"], draft_list_default["input-field"]],
        value: "",
        oninput: (event) => {
          if (!selectedDraft) return;
          selectedDraft.note = event.target.value;
          saveDraftChanges(selectedDraft);
        }
      }
    );
    const detailCoordinates = /* @__PURE__ */ jsx(
      "input",
      {
        type: "text",
        value: "",
        classList: [
          draft_list_default["detail-coordinates"],
          draft_list_default["input-field"]
        ],
        oninput: (event) => {
          if (!selectedDraft) return;
          const textarea = event.target;
          try {
            const newCoordinates = parseCoordinates(textarea.value);
            if (newCoordinates.length > 0) {
              selectedDraft.coordinates = newCoordinates;
              textarea.classList.remove(draft_list_default["input-error"]);
            } else {
              textarea.classList.add(draft_list_default["input-error"]);
              return;
            }
          } catch (e) {
            console.error("Failed to parse coordinates:", e);
            textarea.classList.add(draft_list_default["input-error"]);
            return;
          }
          overlay.updateDraftCoordinates(selectedDraft);
          saveDraftChanges(selectedDraft);
        }
      }
    );
    const deleteButton = /* @__PURE__ */ jsx(
      "button",
      {
        class: draft_list_default["delete-button"],
        onclick: () => {
          if (!selectedDraft) {
            alert("\u524A\u9664\u3059\u308B\u5019\u88DC\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002");
            return;
          }
          if (confirm(`\u672C\u5F53\u306B\u300C${selectedDraft.name}\u300D\u3092\u524A\u9664\u3057\u307E\u3059\u304B\uFF1F`)) {
            deleteSelectedDraft(selectedDraft.id);
          }
        },
        children: "\u{1F5D1}\uFE0F\u524A\u9664"
      }
    );
    const mapButton = /* @__PURE__ */ jsx(
      "button",
      {
        class: draft_list_default["map-button"],
        onclick: () => {
          if (selectedDraft) {
            overlay.map.setCenter(selectedDraft.coordinates[0]);
          }
        },
        children: "\u{1F3AF}\u5730\u56F3\u3067\u8868\u793A"
      }
    );
    const templateToggleButton = /* @__PURE__ */ jsx(
      "button",
      {
        class: draft_list_default["template-button"],
        onclick: () => {
          if (!selectedDraft) return;
          if (getDraftIsTemplate(selectedDraft)) {
            setDraftIsTemplate(selectedDraft, false);
            saveDraftChanges(selectedDraft);
          } else {
            const currentTemplate = allDrafts.find(
              (d) => getDraftIsTemplate(d)
            );
            if (currentTemplate) {
              setDraftIsTemplate(currentTemplate, false);
              saveDraftChanges(currentTemplate);
            }
            setDraftIsTemplate(selectedDraft, true);
            saveDraftChanges(selectedDraft);
          }
          updateVirtualList();
          updateDetailPane();
        },
        children: "\u{1F4C4}\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8"
      }
    );
    const configView = createLocalConfigView(local);
    const configDialog = createDialog(configView.element, { title: "\u8A2D\u5B9A" });
    const deleteSelectedDraft = (draftId) => {
      const { apiRoot, userId } = local.getConfig();
      if (!userId || !apiRoot) {
        console.error(
          "User ID or API Root not available. Cannot delete draft."
        );
        return;
      }
      overlay.deleteDraft(draftId);
      allDrafts = allDrafts.filter((d) => d.id !== draftId);
      filteredDrafts = filteredDrafts.filter((d) => d.id !== draftId);
      if (selectedDraft?.id === draftId) {
        selectedDraft = null;
        updateDetailPane();
      }
      updateVirtualList();
      remote.delete(
        {
          "route-id": draftId
        },
        apiRoot
      );
    };
    const container = /* @__PURE__ */ jsxs("div", { class: draft_list_default["container"], children: [
      filterInput.element,
      /* @__PURE__ */ jsx("div", { class: draft_list_default["list-container"], children: virtualListElement }),
      /* @__PURE__ */ jsxs("details", { class: draft_list_default["detail-pane"], open: true, children: [
        /* @__PURE__ */ jsx("summary", { class: draft_list_default["detail-summary"], children: detailName }),
        /* @__PURE__ */ jsxs("div", { class: draft_list_default["detail-content-wrapper"], children: [
          detailDescription,
          detailNote,
          detailCoordinates,
          /* @__PURE__ */ jsx(
            "button",
            {
              class: draft_list_default["create-button"],
              onclick: () => addNewDraft(),
              children: "\u{1F4CD}\u65B0\u898F\u4F5C\u6210"
            }
          ),
          deleteButton,
          mapButton,
          templateToggleButton,
          /* @__PURE__ */ jsx(
            "button",
            {
              class: draft_list_default["config-button"],
              onclick: () => {
                configDialog.show();
              },
              children: "\u2699\uFE0F\u8A2D\u5B9A"
            }
          )
        ] })
      ] })
    ] });
    const addNewDraft = () => {
      const { userId } = local.getConfig();
      if (!userId) {
        console.error("User ID not available. Cannot create draft.");
        return;
      }
      const center = overlay.map.getCenter();
      if (!center) return;
      const newDraftId = `draft-${Date.now()}-${Math.floor(
        Math.random() * 1e6
      )}`;
      const newDraft = {
        id: newDraftId,
        type: "route",
        userId,
        name: "\u65B0\u3057\u3044\u5019\u88DC",
        coordinates: [{ lat: center.lat(), lng: center.lng() }],
        description: "",
        note: "",
        data: {}
      };
      const templateDraft = allDrafts.find((d) => getDraftIsTemplate(d));
      if (templateDraft) {
        newDraft.name = applyTemplate(templateDraft.name);
        newDraft.description = applyTemplate(templateDraft.description);
        newDraft.note = applyTemplate(templateDraft.note);
        newDraft.data = structuredClone(templateDraft.data);
        setDraftIsTemplate(newDraft, false);
      }
      overlay.addDraft(newDraft);
      overlay.select(newDraft.id);
      selectedDraft = newDraft;
      updateDetailPane();
      updateVirtualList();
      dispatchCountUpdatedEvent();
      saveDraftChanges(newDraft);
    };
    const updateDetailPane = () => {
      if (selectedDraft) {
        detailName.value = selectedDraft.name;
        detailDescription.value = selectedDraft.description;
        detailNote.value = selectedDraft.note;
        detailCoordinates.value = coordinatesToString(
          selectedDraft.coordinates
        );
        detailCoordinates.classList.remove(draft_list_default["input-error"]);
        mapButton.style.display = "";
        deleteButton.style.display = "";
        templateToggleButton.style.display = "";
        if (getDraftIsTemplate(selectedDraft)) {
          templateToggleButton.textContent = "\u{1F4C4}\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8 (\u8A2D\u5B9A\u6E08\u307F)";
          templateToggleButton.classList.add(draft_list_default["is-template"]);
        } else {
          templateToggleButton.textContent = "\u{1F4C4}\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8\u306B\u8A2D\u5B9A";
          templateToggleButton.classList.remove(
            draft_list_default["is-template"]
          );
        }
      } else {
        detailName.value = "";
        detailDescription.value = "";
        detailNote.value = "";
        detailCoordinates.value = "";
        detailCoordinates.classList.remove(draft_list_default["input-error"]);
        mapButton.style.display = "none";
        deleteButton.style.display = "none";
        templateToggleButton.style.display = "none";
      }
    };
    updateDetailPane();
    const applyFilterCancelScope = createAsyncCancelScope(handleAsyncError2);
    const requestFilterUpdate = () => applyFilterCancelScope(async (signal) => {
      await sleep(500, { signal });
      const query = getSelectedSource() ?? "";
      events.dispatchEvent(
        createTypedCustomEvent("filter-start", void 0)
      );
      try {
        filteredDrafts = await filterDrafts(
          records,
          allDrafts,
          query,
          signal
        );
      } finally {
        events.dispatchEvent(
          createTypedCustomEvent("filter-end", void 0)
        );
      }
      dispatchCountUpdatedEvent();
      updateVirtualList();
    });
    const updateVirtualList = () => {
      const virtualElements = {
        itemHeight: 40,
        count: filteredDrafts.length,
        get: (index) => {
          const draft = filteredDrafts[index];
          if (!draft) return void 0;
          const item = document.createElement("div");
          item.className = draft_list_default["item"];
          if (selectedDraft && selectedDraft.id === draft.id) {
            item.classList.add(draft_list_default["selected"]);
          }
          const nameDiv = document.createElement("div");
          nameDiv.className = draft_list_default["item-name"];
          nameDiv.textContent = draft.name;
          const noteDiv = document.createElement("div");
          noteDiv.className = draft_list_default["item-note"];
          noteDiv.textContent = draft.note;
          item.append(nameDiv, noteDiv);
          const onClick = () => {
            overlay.select(draft.id);
            updateDetailPane();
            updateVirtualList();
          };
          const onDblclick = () => {
            if (draft) {
              overlay.map.setCenter(draft.coordinates[0]);
            }
          };
          let clickTimer = null;
          item.addEventListener("click", () => {
            clickTimer = setTimeout(() => {
              selectedDraft = draft;
              onClick();
              clickTimer = null;
            }, 0);
          });
          item.addEventListener("dblclick", () => {
            if (clickTimer !== null) clearTimeout(clickTimer);
            clickTimer = null;
            onDblclick();
          });
          return item;
        }
      };
      setVirtualListItems(virtualElements);
    };
    updateVirtualList();
    return {
      events,
      element: container,
      setDrafts(newDrafts) {
        allDrafts.splice(0, allDrafts.length, ...newDrafts);
        requestFilterUpdate();
        if (selectedDraft && !newDrafts.some((d) => d.id === selectedDraft?.id)) {
          selectedDraft = null;
          updateDetailPane();
        }
      }
    };
  }

  // source/locales/ja.json
  var ja_default2 = {
    draftsTitle: "\u5019\u88DC"
  };

  // source/drafts-view/drafts-dialog-title.module.css
  var cssText11 = ":root {\n    --text-color-b5fcef7c2e75eaff3726c619b44d741fa4d5c907: #333;\n    --secondary-text-color-688b6add60d632c00d21958cec42f53996ebfce5: #666;\n    --primary-color-85c1441dbfb39319542140435119ee442e85721a: #007bff;\n    --background-color-light-d3c1d427ed49fb706d5d27ecc2e2bf2144145b42: #f8f9fa;\n    --border-color-0c4d1205af0f0747deb181610984f634e079550a: #dee2e6;\n}\n\n.container-3a7a3702be125e4c680a49a5f6b48a0685a89213 {\n    display: flex;\n    align-items: center;\n    border-bottom: 1px solid var(--border-color-0c4d1205af0f0747deb181610984f634e079550a);\n    color: var(--text-color-b5fcef7c2e75eaff3726c619b44d741fa4d5c907);\n    gap: 10px;\n}\n\n.main-title-af45008e5a094765ba2506a66e549cf852ebcfe3 {\n    font-size: 1.2em;\n    font-weight: bold;\n    color: var(--text-color-b5fcef7c2e75eaff3726c619b44d741fa4d5c907);\n    flex-grow: 1;\n}\n\n.counts-element-a73b5f2718d6c70b187f8e1f493bdd0805dd7a96 {\n    font-size: 0.9em;\n    color: var(--secondary-text-color-688b6add60d632c00d21958cec42f53996ebfce5);\n    white-space: nowrap;\n}\n\n.saving-indicator-ff5b78079ff0b8a9d57fab5841cd61fa1bbc9865 {\n    display: none;\n    font-size: 0.85em;\n    color: var(--primary-color-85c1441dbfb39319542140435119ee442e85721a);\n    margin-left: auto;\n    white-space: nowrap;\n}\n\n.saving-63a9f84c54405daf885a836d67ad7091a22f7475 {\n    display: unset;\n    animation: blink 0.7s infinite steps(1);\n}\n\n@keyframes blink {\n    0% {\n        opacity: 0;\n    }\n\n    50% {\n        opacity: 1;\n    }\n\n    100% {\n        opacity: 0;\n    }\n}\n";
  var drafts_dialog_title_default = {
    container: "container-3a7a3702be125e4c680a49a5f6b48a0685a89213",
    "main-title": "main-title-af45008e5a094765ba2506a66e549cf852ebcfe3",
    "counts-element": "counts-element-a73b5f2718d6c70b187f8e1f493bdd0805dd7a96",
    "saving-indicator": "saving-indicator-ff5b78079ff0b8a9d57fab5841cd61fa1bbc9865",
    saving: "saving-63a9f84c54405daf885a836d67ad7091a22f7475"
  };

  // source/drafts-view/indicator.module.css
  var cssText12 = ".loader-62b568c1cf31831c16b87cb441cc3a63b60f4dbd {\n    position: relative;\n    width: 1rem;\n    height: 1rem;\n}\n\n.orb-86b430db43d2410a62a17c1ee0232463705b2aa5 {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    background: radial-gradient(\n        circle,\n        rgba(59, 130, 246, 0.95) 0%,\n        rgba(96, 165, 250, 0.6) 45%,\n        rgba(147, 197, 253, 0.25) 75%,\n        transparent 100%\n    );\n    box-shadow:\n        0 0 4px rgba(96, 165, 250, 0.8),\n        0 0 8px rgba(147, 197, 253, 0.5);\n    transform: translate(-50%, -50%);\n    opacity: 0;\n    animation: pulse var(--pulseDur-cefcb0590d6e63a0997f5b774909fa76285c1337, 2.6s) ease-in-out infinite;\n}\n\n@keyframes pulse {\n    0%,\n    100% {\n        opacity: 0.35;\n        filter: blur(0.6px);\n    }\n\n    50% {\n        opacity: 1;\n        filter: blur(0);\n    }\n}\n\n@keyframes softAppear {\n    from {\n        opacity: 0;\n        filter: blur(2px);\n    }\n\n    to {\n        opacity: 0.9;\n        filter: blur(0.6px);\n    }\n}\n\n@keyframes endFade {\n    to {\n        opacity: 0;\n        filter: blur(2px);\n    }\n}\n\n.starting-02933a59452e89089c97a52e6fe88a96cf4766d4 .orb-86b430db43d2410a62a17c1ee0232463705b2aa5 {\n    animation: softAppear 0.35s ease-out forwards;\n}\n\n.ending-701c23d5aacc00f9e4c0bb8ae539ee979c42e024 .orb-86b430db43d2410a62a17c1ee0232463705b2aa5 {\n    animation: endFade 0.4s ease-in forwards;\n}\n";
  var variables3 = {
    "--pulseDur": "--pulseDur-cefcb0590d6e63a0997f5b774909fa76285c1337"
  };
  var indicator_default = {
    loader: "loader-62b568c1cf31831c16b87cb441cc3a63b60f4dbd",
    orb: "orb-86b430db43d2410a62a17c1ee0232463705b2aa5",
    starting: "starting-02933a59452e89089c97a52e6fe88a96cf4766d4",
    ending: "ending-701c23d5aacc00f9e4c0bb8ae539ee979c42e024"
  };

  // source/drafts-view/indicator.tsx
  var setStyle12 = styleSetter(cssText12);
  function createIndicator() {
    setStyle12();
    const loader = /* @__PURE__ */ jsxs("div", { class: indicator_default.loader, "aria-label": "Communicating", children: [
      /* @__PURE__ */ jsx("div", { class: indicator_default.orb }),
      /* @__PURE__ */ jsx("div", { class: indicator_default.orb }),
      /* @__PURE__ */ jsx("div", { class: indicator_default.orb }),
      /* @__PURE__ */ jsx("div", { class: indicator_default.orb })
    ] });
    const orbs = [
      ...loader.getElementsByClassName(indicator_default.orb)
    ];
    const intervals = [];
    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }
    function setOrbPosition(orb, x, y) {
      orb.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
      orb._x = x;
      orb._y = y;
    }
    function animateOrbit(orb) {
      const radius = rand(5, 12);
      const duration3 = rand(2.5, 5);
      const drift = rand(-0.6, 0.6);
      const startAngle = Math.atan2(orb._y || 0, orb._x || 0);
      let start = null;
      function frame(ts) {
        if (!start) start = ts;
        const t = (ts - start) / 1e3;
        const angle = startAngle + t * (Math.PI * 2 / duration3) + Math.sin(t) * drift;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        setOrbPosition(orb, x, y);
        orb._anim = requestAnimationFrame(frame);
      }
      orb._anim = requestAnimationFrame(frame);
    }
    function randomizePulse(orb) {
      orb.style.setProperty(variables3["--pulseDur"], rand(2, 4) + "s");
    }
    function startCommunication() {
      loader.classList.remove(indicator_default.ending);
      loader.classList.add(indicator_default.starting);
      loader.classList.remove(indicator_default.starting);
      orbs.forEach((orb) => {
        orb.style.opacity = String(0.9);
        randomizePulse(orb);
        animateOrbit(orb);
        const id2 = setInterval(() => randomizePulse(orb), rand(3e3, 5e3));
        intervals.push(id2);
      });
    }
    function stopCommunication() {
      loader.classList.add(indicator_default.ending);
      setTimeout(() => {
        intervals.forEach(clearInterval);
        intervals.length = 0;
        orbs.forEach((o) => cancelAnimationFrame(o._anim));
      }, 400);
    }
    stopCommunication();
    return {
      element: loader,
      start: startCommunication,
      stop: stopCommunication
    };
  }

  // source/drafts-view/drafts-dialog-title.tsx
  var setStyle13 = styleSetter(cssText11);
  function createDraftsDialogTitle({ title }) {
    setStyle13();
    const mainTitleElement = /* @__PURE__ */ jsx("div", { class: drafts_dialog_title_default["main-title"], children: title });
    const countsElement = /* @__PURE__ */ jsx("div", { class: drafts_dialog_title_default["counts-element"] });
    const indicator = createIndicator();
    const element = /* @__PURE__ */ jsxs("div", { class: drafts_dialog_title_default.container, children: [
      mainTitleElement,
      countsElement,
      indicator.element
    ] });
    let busyCount = 0;
    let currentIsBusy;
    function changeIsBusy() {
      const isBusy = 0 < busyCount;
      if (currentIsBusy !== isBusy) {
        if (isBusy) {
          indicator.start();
        } else {
          indicator.stop();
        }
        currentIsBusy = isBusy;
      }
    }
    return {
      element,
      setCounts({
        totalCount,
        filteredCount
      }) {
        if (filteredCount !== totalCount) {
          countsElement.innerText = `${filteredCount}/${totalCount}\u4EF6`;
        } else {
          countsElement.innerText = `${totalCount}\u4EF6`;
        }
      },
      pushIsBusy() {
        busyCount++;
        changeIsBusy();
      },
      popIsBusy() {
        busyCount--;
        changeIsBusy();
      }
    };
  }

  // source/setup.ts
  var localConfigKey = "wayfarer-map-extension-f079bd37-f7cd-4d65-9def-f0888b70b231";
  function handleAsyncError(reason) {
    console.error("An error occurred during asynchronous processing:", reason);
  }
  async function getGMapObject(options) {
    return await awaitElement(() => {
      try {
        const e = document.querySelector("app-wf-base-map");
        return e.__ngContext__[27];
      } catch {
        return null;
      }
    }, options);
  }
  var defaultDictionary = ja_default2;
  function setupWorkerRecorder(events) {
    const mainApi = {
      dispatchEvent(type, data) {
        events.dispatchEvent(createTypedCustomEvent(type, data));
      }
    };
    const recordsWorker = new Worker2();
    expose(mainApi, recordsWorker);
    const workerApi = wrap2(recordsWorker);
    injectGcsListener((url2, responseText) => {
      events.dispatchEvent(createTypedCustomEvent("gcs-received", void 0));
      workerApi.onGcsReceived(url2.toString(), responseText).catch(handleAsyncError);
    });
  }
  function getDictionaryEntry(page, key) {
    const lang = navigator.language;
    return page.local.getConfig()?.dictionaries?.[lang]?.[key] ?? page.defaultDictionary[key];
  }
  function setupDraftManagerDialog(page) {
    const draftList = createDraftList({
      overlay: page.drafts,
      remote: page.remote,
      records: page.records,
      local: page.local,
      handleAsyncError
    });
    const title = createDraftsDialogTitle({
      title: getDictionaryEntry(page, "draftsTitle")
    });
    const drafts = createDialog(draftList.element, {
      title: title.element
    });
    drafts.show();
    document.body.append(drafts.element);
    draftList.events.addEventListener("count-changed", (e) => {
      title.setCounts(e.detail);
    });
    draftList.events.addEventListener("filter-start", () => title.pushIsBusy());
    draftList.events.addEventListener("filter-end", () => title.popIsBusy());
    page.remote.events.addEventListener(
      "fetch-start",
      () => title.pushIsBusy()
    );
    page.remote.events.addEventListener("fetch-end", () => title.popIsBusy());
    page.drafts.events.addEventListener(
      "drafts-updated",
      (e) => draftList.setDrafts(e.detail)
    );
  }
  async function asyncSetup(signal) {
    await awaitElement(() => document.querySelector("#wfmapmods-side-panel"), {
      signal
    });
    const map2 = await getGMapObject({ signal });
    const events = createTypedEventTarget();
    const local = createConfigAccessor(localConfigKey);
    local.events.addEventListener(
      "config-changed",
      () => events.dispatchEvent(
        createTypedCustomEvent("config-changed", void 0)
      )
    );
    const scheduler = createScheduler(signal);
    const page = {
      records: await openRecords(),
      remote: createRemote(handleAsyncError, 2e3),
      styleElement: document.createElement("style"),
      map: map2,
      defaultAsyncErrorHandler: handleAsyncError,
      overlay: createPoisOverlay(map2),
      events,
      local,
      drafts: createDraftsOverlay(map2, handleAsyncError),
      defaultDictionary
    };
    document.head.appendChild(page.styleElement);
    setupWorkerRecorder(events);
    setupPoiRecordOverlay(page);
    setupDraftManagerDialog(page);
    await setupDraftsOverlay(page.drafts, local, scheduler);
  }
  function setup() {
    const cancel = new AbortController();
    asyncSetup(cancel.signal).catch(handleAsyncError);
  }

  // wayfarer-map-extension.user.ts
  setup();
})();
/*! Bundled license information:

antlr4ts/ANTLRErrorListener.js:
antlr4ts/ANTLRErrorStrategy.js:
antlr4ts/Decorators.js:
antlr4ts/IntStream.js:
antlr4ts/ANTLRInputStream.js:
antlr4ts/atn/ATNState.js:
antlr4ts/atn/ATNStateType.js:
antlr4ts/RecognitionException.js:
antlr4ts/atn/Transition.js:
antlr4ts/atn/AbstractPredicateTransition.js:
antlr4ts/misc/MurmurHash.js:
antlr4ts/misc/ObjectEqualityComparator.js:
antlr4ts/misc/DefaultEqualityComparator.js:
antlr4ts/misc/Array2DHashSet.js:
antlr4ts/misc/ArrayEqualityComparator.js:
antlr4ts/misc/Utils.js:
antlr4ts/atn/SemanticContext.js:
antlr4ts/atn/PredicateTransition.js:
antlr4ts/FailedPredicateException.js:
antlr4ts/InputMismatchException.js:
antlr4ts/misc/Arrays.js:
antlr4ts/misc/IntegerList.js:
antlr4ts/misc/Interval.js:
antlr4ts/Token.js:
antlr4ts/CommonToken.js:
antlr4ts/CommonTokenFactory.js:
antlr4ts/misc/IntegerStack.js:
antlr4ts/dfa/AcceptStateInfo.js:
antlr4ts/misc/Array2DHashMap.js:
antlr4ts/atn/DecisionState.js:
antlr4ts/atn/PredictionContextCache.js:
antlr4ts/atn/PredictionContext.js:
antlr4ts/atn/ATNConfig.js:
antlr4ts/misc/BitSet.js:
antlr4ts/atn/ATNConfigSet.js:
antlr4ts/dfa/DFAState.js:
antlr4ts/atn/ATNSimulator.js:
antlr4ts/ConsoleErrorListener.js:
antlr4ts/ProxyErrorListener.js:
antlr4ts/Recognizer.js:
antlr4ts/VocabularyImpl.js:
antlr4ts/dfa/DFASerializer.js:
antlr4ts/dfa/LexerDFASerializer.js:
antlr4ts/atn/StarLoopEntryState.js:
antlr4ts/dfa/DFA.js:
antlr4ts/atn/BasicState.js:
antlr4ts/atn/InvalidState.js:
antlr4ts/atn/SetTransition.js:
antlr4ts/atn/NotSetTransition.js:
antlr4ts/atn/RuleStopState.js:
antlr4ts/atn/RuleTransition.js:
antlr4ts/atn/WildcardTransition.js:
antlr4ts/atn/LL1Analyzer.js:
antlr4ts/atn/ATN.js:
antlr4ts/atn/LexerIndexedCustomAction.js:
antlr4ts/atn/LexerActionExecutor.js:
antlr4ts/LexerNoViableAltException.js:
antlr4ts/atn/OrderedATNConfigSet.js:
antlr4ts/atn/LexerATNSimulator.js:
antlr4ts/Lexer.js:
antlr4ts/misc/IntervalSet.js:
antlr4ts/atn/ATNDeserializationOptions.js:
antlr4ts/atn/ActionTransition.js:
antlr4ts/atn/AtomTransition.js:
antlr4ts/atn/BlockStartState.js:
antlr4ts/atn/BasicBlockStartState.js:
antlr4ts/atn/BlockEndState.js:
antlr4ts/atn/EpsilonTransition.js:
antlr4ts/atn/LexerChannelAction.js:
antlr4ts/atn/LexerCustomAction.js:
antlr4ts/atn/LexerModeAction.js:
antlr4ts/atn/LexerMoreAction.js:
antlr4ts/atn/LexerPopModeAction.js:
antlr4ts/atn/LexerPushModeAction.js:
antlr4ts/atn/LexerSkipAction.js:
antlr4ts/atn/LexerTypeAction.js:
antlr4ts/atn/LoopEndState.js:
antlr4ts/atn/ConflictInfo.js:
antlr4ts/tree/TerminalNode.js:
antlr4ts/tree/ErrorNode.js:
antlr4ts/tree/RuleNode.js:
antlr4ts/tree/Trees.js:
antlr4ts/RuleContext.js:
antlr4ts/ParserRuleContext.js:
antlr4ts/atn/PredictionMode.js:
antlr4ts/atn/SimulatorState.js:
antlr4ts/atn/ParserATNSimulator.js:
antlr4ts/atn/PlusBlockStartState.js:
antlr4ts/atn/PlusLoopbackState.js:
antlr4ts/atn/PrecedencePredicateTransition.js:
antlr4ts/atn/RangeTransition.js:
antlr4ts/atn/RuleStartState.js:
antlr4ts/atn/StarBlockStartState.js:
antlr4ts/atn/StarLoopbackState.js:
antlr4ts/atn/TokensStartState.js:
antlr4ts/misc/UUID.js:
antlr4ts/atn/ATNDeserializer.js:
antlr4ts/atn/ParseInfo.js:
antlr4ts/ProxyParserErrorListener.js:
antlr4ts/misc/Character.js:
antlr4ts/CodePointBuffer.js:
antlr4ts/CodePointCharStream.js:
antlr4ts/CharStreams.js:
antlr4ts/BufferedTokenStream.js:
antlr4ts/CommonTokenStream.js:
antlr4ts/ListTokenSource.js:
antlr4ts/misc/MultiMap.js:
antlr4ts/misc/ParseCancellationException.js:
antlr4ts/InterpreterRuleContext.js:
antlr4ts/ParserInterpreter.js:
antlr4ts/tree/pattern/ParseTreeMatch.js:
antlr4ts/tree/xpath/XPathLexerErrorListener.js:
antlr4ts/tree/xpath/XPathElement.js:
antlr4ts/tree/xpath/XPathRuleAnywhereElement.js:
antlr4ts/tree/xpath/XPathRuleElement.js:
antlr4ts/tree/xpath/XPathTokenAnywhereElement.js:
antlr4ts/tree/xpath/XPathTokenElement.js:
antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js:
antlr4ts/tree/xpath/XPathWildcardElement.js:
antlr4ts/tree/xpath/XPath.js:
antlr4ts/tree/pattern/ParseTreePattern.js:
antlr4ts/tree/pattern/RuleTagToken.js:
antlr4ts/tree/pattern/Chunk.js:
antlr4ts/tree/pattern/TagChunk.js:
antlr4ts/tree/pattern/TextChunk.js:
antlr4ts/tree/pattern/TokenTagToken.js:
antlr4ts/tree/pattern/ParseTreePatternMatcher.js:
antlr4ts/atn/DecisionEventInfo.js:
antlr4ts/atn/AmbiguityInfo.js:
antlr4ts/atn/ContextSensitivityInfo.js:
antlr4ts/atn/DecisionInfo.js:
antlr4ts/atn/ErrorInfo.js:
antlr4ts/atn/LookaheadEventInfo.js:
antlr4ts/atn/PredicateEvalInfo.js:
antlr4ts/atn/ProfilingATNSimulator.js:
antlr4ts/Parser.js:
antlr4ts/NoViableAltException.js:
antlr4ts/DefaultErrorStrategy.js:
antlr4ts/BailErrorStrategy.js:
antlr4ts/CharStream.js:
antlr4ts/Dependents.js:
antlr4ts/DiagnosticErrorListener.js:
antlr4ts/LexerInterpreter.js:
antlr4ts/ParserErrorListener.js:
antlr4ts/RuleContextWithAltNum.js:
antlr4ts/RuleDependency.js:
antlr4ts/RuleVersion.js:
antlr4ts/TokenFactory.js:
antlr4ts/TokenSource.js:
antlr4ts/TokenStream.js:
antlr4ts/TokenStreamRewriter.js:
antlr4ts/Vocabulary.js:
antlr4ts/WritableToken.js:
antlr4ts/index.js:
antlr4ts/tree/ParseTree.js:
  (*!
   * Copyright 2016 The ANTLR Project. All rights reserved.
   * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
   *)

comlink/dist/esm/comlink.mjs:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
